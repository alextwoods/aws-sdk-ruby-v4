# frozen_string_literal: true

# WARNING ABOUT GENERATED CODE
#
# This file was code generated using smithy-ruby.
# https://github.com/awslabs/smithy-ruby
#
# WARNING ABOUT GENERATED CODE

require 'base64'
require 'stringio'

module AWS::SDK::EC2
  module Stubs

    # Operation Stubber for AcceptReservedInstancesExchangeQuote
    class AcceptReservedInstancesExchangeQuote
      def self.default(visited=[])
        {
          exchange_id: 'exchange_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptReservedInstancesExchangeQuoteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('exchangeId', stub[:exchange_id].to_s) unless stub[:exchange_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AcceptTransitGatewayMulticastDomainAssociations
    class AcceptTransitGatewayMulticastDomainAssociations
      def self.default(visited=[])
        {
          associations: TransitGatewayMulticastDomainAssociations.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptTransitGatewayMulticastDomainAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomainAssociations.stub('associations', stub[:associations]) unless stub[:associations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayMulticastDomainAssociations
    class TransitGatewayMulticastDomainAssociations
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastDomainAssociations')
        visited = visited + ['TransitGatewayMulticastDomainAssociations']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          resource_owner_id: 'resource_owner_id',
          subnets: SubnetAssociationList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('subnets', SubnetAssociationList.stub('item', stub[:subnets])) unless stub[:subnets].nil?
        xml
      end
    end

    # List Stubber for SubnetAssociationList
    class SubnetAssociationList
      def self.default(visited=[])
        return nil if visited.include?('SubnetAssociationList')
        visited = visited + ['SubnetAssociationList']
        [
          SubnetAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SubnetAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SubnetAssociation
    class SubnetAssociation
      def self.default(visited=[])
        return nil if visited.include?('SubnetAssociation')
        visited = visited + ['SubnetAssociation']
        {
          subnet_id: 'subnet_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for AcceptTransitGatewayPeeringAttachment
    class AcceptTransitGatewayPeeringAttachment
      def self.default(visited=[])
        {
          transit_gateway_peering_attachment: TransitGatewayPeeringAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptTransitGatewayPeeringAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPeeringAttachment.stub('transitGatewayPeeringAttachment', stub[:transit_gateway_peering_attachment]) unless stub[:transit_gateway_peering_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayPeeringAttachment
    class TransitGatewayPeeringAttachment
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayPeeringAttachment')
        visited = visited + ['TransitGatewayPeeringAttachment']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          requester_tgw_info: PeeringTgwInfo.default(visited),
          accepter_tgw_info: PeeringTgwInfo.default(visited),
          status: PeeringAttachmentStatus.default(visited),
          state: 'state',
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << PeeringTgwInfo.stub('requesterTgwInfo', stub[:requester_tgw_info]) unless stub[:requester_tgw_info].nil?
        xml << PeeringTgwInfo.stub('accepterTgwInfo', stub[:accepter_tgw_info]) unless stub[:accepter_tgw_info].nil?
        xml << PeeringAttachmentStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for TagList
    class TagList
      def self.default(visited=[])
        return nil if visited.include?('TagList')
        visited = visited + ['TagList']
        [
          Tag.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Tag.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Tag
    class Tag
      def self.default(visited=[])
        return nil if visited.include?('Tag')
        visited = visited + ['Tag']
        {
          key: 'key',
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('key', stub[:key].to_s) unless stub[:key].nil?
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # Structure Stubber for PeeringAttachmentStatus
    class PeeringAttachmentStatus
      def self.default(visited=[])
        return nil if visited.include?('PeeringAttachmentStatus')
        visited = visited + ['PeeringAttachmentStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Structure Stubber for PeeringTgwInfo
    class PeeringTgwInfo
      def self.default(visited=[])
        return nil if visited.include?('PeeringTgwInfo')
        visited = visited + ['PeeringTgwInfo']
        {
          transit_gateway_id: 'transit_gateway_id',
          owner_id: 'owner_id',
          region: 'region',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('region', stub[:region].to_s) unless stub[:region].nil?
        xml
      end
    end

    # Operation Stubber for AcceptTransitGatewayVpcAttachment
    class AcceptTransitGatewayVpcAttachment
      def self.default(visited=[])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayVpcAttachment
    class TransitGatewayVpcAttachment
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayVpcAttachment')
        visited = visited + ['TransitGatewayVpcAttachment']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          transit_gateway_id: 'transit_gateway_id',
          vpc_id: 'vpc_id',
          vpc_owner_id: 'vpc_owner_id',
          state: 'state',
          subnet_ids: ValueStringList.default(visited),
          creation_time: Time.now,
          options: TransitGatewayVpcAttachmentOptions.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('vpcOwnerId', stub[:vpc_owner_id].to_s) unless stub[:vpc_owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('subnetIds', ValueStringList.stub('item', stub[:subnet_ids])) unless stub[:subnet_ids].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << TransitGatewayVpcAttachmentOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for TransitGatewayVpcAttachmentOptions
    class TransitGatewayVpcAttachmentOptions
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayVpcAttachmentOptions')
        visited = visited + ['TransitGatewayVpcAttachmentOptions']
        {
          dns_support: 'dns_support',
          ipv6_support: 'ipv6_support',
          appliance_mode_support: 'appliance_mode_support',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dnsSupport', stub[:dns_support].to_s) unless stub[:dns_support].nil?
        xml << Hearth::XML::Node.new('ipv6Support', stub[:ipv6_support].to_s) unless stub[:ipv6_support].nil?
        xml << Hearth::XML::Node.new('applianceModeSupport', stub[:appliance_mode_support].to_s) unless stub[:appliance_mode_support].nil?
        xml
      end
    end

    # List Stubber for ValueStringList
    class ValueStringList
      def self.default(visited=[])
        return nil if visited.include?('ValueStringList')
        visited = visited + ['ValueStringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for AcceptVpcEndpointConnections
    class AcceptVpcEndpointConnections
      def self.default(visited=[])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptVpcEndpointConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for UnsuccessfulItemSet
    class UnsuccessfulItemSet
      def self.default(visited=[])
        return nil if visited.include?('UnsuccessfulItemSet')
        visited = visited + ['UnsuccessfulItemSet']
        [
          UnsuccessfulItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UnsuccessfulItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for UnsuccessfulItem
    class UnsuccessfulItem
      def self.default(visited=[])
        return nil if visited.include?('UnsuccessfulItem')
        visited = visited + ['UnsuccessfulItem']
        {
          error: UnsuccessfulItemError.default(visited),
          resource_id: 'resource_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << UnsuccessfulItemError.stub('error', stub[:error]) unless stub[:error].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml
      end
    end

    # Structure Stubber for UnsuccessfulItemError
    class UnsuccessfulItemError
      def self.default(visited=[])
        return nil if visited.include?('UnsuccessfulItemError')
        visited = visited + ['UnsuccessfulItemError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for AcceptVpcPeeringConnection
    class AcceptVpcPeeringConnection
      def self.default(visited=[])
        {
          vpc_peering_connection: VpcPeeringConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptVpcPeeringConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcPeeringConnection.stub('vpcPeeringConnection', stub[:vpc_peering_connection]) unless stub[:vpc_peering_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for VpcPeeringConnection
    class VpcPeeringConnection
      def self.default(visited=[])
        return nil if visited.include?('VpcPeeringConnection')
        visited = visited + ['VpcPeeringConnection']
        {
          accepter_vpc_info: VpcPeeringConnectionVpcInfo.default(visited),
          expiration_time: Time.now,
          requester_vpc_info: VpcPeeringConnectionVpcInfo.default(visited),
          status: VpcPeeringConnectionStateReason.default(visited),
          tags: TagList.default(visited),
          vpc_peering_connection_id: 'vpc_peering_connection_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << VpcPeeringConnectionVpcInfo.stub('accepterVpcInfo', stub[:accepter_vpc_info]) unless stub[:accepter_vpc_info].nil?
        xml << Hearth::XML::Node.new('expirationTime', Hearth::TimeHelper.to_date_time(stub[:expiration_time])) unless stub[:expiration_time].nil?
        xml << VpcPeeringConnectionVpcInfo.stub('requesterVpcInfo', stub[:requester_vpc_info]) unless stub[:requester_vpc_info].nil?
        xml << VpcPeeringConnectionStateReason.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml
      end
    end

    # Structure Stubber for VpcPeeringConnectionStateReason
    class VpcPeeringConnectionStateReason
      def self.default(visited=[])
        return nil if visited.include?('VpcPeeringConnectionStateReason')
        visited = visited + ['VpcPeeringConnectionStateReason']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Structure Stubber for VpcPeeringConnectionVpcInfo
    class VpcPeeringConnectionVpcInfo
      def self.default(visited=[])
        return nil if visited.include?('VpcPeeringConnectionVpcInfo')
        visited = visited + ['VpcPeeringConnectionVpcInfo']
        {
          cidr_block: 'cidr_block',
          ipv6_cidr_block_set: Ipv6CidrBlockSet.default(visited),
          cidr_block_set: CidrBlockSet.default(visited),
          owner_id: 'owner_id',
          peering_options: VpcPeeringConnectionOptionsDescription.default(visited),
          vpc_id: 'vpc_id',
          region: 'region',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlockSet', Ipv6CidrBlockSet.stub('item', stub[:ipv6_cidr_block_set])) unless stub[:ipv6_cidr_block_set].nil?
        xml << Hearth::XML::Node.new('cidrBlockSet', CidrBlockSet.stub('item', stub[:cidr_block_set])) unless stub[:cidr_block_set].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << VpcPeeringConnectionOptionsDescription.stub('peeringOptions', stub[:peering_options]) unless stub[:peering_options].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('region', stub[:region].to_s) unless stub[:region].nil?
        xml
      end
    end

    # Structure Stubber for VpcPeeringConnectionOptionsDescription
    class VpcPeeringConnectionOptionsDescription
      def self.default(visited=[])
        return nil if visited.include?('VpcPeeringConnectionOptionsDescription')
        visited = visited + ['VpcPeeringConnectionOptionsDescription']
        {
          allow_dns_resolution_from_remote_vpc: false,
          allow_egress_from_local_classic_link_to_remote_vpc: false,
          allow_egress_from_local_vpc_to_remote_classic_link: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allowDnsResolutionFromRemoteVpc', stub[:allow_dns_resolution_from_remote_vpc].to_s) unless stub[:allow_dns_resolution_from_remote_vpc].nil?
        xml << Hearth::XML::Node.new('allowEgressFromLocalClassicLinkToRemoteVpc', stub[:allow_egress_from_local_classic_link_to_remote_vpc].to_s) unless stub[:allow_egress_from_local_classic_link_to_remote_vpc].nil?
        xml << Hearth::XML::Node.new('allowEgressFromLocalVpcToRemoteClassicLink', stub[:allow_egress_from_local_vpc_to_remote_classic_link].to_s) unless stub[:allow_egress_from_local_vpc_to_remote_classic_link].nil?
        xml
      end
    end

    # List Stubber for CidrBlockSet
    class CidrBlockSet
      def self.default(visited=[])
        return nil if visited.include?('CidrBlockSet')
        visited = visited + ['CidrBlockSet']
        [
          CidrBlock.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CidrBlock.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CidrBlock
    class CidrBlock
      def self.default(visited=[])
        return nil if visited.include?('CidrBlock')
        visited = visited + ['CidrBlock']
        {
          cidr_block: 'cidr_block',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml
      end
    end

    # List Stubber for Ipv6CidrBlockSet
    class Ipv6CidrBlockSet
      def self.default(visited=[])
        return nil if visited.include?('Ipv6CidrBlockSet')
        visited = visited + ['Ipv6CidrBlockSet']
        [
          Ipv6CidrBlock.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6CidrBlock.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv6CidrBlock
    class Ipv6CidrBlock
      def self.default(visited=[])
        return nil if visited.include?('Ipv6CidrBlock')
        visited = visited + ['Ipv6CidrBlock']
        {
          ipv6_cidr_block: 'ipv6_cidr_block',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6CidrBlock', stub[:ipv6_cidr_block].to_s) unless stub[:ipv6_cidr_block].nil?
        xml
      end
    end

    # Operation Stubber for AdvertiseByoipCidr
    class AdvertiseByoipCidr
      def self.default(visited=[])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AdvertiseByoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ByoipCidr
    class ByoipCidr
      def self.default(visited=[])
        return nil if visited.include?('ByoipCidr')
        visited = visited + ['ByoipCidr']
        {
          cidr: 'cidr',
          description: 'description',
          status_message: 'status_message',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for AllocateAddress
    class AllocateAddress
      def self.default(visited=[])
        {
          public_ip: 'public_ip',
          allocation_id: 'allocation_id',
          public_ipv4_pool: 'public_ipv4_pool',
          network_border_group: 'network_border_group',
          domain: 'domain',
          customer_owned_ip: 'customer_owned_ip',
          customer_owned_ipv4_pool: 'customer_owned_ipv4_pool',
          carrier_ip: 'carrier_ip',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AllocateAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('publicIpv4Pool', stub[:public_ipv4_pool].to_s) unless stub[:public_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('domain', stub[:domain].to_s) unless stub[:domain].nil?
        xml << Hearth::XML::Node.new('customerOwnedIp', stub[:customer_owned_ip].to_s) unless stub[:customer_owned_ip].nil?
        xml << Hearth::XML::Node.new('customerOwnedIpv4Pool', stub[:customer_owned_ipv4_pool].to_s) unless stub[:customer_owned_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('carrierIp', stub[:carrier_ip].to_s) unless stub[:carrier_ip].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AllocateHosts
    class AllocateHosts
      def self.default(visited=[])
        {
          host_ids: ResponseHostIdList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AllocateHostsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('hostIdSet', ResponseHostIdList.stub('item', stub[:host_ids])) unless stub[:host_ids].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ResponseHostIdList
    class ResponseHostIdList
      def self.default(visited=[])
        return nil if visited.include?('ResponseHostIdList')
        visited = visited + ['ResponseHostIdList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for AllocateIpamPoolCidr
    class AllocateIpamPoolCidr
      def self.default(visited=[])
        {
          ipam_pool_allocation: IpamPoolAllocation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AllocateIpamPoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPoolAllocation.stub('ipamPoolAllocation', stub[:ipam_pool_allocation]) unless stub[:ipam_pool_allocation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for IpamPoolAllocation
    class IpamPoolAllocation
      def self.default(visited=[])
        return nil if visited.include?('IpamPoolAllocation')
        visited = visited + ['IpamPoolAllocation']
        {
          cidr: 'cidr',
          ipam_pool_allocation_id: 'ipam_pool_allocation_id',
          description: 'description',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          resource_region: 'resource_region',
          resource_owner: 'resource_owner',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('ipamPoolAllocationId', stub[:ipam_pool_allocation_id].to_s) unless stub[:ipam_pool_allocation_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceRegion', stub[:resource_region].to_s) unless stub[:resource_region].nil?
        xml << Hearth::XML::Node.new('resourceOwner', stub[:resource_owner].to_s) unless stub[:resource_owner].nil?
        xml
      end
    end

    # Operation Stubber for ApplySecurityGroupsToClientVpnTargetNetwork
    class ApplySecurityGroupsToClientVpnTargetNetwork
      def self.default(visited=[])
        {
          security_group_ids: ClientVpnSecurityGroupIdSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ApplySecurityGroupsToClientVpnTargetNetworkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('securityGroupIds', ClientVpnSecurityGroupIdSet.stub('item', stub[:security_group_ids])) unless stub[:security_group_ids].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ClientVpnSecurityGroupIdSet
    class ClientVpnSecurityGroupIdSet
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnSecurityGroupIdSet')
        visited = visited + ['ClientVpnSecurityGroupIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for AssignIpv6Addresses
    class AssignIpv6Addresses
      def self.default(visited=[])
        {
          assigned_ipv6_addresses: Ipv6AddressList.default(visited),
          assigned_ipv6_prefixes: IpPrefixList.default(visited),
          network_interface_id: 'network_interface_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssignIpv6AddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('assignedIpv6Addresses', Ipv6AddressList.stub('item', stub[:assigned_ipv6_addresses])) unless stub[:assigned_ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('assignedIpv6PrefixSet', IpPrefixList.stub('item', stub[:assigned_ipv6_prefixes])) unless stub[:assigned_ipv6_prefixes].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IpPrefixList
    class IpPrefixList
      def self.default(visited=[])
        return nil if visited.include?('IpPrefixList')
        visited = visited + ['IpPrefixList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for Ipv6AddressList
    class Ipv6AddressList
      def self.default(visited=[])
        return nil if visited.include?('Ipv6AddressList')
        visited = visited + ['Ipv6AddressList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for AssignPrivateIpAddresses
    class AssignPrivateIpAddresses
      def self.default(visited=[])
        {
          network_interface_id: 'network_interface_id',
          assigned_private_ip_addresses: AssignedPrivateIpAddressList.default(visited),
          assigned_ipv4_prefixes: Ipv4PrefixesList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssignPrivateIpAddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('assignedPrivateIpAddressesSet', AssignedPrivateIpAddressList.stub('item', stub[:assigned_private_ip_addresses])) unless stub[:assigned_private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('assignedIpv4PrefixSet', Ipv4PrefixesList.stub('item', stub[:assigned_ipv4_prefixes])) unless stub[:assigned_ipv4_prefixes].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for Ipv4PrefixesList
    class Ipv4PrefixesList
      def self.default(visited=[])
        return nil if visited.include?('Ipv4PrefixesList')
        visited = visited + ['Ipv4PrefixesList']
        [
          Ipv4PrefixSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv4PrefixSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv4PrefixSpecification
    class Ipv4PrefixSpecification
      def self.default(visited=[])
        return nil if visited.include?('Ipv4PrefixSpecification')
        visited = visited + ['Ipv4PrefixSpecification']
        {
          ipv4_prefix: 'ipv4_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv4Prefix', stub[:ipv4_prefix].to_s) unless stub[:ipv4_prefix].nil?
        xml
      end
    end

    # List Stubber for AssignedPrivateIpAddressList
    class AssignedPrivateIpAddressList
      def self.default(visited=[])
        return nil if visited.include?('AssignedPrivateIpAddressList')
        visited = visited + ['AssignedPrivateIpAddressList']
        [
          AssignedPrivateIpAddress.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AssignedPrivateIpAddress.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AssignedPrivateIpAddress
    class AssignedPrivateIpAddress
      def self.default(visited=[])
        return nil if visited.include?('AssignedPrivateIpAddress')
        visited = visited + ['AssignedPrivateIpAddress']
        {
          private_ip_address: 'private_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml
      end
    end

    # Operation Stubber for AssociateAddress
    class AssociateAddress
      def self.default(visited=[])
        {
          association_id: 'association_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AssociateClientVpnTargetNetwork
    class AssociateClientVpnTargetNetwork
      def self.default(visited=[])
        {
          association_id: 'association_id',
          status: AssociationStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateClientVpnTargetNetworkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << AssociationStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for AssociationStatus
    class AssociationStatus
      def self.default(visited=[])
        return nil if visited.include?('AssociationStatus')
        visited = visited + ['AssociationStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for AssociateDhcpOptions
    class AssociateDhcpOptions
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateDhcpOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AssociateEnclaveCertificateIamRole
    class AssociateEnclaveCertificateIamRole
      def self.default(visited=[])
        {
          certificate_s3_bucket_name: 'certificate_s3_bucket_name',
          certificate_s3_object_key: 'certificate_s3_object_key',
          encryption_kms_key_id: 'encryption_kms_key_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateEnclaveCertificateIamRoleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('certificateS3BucketName', stub[:certificate_s3_bucket_name].to_s) unless stub[:certificate_s3_bucket_name].nil?
        xml << Hearth::XML::Node.new('certificateS3ObjectKey', stub[:certificate_s3_object_key].to_s) unless stub[:certificate_s3_object_key].nil?
        xml << Hearth::XML::Node.new('encryptionKmsKeyId', stub[:encryption_kms_key_id].to_s) unless stub[:encryption_kms_key_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AssociateIamInstanceProfile
    class AssociateIamInstanceProfile
      def self.default(visited=[])
        {
          iam_instance_profile_association: IamInstanceProfileAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateIamInstanceProfileResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IamInstanceProfileAssociation.stub('iamInstanceProfileAssociation', stub[:iam_instance_profile_association]) unless stub[:iam_instance_profile_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for IamInstanceProfileAssociation
    class IamInstanceProfileAssociation
      def self.default(visited=[])
        return nil if visited.include?('IamInstanceProfileAssociation')
        visited = visited + ['IamInstanceProfileAssociation']
        {
          association_id: 'association_id',
          instance_id: 'instance_id',
          iam_instance_profile: IamInstanceProfile.default(visited),
          state: 'state',
          timestamp: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << IamInstanceProfile.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        xml
      end
    end

    # Structure Stubber for IamInstanceProfile
    class IamInstanceProfile
      def self.default(visited=[])
        return nil if visited.include?('IamInstanceProfile')
        visited = visited + ['IamInstanceProfile']
        {
          arn: 'arn',
          id: 'id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('id', stub[:id].to_s) unless stub[:id].nil?
        xml
      end
    end

    # Operation Stubber for AssociateInstanceEventWindow
    class AssociateInstanceEventWindow
      def self.default(visited=[])
        {
          instance_event_window: InstanceEventWindow.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindow.stub('instanceEventWindow', stub[:instance_event_window]) unless stub[:instance_event_window].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for InstanceEventWindow
    class InstanceEventWindow
      def self.default(visited=[])
        return nil if visited.include?('InstanceEventWindow')
        visited = visited + ['InstanceEventWindow']
        {
          instance_event_window_id: 'instance_event_window_id',
          time_ranges: InstanceEventWindowTimeRangeList.default(visited),
          name: 'name',
          cron_expression: 'cron_expression',
          association_target: InstanceEventWindowAssociationTarget.default(visited),
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceEventWindowId', stub[:instance_event_window_id].to_s) unless stub[:instance_event_window_id].nil?
        xml << Hearth::XML::Node.new('timeRangeSet', InstanceEventWindowTimeRangeList.stub('item', stub[:time_ranges])) unless stub[:time_ranges].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('cronExpression', stub[:cron_expression].to_s) unless stub[:cron_expression].nil?
        xml << InstanceEventWindowAssociationTarget.stub('associationTarget', stub[:association_target]) unless stub[:association_target].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for InstanceEventWindowAssociationTarget
    class InstanceEventWindowAssociationTarget
      def self.default(visited=[])
        return nil if visited.include?('InstanceEventWindowAssociationTarget')
        visited = visited + ['InstanceEventWindowAssociationTarget']
        {
          instance_ids: InstanceIdList.default(visited),
          tags: TagList.default(visited),
          dedicated_host_ids: DedicatedHostIdList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceIdSet', InstanceIdList.stub('item', stub[:instance_ids])) unless stub[:instance_ids].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('dedicatedHostIdSet', DedicatedHostIdList.stub('item', stub[:dedicated_host_ids])) unless stub[:dedicated_host_ids].nil?
        xml
      end
    end

    # List Stubber for DedicatedHostIdList
    class DedicatedHostIdList
      def self.default(visited=[])
        return nil if visited.include?('DedicatedHostIdList')
        visited = visited + ['DedicatedHostIdList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for InstanceIdList
    class InstanceIdList
      def self.default(visited=[])
        return nil if visited.include?('InstanceIdList')
        visited = visited + ['InstanceIdList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for InstanceEventWindowTimeRangeList
    class InstanceEventWindowTimeRangeList
      def self.default(visited=[])
        return nil if visited.include?('InstanceEventWindowTimeRangeList')
        visited = visited + ['InstanceEventWindowTimeRangeList']
        [
          InstanceEventWindowTimeRange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceEventWindowTimeRange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceEventWindowTimeRange
    class InstanceEventWindowTimeRange
      def self.default(visited=[])
        return nil if visited.include?('InstanceEventWindowTimeRange')
        visited = visited + ['InstanceEventWindowTimeRange']
        {
          start_week_day: 'start_week_day',
          start_hour: 1,
          end_week_day: 'end_week_day',
          end_hour: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('startWeekDay', stub[:start_week_day].to_s) unless stub[:start_week_day].nil?
        xml << Hearth::XML::Node.new('startHour', stub[:start_hour].to_s) unless stub[:start_hour].nil?
        xml << Hearth::XML::Node.new('endWeekDay', stub[:end_week_day].to_s) unless stub[:end_week_day].nil?
        xml << Hearth::XML::Node.new('endHour', stub[:end_hour].to_s) unless stub[:end_hour].nil?
        xml
      end
    end

    # Operation Stubber for AssociateRouteTable
    class AssociateRouteTable
      def self.default(visited=[])
        {
          association_id: 'association_id',
          association_state: RouteTableAssociationState.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << RouteTableAssociationState.stub('associationState', stub[:association_state]) unless stub[:association_state].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for RouteTableAssociationState
    class RouteTableAssociationState
      def self.default(visited=[])
        return nil if visited.include?('RouteTableAssociationState')
        visited = visited + ['RouteTableAssociationState']
        {
          state: 'state',
          status_message: 'status_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml
      end
    end

    # Operation Stubber for AssociateSubnetCidrBlock
    class AssociateSubnetCidrBlock
      def self.default(visited=[])
        {
          ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.default(visited),
          subnet_id: 'subnet_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateSubnetCidrBlockResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SubnetIpv6CidrBlockAssociation.stub('ipv6CidrBlockAssociation', stub[:ipv6_cidr_block_association]) unless stub[:ipv6_cidr_block_association].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for SubnetIpv6CidrBlockAssociation
    class SubnetIpv6CidrBlockAssociation
      def self.default(visited=[])
        return nil if visited.include?('SubnetIpv6CidrBlockAssociation')
        visited = visited + ['SubnetIpv6CidrBlockAssociation']
        {
          association_id: 'association_id',
          ipv6_cidr_block: 'ipv6_cidr_block',
          ipv6_cidr_block_state: SubnetCidrBlockState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlock', stub[:ipv6_cidr_block].to_s) unless stub[:ipv6_cidr_block].nil?
        xml << SubnetCidrBlockState.stub('ipv6CidrBlockState', stub[:ipv6_cidr_block_state]) unless stub[:ipv6_cidr_block_state].nil?
        xml
      end
    end

    # Structure Stubber for SubnetCidrBlockState
    class SubnetCidrBlockState
      def self.default(visited=[])
        return nil if visited.include?('SubnetCidrBlockState')
        visited = visited + ['SubnetCidrBlockState']
        {
          state: 'state',
          status_message: 'status_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml
      end
    end

    # Operation Stubber for AssociateTransitGatewayMulticastDomain
    class AssociateTransitGatewayMulticastDomain
      def self.default(visited=[])
        {
          associations: TransitGatewayMulticastDomainAssociations.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateTransitGatewayMulticastDomainResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomainAssociations.stub('associations', stub[:associations]) unless stub[:associations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AssociateTransitGatewayRouteTable
    class AssociateTransitGatewayRouteTable
      def self.default(visited=[])
        {
          association: TransitGatewayAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateTransitGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayAssociation
    class TransitGatewayAssociation
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayAssociation')
        visited = visited + ['TransitGatewayAssociation']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for AssociateTrunkInterface
    class AssociateTrunkInterface
      def self.default(visited=[])
        {
          interface_association: TrunkInterfaceAssociation.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateTrunkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrunkInterfaceAssociation.stub('interfaceAssociation', stub[:interface_association]) unless stub[:interface_association].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TrunkInterfaceAssociation
    class TrunkInterfaceAssociation
      def self.default(visited=[])
        return nil if visited.include?('TrunkInterfaceAssociation')
        visited = visited + ['TrunkInterfaceAssociation']
        {
          association_id: 'association_id',
          branch_interface_id: 'branch_interface_id',
          trunk_interface_id: 'trunk_interface_id',
          interface_protocol: 'interface_protocol',
          vlan_id: 1,
          gre_key: 1,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('branchInterfaceId', stub[:branch_interface_id].to_s) unless stub[:branch_interface_id].nil?
        xml << Hearth::XML::Node.new('trunkInterfaceId', stub[:trunk_interface_id].to_s) unless stub[:trunk_interface_id].nil?
        xml << Hearth::XML::Node.new('interfaceProtocol', stub[:interface_protocol].to_s) unless stub[:interface_protocol].nil?
        xml << Hearth::XML::Node.new('vlanId', stub[:vlan_id].to_s) unless stub[:vlan_id].nil?
        xml << Hearth::XML::Node.new('greKey', stub[:gre_key].to_s) unless stub[:gre_key].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for AssociateVpcCidrBlock
    class AssociateVpcCidrBlock
      def self.default(visited=[])
        {
          ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.default(visited),
          cidr_block_association: VpcCidrBlockAssociation.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateVpcCidrBlockResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcIpv6CidrBlockAssociation.stub('ipv6CidrBlockAssociation', stub[:ipv6_cidr_block_association]) unless stub[:ipv6_cidr_block_association].nil?
        xml << VpcCidrBlockAssociation.stub('cidrBlockAssociation', stub[:cidr_block_association]) unless stub[:cidr_block_association].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for VpcCidrBlockAssociation
    class VpcCidrBlockAssociation
      def self.default(visited=[])
        return nil if visited.include?('VpcCidrBlockAssociation')
        visited = visited + ['VpcCidrBlockAssociation']
        {
          association_id: 'association_id',
          cidr_block: 'cidr_block',
          cidr_block_state: VpcCidrBlockState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << VpcCidrBlockState.stub('cidrBlockState', stub[:cidr_block_state]) unless stub[:cidr_block_state].nil?
        xml
      end
    end

    # Structure Stubber for VpcCidrBlockState
    class VpcCidrBlockState
      def self.default(visited=[])
        return nil if visited.include?('VpcCidrBlockState')
        visited = visited + ['VpcCidrBlockState']
        {
          state: 'state',
          status_message: 'status_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml
      end
    end

    # Structure Stubber for VpcIpv6CidrBlockAssociation
    class VpcIpv6CidrBlockAssociation
      def self.default(visited=[])
        return nil if visited.include?('VpcIpv6CidrBlockAssociation')
        visited = visited + ['VpcIpv6CidrBlockAssociation']
        {
          association_id: 'association_id',
          ipv6_cidr_block: 'ipv6_cidr_block',
          ipv6_cidr_block_state: VpcCidrBlockState.default(visited),
          network_border_group: 'network_border_group',
          ipv6_pool: 'ipv6_pool',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlock', stub[:ipv6_cidr_block].to_s) unless stub[:ipv6_cidr_block].nil?
        xml << VpcCidrBlockState.stub('ipv6CidrBlockState', stub[:ipv6_cidr_block_state]) unless stub[:ipv6_cidr_block_state].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('ipv6Pool', stub[:ipv6_pool].to_s) unless stub[:ipv6_pool].nil?
        xml
      end
    end

    # Operation Stubber for AttachClassicLinkVpc
    class AttachClassicLinkVpc
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachClassicLinkVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AttachInternetGateway
    class AttachInternetGateway
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AttachNetworkInterface
    class AttachNetworkInterface
      def self.default(visited=[])
        {
          attachment_id: 'attachment_id',
          network_card_index: 1,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachNetworkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('attachmentId', stub[:attachment_id].to_s) unless stub[:attachment_id].nil?
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AttachVolume
    class AttachVolume
      def self.default(visited=[])
        {
          attach_time: Time.now,
          device: 'device',
          instance_id: 'instance_id',
          state: 'state',
          volume_id: 'volume_id',
          delete_on_termination: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('device', stub[:device].to_s) unless stub[:device].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for AttachVpnGateway
    class AttachVpnGateway
      def self.default(visited=[])
        {
          vpc_attachment: VpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachVpnGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcAttachment.stub('attachment', stub[:vpc_attachment]) unless stub[:vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for VpcAttachment
    class VpcAttachment
      def self.default(visited=[])
        return nil if visited.include?('VpcAttachment')
        visited = visited + ['VpcAttachment']
        {
          state: 'state',
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    # Operation Stubber for AuthorizeClientVpnIngress
    class AuthorizeClientVpnIngress
      def self.default(visited=[])
        {
          status: ClientVpnAuthorizationRuleStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AuthorizeClientVpnIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnAuthorizationRuleStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ClientVpnAuthorizationRuleStatus
    class ClientVpnAuthorizationRuleStatus
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnAuthorizationRuleStatus')
        visited = visited + ['ClientVpnAuthorizationRuleStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for AuthorizeSecurityGroupEgress
    class AuthorizeSecurityGroupEgress
      def self.default(visited=[])
        {
          return: false,
          security_group_rules: SecurityGroupRuleList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AuthorizeSecurityGroupEgressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('securityGroupRuleSet', SecurityGroupRuleList.stub('item', stub[:security_group_rules])) unless stub[:security_group_rules].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SecurityGroupRuleList
    class SecurityGroupRuleList
      def self.default(visited=[])
        return nil if visited.include?('SecurityGroupRuleList')
        visited = visited + ['SecurityGroupRuleList']
        [
          SecurityGroupRule.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SecurityGroupRule.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SecurityGroupRule
    class SecurityGroupRule
      def self.default(visited=[])
        return nil if visited.include?('SecurityGroupRule')
        visited = visited + ['SecurityGroupRule']
        {
          security_group_rule_id: 'security_group_rule_id',
          group_id: 'group_id',
          group_owner_id: 'group_owner_id',
          is_egress: false,
          ip_protocol: 'ip_protocol',
          from_port: 1,
          to_port: 1,
          cidr_ipv4: 'cidr_ipv4',
          cidr_ipv6: 'cidr_ipv6',
          prefix_list_id: 'prefix_list_id',
          referenced_group_info: ReferencedSecurityGroup.default(visited),
          description: 'description',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('securityGroupRuleId', stub[:security_group_rule_id].to_s) unless stub[:security_group_rule_id].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('groupOwnerId', stub[:group_owner_id].to_s) unless stub[:group_owner_id].nil?
        xml << Hearth::XML::Node.new('isEgress', stub[:is_egress].to_s) unless stub[:is_egress].nil?
        xml << Hearth::XML::Node.new('ipProtocol', stub[:ip_protocol].to_s) unless stub[:ip_protocol].nil?
        xml << Hearth::XML::Node.new('fromPort', stub[:from_port].to_s) unless stub[:from_port].nil?
        xml << Hearth::XML::Node.new('toPort', stub[:to_port].to_s) unless stub[:to_port].nil?
        xml << Hearth::XML::Node.new('cidrIpv4', stub[:cidr_ipv4].to_s) unless stub[:cidr_ipv4].nil?
        xml << Hearth::XML::Node.new('cidrIpv6', stub[:cidr_ipv6].to_s) unless stub[:cidr_ipv6].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << ReferencedSecurityGroup.stub('referencedGroupInfo', stub[:referenced_group_info]) unless stub[:referenced_group_info].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for ReferencedSecurityGroup
    class ReferencedSecurityGroup
      def self.default(visited=[])
        return nil if visited.include?('ReferencedSecurityGroup')
        visited = visited + ['ReferencedSecurityGroup']
        {
          group_id: 'group_id',
          peering_status: 'peering_status',
          user_id: 'user_id',
          vpc_id: 'vpc_id',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('peeringStatus', stub[:peering_status].to_s) unless stub[:peering_status].nil?
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml
      end
    end

    # Operation Stubber for AuthorizeSecurityGroupIngress
    class AuthorizeSecurityGroupIngress
      def self.default(visited=[])
        {
          return: false,
          security_group_rules: SecurityGroupRuleList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AuthorizeSecurityGroupIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('securityGroupRuleSet', SecurityGroupRuleList.stub('item', stub[:security_group_rules])) unless stub[:security_group_rules].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for BundleInstance
    class BundleInstance
      def self.default(visited=[])
        {
          bundle_task: BundleTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('BundleInstanceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << BundleTask.stub('bundleInstanceTask', stub[:bundle_task]) unless stub[:bundle_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for BundleTask
    class BundleTask
      def self.default(visited=[])
        return nil if visited.include?('BundleTask')
        visited = visited + ['BundleTask']
        {
          bundle_id: 'bundle_id',
          bundle_task_error: BundleTaskError.default(visited),
          instance_id: 'instance_id',
          progress: 'progress',
          start_time: Time.now,
          state: 'state',
          storage: Storage.default(visited),
          update_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('bundleId', stub[:bundle_id].to_s) unless stub[:bundle_id].nil?
        xml << BundleTaskError.stub('error', stub[:bundle_task_error]) unless stub[:bundle_task_error].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Storage.stub('storage', stub[:storage]) unless stub[:storage].nil?
        xml << Hearth::XML::Node.new('updateTime', Hearth::TimeHelper.to_date_time(stub[:update_time])) unless stub[:update_time].nil?
        xml
      end
    end

    # Structure Stubber for Storage
    class Storage
      def self.default(visited=[])
        return nil if visited.include?('Storage')
        visited = visited + ['Storage']
        {
          s3: S3Storage.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << S3Storage.stub('S3', stub[:s3]) unless stub[:s3].nil?
        xml
      end
    end

    # Structure Stubber for S3Storage
    class S3Storage
      def self.default(visited=[])
        return nil if visited.include?('S3Storage')
        visited = visited + ['S3Storage']
        {
          aws_access_key_id: 'aws_access_key_id',
          bucket: 'bucket',
          prefix: 'prefix',
          upload_policy: 'upload_policy',
          upload_policy_signature: 'upload_policy_signature',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('AWSAccessKeyId', stub[:aws_access_key_id].to_s) unless stub[:aws_access_key_id].nil?
        xml << Hearth::XML::Node.new('bucket', stub[:bucket].to_s) unless stub[:bucket].nil?
        xml << Hearth::XML::Node.new('prefix', stub[:prefix].to_s) unless stub[:prefix].nil?
        xml << Hearth::XML::Node.new('uploadPolicy', ::Base64::encode64(stub[:upload_policy]).strip) unless stub[:upload_policy].nil?
        xml << Hearth::XML::Node.new('uploadPolicySignature', stub[:upload_policy_signature].to_s) unless stub[:upload_policy_signature].nil?
        xml
      end
    end

    # Structure Stubber for BundleTaskError
    class BundleTaskError
      def self.default(visited=[])
        return nil if visited.include?('BundleTaskError')
        visited = visited + ['BundleTaskError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for CancelBundleTask
    class CancelBundleTask
      def self.default(visited=[])
        {
          bundle_task: BundleTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelBundleTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << BundleTask.stub('bundleInstanceTask', stub[:bundle_task]) unless stub[:bundle_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CancelCapacityReservation
    class CancelCapacityReservation
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelCapacityReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CancelCapacityReservationFleets
    class CancelCapacityReservationFleets
      def self.default(visited=[])
        {
          successful_fleet_cancellations: CapacityReservationFleetCancellationStateSet.default(visited),
          failed_fleet_cancellations: FailedCapacityReservationFleetCancellationResultSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelCapacityReservationFleetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulFleetCancellationSet', CapacityReservationFleetCancellationStateSet.stub('item', stub[:successful_fleet_cancellations])) unless stub[:successful_fleet_cancellations].nil?
        xml << Hearth::XML::Node.new('failedFleetCancellationSet', FailedCapacityReservationFleetCancellationResultSet.stub('item', stub[:failed_fleet_cancellations])) unless stub[:failed_fleet_cancellations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for FailedCapacityReservationFleetCancellationResultSet
    class FailedCapacityReservationFleetCancellationResultSet
      def self.default(visited=[])
        return nil if visited.include?('FailedCapacityReservationFleetCancellationResultSet')
        visited = visited + ['FailedCapacityReservationFleetCancellationResultSet']
        [
          FailedCapacityReservationFleetCancellationResult.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FailedCapacityReservationFleetCancellationResult.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for FailedCapacityReservationFleetCancellationResult
    class FailedCapacityReservationFleetCancellationResult
      def self.default(visited=[])
        return nil if visited.include?('FailedCapacityReservationFleetCancellationResult')
        visited = visited + ['FailedCapacityReservationFleetCancellationResult']
        {
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
          cancel_capacity_reservation_fleet_error: CancelCapacityReservationFleetError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml << CancelCapacityReservationFleetError.stub('cancelCapacityReservationFleetError', stub[:cancel_capacity_reservation_fleet_error]) unless stub[:cancel_capacity_reservation_fleet_error].nil?
        xml
      end
    end

    # Structure Stubber for CancelCapacityReservationFleetError
    class CancelCapacityReservationFleetError
      def self.default(visited=[])
        return nil if visited.include?('CancelCapacityReservationFleetError')
        visited = visited + ['CancelCapacityReservationFleetError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # List Stubber for CapacityReservationFleetCancellationStateSet
    class CapacityReservationFleetCancellationStateSet
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationFleetCancellationStateSet')
        visited = visited + ['CapacityReservationFleetCancellationStateSet']
        [
          CapacityReservationFleetCancellationState.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CapacityReservationFleetCancellationState.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CapacityReservationFleetCancellationState
    class CapacityReservationFleetCancellationState
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationFleetCancellationState')
        visited = visited + ['CapacityReservationFleetCancellationState']
        {
          current_fleet_state: 'current_fleet_state',
          previous_fleet_state: 'previous_fleet_state',
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currentFleetState', stub[:current_fleet_state].to_s) unless stub[:current_fleet_state].nil?
        xml << Hearth::XML::Node.new('previousFleetState', stub[:previous_fleet_state].to_s) unless stub[:previous_fleet_state].nil?
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml
      end
    end

    # Operation Stubber for CancelConversionTask
    class CancelConversionTask
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelConversionTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CancelExportTask
    class CancelExportTask
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelExportTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CancelImportTask
    class CancelImportTask
      def self.default(visited=[])
        {
          import_task_id: 'import_task_id',
          previous_state: 'previous_state',
          state: 'state',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelImportTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << Hearth::XML::Node.new('previousState', stub[:previous_state].to_s) unless stub[:previous_state].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CancelReservedInstancesListing
    class CancelReservedInstancesListing
      def self.default(visited=[])
        {
          reserved_instances_listings: ReservedInstancesListingList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelReservedInstancesListingResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesListingsSet', ReservedInstancesListingList.stub('item', stub[:reserved_instances_listings])) unless stub[:reserved_instances_listings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ReservedInstancesListingList
    class ReservedInstancesListingList
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesListingList')
        visited = visited + ['ReservedInstancesListingList']
        [
          ReservedInstancesListing.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesListing.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ReservedInstancesListing
    class ReservedInstancesListing
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesListing')
        visited = visited + ['ReservedInstancesListing']
        {
          client_token: 'client_token',
          create_date: Time.now,
          instance_counts: InstanceCountList.default(visited),
          price_schedules: PriceScheduleList.default(visited),
          reserved_instances_id: 'reserved_instances_id',
          reserved_instances_listing_id: 'reserved_instances_listing_id',
          status: 'status',
          status_message: 'status_message',
          tags: TagList.default(visited),
          update_date: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('instanceCounts', InstanceCountList.stub('item', stub[:instance_counts])) unless stub[:instance_counts].nil?
        xml << Hearth::XML::Node.new('priceSchedules', PriceScheduleList.stub('item', stub[:price_schedules])) unless stub[:price_schedules].nil?
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml << Hearth::XML::Node.new('reservedInstancesListingId', stub[:reserved_instances_listing_id].to_s) unless stub[:reserved_instances_listing_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('updateDate', Hearth::TimeHelper.to_date_time(stub[:update_date])) unless stub[:update_date].nil?
        xml
      end
    end

    # List Stubber for PriceScheduleList
    class PriceScheduleList
      def self.default(visited=[])
        return nil if visited.include?('PriceScheduleList')
        visited = visited + ['PriceScheduleList']
        [
          PriceSchedule.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PriceSchedule.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PriceSchedule
    class PriceSchedule
      def self.default(visited=[])
        return nil if visited.include?('PriceSchedule')
        visited = visited + ['PriceSchedule']
        {
          active: false,
          currency_code: 'currency_code',
          price: 1.0,
          term: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('active', stub[:active].to_s) unless stub[:active].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('price', Hearth::NumberHelper.serialize(stub[:price]).to_s) unless stub[:price].nil?
        xml << Hearth::XML::Node.new('term', stub[:term].to_s) unless stub[:term].nil?
        xml
      end
    end

    # List Stubber for InstanceCountList
    class InstanceCountList
      def self.default(visited=[])
        return nil if visited.include?('InstanceCountList')
        visited = visited + ['InstanceCountList']
        [
          InstanceCount.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceCount.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceCount
    class InstanceCount
      def self.default(visited=[])
        return nil if visited.include?('InstanceCount')
        visited = visited + ['InstanceCount']
        {
          instance_count: 1,
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for CancelSpotFleetRequests
    class CancelSpotFleetRequests
      def self.default(visited=[])
        {
          successful_fleet_requests: CancelSpotFleetRequestsSuccessSet.default(visited),
          unsuccessful_fleet_requests: CancelSpotFleetRequestsErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelSpotFleetRequestsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulFleetRequestSet', CancelSpotFleetRequestsSuccessSet.stub('item', stub[:successful_fleet_requests])) unless stub[:successful_fleet_requests].nil?
        xml << Hearth::XML::Node.new('unsuccessfulFleetRequestSet', CancelSpotFleetRequestsErrorSet.stub('item', stub[:unsuccessful_fleet_requests])) unless stub[:unsuccessful_fleet_requests].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CancelSpotFleetRequestsErrorSet
    class CancelSpotFleetRequestsErrorSet
      def self.default(visited=[])
        return nil if visited.include?('CancelSpotFleetRequestsErrorSet')
        visited = visited + ['CancelSpotFleetRequestsErrorSet']
        [
          CancelSpotFleetRequestsErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CancelSpotFleetRequestsErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CancelSpotFleetRequestsErrorItem
    class CancelSpotFleetRequestsErrorItem
      def self.default(visited=[])
        return nil if visited.include?('CancelSpotFleetRequestsErrorItem')
        visited = visited + ['CancelSpotFleetRequestsErrorItem']
        {
          error: CancelSpotFleetRequestsError.default(visited),
          spot_fleet_request_id: 'spot_fleet_request_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << CancelSpotFleetRequestsError.stub('error', stub[:error]) unless stub[:error].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        xml
      end
    end

    # Structure Stubber for CancelSpotFleetRequestsError
    class CancelSpotFleetRequestsError
      def self.default(visited=[])
        return nil if visited.include?('CancelSpotFleetRequestsError')
        visited = visited + ['CancelSpotFleetRequestsError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # List Stubber for CancelSpotFleetRequestsSuccessSet
    class CancelSpotFleetRequestsSuccessSet
      def self.default(visited=[])
        return nil if visited.include?('CancelSpotFleetRequestsSuccessSet')
        visited = visited + ['CancelSpotFleetRequestsSuccessSet']
        [
          CancelSpotFleetRequestsSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CancelSpotFleetRequestsSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CancelSpotFleetRequestsSuccessItem
    class CancelSpotFleetRequestsSuccessItem
      def self.default(visited=[])
        return nil if visited.include?('CancelSpotFleetRequestsSuccessItem')
        visited = visited + ['CancelSpotFleetRequestsSuccessItem']
        {
          current_spot_fleet_request_state: 'current_spot_fleet_request_state',
          previous_spot_fleet_request_state: 'previous_spot_fleet_request_state',
          spot_fleet_request_id: 'spot_fleet_request_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currentSpotFleetRequestState', stub[:current_spot_fleet_request_state].to_s) unless stub[:current_spot_fleet_request_state].nil?
        xml << Hearth::XML::Node.new('previousSpotFleetRequestState', stub[:previous_spot_fleet_request_state].to_s) unless stub[:previous_spot_fleet_request_state].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        xml
      end
    end

    # Operation Stubber for CancelSpotInstanceRequests
    class CancelSpotInstanceRequests
      def self.default(visited=[])
        {
          cancelled_spot_instance_requests: CancelledSpotInstanceRequestList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelSpotInstanceRequestsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotInstanceRequestSet', CancelledSpotInstanceRequestList.stub('item', stub[:cancelled_spot_instance_requests])) unless stub[:cancelled_spot_instance_requests].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CancelledSpotInstanceRequestList
    class CancelledSpotInstanceRequestList
      def self.default(visited=[])
        return nil if visited.include?('CancelledSpotInstanceRequestList')
        visited = visited + ['CancelledSpotInstanceRequestList']
        [
          CancelledSpotInstanceRequest.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CancelledSpotInstanceRequest.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CancelledSpotInstanceRequest
    class CancelledSpotInstanceRequest
      def self.default(visited=[])
        return nil if visited.include?('CancelledSpotInstanceRequest')
        visited = visited + ['CancelledSpotInstanceRequest']
        {
          spot_instance_request_id: 'spot_instance_request_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('spotInstanceRequestId', stub[:spot_instance_request_id].to_s) unless stub[:spot_instance_request_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for ConfirmProductInstance
    class ConfirmProductInstance
      def self.default(visited=[])
        {
          owner_id: 'owner_id',
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ConfirmProductInstanceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CopyFpgaImage
    class CopyFpgaImage
      def self.default(visited=[])
        {
          fpga_image_id: 'fpga_image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CopyFpgaImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fpgaImageId', stub[:fpga_image_id].to_s) unless stub[:fpga_image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CopyImage
    class CopyImage
      def self.default(visited=[])
        {
          image_id: 'image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CopyImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CopySnapshot
    class CopySnapshot
      def self.default(visited=[])
        {
          snapshot_id: 'snapshot_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CopySnapshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateCapacityReservation
    class CreateCapacityReservation
      def self.default(visited=[])
        {
          capacity_reservation: CapacityReservation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCapacityReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CapacityReservation.stub('capacityReservation', stub[:capacity_reservation]) unless stub[:capacity_reservation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for CapacityReservation
    class CapacityReservation
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservation')
        visited = visited + ['CapacityReservation']
        {
          capacity_reservation_id: 'capacity_reservation_id',
          owner_id: 'owner_id',
          capacity_reservation_arn: 'capacity_reservation_arn',
          availability_zone_id: 'availability_zone_id',
          instance_type: 'instance_type',
          instance_platform: 'instance_platform',
          availability_zone: 'availability_zone',
          tenancy: 'tenancy',
          total_instance_count: 1,
          available_instance_count: 1,
          ebs_optimized: false,
          ephemeral_storage: false,
          state: 'state',
          start_date: Time.now,
          end_date: Time.now,
          end_date_type: 'end_date_type',
          instance_match_criteria: 'instance_match_criteria',
          create_date: Time.now,
          tags: TagList.default(visited),
          outpost_arn: 'outpost_arn',
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
          placement_group_arn: 'placement_group_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('capacityReservationArn', stub[:capacity_reservation_arn].to_s) unless stub[:capacity_reservation_arn].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('instancePlatform', stub[:instance_platform].to_s) unless stub[:instance_platform].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('totalInstanceCount', stub[:total_instance_count].to_s) unless stub[:total_instance_count].nil?
        xml << Hearth::XML::Node.new('availableInstanceCount', stub[:available_instance_count].to_s) unless stub[:available_instance_count].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << Hearth::XML::Node.new('ephemeralStorage', stub[:ephemeral_storage].to_s) unless stub[:ephemeral_storage].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('startDate', Hearth::TimeHelper.to_date_time(stub[:start_date])) unless stub[:start_date].nil?
        xml << Hearth::XML::Node.new('endDate', Hearth::TimeHelper.to_date_time(stub[:end_date])) unless stub[:end_date].nil?
        xml << Hearth::XML::Node.new('endDateType', stub[:end_date_type].to_s) unless stub[:end_date_type].nil?
        xml << Hearth::XML::Node.new('instanceMatchCriteria', stub[:instance_match_criteria].to_s) unless stub[:instance_match_criteria].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml << Hearth::XML::Node.new('placementGroupArn', stub[:placement_group_arn].to_s) unless stub[:placement_group_arn].nil?
        xml
      end
    end

    # Operation Stubber for CreateCapacityReservationFleet
    class CreateCapacityReservationFleet
      def self.default(visited=[])
        {
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
          state: 'state',
          total_target_capacity: 1,
          total_fulfilled_capacity: 1.0,
          instance_match_criteria: 'instance_match_criteria',
          allocation_strategy: 'allocation_strategy',
          create_time: Time.now,
          end_date: Time.now,
          tenancy: 'tenancy',
          fleet_capacity_reservations: FleetCapacityReservationSet.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCapacityReservationFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('totalTargetCapacity', stub[:total_target_capacity].to_s) unless stub[:total_target_capacity].nil?
        xml << Hearth::XML::Node.new('totalFulfilledCapacity', Hearth::NumberHelper.serialize(stub[:total_fulfilled_capacity]).to_s) unless stub[:total_fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('instanceMatchCriteria', stub[:instance_match_criteria].to_s) unless stub[:instance_match_criteria].nil?
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('endDate', Hearth::TimeHelper.to_date_time(stub[:end_date])) unless stub[:end_date].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('fleetCapacityReservationSet', FleetCapacityReservationSet.stub('item', stub[:fleet_capacity_reservations])) unless stub[:fleet_capacity_reservations].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for FleetCapacityReservationSet
    class FleetCapacityReservationSet
      def self.default(visited=[])
        return nil if visited.include?('FleetCapacityReservationSet')
        visited = visited + ['FleetCapacityReservationSet']
        [
          FleetCapacityReservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FleetCapacityReservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for FleetCapacityReservation
    class FleetCapacityReservation
      def self.default(visited=[])
        return nil if visited.include?('FleetCapacityReservation')
        visited = visited + ['FleetCapacityReservation']
        {
          capacity_reservation_id: 'capacity_reservation_id',
          availability_zone_id: 'availability_zone_id',
          instance_type: 'instance_type',
          instance_platform: 'instance_platform',
          availability_zone: 'availability_zone',
          total_instance_count: 1,
          fulfilled_capacity: 1.0,
          ebs_optimized: false,
          create_date: Time.now,
          weight: 1.0,
          priority: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('instancePlatform', stub[:instance_platform].to_s) unless stub[:instance_platform].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('totalInstanceCount', stub[:total_instance_count].to_s) unless stub[:total_instance_count].nil?
        xml << Hearth::XML::Node.new('fulfilledCapacity', Hearth::NumberHelper.serialize(stub[:fulfilled_capacity]).to_s) unless stub[:fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('weight', Hearth::NumberHelper.serialize(stub[:weight]).to_s) unless stub[:weight].nil?
        xml << Hearth::XML::Node.new('priority', stub[:priority].to_s) unless stub[:priority].nil?
        xml
      end
    end

    # Operation Stubber for CreateCarrierGateway
    class CreateCarrierGateway
      def self.default(visited=[])
        {
          carrier_gateway: CarrierGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCarrierGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CarrierGateway.stub('carrierGateway', stub[:carrier_gateway]) unless stub[:carrier_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for CarrierGateway
    class CarrierGateway
      def self.default(visited=[])
        return nil if visited.include?('CarrierGateway')
        visited = visited + ['CarrierGateway']
        {
          carrier_gateway_id: 'carrier_gateway_id',
          vpc_id: 'vpc_id',
          state: 'state',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('carrierGatewayId', stub[:carrier_gateway_id].to_s) unless stub[:carrier_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateClientVpnEndpoint
    class CreateClientVpnEndpoint
      def self.default(visited=[])
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          status: ClientVpnEndpointStatus.default(visited),
          dns_name: 'dns_name',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateClientVpnEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << ClientVpnEndpointStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('dnsName', stub[:dns_name].to_s) unless stub[:dns_name].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ClientVpnEndpointStatus
    class ClientVpnEndpointStatus
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnEndpointStatus')
        visited = visited + ['ClientVpnEndpointStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for CreateClientVpnRoute
    class CreateClientVpnRoute
      def self.default(visited=[])
        {
          status: ClientVpnRouteStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateClientVpnRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnRouteStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ClientVpnRouteStatus
    class ClientVpnRouteStatus
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnRouteStatus')
        visited = visited + ['ClientVpnRouteStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for CreateCustomerGateway
    class CreateCustomerGateway
      def self.default(visited=[])
        {
          customer_gateway: CustomerGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCustomerGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CustomerGateway.stub('customerGateway', stub[:customer_gateway]) unless stub[:customer_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for CustomerGateway
    class CustomerGateway
      def self.default(visited=[])
        return nil if visited.include?('CustomerGateway')
        visited = visited + ['CustomerGateway']
        {
          bgp_asn: 'bgp_asn',
          customer_gateway_id: 'customer_gateway_id',
          ip_address: 'ip_address',
          certificate_arn: 'certificate_arn',
          state: 'state',
          type: 'type',
          device_name: 'device_name',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('bgpAsn', stub[:bgp_asn].to_s) unless stub[:bgp_asn].nil?
        xml << Hearth::XML::Node.new('customerGatewayId', stub[:customer_gateway_id].to_s) unless stub[:customer_gateway_id].nil?
        xml << Hearth::XML::Node.new('ipAddress', stub[:ip_address].to_s) unless stub[:ip_address].nil?
        xml << Hearth::XML::Node.new('certificateArn', stub[:certificate_arn].to_s) unless stub[:certificate_arn].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateDefaultSubnet
    class CreateDefaultSubnet
      def self.default(visited=[])
        {
          subnet: Subnet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateDefaultSubnetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Subnet.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for Subnet
    class Subnet
      def self.default(visited=[])
        return nil if visited.include?('Subnet')
        visited = visited + ['Subnet']
        {
          availability_zone: 'availability_zone',
          availability_zone_id: 'availability_zone_id',
          available_ip_address_count: 1,
          cidr_block: 'cidr_block',
          default_for_az: false,
          enable_lni_at_device_index: 1,
          map_public_ip_on_launch: false,
          map_customer_owned_ip_on_launch: false,
          customer_owned_ipv4_pool: 'customer_owned_ipv4_pool',
          state: 'state',
          subnet_id: 'subnet_id',
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
          assign_ipv6_address_on_creation: false,
          ipv6_cidr_block_association_set: SubnetIpv6CidrBlockAssociationSet.default(visited),
          tags: TagList.default(visited),
          subnet_arn: 'subnet_arn',
          outpost_arn: 'outpost_arn',
          enable_dns64: false,
          ipv6_native: false,
          private_dns_name_options_on_launch: PrivateDnsNameOptionsOnLaunch.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('availableIpAddressCount', stub[:available_ip_address_count].to_s) unless stub[:available_ip_address_count].nil?
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << Hearth::XML::Node.new('defaultForAz', stub[:default_for_az].to_s) unless stub[:default_for_az].nil?
        xml << Hearth::XML::Node.new('enableLniAtDeviceIndex', stub[:enable_lni_at_device_index].to_s) unless stub[:enable_lni_at_device_index].nil?
        xml << Hearth::XML::Node.new('mapPublicIpOnLaunch', stub[:map_public_ip_on_launch].to_s) unless stub[:map_public_ip_on_launch].nil?
        xml << Hearth::XML::Node.new('mapCustomerOwnedIpOnLaunch', stub[:map_customer_owned_ip_on_launch].to_s) unless stub[:map_customer_owned_ip_on_launch].nil?
        xml << Hearth::XML::Node.new('customerOwnedIpv4Pool', stub[:customer_owned_ipv4_pool].to_s) unless stub[:customer_owned_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('assignIpv6AddressOnCreation', stub[:assign_ipv6_address_on_creation].to_s) unless stub[:assign_ipv6_address_on_creation].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlockAssociationSet', SubnetIpv6CidrBlockAssociationSet.stub('item', stub[:ipv6_cidr_block_association_set])) unless stub[:ipv6_cidr_block_association_set].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('subnetArn', stub[:subnet_arn].to_s) unless stub[:subnet_arn].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('enableDns64', stub[:enable_dns64].to_s) unless stub[:enable_dns64].nil?
        xml << Hearth::XML::Node.new('ipv6Native', stub[:ipv6_native].to_s) unless stub[:ipv6_native].nil?
        xml << PrivateDnsNameOptionsOnLaunch.stub('privateDnsNameOptionsOnLaunch', stub[:private_dns_name_options_on_launch]) unless stub[:private_dns_name_options_on_launch].nil?
        xml
      end
    end

    # Structure Stubber for PrivateDnsNameOptionsOnLaunch
    class PrivateDnsNameOptionsOnLaunch
      def self.default(visited=[])
        return nil if visited.include?('PrivateDnsNameOptionsOnLaunch')
        visited = visited + ['PrivateDnsNameOptionsOnLaunch']
        {
          hostname_type: 'hostname_type',
          enable_resource_name_dns_a_record: false,
          enable_resource_name_dns_aaaa_record: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('hostnameType', stub[:hostname_type].to_s) unless stub[:hostname_type].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsARecord', stub[:enable_resource_name_dns_a_record].to_s) unless stub[:enable_resource_name_dns_a_record].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsAAAARecord', stub[:enable_resource_name_dns_aaaa_record].to_s) unless stub[:enable_resource_name_dns_aaaa_record].nil?
        xml
      end
    end

    # List Stubber for SubnetIpv6CidrBlockAssociationSet
    class SubnetIpv6CidrBlockAssociationSet
      def self.default(visited=[])
        return nil if visited.include?('SubnetIpv6CidrBlockAssociationSet')
        visited = visited + ['SubnetIpv6CidrBlockAssociationSet']
        [
          SubnetIpv6CidrBlockAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SubnetIpv6CidrBlockAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for CreateDefaultVpc
    class CreateDefaultVpc
      def self.default(visited=[])
        {
          vpc: Vpc.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateDefaultVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Vpc.stub('vpc', stub[:vpc]) unless stub[:vpc].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for Vpc
    class Vpc
      def self.default(visited=[])
        return nil if visited.include?('Vpc')
        visited = visited + ['Vpc']
        {
          cidr_block: 'cidr_block',
          dhcp_options_id: 'dhcp_options_id',
          state: 'state',
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
          instance_tenancy: 'instance_tenancy',
          ipv6_cidr_block_association_set: VpcIpv6CidrBlockAssociationSet.default(visited),
          cidr_block_association_set: VpcCidrBlockAssociationSet.default(visited),
          is_default: false,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << Hearth::XML::Node.new('dhcpOptionsId', stub[:dhcp_options_id].to_s) unless stub[:dhcp_options_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('instanceTenancy', stub[:instance_tenancy].to_s) unless stub[:instance_tenancy].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlockAssociationSet', VpcIpv6CidrBlockAssociationSet.stub('item', stub[:ipv6_cidr_block_association_set])) unless stub[:ipv6_cidr_block_association_set].nil?
        xml << Hearth::XML::Node.new('cidrBlockAssociationSet', VpcCidrBlockAssociationSet.stub('item', stub[:cidr_block_association_set])) unless stub[:cidr_block_association_set].nil?
        xml << Hearth::XML::Node.new('isDefault', stub[:is_default].to_s) unless stub[:is_default].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for VpcCidrBlockAssociationSet
    class VpcCidrBlockAssociationSet
      def self.default(visited=[])
        return nil if visited.include?('VpcCidrBlockAssociationSet')
        visited = visited + ['VpcCidrBlockAssociationSet']
        [
          VpcCidrBlockAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcCidrBlockAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for VpcIpv6CidrBlockAssociationSet
    class VpcIpv6CidrBlockAssociationSet
      def self.default(visited=[])
        return nil if visited.include?('VpcIpv6CidrBlockAssociationSet')
        visited = visited + ['VpcIpv6CidrBlockAssociationSet']
        [
          VpcIpv6CidrBlockAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcIpv6CidrBlockAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for CreateDhcpOptions
    class CreateDhcpOptions
      def self.default(visited=[])
        {
          dhcp_options: DhcpOptions.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateDhcpOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << DhcpOptions.stub('dhcpOptions', stub[:dhcp_options]) unless stub[:dhcp_options].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for DhcpOptions
    class DhcpOptions
      def self.default(visited=[])
        return nil if visited.include?('DhcpOptions')
        visited = visited + ['DhcpOptions']
        {
          dhcp_configurations: DhcpConfigurationList.default(visited),
          dhcp_options_id: 'dhcp_options_id',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dhcpConfigurationSet', DhcpConfigurationList.stub('item', stub[:dhcp_configurations])) unless stub[:dhcp_configurations].nil?
        xml << Hearth::XML::Node.new('dhcpOptionsId', stub[:dhcp_options_id].to_s) unless stub[:dhcp_options_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for DhcpConfigurationList
    class DhcpConfigurationList
      def self.default(visited=[])
        return nil if visited.include?('DhcpConfigurationList')
        visited = visited + ['DhcpConfigurationList']
        [
          DhcpConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DhcpConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DhcpConfiguration
    class DhcpConfiguration
      def self.default(visited=[])
        return nil if visited.include?('DhcpConfiguration')
        visited = visited + ['DhcpConfiguration']
        {
          key: 'key',
          values: DhcpConfigurationValueList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('key', stub[:key].to_s) unless stub[:key].nil?
        xml << Hearth::XML::Node.new('valueSet', DhcpConfigurationValueList.stub('item', stub[:values])) unless stub[:values].nil?
        xml
      end
    end

    # List Stubber for DhcpConfigurationValueList
    class DhcpConfigurationValueList
      def self.default(visited=[])
        return nil if visited.include?('DhcpConfigurationValueList')
        visited = visited + ['DhcpConfigurationValueList']
        [
          AttributeValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AttributeValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AttributeValue
    class AttributeValue
      def self.default(visited=[])
        return nil if visited.include?('AttributeValue')
        visited = visited + ['AttributeValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # Operation Stubber for CreateEgressOnlyInternetGateway
    class CreateEgressOnlyInternetGateway
      def self.default(visited=[])
        {
          client_token: 'client_token',
          egress_only_internet_gateway: EgressOnlyInternetGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateEgressOnlyInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << EgressOnlyInternetGateway.stub('egressOnlyInternetGateway', stub[:egress_only_internet_gateway]) unless stub[:egress_only_internet_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for EgressOnlyInternetGateway
    class EgressOnlyInternetGateway
      def self.default(visited=[])
        return nil if visited.include?('EgressOnlyInternetGateway')
        visited = visited + ['EgressOnlyInternetGateway']
        {
          attachments: InternetGatewayAttachmentList.default(visited),
          egress_only_internet_gateway_id: 'egress_only_internet_gateway_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachmentSet', InternetGatewayAttachmentList.stub('item', stub[:attachments])) unless stub[:attachments].nil?
        xml << Hearth::XML::Node.new('egressOnlyInternetGatewayId', stub[:egress_only_internet_gateway_id].to_s) unless stub[:egress_only_internet_gateway_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for InternetGatewayAttachmentList
    class InternetGatewayAttachmentList
      def self.default(visited=[])
        return nil if visited.include?('InternetGatewayAttachmentList')
        visited = visited + ['InternetGatewayAttachmentList']
        [
          InternetGatewayAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InternetGatewayAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InternetGatewayAttachment
    class InternetGatewayAttachment
      def self.default(visited=[])
        return nil if visited.include?('InternetGatewayAttachment')
        visited = visited + ['InternetGatewayAttachment']
        {
          state: 'state',
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    # Operation Stubber for CreateFleet
    class CreateFleet
      def self.default(visited=[])
        {
          fleet_id: 'fleet_id',
          errors: CreateFleetErrorsSet.default(visited),
          instances: CreateFleetInstancesSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml << Hearth::XML::Node.new('errorSet', CreateFleetErrorsSet.stub('item', stub[:errors])) unless stub[:errors].nil?
        xml << Hearth::XML::Node.new('fleetInstanceSet', CreateFleetInstancesSet.stub('item', stub[:instances])) unless stub[:instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CreateFleetInstancesSet
    class CreateFleetInstancesSet
      def self.default(visited=[])
        return nil if visited.include?('CreateFleetInstancesSet')
        visited = visited + ['CreateFleetInstancesSet']
        [
          CreateFleetInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CreateFleetInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CreateFleetInstance
    class CreateFleetInstance
      def self.default(visited=[])
        return nil if visited.include?('CreateFleetInstance')
        visited = visited + ['CreateFleetInstance']
        {
          launch_template_and_overrides: LaunchTemplateAndOverridesResponse.default(visited),
          lifecycle: 'lifecycle',
          instance_ids: InstanceIdsSet.default(visited),
          instance_type: 'instance_type',
          platform: 'platform',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << LaunchTemplateAndOverridesResponse.stub('launchTemplateAndOverrides', stub[:launch_template_and_overrides]) unless stub[:launch_template_and_overrides].nil?
        xml << Hearth::XML::Node.new('lifecycle', stub[:lifecycle].to_s) unless stub[:lifecycle].nil?
        xml << Hearth::XML::Node.new('instanceIds', InstanceIdsSet.stub('item', stub[:instance_ids])) unless stub[:instance_ids].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml
      end
    end

    # List Stubber for InstanceIdsSet
    class InstanceIdsSet
      def self.default(visited=[])
        return nil if visited.include?('InstanceIdsSet')
        visited = visited + ['InstanceIdsSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LaunchTemplateAndOverridesResponse
    class LaunchTemplateAndOverridesResponse
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateAndOverridesResponse')
        visited = visited + ['LaunchTemplateAndOverridesResponse']
        {
          launch_template_specification: FleetLaunchTemplateSpecification.default(visited),
          overrides: FleetLaunchTemplateOverrides.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << FleetLaunchTemplateSpecification.stub('launchTemplateSpecification', stub[:launch_template_specification]) unless stub[:launch_template_specification].nil?
        xml << FleetLaunchTemplateOverrides.stub('overrides', stub[:overrides]) unless stub[:overrides].nil?
        xml
      end
    end

    # Structure Stubber for FleetLaunchTemplateOverrides
    class FleetLaunchTemplateOverrides
      def self.default(visited=[])
        return nil if visited.include?('FleetLaunchTemplateOverrides')
        visited = visited + ['FleetLaunchTemplateOverrides']
        {
          instance_type: 'instance_type',
          max_price: 'max_price',
          subnet_id: 'subnet_id',
          availability_zone: 'availability_zone',
          weighted_capacity: 1.0,
          priority: 1.0,
          placement: PlacementResponse.default(visited),
          instance_requirements: InstanceRequirements.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('maxPrice', stub[:max_price].to_s) unless stub[:max_price].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('weightedCapacity', Hearth::NumberHelper.serialize(stub[:weighted_capacity]).to_s) unless stub[:weighted_capacity].nil?
        xml << Hearth::XML::Node.new('priority', Hearth::NumberHelper.serialize(stub[:priority]).to_s) unless stub[:priority].nil?
        xml << PlacementResponse.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << InstanceRequirements.stub('instanceRequirements', stub[:instance_requirements]) unless stub[:instance_requirements].nil?
        xml
      end
    end

    # Structure Stubber for InstanceRequirements
    class InstanceRequirements
      def self.default(visited=[])
        return nil if visited.include?('InstanceRequirements')
        visited = visited + ['InstanceRequirements']
        {
          v_cpu_count: VCpuCountRange.default(visited),
          memory_mi_b: MemoryMiB.default(visited),
          cpu_manufacturers: CpuManufacturerSet.default(visited),
          memory_gi_b_per_v_cpu: MemoryGiBPerVCpu.default(visited),
          excluded_instance_types: ExcludedInstanceTypeSet.default(visited),
          instance_generations: InstanceGenerationSet.default(visited),
          spot_max_price_percentage_over_lowest_price: 1,
          on_demand_max_price_percentage_over_lowest_price: 1,
          bare_metal: 'bare_metal',
          burstable_performance: 'burstable_performance',
          require_hibernate_support: false,
          network_interface_count: NetworkInterfaceCount.default(visited),
          local_storage: 'local_storage',
          local_storage_types: LocalStorageTypeSet.default(visited),
          total_local_storage_gb: TotalLocalStorageGB.default(visited),
          baseline_ebs_bandwidth_mbps: BaselineEbsBandwidthMbps.default(visited),
          accelerator_types: AcceleratorTypeSet.default(visited),
          accelerator_count: AcceleratorCount.default(visited),
          accelerator_manufacturers: AcceleratorManufacturerSet.default(visited),
          accelerator_names: AcceleratorNameSet.default(visited),
          accelerator_total_memory_mi_b: AcceleratorTotalMemoryMiB.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << VCpuCountRange.stub('vCpuCount', stub[:v_cpu_count]) unless stub[:v_cpu_count].nil?
        xml << MemoryMiB.stub('memoryMiB', stub[:memory_mi_b]) unless stub[:memory_mi_b].nil?
        xml << Hearth::XML::Node.new('cpuManufacturerSet', CpuManufacturerSet.stub('item', stub[:cpu_manufacturers])) unless stub[:cpu_manufacturers].nil?
        xml << MemoryGiBPerVCpu.stub('memoryGiBPerVCpu', stub[:memory_gi_b_per_v_cpu]) unless stub[:memory_gi_b_per_v_cpu].nil?
        xml << Hearth::XML::Node.new('excludedInstanceTypeSet', ExcludedInstanceTypeSet.stub('item', stub[:excluded_instance_types])) unless stub[:excluded_instance_types].nil?
        xml << Hearth::XML::Node.new('instanceGenerationSet', InstanceGenerationSet.stub('item', stub[:instance_generations])) unless stub[:instance_generations].nil?
        xml << Hearth::XML::Node.new('spotMaxPricePercentageOverLowestPrice', stub[:spot_max_price_percentage_over_lowest_price].to_s) unless stub[:spot_max_price_percentage_over_lowest_price].nil?
        xml << Hearth::XML::Node.new('onDemandMaxPricePercentageOverLowestPrice', stub[:on_demand_max_price_percentage_over_lowest_price].to_s) unless stub[:on_demand_max_price_percentage_over_lowest_price].nil?
        xml << Hearth::XML::Node.new('bareMetal', stub[:bare_metal].to_s) unless stub[:bare_metal].nil?
        xml << Hearth::XML::Node.new('burstablePerformance', stub[:burstable_performance].to_s) unless stub[:burstable_performance].nil?
        xml << Hearth::XML::Node.new('requireHibernateSupport', stub[:require_hibernate_support].to_s) unless stub[:require_hibernate_support].nil?
        xml << NetworkInterfaceCount.stub('networkInterfaceCount', stub[:network_interface_count]) unless stub[:network_interface_count].nil?
        xml << Hearth::XML::Node.new('localStorage', stub[:local_storage].to_s) unless stub[:local_storage].nil?
        xml << Hearth::XML::Node.new('localStorageTypeSet', LocalStorageTypeSet.stub('item', stub[:local_storage_types])) unless stub[:local_storage_types].nil?
        xml << TotalLocalStorageGB.stub('totalLocalStorageGB', stub[:total_local_storage_gb]) unless stub[:total_local_storage_gb].nil?
        xml << BaselineEbsBandwidthMbps.stub('baselineEbsBandwidthMbps', stub[:baseline_ebs_bandwidth_mbps]) unless stub[:baseline_ebs_bandwidth_mbps].nil?
        xml << Hearth::XML::Node.new('acceleratorTypeSet', AcceleratorTypeSet.stub('item', stub[:accelerator_types])) unless stub[:accelerator_types].nil?
        xml << AcceleratorCount.stub('acceleratorCount', stub[:accelerator_count]) unless stub[:accelerator_count].nil?
        xml << Hearth::XML::Node.new('acceleratorManufacturerSet', AcceleratorManufacturerSet.stub('item', stub[:accelerator_manufacturers])) unless stub[:accelerator_manufacturers].nil?
        xml << Hearth::XML::Node.new('acceleratorNameSet', AcceleratorNameSet.stub('item', stub[:accelerator_names])) unless stub[:accelerator_names].nil?
        xml << AcceleratorTotalMemoryMiB.stub('acceleratorTotalMemoryMiB', stub[:accelerator_total_memory_mi_b]) unless stub[:accelerator_total_memory_mi_b].nil?
        xml
      end
    end

    # Structure Stubber for AcceleratorTotalMemoryMiB
    class AcceleratorTotalMemoryMiB
      def self.default(visited=[])
        return nil if visited.include?('AcceleratorTotalMemoryMiB')
        visited = visited + ['AcceleratorTotalMemoryMiB']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    # List Stubber for AcceleratorNameSet
    class AcceleratorNameSet
      def self.default(visited=[])
        return nil if visited.include?('AcceleratorNameSet')
        visited = visited + ['AcceleratorNameSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for AcceleratorManufacturerSet
    class AcceleratorManufacturerSet
      def self.default(visited=[])
        return nil if visited.include?('AcceleratorManufacturerSet')
        visited = visited + ['AcceleratorManufacturerSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AcceleratorCount
    class AcceleratorCount
      def self.default(visited=[])
        return nil if visited.include?('AcceleratorCount')
        visited = visited + ['AcceleratorCount']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    # List Stubber for AcceleratorTypeSet
    class AcceleratorTypeSet
      def self.default(visited=[])
        return nil if visited.include?('AcceleratorTypeSet')
        visited = visited + ['AcceleratorTypeSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for BaselineEbsBandwidthMbps
    class BaselineEbsBandwidthMbps
      def self.default(visited=[])
        return nil if visited.include?('BaselineEbsBandwidthMbps')
        visited = visited + ['BaselineEbsBandwidthMbps']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    # Structure Stubber for TotalLocalStorageGB
    class TotalLocalStorageGB
      def self.default(visited=[])
        return nil if visited.include?('TotalLocalStorageGB')
        visited = visited + ['TotalLocalStorageGB']
        {
          min: 1.0,
          max: 1.0,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', Hearth::NumberHelper.serialize(stub[:min]).to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', Hearth::NumberHelper.serialize(stub[:max]).to_s) unless stub[:max].nil?
        xml
      end
    end

    # List Stubber for LocalStorageTypeSet
    class LocalStorageTypeSet
      def self.default(visited=[])
        return nil if visited.include?('LocalStorageTypeSet')
        visited = visited + ['LocalStorageTypeSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NetworkInterfaceCount
    class NetworkInterfaceCount
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfaceCount')
        visited = visited + ['NetworkInterfaceCount']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    # List Stubber for InstanceGenerationSet
    class InstanceGenerationSet
      def self.default(visited=[])
        return nil if visited.include?('InstanceGenerationSet')
        visited = visited + ['InstanceGenerationSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for ExcludedInstanceTypeSet
    class ExcludedInstanceTypeSet
      def self.default(visited=[])
        return nil if visited.include?('ExcludedInstanceTypeSet')
        visited = visited + ['ExcludedInstanceTypeSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for MemoryGiBPerVCpu
    class MemoryGiBPerVCpu
      def self.default(visited=[])
        return nil if visited.include?('MemoryGiBPerVCpu')
        visited = visited + ['MemoryGiBPerVCpu']
        {
          min: 1.0,
          max: 1.0,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', Hearth::NumberHelper.serialize(stub[:min]).to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', Hearth::NumberHelper.serialize(stub[:max]).to_s) unless stub[:max].nil?
        xml
      end
    end

    # List Stubber for CpuManufacturerSet
    class CpuManufacturerSet
      def self.default(visited=[])
        return nil if visited.include?('CpuManufacturerSet')
        visited = visited + ['CpuManufacturerSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for MemoryMiB
    class MemoryMiB
      def self.default(visited=[])
        return nil if visited.include?('MemoryMiB')
        visited = visited + ['MemoryMiB']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    # Structure Stubber for VCpuCountRange
    class VCpuCountRange
      def self.default(visited=[])
        return nil if visited.include?('VCpuCountRange')
        visited = visited + ['VCpuCountRange']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    # Structure Stubber for PlacementResponse
    class PlacementResponse
      def self.default(visited=[])
        return nil if visited.include?('PlacementResponse')
        visited = visited + ['PlacementResponse']
        {
          group_name: 'group_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml
      end
    end

    # Structure Stubber for FleetLaunchTemplateSpecification
    class FleetLaunchTemplateSpecification
      def self.default(visited=[])
        return nil if visited.include?('FleetLaunchTemplateSpecification')
        visited = visited + ['FleetLaunchTemplateSpecification']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version: 'version',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('version', stub[:version].to_s) unless stub[:version].nil?
        xml
      end
    end

    # List Stubber for CreateFleetErrorsSet
    class CreateFleetErrorsSet
      def self.default(visited=[])
        return nil if visited.include?('CreateFleetErrorsSet')
        visited = visited + ['CreateFleetErrorsSet']
        [
          CreateFleetError.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CreateFleetError.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CreateFleetError
    class CreateFleetError
      def self.default(visited=[])
        return nil if visited.include?('CreateFleetError')
        visited = visited + ['CreateFleetError']
        {
          launch_template_and_overrides: LaunchTemplateAndOverridesResponse.default(visited),
          lifecycle: 'lifecycle',
          error_code: 'error_code',
          error_message: 'error_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << LaunchTemplateAndOverridesResponse.stub('launchTemplateAndOverrides', stub[:launch_template_and_overrides]) unless stub[:launch_template_and_overrides].nil?
        xml << Hearth::XML::Node.new('lifecycle', stub[:lifecycle].to_s) unless stub[:lifecycle].nil?
        xml << Hearth::XML::Node.new('errorCode', stub[:error_code].to_s) unless stub[:error_code].nil?
        xml << Hearth::XML::Node.new('errorMessage', stub[:error_message].to_s) unless stub[:error_message].nil?
        xml
      end
    end

    # Operation Stubber for CreateFlowLogs
    class CreateFlowLogs
      def self.default(visited=[])
        {
          client_token: 'client_token',
          flow_log_ids: ValueStringList.default(visited),
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateFlowLogsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('flowLogIdSet', ValueStringList.stub('item', stub[:flow_log_ids])) unless stub[:flow_log_ids].nil?
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateFpgaImage
    class CreateFpgaImage
      def self.default(visited=[])
        {
          fpga_image_id: 'fpga_image_id',
          fpga_image_global_id: 'fpga_image_global_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateFpgaImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fpgaImageId', stub[:fpga_image_id].to_s) unless stub[:fpga_image_id].nil?
        xml << Hearth::XML::Node.new('fpgaImageGlobalId', stub[:fpga_image_global_id].to_s) unless stub[:fpga_image_global_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateImage
    class CreateImage
      def self.default(visited=[])
        {
          image_id: 'image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateInstanceEventWindow
    class CreateInstanceEventWindow
      def self.default(visited=[])
        {
          instance_event_window: InstanceEventWindow.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindow.stub('instanceEventWindow', stub[:instance_event_window]) unless stub[:instance_event_window].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateInstanceExportTask
    class CreateInstanceExportTask
      def self.default(visited=[])
        {
          export_task: ExportTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateInstanceExportTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ExportTask.stub('exportTask', stub[:export_task]) unless stub[:export_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ExportTask
    class ExportTask
      def self.default(visited=[])
        return nil if visited.include?('ExportTask')
        visited = visited + ['ExportTask']
        {
          description: 'description',
          export_task_id: 'export_task_id',
          export_to_s3_task: ExportToS3Task.default(visited),
          instance_export_details: InstanceExportDetails.default(visited),
          state: 'state',
          status_message: 'status_message',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('exportTaskId', stub[:export_task_id].to_s) unless stub[:export_task_id].nil?
        xml << ExportToS3Task.stub('exportToS3', stub[:export_to_s3_task]) unless stub[:export_to_s3_task].nil?
        xml << InstanceExportDetails.stub('instanceExport', stub[:instance_export_details]) unless stub[:instance_export_details].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for InstanceExportDetails
    class InstanceExportDetails
      def self.default(visited=[])
        return nil if visited.include?('InstanceExportDetails')
        visited = visited + ['InstanceExportDetails']
        {
          instance_id: 'instance_id',
          target_environment: 'target_environment',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('targetEnvironment', stub[:target_environment].to_s) unless stub[:target_environment].nil?
        xml
      end
    end

    # Structure Stubber for ExportToS3Task
    class ExportToS3Task
      def self.default(visited=[])
        return nil if visited.include?('ExportToS3Task')
        visited = visited + ['ExportToS3Task']
        {
          container_format: 'container_format',
          disk_image_format: 'disk_image_format',
          s3_bucket: 's3_bucket',
          s3_key: 's3_key',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('containerFormat', stub[:container_format].to_s) unless stub[:container_format].nil?
        xml << Hearth::XML::Node.new('diskImageFormat', stub[:disk_image_format].to_s) unless stub[:disk_image_format].nil?
        xml << Hearth::XML::Node.new('s3Bucket', stub[:s3_bucket].to_s) unless stub[:s3_bucket].nil?
        xml << Hearth::XML::Node.new('s3Key', stub[:s3_key].to_s) unless stub[:s3_key].nil?
        xml
      end
    end

    # Operation Stubber for CreateInternetGateway
    class CreateInternetGateway
      def self.default(visited=[])
        {
          internet_gateway: InternetGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InternetGateway.stub('internetGateway', stub[:internet_gateway]) unless stub[:internet_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for InternetGateway
    class InternetGateway
      def self.default(visited=[])
        return nil if visited.include?('InternetGateway')
        visited = visited + ['InternetGateway']
        {
          attachments: InternetGatewayAttachmentList.default(visited),
          internet_gateway_id: 'internet_gateway_id',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachmentSet', InternetGatewayAttachmentList.stub('item', stub[:attachments])) unless stub[:attachments].nil?
        xml << Hearth::XML::Node.new('internetGatewayId', stub[:internet_gateway_id].to_s) unless stub[:internet_gateway_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateIpam
    class CreateIpam
      def self.default(visited=[])
        {
          ipam: Ipam.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateIpamResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Ipam.stub('ipam', stub[:ipam]) unless stub[:ipam].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for Ipam
    class Ipam
      def self.default(visited=[])
        return nil if visited.include?('Ipam')
        visited = visited + ['Ipam']
        {
          owner_id: 'owner_id',
          ipam_id: 'ipam_id',
          ipam_arn: 'ipam_arn',
          ipam_region: 'ipam_region',
          public_default_scope_id: 'public_default_scope_id',
          private_default_scope_id: 'private_default_scope_id',
          scope_count: 1,
          description: 'description',
          operating_regions: IpamOperatingRegionSet.default(visited),
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ipamId', stub[:ipam_id].to_s) unless stub[:ipam_id].nil?
        xml << Hearth::XML::Node.new('ipamArn', stub[:ipam_arn].to_s) unless stub[:ipam_arn].nil?
        xml << Hearth::XML::Node.new('ipamRegion', stub[:ipam_region].to_s) unless stub[:ipam_region].nil?
        xml << Hearth::XML::Node.new('publicDefaultScopeId', stub[:public_default_scope_id].to_s) unless stub[:public_default_scope_id].nil?
        xml << Hearth::XML::Node.new('privateDefaultScopeId', stub[:private_default_scope_id].to_s) unless stub[:private_default_scope_id].nil?
        xml << Hearth::XML::Node.new('scopeCount', stub[:scope_count].to_s) unless stub[:scope_count].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('operatingRegionSet', IpamOperatingRegionSet.stub('item', stub[:operating_regions])) unless stub[:operating_regions].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for IpamOperatingRegionSet
    class IpamOperatingRegionSet
      def self.default(visited=[])
        return nil if visited.include?('IpamOperatingRegionSet')
        visited = visited + ['IpamOperatingRegionSet']
        [
          IpamOperatingRegion.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamOperatingRegion.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for IpamOperatingRegion
    class IpamOperatingRegion
      def self.default(visited=[])
        return nil if visited.include?('IpamOperatingRegion')
        visited = visited + ['IpamOperatingRegion']
        {
          region_name: 'region_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('regionName', stub[:region_name].to_s) unless stub[:region_name].nil?
        xml
      end
    end

    # Operation Stubber for CreateIpamPool
    class CreateIpamPool
      def self.default(visited=[])
        {
          ipam_pool: IpamPool.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateIpamPoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPool.stub('ipamPool', stub[:ipam_pool]) unless stub[:ipam_pool].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for IpamPool
    class IpamPool
      def self.default(visited=[])
        return nil if visited.include?('IpamPool')
        visited = visited + ['IpamPool']
        {
          owner_id: 'owner_id',
          ipam_pool_id: 'ipam_pool_id',
          source_ipam_pool_id: 'source_ipam_pool_id',
          ipam_pool_arn: 'ipam_pool_arn',
          ipam_scope_arn: 'ipam_scope_arn',
          ipam_scope_type: 'ipam_scope_type',
          ipam_arn: 'ipam_arn',
          ipam_region: 'ipam_region',
          locale: 'locale',
          pool_depth: 1,
          state: 'state',
          state_message: 'state_message',
          description: 'description',
          auto_import: false,
          publicly_advertisable: false,
          address_family: 'address_family',
          allocation_min_netmask_length: 1,
          allocation_max_netmask_length: 1,
          allocation_default_netmask_length: 1,
          allocation_resource_tags: IpamResourceTagList.default(visited),
          tags: TagList.default(visited),
          aws_service: 'aws_service',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ipamPoolId', stub[:ipam_pool_id].to_s) unless stub[:ipam_pool_id].nil?
        xml << Hearth::XML::Node.new('sourceIpamPoolId', stub[:source_ipam_pool_id].to_s) unless stub[:source_ipam_pool_id].nil?
        xml << Hearth::XML::Node.new('ipamPoolArn', stub[:ipam_pool_arn].to_s) unless stub[:ipam_pool_arn].nil?
        xml << Hearth::XML::Node.new('ipamScopeArn', stub[:ipam_scope_arn].to_s) unless stub[:ipam_scope_arn].nil?
        xml << Hearth::XML::Node.new('ipamScopeType', stub[:ipam_scope_type].to_s) unless stub[:ipam_scope_type].nil?
        xml << Hearth::XML::Node.new('ipamArn', stub[:ipam_arn].to_s) unless stub[:ipam_arn].nil?
        xml << Hearth::XML::Node.new('ipamRegion', stub[:ipam_region].to_s) unless stub[:ipam_region].nil?
        xml << Hearth::XML::Node.new('locale', stub[:locale].to_s) unless stub[:locale].nil?
        xml << Hearth::XML::Node.new('poolDepth', stub[:pool_depth].to_s) unless stub[:pool_depth].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateMessage', stub[:state_message].to_s) unless stub[:state_message].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('autoImport', stub[:auto_import].to_s) unless stub[:auto_import].nil?
        xml << Hearth::XML::Node.new('publiclyAdvertisable', stub[:publicly_advertisable].to_s) unless stub[:publicly_advertisable].nil?
        xml << Hearth::XML::Node.new('addressFamily', stub[:address_family].to_s) unless stub[:address_family].nil?
        xml << Hearth::XML::Node.new('allocationMinNetmaskLength', stub[:allocation_min_netmask_length].to_s) unless stub[:allocation_min_netmask_length].nil?
        xml << Hearth::XML::Node.new('allocationMaxNetmaskLength', stub[:allocation_max_netmask_length].to_s) unless stub[:allocation_max_netmask_length].nil?
        xml << Hearth::XML::Node.new('allocationDefaultNetmaskLength', stub[:allocation_default_netmask_length].to_s) unless stub[:allocation_default_netmask_length].nil?
        xml << Hearth::XML::Node.new('allocationResourceTagSet', IpamResourceTagList.stub('item', stub[:allocation_resource_tags])) unless stub[:allocation_resource_tags].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('awsService', stub[:aws_service].to_s) unless stub[:aws_service].nil?
        xml
      end
    end

    # List Stubber for IpamResourceTagList
    class IpamResourceTagList
      def self.default(visited=[])
        return nil if visited.include?('IpamResourceTagList')
        visited = visited + ['IpamResourceTagList']
        [
          IpamResourceTag.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamResourceTag.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for IpamResourceTag
    class IpamResourceTag
      def self.default(visited=[])
        return nil if visited.include?('IpamResourceTag')
        visited = visited + ['IpamResourceTag']
        {
          key: 'key',
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('key', stub[:key].to_s) unless stub[:key].nil?
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # Operation Stubber for CreateIpamScope
    class CreateIpamScope
      def self.default(visited=[])
        {
          ipam_scope: IpamScope.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateIpamScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamScope.stub('ipamScope', stub[:ipam_scope]) unless stub[:ipam_scope].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for IpamScope
    class IpamScope
      def self.default(visited=[])
        return nil if visited.include?('IpamScope')
        visited = visited + ['IpamScope']
        {
          owner_id: 'owner_id',
          ipam_scope_id: 'ipam_scope_id',
          ipam_scope_arn: 'ipam_scope_arn',
          ipam_arn: 'ipam_arn',
          ipam_region: 'ipam_region',
          ipam_scope_type: 'ipam_scope_type',
          is_default: false,
          description: 'description',
          pool_count: 1,
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ipamScopeId', stub[:ipam_scope_id].to_s) unless stub[:ipam_scope_id].nil?
        xml << Hearth::XML::Node.new('ipamScopeArn', stub[:ipam_scope_arn].to_s) unless stub[:ipam_scope_arn].nil?
        xml << Hearth::XML::Node.new('ipamArn', stub[:ipam_arn].to_s) unless stub[:ipam_arn].nil?
        xml << Hearth::XML::Node.new('ipamRegion', stub[:ipam_region].to_s) unless stub[:ipam_region].nil?
        xml << Hearth::XML::Node.new('ipamScopeType', stub[:ipam_scope_type].to_s) unless stub[:ipam_scope_type].nil?
        xml << Hearth::XML::Node.new('isDefault', stub[:is_default].to_s) unless stub[:is_default].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('poolCount', stub[:pool_count].to_s) unless stub[:pool_count].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateKeyPair
    class CreateKeyPair
      def self.default(visited=[])
        {
          key_fingerprint: 'key_fingerprint',
          key_material: 'key_material',
          key_name: 'key_name',
          key_pair_id: 'key_pair_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateKeyPairResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('keyFingerprint', stub[:key_fingerprint].to_s) unless stub[:key_fingerprint].nil?
        xml << Hearth::XML::Node.new('keyMaterial', stub[:key_material].to_s) unless stub[:key_material].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('keyPairId', stub[:key_pair_id].to_s) unless stub[:key_pair_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateLaunchTemplate
    class CreateLaunchTemplate
      def self.default(visited=[])
        {
          launch_template: LaunchTemplate.default(visited),
          warning: ValidationWarning.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLaunchTemplateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LaunchTemplate.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        xml << ValidationWarning.stub('warning', stub[:warning]) unless stub[:warning].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ValidationWarning
    class ValidationWarning
      def self.default(visited=[])
        return nil if visited.include?('ValidationWarning')
        visited = visited + ['ValidationWarning']
        {
          errors: ErrorSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('errorSet', ErrorSet.stub('item', stub[:errors])) unless stub[:errors].nil?
        xml
      end
    end

    # List Stubber for ErrorSet
    class ErrorSet
      def self.default(visited=[])
        return nil if visited.include?('ErrorSet')
        visited = visited + ['ErrorSet']
        [
          ValidationError.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ValidationError.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ValidationError
    class ValidationError
      def self.default(visited=[])
        return nil if visited.include?('ValidationError')
        visited = visited + ['ValidationError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplate
    class LaunchTemplate
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplate')
        visited = visited + ['LaunchTemplate']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          create_time: Time.now,
          created_by: 'created_by',
          default_version_number: 1,
          latest_version_number: 1,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('createdBy', stub[:created_by].to_s) unless stub[:created_by].nil?
        xml << Hearth::XML::Node.new('defaultVersionNumber', stub[:default_version_number].to_s) unless stub[:default_version_number].nil?
        xml << Hearth::XML::Node.new('latestVersionNumber', stub[:latest_version_number].to_s) unless stub[:latest_version_number].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateLaunchTemplateVersion
    class CreateLaunchTemplateVersion
      def self.default(visited=[])
        {
          launch_template_version: LaunchTemplateVersion.default(visited),
          warning: ValidationWarning.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLaunchTemplateVersionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LaunchTemplateVersion.stub('launchTemplateVersion', stub[:launch_template_version]) unless stub[:launch_template_version].nil?
        xml << ValidationWarning.stub('warning', stub[:warning]) unless stub[:warning].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for LaunchTemplateVersion
    class LaunchTemplateVersion
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateVersion')
        visited = visited + ['LaunchTemplateVersion']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version_number: 1,
          version_description: 'version_description',
          create_time: Time.now,
          created_by: 'created_by',
          default_version: false,
          launch_template_data: ResponseLaunchTemplateData.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('versionNumber', stub[:version_number].to_s) unless stub[:version_number].nil?
        xml << Hearth::XML::Node.new('versionDescription', stub[:version_description].to_s) unless stub[:version_description].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('createdBy', stub[:created_by].to_s) unless stub[:created_by].nil?
        xml << Hearth::XML::Node.new('defaultVersion', stub[:default_version].to_s) unless stub[:default_version].nil?
        xml << ResponseLaunchTemplateData.stub('launchTemplateData', stub[:launch_template_data]) unless stub[:launch_template_data].nil?
        xml
      end
    end

    # Structure Stubber for ResponseLaunchTemplateData
    class ResponseLaunchTemplateData
      def self.default(visited=[])
        return nil if visited.include?('ResponseLaunchTemplateData')
        visited = visited + ['ResponseLaunchTemplateData']
        {
          kernel_id: 'kernel_id',
          ebs_optimized: false,
          iam_instance_profile: LaunchTemplateIamInstanceProfileSpecification.default(visited),
          block_device_mappings: LaunchTemplateBlockDeviceMappingList.default(visited),
          network_interfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationList.default(visited),
          image_id: 'image_id',
          instance_type: 'instance_type',
          key_name: 'key_name',
          monitoring: LaunchTemplatesMonitoring.default(visited),
          placement: LaunchTemplatePlacement.default(visited),
          ram_disk_id: 'ram_disk_id',
          disable_api_termination: false,
          instance_initiated_shutdown_behavior: 'instance_initiated_shutdown_behavior',
          user_data: 'user_data',
          tag_specifications: LaunchTemplateTagSpecificationList.default(visited),
          elastic_gpu_specifications: ElasticGpuSpecificationResponseList.default(visited),
          elastic_inference_accelerators: LaunchTemplateElasticInferenceAcceleratorResponseList.default(visited),
          security_group_ids: ValueStringList.default(visited),
          security_groups: ValueStringList.default(visited),
          instance_market_options: LaunchTemplateInstanceMarketOptions.default(visited),
          credit_specification: CreditSpecification.default(visited),
          cpu_options: LaunchTemplateCpuOptions.default(visited),
          capacity_reservation_specification: LaunchTemplateCapacityReservationSpecificationResponse.default(visited),
          license_specifications: LaunchTemplateLicenseList.default(visited),
          hibernation_options: LaunchTemplateHibernationOptions.default(visited),
          metadata_options: LaunchTemplateInstanceMetadataOptions.default(visited),
          enclave_options: LaunchTemplateEnclaveOptions.default(visited),
          instance_requirements: InstanceRequirements.default(visited),
          private_dns_name_options: LaunchTemplatePrivateDnsNameOptions.default(visited),
          maintenance_options: LaunchTemplateInstanceMaintenanceOptions.default(visited),
          disable_api_stop: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << LaunchTemplateIamInstanceProfileSpecification.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('blockDeviceMappingSet', LaunchTemplateBlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('networkInterfaceSet', LaunchTemplateInstanceNetworkInterfaceSpecificationList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << LaunchTemplatesMonitoring.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml << LaunchTemplatePlacement.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << Hearth::XML::Node.new('ramDiskId', stub[:ram_disk_id].to_s) unless stub[:ram_disk_id].nil?
        xml << Hearth::XML::Node.new('disableApiTermination', stub[:disable_api_termination].to_s) unless stub[:disable_api_termination].nil?
        xml << Hearth::XML::Node.new('instanceInitiatedShutdownBehavior', stub[:instance_initiated_shutdown_behavior].to_s) unless stub[:instance_initiated_shutdown_behavior].nil?
        xml << Hearth::XML::Node.new('userData', stub[:user_data].to_s) unless stub[:user_data].nil?
        xml << Hearth::XML::Node.new('tagSpecificationSet', LaunchTemplateTagSpecificationList.stub('item', stub[:tag_specifications])) unless stub[:tag_specifications].nil?
        xml << Hearth::XML::Node.new('elasticGpuSpecificationSet', ElasticGpuSpecificationResponseList.stub('item', stub[:elastic_gpu_specifications])) unless stub[:elastic_gpu_specifications].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorSet', LaunchTemplateElasticInferenceAcceleratorResponseList.stub('item', stub[:elastic_inference_accelerators])) unless stub[:elastic_inference_accelerators].nil?
        xml << Hearth::XML::Node.new('securityGroupIdSet', ValueStringList.stub('item', stub[:security_group_ids])) unless stub[:security_group_ids].nil?
        xml << Hearth::XML::Node.new('securityGroupSet', ValueStringList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << LaunchTemplateInstanceMarketOptions.stub('instanceMarketOptions', stub[:instance_market_options]) unless stub[:instance_market_options].nil?
        xml << CreditSpecification.stub('creditSpecification', stub[:credit_specification]) unless stub[:credit_specification].nil?
        xml << LaunchTemplateCpuOptions.stub('cpuOptions', stub[:cpu_options]) unless stub[:cpu_options].nil?
        xml << LaunchTemplateCapacityReservationSpecificationResponse.stub('capacityReservationSpecification', stub[:capacity_reservation_specification]) unless stub[:capacity_reservation_specification].nil?
        xml << Hearth::XML::Node.new('licenseSet', LaunchTemplateLicenseList.stub('item', stub[:license_specifications])) unless stub[:license_specifications].nil?
        xml << LaunchTemplateHibernationOptions.stub('hibernationOptions', stub[:hibernation_options]) unless stub[:hibernation_options].nil?
        xml << LaunchTemplateInstanceMetadataOptions.stub('metadataOptions', stub[:metadata_options]) unless stub[:metadata_options].nil?
        xml << LaunchTemplateEnclaveOptions.stub('enclaveOptions', stub[:enclave_options]) unless stub[:enclave_options].nil?
        xml << InstanceRequirements.stub('instanceRequirements', stub[:instance_requirements]) unless stub[:instance_requirements].nil?
        xml << LaunchTemplatePrivateDnsNameOptions.stub('privateDnsNameOptions', stub[:private_dns_name_options]) unless stub[:private_dns_name_options].nil?
        xml << LaunchTemplateInstanceMaintenanceOptions.stub('maintenanceOptions', stub[:maintenance_options]) unless stub[:maintenance_options].nil?
        xml << Hearth::XML::Node.new('disableApiStop', stub[:disable_api_stop].to_s) unless stub[:disable_api_stop].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateInstanceMaintenanceOptions
    class LaunchTemplateInstanceMaintenanceOptions
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateInstanceMaintenanceOptions')
        visited = visited + ['LaunchTemplateInstanceMaintenanceOptions']
        {
          auto_recovery: 'auto_recovery',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('autoRecovery', stub[:auto_recovery].to_s) unless stub[:auto_recovery].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplatePrivateDnsNameOptions
    class LaunchTemplatePrivateDnsNameOptions
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplatePrivateDnsNameOptions')
        visited = visited + ['LaunchTemplatePrivateDnsNameOptions']
        {
          hostname_type: 'hostname_type',
          enable_resource_name_dns_a_record: false,
          enable_resource_name_dns_aaaa_record: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('hostnameType', stub[:hostname_type].to_s) unless stub[:hostname_type].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsARecord', stub[:enable_resource_name_dns_a_record].to_s) unless stub[:enable_resource_name_dns_a_record].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsAAAARecord', stub[:enable_resource_name_dns_aaaa_record].to_s) unless stub[:enable_resource_name_dns_aaaa_record].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateEnclaveOptions
    class LaunchTemplateEnclaveOptions
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateEnclaveOptions')
        visited = visited + ['LaunchTemplateEnclaveOptions']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateInstanceMetadataOptions
    class LaunchTemplateInstanceMetadataOptions
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateInstanceMetadataOptions')
        visited = visited + ['LaunchTemplateInstanceMetadataOptions']
        {
          state: 'state',
          http_tokens: 'http_tokens',
          http_put_response_hop_limit: 1,
          http_endpoint: 'http_endpoint',
          http_protocol_ipv6: 'http_protocol_ipv6',
          instance_metadata_tags: 'instance_metadata_tags',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('httpTokens', stub[:http_tokens].to_s) unless stub[:http_tokens].nil?
        xml << Hearth::XML::Node.new('httpPutResponseHopLimit', stub[:http_put_response_hop_limit].to_s) unless stub[:http_put_response_hop_limit].nil?
        xml << Hearth::XML::Node.new('httpEndpoint', stub[:http_endpoint].to_s) unless stub[:http_endpoint].nil?
        xml << Hearth::XML::Node.new('httpProtocolIpv6', stub[:http_protocol_ipv6].to_s) unless stub[:http_protocol_ipv6].nil?
        xml << Hearth::XML::Node.new('instanceMetadataTags', stub[:instance_metadata_tags].to_s) unless stub[:instance_metadata_tags].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateHibernationOptions
    class LaunchTemplateHibernationOptions
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateHibernationOptions')
        visited = visited + ['LaunchTemplateHibernationOptions']
        {
          configured: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('configured', stub[:configured].to_s) unless stub[:configured].nil?
        xml
      end
    end

    # List Stubber for LaunchTemplateLicenseList
    class LaunchTemplateLicenseList
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateLicenseList')
        visited = visited + ['LaunchTemplateLicenseList']
        [
          LaunchTemplateLicenseConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateLicenseConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LaunchTemplateLicenseConfiguration
    class LaunchTemplateLicenseConfiguration
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateLicenseConfiguration')
        visited = visited + ['LaunchTemplateLicenseConfiguration']
        {
          license_configuration_arn: 'license_configuration_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('licenseConfigurationArn', stub[:license_configuration_arn].to_s) unless stub[:license_configuration_arn].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateCapacityReservationSpecificationResponse
    class LaunchTemplateCapacityReservationSpecificationResponse
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateCapacityReservationSpecificationResponse')
        visited = visited + ['LaunchTemplateCapacityReservationSpecificationResponse']
        {
          capacity_reservation_preference: 'capacity_reservation_preference',
          capacity_reservation_target: CapacityReservationTargetResponse.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationPreference', stub[:capacity_reservation_preference].to_s) unless stub[:capacity_reservation_preference].nil?
        xml << CapacityReservationTargetResponse.stub('capacityReservationTarget', stub[:capacity_reservation_target]) unless stub[:capacity_reservation_target].nil?
        xml
      end
    end

    # Structure Stubber for CapacityReservationTargetResponse
    class CapacityReservationTargetResponse
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationTargetResponse')
        visited = visited + ['CapacityReservationTargetResponse']
        {
          capacity_reservation_id: 'capacity_reservation_id',
          capacity_reservation_resource_group_arn: 'capacity_reservation_resource_group_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << Hearth::XML::Node.new('capacityReservationResourceGroupArn', stub[:capacity_reservation_resource_group_arn].to_s) unless stub[:capacity_reservation_resource_group_arn].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateCpuOptions
    class LaunchTemplateCpuOptions
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateCpuOptions')
        visited = visited + ['LaunchTemplateCpuOptions']
        {
          core_count: 1,
          threads_per_core: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('coreCount', stub[:core_count].to_s) unless stub[:core_count].nil?
        xml << Hearth::XML::Node.new('threadsPerCore', stub[:threads_per_core].to_s) unless stub[:threads_per_core].nil?
        xml
      end
    end

    # Structure Stubber for CreditSpecification
    class CreditSpecification
      def self.default(visited=[])
        return nil if visited.include?('CreditSpecification')
        visited = visited + ['CreditSpecification']
        {
          cpu_credits: 'cpu_credits',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cpuCredits', stub[:cpu_credits].to_s) unless stub[:cpu_credits].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateInstanceMarketOptions
    class LaunchTemplateInstanceMarketOptions
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateInstanceMarketOptions')
        visited = visited + ['LaunchTemplateInstanceMarketOptions']
        {
          market_type: 'market_type',
          spot_options: LaunchTemplateSpotMarketOptions.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('marketType', stub[:market_type].to_s) unless stub[:market_type].nil?
        xml << LaunchTemplateSpotMarketOptions.stub('spotOptions', stub[:spot_options]) unless stub[:spot_options].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateSpotMarketOptions
    class LaunchTemplateSpotMarketOptions
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateSpotMarketOptions')
        visited = visited + ['LaunchTemplateSpotMarketOptions']
        {
          max_price: 'max_price',
          spot_instance_type: 'spot_instance_type',
          block_duration_minutes: 1,
          valid_until: Time.now,
          instance_interruption_behavior: 'instance_interruption_behavior',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('maxPrice', stub[:max_price].to_s) unless stub[:max_price].nil?
        xml << Hearth::XML::Node.new('spotInstanceType', stub[:spot_instance_type].to_s) unless stub[:spot_instance_type].nil?
        xml << Hearth::XML::Node.new('blockDurationMinutes', stub[:block_duration_minutes].to_s) unless stub[:block_duration_minutes].nil?
        xml << Hearth::XML::Node.new('validUntil', Hearth::TimeHelper.to_date_time(stub[:valid_until])) unless stub[:valid_until].nil?
        xml << Hearth::XML::Node.new('instanceInterruptionBehavior', stub[:instance_interruption_behavior].to_s) unless stub[:instance_interruption_behavior].nil?
        xml
      end
    end

    # List Stubber for LaunchTemplateElasticInferenceAcceleratorResponseList
    class LaunchTemplateElasticInferenceAcceleratorResponseList
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateElasticInferenceAcceleratorResponseList')
        visited = visited + ['LaunchTemplateElasticInferenceAcceleratorResponseList']
        [
          LaunchTemplateElasticInferenceAcceleratorResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateElasticInferenceAcceleratorResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LaunchTemplateElasticInferenceAcceleratorResponse
    class LaunchTemplateElasticInferenceAcceleratorResponse
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateElasticInferenceAcceleratorResponse')
        visited = visited + ['LaunchTemplateElasticInferenceAcceleratorResponse']
        {
          type: 'type',
          count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml
      end
    end

    # List Stubber for ElasticGpuSpecificationResponseList
    class ElasticGpuSpecificationResponseList
      def self.default(visited=[])
        return nil if visited.include?('ElasticGpuSpecificationResponseList')
        visited = visited + ['ElasticGpuSpecificationResponseList']
        [
          ElasticGpuSpecificationResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ElasticGpuSpecificationResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ElasticGpuSpecificationResponse
    class ElasticGpuSpecificationResponse
      def self.default(visited=[])
        return nil if visited.include?('ElasticGpuSpecificationResponse')
        visited = visited + ['ElasticGpuSpecificationResponse']
        {
          type: 'type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml
      end
    end

    # List Stubber for LaunchTemplateTagSpecificationList
    class LaunchTemplateTagSpecificationList
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateTagSpecificationList')
        visited = visited + ['LaunchTemplateTagSpecificationList']
        [
          LaunchTemplateTagSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateTagSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LaunchTemplateTagSpecification
    class LaunchTemplateTagSpecification
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateTagSpecification')
        visited = visited + ['LaunchTemplateTagSpecification']
        {
          resource_type: 'resource_type',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplatePlacement
    class LaunchTemplatePlacement
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplatePlacement')
        visited = visited + ['LaunchTemplatePlacement']
        {
          availability_zone: 'availability_zone',
          affinity: 'affinity',
          group_name: 'group_name',
          host_id: 'host_id',
          tenancy: 'tenancy',
          spread_domain: 'spread_domain',
          host_resource_group_arn: 'host_resource_group_arn',
          partition_number: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('affinity', stub[:affinity].to_s) unless stub[:affinity].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('hostId', stub[:host_id].to_s) unless stub[:host_id].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('spreadDomain', stub[:spread_domain].to_s) unless stub[:spread_domain].nil?
        xml << Hearth::XML::Node.new('hostResourceGroupArn', stub[:host_resource_group_arn].to_s) unless stub[:host_resource_group_arn].nil?
        xml << Hearth::XML::Node.new('partitionNumber', stub[:partition_number].to_s) unless stub[:partition_number].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplatesMonitoring
    class LaunchTemplatesMonitoring
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplatesMonitoring')
        visited = visited + ['LaunchTemplatesMonitoring']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    # List Stubber for LaunchTemplateInstanceNetworkInterfaceSpecificationList
    class LaunchTemplateInstanceNetworkInterfaceSpecificationList
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateInstanceNetworkInterfaceSpecificationList')
        visited = visited + ['LaunchTemplateInstanceNetworkInterfaceSpecificationList']
        [
          LaunchTemplateInstanceNetworkInterfaceSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateInstanceNetworkInterfaceSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LaunchTemplateInstanceNetworkInterfaceSpecification
    class LaunchTemplateInstanceNetworkInterfaceSpecification
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateInstanceNetworkInterfaceSpecification')
        visited = visited + ['LaunchTemplateInstanceNetworkInterfaceSpecification']
        {
          associate_carrier_ip_address: false,
          associate_public_ip_address: false,
          delete_on_termination: false,
          description: 'description',
          device_index: 1,
          groups: GroupIdStringList.default(visited),
          interface_type: 'interface_type',
          ipv6_address_count: 1,
          ipv6_addresses: InstanceIpv6AddressList.default(visited),
          network_interface_id: 'network_interface_id',
          private_ip_address: 'private_ip_address',
          private_ip_addresses: PrivateIpAddressSpecificationList.default(visited),
          secondary_private_ip_address_count: 1,
          subnet_id: 'subnet_id',
          network_card_index: 1,
          ipv4_prefixes: Ipv4PrefixListResponse.default(visited),
          ipv4_prefix_count: 1,
          ipv6_prefixes: Ipv6PrefixListResponse.default(visited),
          ipv6_prefix_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associateCarrierIpAddress', stub[:associate_carrier_ip_address].to_s) unless stub[:associate_carrier_ip_address].nil?
        xml << Hearth::XML::Node.new('associatePublicIpAddress', stub[:associate_public_ip_address].to_s) unless stub[:associate_public_ip_address].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('deviceIndex', stub[:device_index].to_s) unless stub[:device_index].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdStringList.stub('groupId', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('interfaceType', stub[:interface_type].to_s) unless stub[:interface_type].nil?
        xml << Hearth::XML::Node.new('ipv6AddressCount', stub[:ipv6_address_count].to_s) unless stub[:ipv6_address_count].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesSet', InstanceIpv6AddressList.stub('item', stub[:ipv6_addresses])) unless stub[:ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('privateIpAddressesSet', PrivateIpAddressSpecificationList.stub('item', stub[:private_ip_addresses])) unless stub[:private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('secondaryPrivateIpAddressCount', stub[:secondary_private_ip_address_count].to_s) unless stub[:secondary_private_ip_address_count].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml << Hearth::XML::Node.new('ipv4PrefixSet', Ipv4PrefixListResponse.stub('item', stub[:ipv4_prefixes])) unless stub[:ipv4_prefixes].nil?
        xml << Hearth::XML::Node.new('ipv4PrefixCount', stub[:ipv4_prefix_count].to_s) unless stub[:ipv4_prefix_count].nil?
        xml << Hearth::XML::Node.new('ipv6PrefixSet', Ipv6PrefixListResponse.stub('item', stub[:ipv6_prefixes])) unless stub[:ipv6_prefixes].nil?
        xml << Hearth::XML::Node.new('ipv6PrefixCount', stub[:ipv6_prefix_count].to_s) unless stub[:ipv6_prefix_count].nil?
        xml
      end
    end

    # List Stubber for Ipv6PrefixListResponse
    class Ipv6PrefixListResponse
      def self.default(visited=[])
        return nil if visited.include?('Ipv6PrefixListResponse')
        visited = visited + ['Ipv6PrefixListResponse']
        [
          Ipv6PrefixSpecificationResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6PrefixSpecificationResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv6PrefixSpecificationResponse
    class Ipv6PrefixSpecificationResponse
      def self.default(visited=[])
        return nil if visited.include?('Ipv6PrefixSpecificationResponse')
        visited = visited + ['Ipv6PrefixSpecificationResponse']
        {
          ipv6_prefix: 'ipv6_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Prefix', stub[:ipv6_prefix].to_s) unless stub[:ipv6_prefix].nil?
        xml
      end
    end

    # List Stubber for Ipv4PrefixListResponse
    class Ipv4PrefixListResponse
      def self.default(visited=[])
        return nil if visited.include?('Ipv4PrefixListResponse')
        visited = visited + ['Ipv4PrefixListResponse']
        [
          Ipv4PrefixSpecificationResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv4PrefixSpecificationResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv4PrefixSpecificationResponse
    class Ipv4PrefixSpecificationResponse
      def self.default(visited=[])
        return nil if visited.include?('Ipv4PrefixSpecificationResponse')
        visited = visited + ['Ipv4PrefixSpecificationResponse']
        {
          ipv4_prefix: 'ipv4_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv4Prefix', stub[:ipv4_prefix].to_s) unless stub[:ipv4_prefix].nil?
        xml
      end
    end

    # List Stubber for PrivateIpAddressSpecificationList
    class PrivateIpAddressSpecificationList
      def self.default(visited=[])
        return nil if visited.include?('PrivateIpAddressSpecificationList')
        visited = visited + ['PrivateIpAddressSpecificationList']
        [
          PrivateIpAddressSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrivateIpAddressSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PrivateIpAddressSpecification
    class PrivateIpAddressSpecification
      def self.default(visited=[])
        return nil if visited.include?('PrivateIpAddressSpecification')
        visited = visited + ['PrivateIpAddressSpecification']
        {
          primary: false,
          private_ip_address: 'private_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('primary', stub[:primary].to_s) unless stub[:primary].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml
      end
    end

    # List Stubber for InstanceIpv6AddressList
    class InstanceIpv6AddressList
      def self.default(visited=[])
        return nil if visited.include?('InstanceIpv6AddressList')
        visited = visited + ['InstanceIpv6AddressList']
        [
          InstanceIpv6Address.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceIpv6Address.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceIpv6Address
    class InstanceIpv6Address
      def self.default(visited=[])
        return nil if visited.include?('InstanceIpv6Address')
        visited = visited + ['InstanceIpv6Address']
        {
          ipv6_address: 'ipv6_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Address', stub[:ipv6_address].to_s) unless stub[:ipv6_address].nil?
        xml
      end
    end

    # List Stubber for GroupIdStringList
    class GroupIdStringList
      def self.default(visited=[])
        return nil if visited.include?('GroupIdStringList')
        visited = visited + ['GroupIdStringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for LaunchTemplateBlockDeviceMappingList
    class LaunchTemplateBlockDeviceMappingList
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateBlockDeviceMappingList')
        visited = visited + ['LaunchTemplateBlockDeviceMappingList']
        [
          LaunchTemplateBlockDeviceMapping.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateBlockDeviceMapping.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LaunchTemplateBlockDeviceMapping
    class LaunchTemplateBlockDeviceMapping
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateBlockDeviceMapping')
        visited = visited + ['LaunchTemplateBlockDeviceMapping']
        {
          device_name: 'device_name',
          virtual_name: 'virtual_name',
          ebs: LaunchTemplateEbsBlockDevice.default(visited),
          no_device: 'no_device',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << Hearth::XML::Node.new('virtualName', stub[:virtual_name].to_s) unless stub[:virtual_name].nil?
        xml << LaunchTemplateEbsBlockDevice.stub('ebs', stub[:ebs]) unless stub[:ebs].nil?
        xml << Hearth::XML::Node.new('noDevice', stub[:no_device].to_s) unless stub[:no_device].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateEbsBlockDevice
    class LaunchTemplateEbsBlockDevice
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateEbsBlockDevice')
        visited = visited + ['LaunchTemplateEbsBlockDevice']
        {
          encrypted: false,
          delete_on_termination: false,
          iops: 1,
          kms_key_id: 'kms_key_id',
          snapshot_id: 'snapshot_id',
          volume_size: 1,
          volume_type: 'volume_type',
          throughput: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('iops', stub[:iops].to_s) unless stub[:iops].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('volumeType', stub[:volume_type].to_s) unless stub[:volume_type].nil?
        xml << Hearth::XML::Node.new('throughput', stub[:throughput].to_s) unless stub[:throughput].nil?
        xml
      end
    end

    # Structure Stubber for LaunchTemplateIamInstanceProfileSpecification
    class LaunchTemplateIamInstanceProfileSpecification
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateIamInstanceProfileSpecification')
        visited = visited + ['LaunchTemplateIamInstanceProfileSpecification']
        {
          arn: 'arn',
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    # Operation Stubber for CreateLocalGatewayRoute
    class CreateLocalGatewayRoute
      def self.default(visited=[])
        {
          route: LocalGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLocalGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for LocalGatewayRoute
    class LocalGatewayRoute
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayRoute')
        visited = visited + ['LocalGatewayRoute']
        {
          destination_cidr_block: 'destination_cidr_block',
          local_gateway_virtual_interface_group_id: 'local_gateway_virtual_interface_group_id',
          type: 'type',
          state: 'state',
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          local_gateway_route_table_arn: 'local_gateway_route_table_arn',
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceGroupId', stub[:local_gateway_virtual_interface_group_id].to_s) unless stub[:local_gateway_virtual_interface_group_id].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableArn', stub[:local_gateway_route_table_arn].to_s) unless stub[:local_gateway_route_table_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    # Operation Stubber for CreateLocalGatewayRouteTableVpcAssociation
    class CreateLocalGatewayRouteTableVpcAssociation
      def self.default(visited=[])
        {
          local_gateway_route_table_vpc_association: LocalGatewayRouteTableVpcAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLocalGatewayRouteTableVpcAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRouteTableVpcAssociation.stub('localGatewayRouteTableVpcAssociation', stub[:local_gateway_route_table_vpc_association]) unless stub[:local_gateway_route_table_vpc_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for LocalGatewayRouteTableVpcAssociation
    class LocalGatewayRouteTableVpcAssociation
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayRouteTableVpcAssociation')
        visited = visited + ['LocalGatewayRouteTableVpcAssociation']
        {
          local_gateway_route_table_vpc_association_id: 'local_gateway_route_table_vpc_association_id',
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          local_gateway_route_table_arn: 'local_gateway_route_table_arn',
          local_gateway_id: 'local_gateway_id',
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayRouteTableVpcAssociationId', stub[:local_gateway_route_table_vpc_association_id].to_s) unless stub[:local_gateway_route_table_vpc_association_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableArn', stub[:local_gateway_route_table_arn].to_s) unless stub[:local_gateway_route_table_arn].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateManagedPrefixList
    class CreateManagedPrefixList
      def self.default(visited=[])
        {
          prefix_list: ManagedPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateManagedPrefixListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ManagedPrefixList.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ManagedPrefixList
    class ManagedPrefixList
      def self.default(visited=[])
        return nil if visited.include?('ManagedPrefixList')
        visited = visited + ['ManagedPrefixList']
        {
          prefix_list_id: 'prefix_list_id',
          address_family: 'address_family',
          state: 'state',
          state_message: 'state_message',
          prefix_list_arn: 'prefix_list_arn',
          prefix_list_name: 'prefix_list_name',
          max_entries: 1,
          version: 1,
          tags: TagList.default(visited),
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('addressFamily', stub[:address_family].to_s) unless stub[:address_family].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateMessage', stub[:state_message].to_s) unless stub[:state_message].nil?
        xml << Hearth::XML::Node.new('prefixListArn', stub[:prefix_list_arn].to_s) unless stub[:prefix_list_arn].nil?
        xml << Hearth::XML::Node.new('prefixListName', stub[:prefix_list_name].to_s) unless stub[:prefix_list_name].nil?
        xml << Hearth::XML::Node.new('maxEntries', stub[:max_entries].to_s) unless stub[:max_entries].nil?
        xml << Hearth::XML::Node.new('version', stub[:version].to_s) unless stub[:version].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    # Operation Stubber for CreateNatGateway
    class CreateNatGateway
      def self.default(visited=[])
        {
          client_token: 'client_token',
          nat_gateway: NatGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNatGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << NatGateway.stub('natGateway', stub[:nat_gateway]) unless stub[:nat_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for NatGateway
    class NatGateway
      def self.default(visited=[])
        return nil if visited.include?('NatGateway')
        visited = visited + ['NatGateway']
        {
          create_time: Time.now,
          delete_time: Time.now,
          failure_code: 'failure_code',
          failure_message: 'failure_message',
          nat_gateway_addresses: NatGatewayAddressList.default(visited),
          nat_gateway_id: 'nat_gateway_id',
          provisioned_bandwidth: ProvisionedBandwidth.default(visited),
          state: 'state',
          subnet_id: 'subnet_id',
          vpc_id: 'vpc_id',
          tags: TagList.default(visited),
          connectivity_type: 'connectivity_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('deleteTime', Hearth::TimeHelper.to_date_time(stub[:delete_time])) unless stub[:delete_time].nil?
        xml << Hearth::XML::Node.new('failureCode', stub[:failure_code].to_s) unless stub[:failure_code].nil?
        xml << Hearth::XML::Node.new('failureMessage', stub[:failure_message].to_s) unless stub[:failure_message].nil?
        xml << Hearth::XML::Node.new('natGatewayAddressSet', NatGatewayAddressList.stub('item', stub[:nat_gateway_addresses])) unless stub[:nat_gateway_addresses].nil?
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << ProvisionedBandwidth.stub('provisionedBandwidth', stub[:provisioned_bandwidth]) unless stub[:provisioned_bandwidth].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('connectivityType', stub[:connectivity_type].to_s) unless stub[:connectivity_type].nil?
        xml
      end
    end

    # Structure Stubber for ProvisionedBandwidth
    class ProvisionedBandwidth
      def self.default(visited=[])
        return nil if visited.include?('ProvisionedBandwidth')
        visited = visited + ['ProvisionedBandwidth']
        {
          provision_time: Time.now,
          provisioned: 'provisioned',
          request_time: Time.now,
          requested: 'requested',
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('provisionTime', Hearth::TimeHelper.to_date_time(stub[:provision_time])) unless stub[:provision_time].nil?
        xml << Hearth::XML::Node.new('provisioned', stub[:provisioned].to_s) unless stub[:provisioned].nil?
        xml << Hearth::XML::Node.new('requestTime', Hearth::TimeHelper.to_date_time(stub[:request_time])) unless stub[:request_time].nil?
        xml << Hearth::XML::Node.new('requested', stub[:requested].to_s) unless stub[:requested].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    # List Stubber for NatGatewayAddressList
    class NatGatewayAddressList
      def self.default(visited=[])
        return nil if visited.include?('NatGatewayAddressList')
        visited = visited + ['NatGatewayAddressList']
        [
          NatGatewayAddress.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NatGatewayAddress.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NatGatewayAddress
    class NatGatewayAddress
      def self.default(visited=[])
        return nil if visited.include?('NatGatewayAddress')
        visited = visited + ['NatGatewayAddress']
        {
          allocation_id: 'allocation_id',
          network_interface_id: 'network_interface_id',
          private_ip: 'private_ip',
          public_ip: 'public_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('privateIp', stub[:private_ip].to_s) unless stub[:private_ip].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml
      end
    end

    # Operation Stubber for CreateNetworkAcl
    class CreateNetworkAcl
      def self.default(visited=[])
        {
          network_acl: NetworkAcl.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkAclResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkAcl.stub('networkAcl', stub[:network_acl]) unless stub[:network_acl].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for NetworkAcl
    class NetworkAcl
      def self.default(visited=[])
        return nil if visited.include?('NetworkAcl')
        visited = visited + ['NetworkAcl']
        {
          associations: NetworkAclAssociationList.default(visited),
          entries: NetworkAclEntryList.default(visited),
          is_default: false,
          network_acl_id: 'network_acl_id',
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationSet', NetworkAclAssociationList.stub('item', stub[:associations])) unless stub[:associations].nil?
        xml << Hearth::XML::Node.new('entrySet', NetworkAclEntryList.stub('item', stub[:entries])) unless stub[:entries].nil?
        xml << Hearth::XML::Node.new('default', stub[:is_default].to_s) unless stub[:is_default].nil?
        xml << Hearth::XML::Node.new('networkAclId', stub[:network_acl_id].to_s) unless stub[:network_acl_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    # List Stubber for NetworkAclEntryList
    class NetworkAclEntryList
      def self.default(visited=[])
        return nil if visited.include?('NetworkAclEntryList')
        visited = visited + ['NetworkAclEntryList']
        [
          NetworkAclEntry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkAclEntry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NetworkAclEntry
    class NetworkAclEntry
      def self.default(visited=[])
        return nil if visited.include?('NetworkAclEntry')
        visited = visited + ['NetworkAclEntry']
        {
          cidr_block: 'cidr_block',
          egress: false,
          icmp_type_code: IcmpTypeCode.default(visited),
          ipv6_cidr_block: 'ipv6_cidr_block',
          port_range: PortRange.default(visited),
          protocol: 'protocol',
          rule_action: 'rule_action',
          rule_number: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << Hearth::XML::Node.new('egress', stub[:egress].to_s) unless stub[:egress].nil?
        xml << IcmpTypeCode.stub('icmpTypeCode', stub[:icmp_type_code]) unless stub[:icmp_type_code].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlock', stub[:ipv6_cidr_block].to_s) unless stub[:ipv6_cidr_block].nil?
        xml << PortRange.stub('portRange', stub[:port_range]) unless stub[:port_range].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('ruleAction', stub[:rule_action].to_s) unless stub[:rule_action].nil?
        xml << Hearth::XML::Node.new('ruleNumber', stub[:rule_number].to_s) unless stub[:rule_number].nil?
        xml
      end
    end

    # Structure Stubber for PortRange
    class PortRange
      def self.default(visited=[])
        return nil if visited.include?('PortRange')
        visited = visited + ['PortRange']
        {
          from: 1,
          to: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('from', stub[:from].to_s) unless stub[:from].nil?
        xml << Hearth::XML::Node.new('to', stub[:to].to_s) unless stub[:to].nil?
        xml
      end
    end

    # Structure Stubber for IcmpTypeCode
    class IcmpTypeCode
      def self.default(visited=[])
        return nil if visited.include?('IcmpTypeCode')
        visited = visited + ['IcmpTypeCode']
        {
          code: 1,
          type: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml
      end
    end

    # List Stubber for NetworkAclAssociationList
    class NetworkAclAssociationList
      def self.default(visited=[])
        return nil if visited.include?('NetworkAclAssociationList')
        visited = visited + ['NetworkAclAssociationList']
        [
          NetworkAclAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkAclAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NetworkAclAssociation
    class NetworkAclAssociation
      def self.default(visited=[])
        return nil if visited.include?('NetworkAclAssociation')
        visited = visited + ['NetworkAclAssociation']
        {
          network_acl_association_id: 'network_acl_association_id',
          network_acl_id: 'network_acl_id',
          subnet_id: 'subnet_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkAclAssociationId', stub[:network_acl_association_id].to_s) unless stub[:network_acl_association_id].nil?
        xml << Hearth::XML::Node.new('networkAclId', stub[:network_acl_id].to_s) unless stub[:network_acl_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml
      end
    end

    # Operation Stubber for CreateNetworkAclEntry
    class CreateNetworkAclEntry
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkAclEntryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateNetworkInsightsAccessScope
    class CreateNetworkInsightsAccessScope
      def self.default(visited=[])
        {
          network_insights_access_scope: NetworkInsightsAccessScope.default(visited),
          network_insights_access_scope_content: NetworkInsightsAccessScopeContent.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkInsightsAccessScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsAccessScope.stub('networkInsightsAccessScope', stub[:network_insights_access_scope]) unless stub[:network_insights_access_scope].nil?
        xml << NetworkInsightsAccessScopeContent.stub('networkInsightsAccessScopeContent', stub[:network_insights_access_scope_content]) unless stub[:network_insights_access_scope_content].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for NetworkInsightsAccessScopeContent
    class NetworkInsightsAccessScopeContent
      def self.default(visited=[])
        return nil if visited.include?('NetworkInsightsAccessScopeContent')
        visited = visited + ['NetworkInsightsAccessScopeContent']
        {
          network_insights_access_scope_id: 'network_insights_access_scope_id',
          match_paths: AccessScopePathList.default(visited),
          exclude_paths: AccessScopePathList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        xml << Hearth::XML::Node.new('matchPathSet', AccessScopePathList.stub('item', stub[:match_paths])) unless stub[:match_paths].nil?
        xml << Hearth::XML::Node.new('excludePathSet', AccessScopePathList.stub('item', stub[:exclude_paths])) unless stub[:exclude_paths].nil?
        xml
      end
    end

    # List Stubber for AccessScopePathList
    class AccessScopePathList
      def self.default(visited=[])
        return nil if visited.include?('AccessScopePathList')
        visited = visited + ['AccessScopePathList']
        [
          AccessScopePath.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AccessScopePath.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AccessScopePath
    class AccessScopePath
      def self.default(visited=[])
        return nil if visited.include?('AccessScopePath')
        visited = visited + ['AccessScopePath']
        {
          source: PathStatement.default(visited),
          destination: PathStatement.default(visited),
          through_resources: ThroughResourcesStatementList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << PathStatement.stub('source', stub[:source]) unless stub[:source].nil?
        xml << PathStatement.stub('destination', stub[:destination]) unless stub[:destination].nil?
        xml << Hearth::XML::Node.new('throughResourceSet', ThroughResourcesStatementList.stub('item', stub[:through_resources])) unless stub[:through_resources].nil?
        xml
      end
    end

    # List Stubber for ThroughResourcesStatementList
    class ThroughResourcesStatementList
      def self.default(visited=[])
        return nil if visited.include?('ThroughResourcesStatementList')
        visited = visited + ['ThroughResourcesStatementList']
        [
          ThroughResourcesStatement.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ThroughResourcesStatement.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ThroughResourcesStatement
    class ThroughResourcesStatement
      def self.default(visited=[])
        return nil if visited.include?('ThroughResourcesStatement')
        visited = visited + ['ThroughResourcesStatement']
        {
          resource_statement: ResourceStatement.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << ResourceStatement.stub('resourceStatement', stub[:resource_statement]) unless stub[:resource_statement].nil?
        xml
      end
    end

    # Structure Stubber for ResourceStatement
    class ResourceStatement
      def self.default(visited=[])
        return nil if visited.include?('ResourceStatement')
        visited = visited + ['ResourceStatement']
        {
          resources: ValueStringList.default(visited),
          resource_types: ValueStringList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceSet', ValueStringList.stub('item', stub[:resources])) unless stub[:resources].nil?
        xml << Hearth::XML::Node.new('resourceTypeSet', ValueStringList.stub('item', stub[:resource_types])) unless stub[:resource_types].nil?
        xml
      end
    end

    # Structure Stubber for PathStatement
    class PathStatement
      def self.default(visited=[])
        return nil if visited.include?('PathStatement')
        visited = visited + ['PathStatement']
        {
          packet_header_statement: PacketHeaderStatement.default(visited),
          resource_statement: ResourceStatement.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << PacketHeaderStatement.stub('packetHeaderStatement', stub[:packet_header_statement]) unless stub[:packet_header_statement].nil?
        xml << ResourceStatement.stub('resourceStatement', stub[:resource_statement]) unless stub[:resource_statement].nil?
        xml
      end
    end

    # Structure Stubber for PacketHeaderStatement
    class PacketHeaderStatement
      def self.default(visited=[])
        return nil if visited.include?('PacketHeaderStatement')
        visited = visited + ['PacketHeaderStatement']
        {
          source_addresses: ValueStringList.default(visited),
          destination_addresses: ValueStringList.default(visited),
          source_ports: ValueStringList.default(visited),
          destination_ports: ValueStringList.default(visited),
          source_prefix_lists: ValueStringList.default(visited),
          destination_prefix_lists: ValueStringList.default(visited),
          protocols: ProtocolList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sourceAddressSet', ValueStringList.stub('item', stub[:source_addresses])) unless stub[:source_addresses].nil?
        xml << Hearth::XML::Node.new('destinationAddressSet', ValueStringList.stub('item', stub[:destination_addresses])) unless stub[:destination_addresses].nil?
        xml << Hearth::XML::Node.new('sourcePortSet', ValueStringList.stub('item', stub[:source_ports])) unless stub[:source_ports].nil?
        xml << Hearth::XML::Node.new('destinationPortSet', ValueStringList.stub('item', stub[:destination_ports])) unless stub[:destination_ports].nil?
        xml << Hearth::XML::Node.new('sourcePrefixListSet', ValueStringList.stub('item', stub[:source_prefix_lists])) unless stub[:source_prefix_lists].nil?
        xml << Hearth::XML::Node.new('destinationPrefixListSet', ValueStringList.stub('item', stub[:destination_prefix_lists])) unless stub[:destination_prefix_lists].nil?
        xml << Hearth::XML::Node.new('protocolSet', ProtocolList.stub('item', stub[:protocols])) unless stub[:protocols].nil?
        xml
      end
    end

    # List Stubber for ProtocolList
    class ProtocolList
      def self.default(visited=[])
        return nil if visited.include?('ProtocolList')
        visited = visited + ['ProtocolList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NetworkInsightsAccessScope
    class NetworkInsightsAccessScope
      def self.default(visited=[])
        return nil if visited.include?('NetworkInsightsAccessScope')
        visited = visited + ['NetworkInsightsAccessScope']
        {
          network_insights_access_scope_id: 'network_insights_access_scope_id',
          network_insights_access_scope_arn: 'network_insights_access_scope_arn',
          created_date: Time.now,
          updated_date: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeArn', stub[:network_insights_access_scope_arn].to_s) unless stub[:network_insights_access_scope_arn].nil?
        xml << Hearth::XML::Node.new('createdDate', Hearth::TimeHelper.to_date_time(stub[:created_date])) unless stub[:created_date].nil?
        xml << Hearth::XML::Node.new('updatedDate', Hearth::TimeHelper.to_date_time(stub[:updated_date])) unless stub[:updated_date].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateNetworkInsightsPath
    class CreateNetworkInsightsPath
      def self.default(visited=[])
        {
          network_insights_path: NetworkInsightsPath.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkInsightsPathResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsPath.stub('networkInsightsPath', stub[:network_insights_path]) unless stub[:network_insights_path].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for NetworkInsightsPath
    class NetworkInsightsPath
      def self.default(visited=[])
        return nil if visited.include?('NetworkInsightsPath')
        visited = visited + ['NetworkInsightsPath']
        {
          network_insights_path_id: 'network_insights_path_id',
          network_insights_path_arn: 'network_insights_path_arn',
          created_date: Time.now,
          source: 'source',
          destination: 'destination',
          source_ip: 'source_ip',
          destination_ip: 'destination_ip',
          protocol: 'protocol',
          destination_port: 1,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsPathId', stub[:network_insights_path_id].to_s) unless stub[:network_insights_path_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsPathArn', stub[:network_insights_path_arn].to_s) unless stub[:network_insights_path_arn].nil?
        xml << Hearth::XML::Node.new('createdDate', Hearth::TimeHelper.to_date_time(stub[:created_date])) unless stub[:created_date].nil?
        xml << Hearth::XML::Node.new('source', stub[:source].to_s) unless stub[:source].nil?
        xml << Hearth::XML::Node.new('destination', stub[:destination].to_s) unless stub[:destination].nil?
        xml << Hearth::XML::Node.new('sourceIp', stub[:source_ip].to_s) unless stub[:source_ip].nil?
        xml << Hearth::XML::Node.new('destinationIp', stub[:destination_ip].to_s) unless stub[:destination_ip].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('destinationPort', stub[:destination_port].to_s) unless stub[:destination_port].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateNetworkInterface
    class CreateNetworkInterface
      def self.default(visited=[])
        {
          network_interface: NetworkInterface.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInterface.stub('networkInterface', stub[:network_interface]) unless stub[:network_interface].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for NetworkInterface
    class NetworkInterface
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterface')
        visited = visited + ['NetworkInterface']
        {
          association: NetworkInterfaceAssociation.default(visited),
          attachment: NetworkInterfaceAttachment.default(visited),
          availability_zone: 'availability_zone',
          description: 'description',
          groups: GroupIdentifierList.default(visited),
          interface_type: 'interface_type',
          ipv6_addresses: NetworkInterfaceIpv6AddressesList.default(visited),
          mac_address: 'mac_address',
          network_interface_id: 'network_interface_id',
          outpost_arn: 'outpost_arn',
          owner_id: 'owner_id',
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
          private_ip_addresses: NetworkInterfacePrivateIpAddressList.default(visited),
          ipv4_prefixes: Ipv4PrefixesList.default(visited),
          ipv6_prefixes: Ipv6PrefixesList.default(visited),
          requester_id: 'requester_id',
          requester_managed: false,
          source_dest_check: false,
          status: 'status',
          subnet_id: 'subnet_id',
          tag_set: TagList.default(visited),
          vpc_id: 'vpc_id',
          deny_all_igw_traffic: false,
          ipv6_native: false,
          ipv6_address: 'ipv6_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << NetworkInterfaceAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << NetworkInterfaceAttachment.stub('attachment', stub[:attachment]) unless stub[:attachment].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('interfaceType', stub[:interface_type].to_s) unless stub[:interface_type].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesSet', NetworkInterfaceIpv6AddressesList.stub('item', stub[:ipv6_addresses])) unless stub[:ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('macAddress', stub[:mac_address].to_s) unless stub[:mac_address].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('privateIpAddressesSet', NetworkInterfacePrivateIpAddressList.stub('item', stub[:private_ip_addresses])) unless stub[:private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('ipv4PrefixSet', Ipv4PrefixesList.stub('item', stub[:ipv4_prefixes])) unless stub[:ipv4_prefixes].nil?
        xml << Hearth::XML::Node.new('ipv6PrefixSet', Ipv6PrefixesList.stub('item', stub[:ipv6_prefixes])) unless stub[:ipv6_prefixes].nil?
        xml << Hearth::XML::Node.new('requesterId', stub[:requester_id].to_s) unless stub[:requester_id].nil?
        xml << Hearth::XML::Node.new('requesterManaged', stub[:requester_managed].to_s) unless stub[:requester_managed].nil?
        xml << Hearth::XML::Node.new('sourceDestCheck', stub[:source_dest_check].to_s) unless stub[:source_dest_check].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tag_set])) unless stub[:tag_set].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('denyAllIgwTraffic', stub[:deny_all_igw_traffic].to_s) unless stub[:deny_all_igw_traffic].nil?
        xml << Hearth::XML::Node.new('ipv6Native', stub[:ipv6_native].to_s) unless stub[:ipv6_native].nil?
        xml << Hearth::XML::Node.new('ipv6Address', stub[:ipv6_address].to_s) unless stub[:ipv6_address].nil?
        xml
      end
    end

    # List Stubber for Ipv6PrefixesList
    class Ipv6PrefixesList
      def self.default(visited=[])
        return nil if visited.include?('Ipv6PrefixesList')
        visited = visited + ['Ipv6PrefixesList']
        [
          Ipv6PrefixSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6PrefixSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv6PrefixSpecification
    class Ipv6PrefixSpecification
      def self.default(visited=[])
        return nil if visited.include?('Ipv6PrefixSpecification')
        visited = visited + ['Ipv6PrefixSpecification']
        {
          ipv6_prefix: 'ipv6_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Prefix', stub[:ipv6_prefix].to_s) unless stub[:ipv6_prefix].nil?
        xml
      end
    end

    # List Stubber for NetworkInterfacePrivateIpAddressList
    class NetworkInterfacePrivateIpAddressList
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfacePrivateIpAddressList')
        visited = visited + ['NetworkInterfacePrivateIpAddressList']
        [
          NetworkInterfacePrivateIpAddress.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInterfacePrivateIpAddress.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NetworkInterfacePrivateIpAddress
    class NetworkInterfacePrivateIpAddress
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfacePrivateIpAddress')
        visited = visited + ['NetworkInterfacePrivateIpAddress']
        {
          association: NetworkInterfaceAssociation.default(visited),
          primary: false,
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << NetworkInterfaceAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << Hearth::XML::Node.new('primary', stub[:primary].to_s) unless stub[:primary].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml
      end
    end

    # Structure Stubber for NetworkInterfaceAssociation
    class NetworkInterfaceAssociation
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfaceAssociation')
        visited = visited + ['NetworkInterfaceAssociation']
        {
          allocation_id: 'allocation_id',
          association_id: 'association_id',
          ip_owner_id: 'ip_owner_id',
          public_dns_name: 'public_dns_name',
          public_ip: 'public_ip',
          customer_owned_ip: 'customer_owned_ip',
          carrier_ip: 'carrier_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('ipOwnerId', stub[:ip_owner_id].to_s) unless stub[:ip_owner_id].nil?
        xml << Hearth::XML::Node.new('publicDnsName', stub[:public_dns_name].to_s) unless stub[:public_dns_name].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('customerOwnedIp', stub[:customer_owned_ip].to_s) unless stub[:customer_owned_ip].nil?
        xml << Hearth::XML::Node.new('carrierIp', stub[:carrier_ip].to_s) unless stub[:carrier_ip].nil?
        xml
      end
    end

    # List Stubber for NetworkInterfaceIpv6AddressesList
    class NetworkInterfaceIpv6AddressesList
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfaceIpv6AddressesList')
        visited = visited + ['NetworkInterfaceIpv6AddressesList']
        [
          NetworkInterfaceIpv6Address.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInterfaceIpv6Address.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NetworkInterfaceIpv6Address
    class NetworkInterfaceIpv6Address
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfaceIpv6Address')
        visited = visited + ['NetworkInterfaceIpv6Address']
        {
          ipv6_address: 'ipv6_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Address', stub[:ipv6_address].to_s) unless stub[:ipv6_address].nil?
        xml
      end
    end

    # List Stubber for GroupIdentifierList
    class GroupIdentifierList
      def self.default(visited=[])
        return nil if visited.include?('GroupIdentifierList')
        visited = visited + ['GroupIdentifierList']
        [
          GroupIdentifier.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << GroupIdentifier.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for GroupIdentifier
    class GroupIdentifier
      def self.default(visited=[])
        return nil if visited.include?('GroupIdentifier')
        visited = visited + ['GroupIdentifier']
        {
          group_name: 'group_name',
          group_id: 'group_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml
      end
    end

    # Structure Stubber for NetworkInterfaceAttachment
    class NetworkInterfaceAttachment
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfaceAttachment')
        visited = visited + ['NetworkInterfaceAttachment']
        {
          attach_time: Time.now,
          attachment_id: 'attachment_id',
          delete_on_termination: false,
          device_index: 1,
          network_card_index: 1,
          instance_id: 'instance_id',
          instance_owner_id: 'instance_owner_id',
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('attachmentId', stub[:attachment_id].to_s) unless stub[:attachment_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('deviceIndex', stub[:device_index].to_s) unless stub[:device_index].nil?
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceOwnerId', stub[:instance_owner_id].to_s) unless stub[:instance_owner_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    # Operation Stubber for CreateNetworkInterfacePermission
    class CreateNetworkInterfacePermission
      def self.default(visited=[])
        {
          interface_permission: NetworkInterfacePermission.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkInterfacePermissionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInterfacePermission.stub('interfacePermission', stub[:interface_permission]) unless stub[:interface_permission].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for NetworkInterfacePermission
    class NetworkInterfacePermission
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfacePermission')
        visited = visited + ['NetworkInterfacePermission']
        {
          network_interface_permission_id: 'network_interface_permission_id',
          network_interface_id: 'network_interface_id',
          aws_account_id: 'aws_account_id',
          aws_service: 'aws_service',
          permission: 'permission',
          permission_state: NetworkInterfacePermissionState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInterfacePermissionId', stub[:network_interface_permission_id].to_s) unless stub[:network_interface_permission_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('awsAccountId', stub[:aws_account_id].to_s) unless stub[:aws_account_id].nil?
        xml << Hearth::XML::Node.new('awsService', stub[:aws_service].to_s) unless stub[:aws_service].nil?
        xml << Hearth::XML::Node.new('permission', stub[:permission].to_s) unless stub[:permission].nil?
        xml << NetworkInterfacePermissionState.stub('permissionState', stub[:permission_state]) unless stub[:permission_state].nil?
        xml
      end
    end

    # Structure Stubber for NetworkInterfacePermissionState
    class NetworkInterfacePermissionState
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfacePermissionState')
        visited = visited + ['NetworkInterfacePermissionState']
        {
          state: 'state',
          status_message: 'status_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml
      end
    end

    # Operation Stubber for CreatePlacementGroup
    class CreatePlacementGroup
      def self.default(visited=[])
        {
          placement_group: PlacementGroup.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreatePlacementGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << PlacementGroup.stub('placementGroup', stub[:placement_group]) unless stub[:placement_group].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for PlacementGroup
    class PlacementGroup
      def self.default(visited=[])
        return nil if visited.include?('PlacementGroup')
        visited = visited + ['PlacementGroup']
        {
          group_name: 'group_name',
          state: 'state',
          strategy: 'strategy',
          partition_count: 1,
          group_id: 'group_id',
          tags: TagList.default(visited),
          group_arn: 'group_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('strategy', stub[:strategy].to_s) unless stub[:strategy].nil?
        xml << Hearth::XML::Node.new('partitionCount', stub[:partition_count].to_s) unless stub[:partition_count].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('groupArn', stub[:group_arn].to_s) unless stub[:group_arn].nil?
        xml
      end
    end

    # Operation Stubber for CreatePublicIpv4Pool
    class CreatePublicIpv4Pool
      def self.default(visited=[])
        {
          pool_id: 'pool_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreatePublicIpv4PoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateReplaceRootVolumeTask
    class CreateReplaceRootVolumeTask
      def self.default(visited=[])
        {
          replace_root_volume_task: ReplaceRootVolumeTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateReplaceRootVolumeTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ReplaceRootVolumeTask.stub('replaceRootVolumeTask', stub[:replace_root_volume_task]) unless stub[:replace_root_volume_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ReplaceRootVolumeTask
    class ReplaceRootVolumeTask
      def self.default(visited=[])
        return nil if visited.include?('ReplaceRootVolumeTask')
        visited = visited + ['ReplaceRootVolumeTask']
        {
          replace_root_volume_task_id: 'replace_root_volume_task_id',
          instance_id: 'instance_id',
          task_state: 'task_state',
          start_time: 'start_time',
          complete_time: 'complete_time',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('replaceRootVolumeTaskId', stub[:replace_root_volume_task_id].to_s) unless stub[:replace_root_volume_task_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('taskState', stub[:task_state].to_s) unless stub[:task_state].nil?
        xml << Hearth::XML::Node.new('startTime', stub[:start_time].to_s) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('completeTime', stub[:complete_time].to_s) unless stub[:complete_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateReservedInstancesListing
    class CreateReservedInstancesListing
      def self.default(visited=[])
        {
          reserved_instances_listings: ReservedInstancesListingList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateReservedInstancesListingResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesListingsSet', ReservedInstancesListingList.stub('item', stub[:reserved_instances_listings])) unless stub[:reserved_instances_listings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateRestoreImageTask
    class CreateRestoreImageTask
      def self.default(visited=[])
        {
          image_id: 'image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateRestoreImageTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateRoute
    class CreateRoute
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateRouteTable
    class CreateRouteTable
      def self.default(visited=[])
        {
          route_table: RouteTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << RouteTable.stub('routeTable', stub[:route_table]) unless stub[:route_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for RouteTable
    class RouteTable
      def self.default(visited=[])
        return nil if visited.include?('RouteTable')
        visited = visited + ['RouteTable']
        {
          associations: RouteTableAssociationList.default(visited),
          propagating_vgws: PropagatingVgwList.default(visited),
          route_table_id: 'route_table_id',
          routes: RouteList.default(visited),
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationSet', RouteTableAssociationList.stub('item', stub[:associations])) unless stub[:associations].nil?
        xml << Hearth::XML::Node.new('propagatingVgwSet', PropagatingVgwList.stub('item', stub[:propagating_vgws])) unless stub[:propagating_vgws].nil?
        xml << Hearth::XML::Node.new('routeTableId', stub[:route_table_id].to_s) unless stub[:route_table_id].nil?
        xml << Hearth::XML::Node.new('routeSet', RouteList.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    # List Stubber for RouteList
    class RouteList
      def self.default(visited=[])
        return nil if visited.include?('RouteList')
        visited = visited + ['RouteList']
        [
          Route.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Route.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Route
    class Route
      def self.default(visited=[])
        return nil if visited.include?('Route')
        visited = visited + ['Route']
        {
          destination_cidr_block: 'destination_cidr_block',
          destination_ipv6_cidr_block: 'destination_ipv6_cidr_block',
          destination_prefix_list_id: 'destination_prefix_list_id',
          egress_only_internet_gateway_id: 'egress_only_internet_gateway_id',
          gateway_id: 'gateway_id',
          instance_id: 'instance_id',
          instance_owner_id: 'instance_owner_id',
          nat_gateway_id: 'nat_gateway_id',
          transit_gateway_id: 'transit_gateway_id',
          local_gateway_id: 'local_gateway_id',
          carrier_gateway_id: 'carrier_gateway_id',
          network_interface_id: 'network_interface_id',
          origin: 'origin',
          state: 'state',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
          core_network_arn: 'core_network_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('destinationIpv6CidrBlock', stub[:destination_ipv6_cidr_block].to_s) unless stub[:destination_ipv6_cidr_block].nil?
        xml << Hearth::XML::Node.new('destinationPrefixListId', stub[:destination_prefix_list_id].to_s) unless stub[:destination_prefix_list_id].nil?
        xml << Hearth::XML::Node.new('egressOnlyInternetGatewayId', stub[:egress_only_internet_gateway_id].to_s) unless stub[:egress_only_internet_gateway_id].nil?
        xml << Hearth::XML::Node.new('gatewayId', stub[:gateway_id].to_s) unless stub[:gateway_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceOwnerId', stub[:instance_owner_id].to_s) unless stub[:instance_owner_id].nil?
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('carrierGatewayId', stub[:carrier_gateway_id].to_s) unless stub[:carrier_gateway_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('origin', stub[:origin].to_s) unless stub[:origin].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml << Hearth::XML::Node.new('coreNetworkArn', stub[:core_network_arn].to_s) unless stub[:core_network_arn].nil?
        xml
      end
    end

    # List Stubber for PropagatingVgwList
    class PropagatingVgwList
      def self.default(visited=[])
        return nil if visited.include?('PropagatingVgwList')
        visited = visited + ['PropagatingVgwList']
        [
          PropagatingVgw.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PropagatingVgw.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PropagatingVgw
    class PropagatingVgw
      def self.default(visited=[])
        return nil if visited.include?('PropagatingVgw')
        visited = visited + ['PropagatingVgw']
        {
          gateway_id: 'gateway_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('gatewayId', stub[:gateway_id].to_s) unless stub[:gateway_id].nil?
        xml
      end
    end

    # List Stubber for RouteTableAssociationList
    class RouteTableAssociationList
      def self.default(visited=[])
        return nil if visited.include?('RouteTableAssociationList')
        visited = visited + ['RouteTableAssociationList']
        [
          RouteTableAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << RouteTableAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for RouteTableAssociation
    class RouteTableAssociation
      def self.default(visited=[])
        return nil if visited.include?('RouteTableAssociation')
        visited = visited + ['RouteTableAssociation']
        {
          main: false,
          route_table_association_id: 'route_table_association_id',
          route_table_id: 'route_table_id',
          subnet_id: 'subnet_id',
          gateway_id: 'gateway_id',
          association_state: RouteTableAssociationState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('main', stub[:main].to_s) unless stub[:main].nil?
        xml << Hearth::XML::Node.new('routeTableAssociationId', stub[:route_table_association_id].to_s) unless stub[:route_table_association_id].nil?
        xml << Hearth::XML::Node.new('routeTableId', stub[:route_table_id].to_s) unless stub[:route_table_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('gatewayId', stub[:gateway_id].to_s) unless stub[:gateway_id].nil?
        xml << RouteTableAssociationState.stub('associationState', stub[:association_state]) unless stub[:association_state].nil?
        xml
      end
    end

    # Operation Stubber for CreateSecurityGroup
    class CreateSecurityGroup
      def self.default(visited=[])
        {
          group_id: 'group_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSecurityGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateSnapshot
    class CreateSnapshot
      def self.default(visited=[])
        {
          data_encryption_key_id: 'data_encryption_key_id',
          description: 'description',
          encrypted: false,
          kms_key_id: 'kms_key_id',
          owner_id: 'owner_id',
          progress: 'progress',
          snapshot_id: 'snapshot_id',
          start_time: Time.now,
          state: 'state',
          state_message: 'state_message',
          volume_id: 'volume_id',
          volume_size: 1,
          owner_alias: 'owner_alias',
          outpost_arn: 'outpost_arn',
          tags: TagList.default(visited),
          storage_tier: 'storage_tier',
          restore_expiry_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSnapshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('dataEncryptionKeyId', stub[:data_encryption_key_id].to_s) unless stub[:data_encryption_key_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:state_message].to_s) unless stub[:state_message].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('storageTier', stub[:storage_tier].to_s) unless stub[:storage_tier].nil?
        xml << Hearth::XML::Node.new('restoreExpiryTime', Hearth::TimeHelper.to_date_time(stub[:restore_expiry_time])) unless stub[:restore_expiry_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateSnapshots
    class CreateSnapshots
      def self.default(visited=[])
        {
          snapshots: SnapshotSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSnapshotsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotSet', SnapshotSet.stub('item', stub[:snapshots])) unless stub[:snapshots].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SnapshotSet
    class SnapshotSet
      def self.default(visited=[])
        return nil if visited.include?('SnapshotSet')
        visited = visited + ['SnapshotSet']
        [
          SnapshotInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SnapshotInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SnapshotInfo
    class SnapshotInfo
      def self.default(visited=[])
        return nil if visited.include?('SnapshotInfo')
        visited = visited + ['SnapshotInfo']
        {
          description: 'description',
          tags: TagList.default(visited),
          encrypted: false,
          volume_id: 'volume_id',
          state: 'state',
          volume_size: 1,
          start_time: Time.now,
          progress: 'progress',
          owner_id: 'owner_id',
          snapshot_id: 'snapshot_id',
          outpost_arn: 'outpost_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml
      end
    end

    # Operation Stubber for CreateSpotDatafeedSubscription
    class CreateSpotDatafeedSubscription
      def self.default(visited=[])
        {
          spot_datafeed_subscription: SpotDatafeedSubscription.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSpotDatafeedSubscriptionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SpotDatafeedSubscription.stub('spotDatafeedSubscription', stub[:spot_datafeed_subscription]) unless stub[:spot_datafeed_subscription].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for SpotDatafeedSubscription
    class SpotDatafeedSubscription
      def self.default(visited=[])
        return nil if visited.include?('SpotDatafeedSubscription')
        visited = visited + ['SpotDatafeedSubscription']
        {
          bucket: 'bucket',
          fault: SpotInstanceStateFault.default(visited),
          owner_id: 'owner_id',
          prefix: 'prefix',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('bucket', stub[:bucket].to_s) unless stub[:bucket].nil?
        xml << SpotInstanceStateFault.stub('fault', stub[:fault]) unless stub[:fault].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('prefix', stub[:prefix].to_s) unless stub[:prefix].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Structure Stubber for SpotInstanceStateFault
    class SpotInstanceStateFault
      def self.default(visited=[])
        return nil if visited.include?('SpotInstanceStateFault')
        visited = visited + ['SpotInstanceStateFault']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for CreateStoreImageTask
    class CreateStoreImageTask
      def self.default(visited=[])
        {
          object_key: 'object_key',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateStoreImageTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('objectKey', stub[:object_key].to_s) unless stub[:object_key].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateSubnet
    class CreateSubnet
      def self.default(visited=[])
        {
          subnet: Subnet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSubnetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Subnet.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateSubnetCidrReservation
    class CreateSubnetCidrReservation
      def self.default(visited=[])
        {
          subnet_cidr_reservation: SubnetCidrReservation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSubnetCidrReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SubnetCidrReservation.stub('subnetCidrReservation', stub[:subnet_cidr_reservation]) unless stub[:subnet_cidr_reservation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for SubnetCidrReservation
    class SubnetCidrReservation
      def self.default(visited=[])
        return nil if visited.include?('SubnetCidrReservation')
        visited = visited + ['SubnetCidrReservation']
        {
          subnet_cidr_reservation_id: 'subnet_cidr_reservation_id',
          subnet_id: 'subnet_id',
          cidr: 'cidr',
          reservation_type: 'reservation_type',
          owner_id: 'owner_id',
          description: 'description',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('subnetCidrReservationId', stub[:subnet_cidr_reservation_id].to_s) unless stub[:subnet_cidr_reservation_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('reservationType', stub[:reservation_type].to_s) unless stub[:reservation_type].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateTags
    class CreateTags
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTagsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateTrafficMirrorFilter
    class CreateTrafficMirrorFilter
      def self.default(visited=[])
        {
          traffic_mirror_filter: TrafficMirrorFilter.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTrafficMirrorFilterResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorFilter.stub('trafficMirrorFilter', stub[:traffic_mirror_filter]) unless stub[:traffic_mirror_filter].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TrafficMirrorFilter
    class TrafficMirrorFilter
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorFilter')
        visited = visited + ['TrafficMirrorFilter']
        {
          traffic_mirror_filter_id: 'traffic_mirror_filter_id',
          ingress_filter_rules: TrafficMirrorFilterRuleList.default(visited),
          egress_filter_rules: TrafficMirrorFilterRuleList.default(visited),
          network_services: TrafficMirrorNetworkServiceList.default(visited),
          description: 'description',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('trafficMirrorFilterId', stub[:traffic_mirror_filter_id].to_s) unless stub[:traffic_mirror_filter_id].nil?
        xml << Hearth::XML::Node.new('ingressFilterRuleSet', TrafficMirrorFilterRuleList.stub('item', stub[:ingress_filter_rules])) unless stub[:ingress_filter_rules].nil?
        xml << Hearth::XML::Node.new('egressFilterRuleSet', TrafficMirrorFilterRuleList.stub('item', stub[:egress_filter_rules])) unless stub[:egress_filter_rules].nil?
        xml << Hearth::XML::Node.new('networkServiceSet', TrafficMirrorNetworkServiceList.stub('item', stub[:network_services])) unless stub[:network_services].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for TrafficMirrorNetworkServiceList
    class TrafficMirrorNetworkServiceList
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorNetworkServiceList')
        visited = visited + ['TrafficMirrorNetworkServiceList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for TrafficMirrorFilterRuleList
    class TrafficMirrorFilterRuleList
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorFilterRuleList')
        visited = visited + ['TrafficMirrorFilterRuleList']
        [
          TrafficMirrorFilterRule.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrafficMirrorFilterRule.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TrafficMirrorFilterRule
    class TrafficMirrorFilterRule
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorFilterRule')
        visited = visited + ['TrafficMirrorFilterRule']
        {
          traffic_mirror_filter_rule_id: 'traffic_mirror_filter_rule_id',
          traffic_mirror_filter_id: 'traffic_mirror_filter_id',
          traffic_direction: 'traffic_direction',
          rule_number: 1,
          rule_action: 'rule_action',
          protocol: 1,
          destination_port_range: TrafficMirrorPortRange.default(visited),
          source_port_range: TrafficMirrorPortRange.default(visited),
          destination_cidr_block: 'destination_cidr_block',
          source_cidr_block: 'source_cidr_block',
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('trafficMirrorFilterRuleId', stub[:traffic_mirror_filter_rule_id].to_s) unless stub[:traffic_mirror_filter_rule_id].nil?
        xml << Hearth::XML::Node.new('trafficMirrorFilterId', stub[:traffic_mirror_filter_id].to_s) unless stub[:traffic_mirror_filter_id].nil?
        xml << Hearth::XML::Node.new('trafficDirection', stub[:traffic_direction].to_s) unless stub[:traffic_direction].nil?
        xml << Hearth::XML::Node.new('ruleNumber', stub[:rule_number].to_s) unless stub[:rule_number].nil?
        xml << Hearth::XML::Node.new('ruleAction', stub[:rule_action].to_s) unless stub[:rule_action].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << TrafficMirrorPortRange.stub('destinationPortRange', stub[:destination_port_range]) unless stub[:destination_port_range].nil?
        xml << TrafficMirrorPortRange.stub('sourcePortRange', stub[:source_port_range]) unless stub[:source_port_range].nil?
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('sourceCidrBlock', stub[:source_cidr_block].to_s) unless stub[:source_cidr_block].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    # Structure Stubber for TrafficMirrorPortRange
    class TrafficMirrorPortRange
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorPortRange')
        visited = visited + ['TrafficMirrorPortRange']
        {
          from_port: 1,
          to_port: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fromPort', stub[:from_port].to_s) unless stub[:from_port].nil?
        xml << Hearth::XML::Node.new('toPort', stub[:to_port].to_s) unless stub[:to_port].nil?
        xml
      end
    end

    # Operation Stubber for CreateTrafficMirrorFilterRule
    class CreateTrafficMirrorFilterRule
      def self.default(visited=[])
        {
          traffic_mirror_filter_rule: TrafficMirrorFilterRule.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTrafficMirrorFilterRuleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorFilterRule.stub('trafficMirrorFilterRule', stub[:traffic_mirror_filter_rule]) unless stub[:traffic_mirror_filter_rule].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateTrafficMirrorSession
    class CreateTrafficMirrorSession
      def self.default(visited=[])
        {
          traffic_mirror_session: TrafficMirrorSession.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTrafficMirrorSessionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorSession.stub('trafficMirrorSession', stub[:traffic_mirror_session]) unless stub[:traffic_mirror_session].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TrafficMirrorSession
    class TrafficMirrorSession
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorSession')
        visited = visited + ['TrafficMirrorSession']
        {
          traffic_mirror_session_id: 'traffic_mirror_session_id',
          traffic_mirror_target_id: 'traffic_mirror_target_id',
          traffic_mirror_filter_id: 'traffic_mirror_filter_id',
          network_interface_id: 'network_interface_id',
          owner_id: 'owner_id',
          packet_length: 1,
          session_number: 1,
          virtual_network_id: 1,
          description: 'description',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('trafficMirrorSessionId', stub[:traffic_mirror_session_id].to_s) unless stub[:traffic_mirror_session_id].nil?
        xml << Hearth::XML::Node.new('trafficMirrorTargetId', stub[:traffic_mirror_target_id].to_s) unless stub[:traffic_mirror_target_id].nil?
        xml << Hearth::XML::Node.new('trafficMirrorFilterId', stub[:traffic_mirror_filter_id].to_s) unless stub[:traffic_mirror_filter_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('packetLength', stub[:packet_length].to_s) unless stub[:packet_length].nil?
        xml << Hearth::XML::Node.new('sessionNumber', stub[:session_number].to_s) unless stub[:session_number].nil?
        xml << Hearth::XML::Node.new('virtualNetworkId', stub[:virtual_network_id].to_s) unless stub[:virtual_network_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateTrafficMirrorTarget
    class CreateTrafficMirrorTarget
      def self.default(visited=[])
        {
          traffic_mirror_target: TrafficMirrorTarget.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTrafficMirrorTargetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorTarget.stub('trafficMirrorTarget', stub[:traffic_mirror_target]) unless stub[:traffic_mirror_target].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TrafficMirrorTarget
    class TrafficMirrorTarget
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorTarget')
        visited = visited + ['TrafficMirrorTarget']
        {
          traffic_mirror_target_id: 'traffic_mirror_target_id',
          network_interface_id: 'network_interface_id',
          network_load_balancer_arn: 'network_load_balancer_arn',
          type: 'type',
          description: 'description',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
          gateway_load_balancer_endpoint_id: 'gateway_load_balancer_endpoint_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('trafficMirrorTargetId', stub[:traffic_mirror_target_id].to_s) unless stub[:traffic_mirror_target_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('networkLoadBalancerArn', stub[:network_load_balancer_arn].to_s) unless stub[:network_load_balancer_arn].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('gatewayLoadBalancerEndpointId', stub[:gateway_load_balancer_endpoint_id].to_s) unless stub[:gateway_load_balancer_endpoint_id].nil?
        xml
      end
    end

    # Operation Stubber for CreateTransitGateway
    class CreateTransitGateway
      def self.default(visited=[])
        {
          transit_gateway: TransitGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGateway.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGateway
    class TransitGateway
      def self.default(visited=[])
        return nil if visited.include?('TransitGateway')
        visited = visited + ['TransitGateway']
        {
          transit_gateway_id: 'transit_gateway_id',
          transit_gateway_arn: 'transit_gateway_arn',
          state: 'state',
          owner_id: 'owner_id',
          description: 'description',
          creation_time: Time.now,
          options: TransitGatewayOptions.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayArn', stub[:transit_gateway_arn].to_s) unless stub[:transit_gateway_arn].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << TransitGatewayOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for TransitGatewayOptions
    class TransitGatewayOptions
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayOptions')
        visited = visited + ['TransitGatewayOptions']
        {
          amazon_side_asn: 1,
          transit_gateway_cidr_blocks: ValueStringList.default(visited),
          auto_accept_shared_attachments: 'auto_accept_shared_attachments',
          default_route_table_association: 'default_route_table_association',
          association_default_route_table_id: 'association_default_route_table_id',
          default_route_table_propagation: 'default_route_table_propagation',
          propagation_default_route_table_id: 'propagation_default_route_table_id',
          vpn_ecmp_support: 'vpn_ecmp_support',
          dns_support: 'dns_support',
          multicast_support: 'multicast_support',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('amazonSideAsn', stub[:amazon_side_asn].to_s) unless stub[:amazon_side_asn].nil?
        xml << Hearth::XML::Node.new('transitGatewayCidrBlocks', ValueStringList.stub('item', stub[:transit_gateway_cidr_blocks])) unless stub[:transit_gateway_cidr_blocks].nil?
        xml << Hearth::XML::Node.new('autoAcceptSharedAttachments', stub[:auto_accept_shared_attachments].to_s) unless stub[:auto_accept_shared_attachments].nil?
        xml << Hearth::XML::Node.new('defaultRouteTableAssociation', stub[:default_route_table_association].to_s) unless stub[:default_route_table_association].nil?
        xml << Hearth::XML::Node.new('associationDefaultRouteTableId', stub[:association_default_route_table_id].to_s) unless stub[:association_default_route_table_id].nil?
        xml << Hearth::XML::Node.new('defaultRouteTablePropagation', stub[:default_route_table_propagation].to_s) unless stub[:default_route_table_propagation].nil?
        xml << Hearth::XML::Node.new('propagationDefaultRouteTableId', stub[:propagation_default_route_table_id].to_s) unless stub[:propagation_default_route_table_id].nil?
        xml << Hearth::XML::Node.new('vpnEcmpSupport', stub[:vpn_ecmp_support].to_s) unless stub[:vpn_ecmp_support].nil?
        xml << Hearth::XML::Node.new('dnsSupport', stub[:dns_support].to_s) unless stub[:dns_support].nil?
        xml << Hearth::XML::Node.new('multicastSupport', stub[:multicast_support].to_s) unless stub[:multicast_support].nil?
        xml
      end
    end

    # Operation Stubber for CreateTransitGatewayConnect
    class CreateTransitGatewayConnect
      def self.default(visited=[])
        {
          transit_gateway_connect: TransitGatewayConnect.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayConnectResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayConnect.stub('transitGatewayConnect', stub[:transit_gateway_connect]) unless stub[:transit_gateway_connect].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayConnect
    class TransitGatewayConnect
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayConnect')
        visited = visited + ['TransitGatewayConnect']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          transport_transit_gateway_attachment_id: 'transport_transit_gateway_attachment_id',
          transit_gateway_id: 'transit_gateway_id',
          state: 'state',
          creation_time: Time.now,
          options: TransitGatewayConnectOptions.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transportTransitGatewayAttachmentId', stub[:transport_transit_gateway_attachment_id].to_s) unless stub[:transport_transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << TransitGatewayConnectOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for TransitGatewayConnectOptions
    class TransitGatewayConnectOptions
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayConnectOptions')
        visited = visited + ['TransitGatewayConnectOptions']
        {
          protocol: 'protocol',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml
      end
    end

    # Operation Stubber for CreateTransitGatewayConnectPeer
    class CreateTransitGatewayConnectPeer
      def self.default(visited=[])
        {
          transit_gateway_connect_peer: TransitGatewayConnectPeer.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayConnectPeerResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayConnectPeer.stub('transitGatewayConnectPeer', stub[:transit_gateway_connect_peer]) unless stub[:transit_gateway_connect_peer].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayConnectPeer
    class TransitGatewayConnectPeer
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayConnectPeer')
        visited = visited + ['TransitGatewayConnectPeer']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          transit_gateway_connect_peer_id: 'transit_gateway_connect_peer_id',
          state: 'state',
          creation_time: Time.now,
          connect_peer_configuration: TransitGatewayConnectPeerConfiguration.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayConnectPeerId', stub[:transit_gateway_connect_peer_id].to_s) unless stub[:transit_gateway_connect_peer_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << TransitGatewayConnectPeerConfiguration.stub('connectPeerConfiguration', stub[:connect_peer_configuration]) unless stub[:connect_peer_configuration].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for TransitGatewayConnectPeerConfiguration
    class TransitGatewayConnectPeerConfiguration
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayConnectPeerConfiguration')
        visited = visited + ['TransitGatewayConnectPeerConfiguration']
        {
          transit_gateway_address: 'transit_gateway_address',
          peer_address: 'peer_address',
          inside_cidr_blocks: InsideCidrBlocksStringList.default(visited),
          protocol: 'protocol',
          bgp_configurations: TransitGatewayAttachmentBgpConfigurationList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAddress', stub[:transit_gateway_address].to_s) unless stub[:transit_gateway_address].nil?
        xml << Hearth::XML::Node.new('peerAddress', stub[:peer_address].to_s) unless stub[:peer_address].nil?
        xml << Hearth::XML::Node.new('insideCidrBlocks', InsideCidrBlocksStringList.stub('item', stub[:inside_cidr_blocks])) unless stub[:inside_cidr_blocks].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('bgpConfigurations', TransitGatewayAttachmentBgpConfigurationList.stub('item', stub[:bgp_configurations])) unless stub[:bgp_configurations].nil?
        xml
      end
    end

    # List Stubber for TransitGatewayAttachmentBgpConfigurationList
    class TransitGatewayAttachmentBgpConfigurationList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayAttachmentBgpConfigurationList')
        visited = visited + ['TransitGatewayAttachmentBgpConfigurationList']
        [
          TransitGatewayAttachmentBgpConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayAttachmentBgpConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TransitGatewayAttachmentBgpConfiguration
    class TransitGatewayAttachmentBgpConfiguration
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayAttachmentBgpConfiguration')
        visited = visited + ['TransitGatewayAttachmentBgpConfiguration']
        {
          transit_gateway_asn: 1,
          peer_asn: 1,
          transit_gateway_address: 'transit_gateway_address',
          peer_address: 'peer_address',
          bgp_status: 'bgp_status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAsn', stub[:transit_gateway_asn].to_s) unless stub[:transit_gateway_asn].nil?
        xml << Hearth::XML::Node.new('peerAsn', stub[:peer_asn].to_s) unless stub[:peer_asn].nil?
        xml << Hearth::XML::Node.new('transitGatewayAddress', stub[:transit_gateway_address].to_s) unless stub[:transit_gateway_address].nil?
        xml << Hearth::XML::Node.new('peerAddress', stub[:peer_address].to_s) unless stub[:peer_address].nil?
        xml << Hearth::XML::Node.new('bgpStatus', stub[:bgp_status].to_s) unless stub[:bgp_status].nil?
        xml
      end
    end

    # List Stubber for InsideCidrBlocksStringList
    class InsideCidrBlocksStringList
      def self.default(visited=[])
        return nil if visited.include?('InsideCidrBlocksStringList')
        visited = visited + ['InsideCidrBlocksStringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for CreateTransitGatewayMulticastDomain
    class CreateTransitGatewayMulticastDomain
      def self.default(visited=[])
        {
          transit_gateway_multicast_domain: TransitGatewayMulticastDomain.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayMulticastDomainResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomain.stub('transitGatewayMulticastDomain', stub[:transit_gateway_multicast_domain]) unless stub[:transit_gateway_multicast_domain].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayMulticastDomain
    class TransitGatewayMulticastDomain
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastDomain')
        visited = visited + ['TransitGatewayMulticastDomain']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          transit_gateway_id: 'transit_gateway_id',
          transit_gateway_multicast_domain_arn: 'transit_gateway_multicast_domain_arn',
          owner_id: 'owner_id',
          options: TransitGatewayMulticastDomainOptions.default(visited),
          state: 'state',
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainArn', stub[:transit_gateway_multicast_domain_arn].to_s) unless stub[:transit_gateway_multicast_domain_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << TransitGatewayMulticastDomainOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for TransitGatewayMulticastDomainOptions
    class TransitGatewayMulticastDomainOptions
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastDomainOptions')
        visited = visited + ['TransitGatewayMulticastDomainOptions']
        {
          igmpv2_support: 'igmpv2_support',
          static_sources_support: 'static_sources_support',
          auto_accept_shared_associations: 'auto_accept_shared_associations',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('igmpv2Support', stub[:igmpv2_support].to_s) unless stub[:igmpv2_support].nil?
        xml << Hearth::XML::Node.new('staticSourcesSupport', stub[:static_sources_support].to_s) unless stub[:static_sources_support].nil?
        xml << Hearth::XML::Node.new('autoAcceptSharedAssociations', stub[:auto_accept_shared_associations].to_s) unless stub[:auto_accept_shared_associations].nil?
        xml
      end
    end

    # Operation Stubber for CreateTransitGatewayPeeringAttachment
    class CreateTransitGatewayPeeringAttachment
      def self.default(visited=[])
        {
          transit_gateway_peering_attachment: TransitGatewayPeeringAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayPeeringAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPeeringAttachment.stub('transitGatewayPeeringAttachment', stub[:transit_gateway_peering_attachment]) unless stub[:transit_gateway_peering_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateTransitGatewayPrefixListReference
    class CreateTransitGatewayPrefixListReference
      def self.default(visited=[])
        {
          transit_gateway_prefix_list_reference: TransitGatewayPrefixListReference.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayPrefixListReferenceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPrefixListReference.stub('transitGatewayPrefixListReference', stub[:transit_gateway_prefix_list_reference]) unless stub[:transit_gateway_prefix_list_reference].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayPrefixListReference
    class TransitGatewayPrefixListReference
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayPrefixListReference')
        visited = visited + ['TransitGatewayPrefixListReference']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          prefix_list_id: 'prefix_list_id',
          prefix_list_owner_id: 'prefix_list_owner_id',
          state: 'state',
          blackhole: false,
          transit_gateway_attachment: TransitGatewayPrefixListAttachment.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('prefixListOwnerId', stub[:prefix_list_owner_id].to_s) unless stub[:prefix_list_owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('blackhole', stub[:blackhole].to_s) unless stub[:blackhole].nil?
        xml << TransitGatewayPrefixListAttachment.stub('transitGatewayAttachment', stub[:transit_gateway_attachment]) unless stub[:transit_gateway_attachment].nil?
        xml
      end
    end

    # Structure Stubber for TransitGatewayPrefixListAttachment
    class TransitGatewayPrefixListAttachment
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayPrefixListAttachment')
        visited = visited + ['TransitGatewayPrefixListAttachment']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_type: 'resource_type',
          resource_id: 'resource_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml
      end
    end

    # Operation Stubber for CreateTransitGatewayRoute
    class CreateTransitGatewayRoute
      def self.default(visited=[])
        {
          route: TransitGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayRoute
    class TransitGatewayRoute
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRoute')
        visited = visited + ['TransitGatewayRoute']
        {
          destination_cidr_block: 'destination_cidr_block',
          prefix_list_id: 'prefix_list_id',
          transit_gateway_attachments: TransitGatewayRouteAttachmentList.default(visited),
          type: 'type',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachments', TransitGatewayRouteAttachmentList.stub('item', stub[:transit_gateway_attachments])) unless stub[:transit_gateway_attachments].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # List Stubber for TransitGatewayRouteAttachmentList
    class TransitGatewayRouteAttachmentList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteAttachmentList')
        visited = visited + ['TransitGatewayRouteAttachmentList']
        [
          TransitGatewayRouteAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRouteAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TransitGatewayRouteAttachment
    class TransitGatewayRouteAttachment
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteAttachment')
        visited = visited + ['TransitGatewayRouteAttachment']
        {
          resource_id: 'resource_id',
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_type: 'resource_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml
      end
    end

    # Operation Stubber for CreateTransitGatewayRouteTable
    class CreateTransitGatewayRouteTable
      def self.default(visited=[])
        {
          transit_gateway_route_table: TransitGatewayRouteTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRouteTable.stub('transitGatewayRouteTable', stub[:transit_gateway_route_table]) unless stub[:transit_gateway_route_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayRouteTable
    class TransitGatewayRouteTable
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteTable')
        visited = visited + ['TransitGatewayRouteTable']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          transit_gateway_id: 'transit_gateway_id',
          state: 'state',
          default_association_route_table: false,
          default_propagation_route_table: false,
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('defaultAssociationRouteTable', stub[:default_association_route_table].to_s) unless stub[:default_association_route_table].nil?
        xml << Hearth::XML::Node.new('defaultPropagationRouteTable', stub[:default_propagation_route_table].to_s) unless stub[:default_propagation_route_table].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for CreateTransitGatewayVpcAttachment
    class CreateTransitGatewayVpcAttachment
      def self.default(visited=[])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateVolume
    class CreateVolume
      def self.default(visited=[])
        {
          attachments: VolumeAttachmentList.default(visited),
          availability_zone: 'availability_zone',
          create_time: Time.now,
          encrypted: false,
          kms_key_id: 'kms_key_id',
          outpost_arn: 'outpost_arn',
          size: 1,
          snapshot_id: 'snapshot_id',
          state: 'state',
          volume_id: 'volume_id',
          iops: 1,
          tags: TagList.default(visited),
          volume_type: 'volume_type',
          fast_restored: false,
          multi_attach_enabled: false,
          throughput: 1,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('attachmentSet', VolumeAttachmentList.stub('item', stub[:attachments])) unless stub[:attachments].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('size', stub[:size].to_s) unless stub[:size].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('iops', stub[:iops].to_s) unless stub[:iops].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('volumeType', stub[:volume_type].to_s) unless stub[:volume_type].nil?
        xml << Hearth::XML::Node.new('fastRestored', stub[:fast_restored].to_s) unless stub[:fast_restored].nil?
        xml << Hearth::XML::Node.new('multiAttachEnabled', stub[:multi_attach_enabled].to_s) unless stub[:multi_attach_enabled].nil?
        xml << Hearth::XML::Node.new('throughput', stub[:throughput].to_s) unless stub[:throughput].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VolumeAttachmentList
    class VolumeAttachmentList
      def self.default(visited=[])
        return nil if visited.include?('VolumeAttachmentList')
        visited = visited + ['VolumeAttachmentList']
        [
          VolumeAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VolumeAttachment
    class VolumeAttachment
      def self.default(visited=[])
        return nil if visited.include?('VolumeAttachment')
        visited = visited + ['VolumeAttachment']
        {
          attach_time: Time.now,
          device: 'device',
          instance_id: 'instance_id',
          state: 'state',
          volume_id: 'volume_id',
          delete_on_termination: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('device', stub[:device].to_s) unless stub[:device].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml
      end
    end

    # Operation Stubber for CreateVpc
    class CreateVpc
      def self.default(visited=[])
        {
          vpc: Vpc.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Vpc.stub('vpc', stub[:vpc]) unless stub[:vpc].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateVpcEndpoint
    class CreateVpcEndpoint
      def self.default(visited=[])
        {
          vpc_endpoint: VpcEndpoint.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcEndpoint.stub('vpcEndpoint', stub[:vpc_endpoint]) unless stub[:vpc_endpoint].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for VpcEndpoint
    class VpcEndpoint
      def self.default(visited=[])
        return nil if visited.include?('VpcEndpoint')
        visited = visited + ['VpcEndpoint']
        {
          vpc_endpoint_id: 'vpc_endpoint_id',
          vpc_endpoint_type: 'vpc_endpoint_type',
          vpc_id: 'vpc_id',
          service_name: 'service_name',
          state: 'state',
          policy_document: 'policy_document',
          route_table_ids: ValueStringList.default(visited),
          subnet_ids: ValueStringList.default(visited),
          groups: GroupIdentifierSet.default(visited),
          ip_address_type: 'ip_address_type',
          dns_options: DnsOptions.default(visited),
          private_dns_enabled: false,
          requester_managed: false,
          network_interface_ids: ValueStringList.default(visited),
          dns_entries: DnsEntrySet.default(visited),
          creation_timestamp: Time.now,
          tags: TagList.default(visited),
          owner_id: 'owner_id',
          last_error: LastError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('vpcEndpointId', stub[:vpc_endpoint_id].to_s) unless stub[:vpc_endpoint_id].nil?
        xml << Hearth::XML::Node.new('vpcEndpointType', stub[:vpc_endpoint_type].to_s) unless stub[:vpc_endpoint_type].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('serviceName', stub[:service_name].to_s) unless stub[:service_name].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('policyDocument', stub[:policy_document].to_s) unless stub[:policy_document].nil?
        xml << Hearth::XML::Node.new('routeTableIdSet', ValueStringList.stub('item', stub[:route_table_ids])) unless stub[:route_table_ids].nil?
        xml << Hearth::XML::Node.new('subnetIdSet', ValueStringList.stub('item', stub[:subnet_ids])) unless stub[:subnet_ids].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierSet.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('ipAddressType', stub[:ip_address_type].to_s) unless stub[:ip_address_type].nil?
        xml << DnsOptions.stub('dnsOptions', stub[:dns_options]) unless stub[:dns_options].nil?
        xml << Hearth::XML::Node.new('privateDnsEnabled', stub[:private_dns_enabled].to_s) unless stub[:private_dns_enabled].nil?
        xml << Hearth::XML::Node.new('requesterManaged', stub[:requester_managed].to_s) unless stub[:requester_managed].nil?
        xml << Hearth::XML::Node.new('networkInterfaceIdSet', ValueStringList.stub('item', stub[:network_interface_ids])) unless stub[:network_interface_ids].nil?
        xml << Hearth::XML::Node.new('dnsEntrySet', DnsEntrySet.stub('item', stub[:dns_entries])) unless stub[:dns_entries].nil?
        xml << Hearth::XML::Node.new('creationTimestamp', Hearth::TimeHelper.to_date_time(stub[:creation_timestamp])) unless stub[:creation_timestamp].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << LastError.stub('lastError', stub[:last_error]) unless stub[:last_error].nil?
        xml
      end
    end

    # Structure Stubber for LastError
    class LastError
      def self.default(visited=[])
        return nil if visited.include?('LastError')
        visited = visited + ['LastError']
        {
          message: 'message',
          code: 'code',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml
      end
    end

    # List Stubber for DnsEntrySet
    class DnsEntrySet
      def self.default(visited=[])
        return nil if visited.include?('DnsEntrySet')
        visited = visited + ['DnsEntrySet']
        [
          DnsEntry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DnsEntry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DnsEntry
    class DnsEntry
      def self.default(visited=[])
        return nil if visited.include?('DnsEntry')
        visited = visited + ['DnsEntry']
        {
          dns_name: 'dns_name',
          hosted_zone_id: 'hosted_zone_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dnsName', stub[:dns_name].to_s) unless stub[:dns_name].nil?
        xml << Hearth::XML::Node.new('hostedZoneId', stub[:hosted_zone_id].to_s) unless stub[:hosted_zone_id].nil?
        xml
      end
    end

    # Structure Stubber for DnsOptions
    class DnsOptions
      def self.default(visited=[])
        return nil if visited.include?('DnsOptions')
        visited = visited + ['DnsOptions']
        {
          dns_record_ip_type: 'dns_record_ip_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dnsRecordIpType', stub[:dns_record_ip_type].to_s) unless stub[:dns_record_ip_type].nil?
        xml
      end
    end

    # List Stubber for GroupIdentifierSet
    class GroupIdentifierSet
      def self.default(visited=[])
        return nil if visited.include?('GroupIdentifierSet')
        visited = visited + ['GroupIdentifierSet']
        [
          SecurityGroupIdentifier.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SecurityGroupIdentifier.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SecurityGroupIdentifier
    class SecurityGroupIdentifier
      def self.default(visited=[])
        return nil if visited.include?('SecurityGroupIdentifier')
        visited = visited + ['SecurityGroupIdentifier']
        {
          group_id: 'group_id',
          group_name: 'group_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml
      end
    end

    # Operation Stubber for CreateVpcEndpointConnectionNotification
    class CreateVpcEndpointConnectionNotification
      def self.default(visited=[])
        {
          connection_notification: ConnectionNotification.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcEndpointConnectionNotificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ConnectionNotification.stub('connectionNotification', stub[:connection_notification]) unless stub[:connection_notification].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ConnectionNotification
    class ConnectionNotification
      def self.default(visited=[])
        return nil if visited.include?('ConnectionNotification')
        visited = visited + ['ConnectionNotification']
        {
          connection_notification_id: 'connection_notification_id',
          service_id: 'service_id',
          vpc_endpoint_id: 'vpc_endpoint_id',
          connection_notification_type: 'connection_notification_type',
          connection_notification_arn: 'connection_notification_arn',
          connection_events: ValueStringList.default(visited),
          connection_notification_state: 'connection_notification_state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('connectionNotificationId', stub[:connection_notification_id].to_s) unless stub[:connection_notification_id].nil?
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml << Hearth::XML::Node.new('vpcEndpointId', stub[:vpc_endpoint_id].to_s) unless stub[:vpc_endpoint_id].nil?
        xml << Hearth::XML::Node.new('connectionNotificationType', stub[:connection_notification_type].to_s) unless stub[:connection_notification_type].nil?
        xml << Hearth::XML::Node.new('connectionNotificationArn', stub[:connection_notification_arn].to_s) unless stub[:connection_notification_arn].nil?
        xml << Hearth::XML::Node.new('connectionEvents', ValueStringList.stub('item', stub[:connection_events])) unless stub[:connection_events].nil?
        xml << Hearth::XML::Node.new('connectionNotificationState', stub[:connection_notification_state].to_s) unless stub[:connection_notification_state].nil?
        xml
      end
    end

    # Operation Stubber for CreateVpcEndpointServiceConfiguration
    class CreateVpcEndpointServiceConfiguration
      def self.default(visited=[])
        {
          service_configuration: ServiceConfiguration.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcEndpointServiceConfigurationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ServiceConfiguration.stub('serviceConfiguration', stub[:service_configuration]) unless stub[:service_configuration].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ServiceConfiguration
    class ServiceConfiguration
      def self.default(visited=[])
        return nil if visited.include?('ServiceConfiguration')
        visited = visited + ['ServiceConfiguration']
        {
          service_type: ServiceTypeDetailSet.default(visited),
          service_id: 'service_id',
          service_name: 'service_name',
          service_state: 'service_state',
          availability_zones: ValueStringList.default(visited),
          acceptance_required: false,
          manages_vpc_endpoints: false,
          network_load_balancer_arns: ValueStringList.default(visited),
          gateway_load_balancer_arns: ValueStringList.default(visited),
          supported_ip_address_types: SupportedIpAddressTypes.default(visited),
          base_endpoint_dns_names: ValueStringList.default(visited),
          private_dns_name: 'private_dns_name',
          private_dns_name_configuration: PrivateDnsNameConfiguration.default(visited),
          payer_responsibility: 'payer_responsibility',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('serviceType', ServiceTypeDetailSet.stub('item', stub[:service_type])) unless stub[:service_type].nil?
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml << Hearth::XML::Node.new('serviceName', stub[:service_name].to_s) unless stub[:service_name].nil?
        xml << Hearth::XML::Node.new('serviceState', stub[:service_state].to_s) unless stub[:service_state].nil?
        xml << Hearth::XML::Node.new('availabilityZoneSet', ValueStringList.stub('item', stub[:availability_zones])) unless stub[:availability_zones].nil?
        xml << Hearth::XML::Node.new('acceptanceRequired', stub[:acceptance_required].to_s) unless stub[:acceptance_required].nil?
        xml << Hearth::XML::Node.new('managesVpcEndpoints', stub[:manages_vpc_endpoints].to_s) unless stub[:manages_vpc_endpoints].nil?
        xml << Hearth::XML::Node.new('networkLoadBalancerArnSet', ValueStringList.stub('item', stub[:network_load_balancer_arns])) unless stub[:network_load_balancer_arns].nil?
        xml << Hearth::XML::Node.new('gatewayLoadBalancerArnSet', ValueStringList.stub('item', stub[:gateway_load_balancer_arns])) unless stub[:gateway_load_balancer_arns].nil?
        xml << Hearth::XML::Node.new('supportedIpAddressTypeSet', SupportedIpAddressTypes.stub('item', stub[:supported_ip_address_types])) unless stub[:supported_ip_address_types].nil?
        xml << Hearth::XML::Node.new('baseEndpointDnsNameSet', ValueStringList.stub('item', stub[:base_endpoint_dns_names])) unless stub[:base_endpoint_dns_names].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << PrivateDnsNameConfiguration.stub('privateDnsNameConfiguration', stub[:private_dns_name_configuration]) unless stub[:private_dns_name_configuration].nil?
        xml << Hearth::XML::Node.new('payerResponsibility', stub[:payer_responsibility].to_s) unless stub[:payer_responsibility].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for PrivateDnsNameConfiguration
    class PrivateDnsNameConfiguration
      def self.default(visited=[])
        return nil if visited.include?('PrivateDnsNameConfiguration')
        visited = visited + ['PrivateDnsNameConfiguration']
        {
          state: 'state',
          type: 'type',
          value: 'value',
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    # List Stubber for SupportedIpAddressTypes
    class SupportedIpAddressTypes
      def self.default(visited=[])
        return nil if visited.include?('SupportedIpAddressTypes')
        visited = visited + ['SupportedIpAddressTypes']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for ServiceTypeDetailSet
    class ServiceTypeDetailSet
      def self.default(visited=[])
        return nil if visited.include?('ServiceTypeDetailSet')
        visited = visited + ['ServiceTypeDetailSet']
        [
          ServiceTypeDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ServiceTypeDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ServiceTypeDetail
    class ServiceTypeDetail
      def self.default(visited=[])
        return nil if visited.include?('ServiceTypeDetail')
        visited = visited + ['ServiceTypeDetail']
        {
          service_type: 'service_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('serviceType', stub[:service_type].to_s) unless stub[:service_type].nil?
        xml
      end
    end

    # Operation Stubber for CreateVpcPeeringConnection
    class CreateVpcPeeringConnection
      def self.default(visited=[])
        {
          vpc_peering_connection: VpcPeeringConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcPeeringConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcPeeringConnection.stub('vpcPeeringConnection', stub[:vpc_peering_connection]) unless stub[:vpc_peering_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateVpnConnection
    class CreateVpnConnection
      def self.default(visited=[])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpnConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for VpnConnection
    class VpnConnection
      def self.default(visited=[])
        return nil if visited.include?('VpnConnection')
        visited = visited + ['VpnConnection']
        {
          customer_gateway_configuration: 'customer_gateway_configuration',
          customer_gateway_id: 'customer_gateway_id',
          category: 'category',
          state: 'state',
          type: 'type',
          vpn_connection_id: 'vpn_connection_id',
          vpn_gateway_id: 'vpn_gateway_id',
          transit_gateway_id: 'transit_gateway_id',
          core_network_arn: 'core_network_arn',
          core_network_attachment_arn: 'core_network_attachment_arn',
          gateway_association_state: 'gateway_association_state',
          options: VpnConnectionOptions.default(visited),
          routes: VpnStaticRouteList.default(visited),
          tags: TagList.default(visited),
          vgw_telemetry: VgwTelemetryList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('customerGatewayConfiguration', stub[:customer_gateway_configuration].to_s) unless stub[:customer_gateway_configuration].nil?
        xml << Hearth::XML::Node.new('customerGatewayId', stub[:customer_gateway_id].to_s) unless stub[:customer_gateway_id].nil?
        xml << Hearth::XML::Node.new('category', stub[:category].to_s) unless stub[:category].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('vpnConnectionId', stub[:vpn_connection_id].to_s) unless stub[:vpn_connection_id].nil?
        xml << Hearth::XML::Node.new('vpnGatewayId', stub[:vpn_gateway_id].to_s) unless stub[:vpn_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('coreNetworkArn', stub[:core_network_arn].to_s) unless stub[:core_network_arn].nil?
        xml << Hearth::XML::Node.new('coreNetworkAttachmentArn', stub[:core_network_attachment_arn].to_s) unless stub[:core_network_attachment_arn].nil?
        xml << Hearth::XML::Node.new('gatewayAssociationState', stub[:gateway_association_state].to_s) unless stub[:gateway_association_state].nil?
        xml << VpnConnectionOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('routes', VpnStaticRouteList.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vgwTelemetry', VgwTelemetryList.stub('item', stub[:vgw_telemetry])) unless stub[:vgw_telemetry].nil?
        xml
      end
    end

    # List Stubber for VgwTelemetryList
    class VgwTelemetryList
      def self.default(visited=[])
        return nil if visited.include?('VgwTelemetryList')
        visited = visited + ['VgwTelemetryList']
        [
          VgwTelemetry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VgwTelemetry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VgwTelemetry
    class VgwTelemetry
      def self.default(visited=[])
        return nil if visited.include?('VgwTelemetry')
        visited = visited + ['VgwTelemetry']
        {
          accepted_route_count: 1,
          last_status_change: Time.now,
          outside_ip_address: 'outside_ip_address',
          status: 'status',
          status_message: 'status_message',
          certificate_arn: 'certificate_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('acceptedRouteCount', stub[:accepted_route_count].to_s) unless stub[:accepted_route_count].nil?
        xml << Hearth::XML::Node.new('lastStatusChange', Hearth::TimeHelper.to_date_time(stub[:last_status_change])) unless stub[:last_status_change].nil?
        xml << Hearth::XML::Node.new('outsideIpAddress', stub[:outside_ip_address].to_s) unless stub[:outside_ip_address].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('certificateArn', stub[:certificate_arn].to_s) unless stub[:certificate_arn].nil?
        xml
      end
    end

    # List Stubber for VpnStaticRouteList
    class VpnStaticRouteList
      def self.default(visited=[])
        return nil if visited.include?('VpnStaticRouteList')
        visited = visited + ['VpnStaticRouteList']
        [
          VpnStaticRoute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpnStaticRoute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VpnStaticRoute
    class VpnStaticRoute
      def self.default(visited=[])
        return nil if visited.include?('VpnStaticRoute')
        visited = visited + ['VpnStaticRoute']
        {
          destination_cidr_block: 'destination_cidr_block',
          source: 'source',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('source', stub[:source].to_s) unless stub[:source].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Structure Stubber for VpnConnectionOptions
    class VpnConnectionOptions
      def self.default(visited=[])
        return nil if visited.include?('VpnConnectionOptions')
        visited = visited + ['VpnConnectionOptions']
        {
          enable_acceleration: false,
          static_routes_only: false,
          local_ipv4_network_cidr: 'local_ipv4_network_cidr',
          remote_ipv4_network_cidr: 'remote_ipv4_network_cidr',
          local_ipv6_network_cidr: 'local_ipv6_network_cidr',
          remote_ipv6_network_cidr: 'remote_ipv6_network_cidr',
          tunnel_inside_ip_version: 'tunnel_inside_ip_version',
          tunnel_options: TunnelOptionsList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enableAcceleration', stub[:enable_acceleration].to_s) unless stub[:enable_acceleration].nil?
        xml << Hearth::XML::Node.new('staticRoutesOnly', stub[:static_routes_only].to_s) unless stub[:static_routes_only].nil?
        xml << Hearth::XML::Node.new('localIpv4NetworkCidr', stub[:local_ipv4_network_cidr].to_s) unless stub[:local_ipv4_network_cidr].nil?
        xml << Hearth::XML::Node.new('remoteIpv4NetworkCidr', stub[:remote_ipv4_network_cidr].to_s) unless stub[:remote_ipv4_network_cidr].nil?
        xml << Hearth::XML::Node.new('localIpv6NetworkCidr', stub[:local_ipv6_network_cidr].to_s) unless stub[:local_ipv6_network_cidr].nil?
        xml << Hearth::XML::Node.new('remoteIpv6NetworkCidr', stub[:remote_ipv6_network_cidr].to_s) unless stub[:remote_ipv6_network_cidr].nil?
        xml << Hearth::XML::Node.new('tunnelInsideIpVersion', stub[:tunnel_inside_ip_version].to_s) unless stub[:tunnel_inside_ip_version].nil?
        xml << Hearth::XML::Node.new('tunnelOptionSet', TunnelOptionsList.stub('item', stub[:tunnel_options])) unless stub[:tunnel_options].nil?
        xml
      end
    end

    # List Stubber for TunnelOptionsList
    class TunnelOptionsList
      def self.default(visited=[])
        return nil if visited.include?('TunnelOptionsList')
        visited = visited + ['TunnelOptionsList']
        [
          TunnelOption.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TunnelOption.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TunnelOption
    class TunnelOption
      def self.default(visited=[])
        return nil if visited.include?('TunnelOption')
        visited = visited + ['TunnelOption']
        {
          outside_ip_address: 'outside_ip_address',
          tunnel_inside_cidr: 'tunnel_inside_cidr',
          tunnel_inside_ipv6_cidr: 'tunnel_inside_ipv6_cidr',
          pre_shared_key: 'pre_shared_key',
          phase1_lifetime_seconds: 1,
          phase2_lifetime_seconds: 1,
          rekey_margin_time_seconds: 1,
          rekey_fuzz_percentage: 1,
          replay_window_size: 1,
          dpd_timeout_seconds: 1,
          dpd_timeout_action: 'dpd_timeout_action',
          phase1_encryption_algorithms: Phase1EncryptionAlgorithmsList.default(visited),
          phase2_encryption_algorithms: Phase2EncryptionAlgorithmsList.default(visited),
          phase1_integrity_algorithms: Phase1IntegrityAlgorithmsList.default(visited),
          phase2_integrity_algorithms: Phase2IntegrityAlgorithmsList.default(visited),
          phase1_dh_group_numbers: Phase1DHGroupNumbersList.default(visited),
          phase2_dh_group_numbers: Phase2DHGroupNumbersList.default(visited),
          ike_versions: IKEVersionsList.default(visited),
          startup_action: 'startup_action',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('outsideIpAddress', stub[:outside_ip_address].to_s) unless stub[:outside_ip_address].nil?
        xml << Hearth::XML::Node.new('tunnelInsideCidr', stub[:tunnel_inside_cidr].to_s) unless stub[:tunnel_inside_cidr].nil?
        xml << Hearth::XML::Node.new('tunnelInsideIpv6Cidr', stub[:tunnel_inside_ipv6_cidr].to_s) unless stub[:tunnel_inside_ipv6_cidr].nil?
        xml << Hearth::XML::Node.new('preSharedKey', stub[:pre_shared_key].to_s) unless stub[:pre_shared_key].nil?
        xml << Hearth::XML::Node.new('phase1LifetimeSeconds', stub[:phase1_lifetime_seconds].to_s) unless stub[:phase1_lifetime_seconds].nil?
        xml << Hearth::XML::Node.new('phase2LifetimeSeconds', stub[:phase2_lifetime_seconds].to_s) unless stub[:phase2_lifetime_seconds].nil?
        xml << Hearth::XML::Node.new('rekeyMarginTimeSeconds', stub[:rekey_margin_time_seconds].to_s) unless stub[:rekey_margin_time_seconds].nil?
        xml << Hearth::XML::Node.new('rekeyFuzzPercentage', stub[:rekey_fuzz_percentage].to_s) unless stub[:rekey_fuzz_percentage].nil?
        xml << Hearth::XML::Node.new('replayWindowSize', stub[:replay_window_size].to_s) unless stub[:replay_window_size].nil?
        xml << Hearth::XML::Node.new('dpdTimeoutSeconds', stub[:dpd_timeout_seconds].to_s) unless stub[:dpd_timeout_seconds].nil?
        xml << Hearth::XML::Node.new('dpdTimeoutAction', stub[:dpd_timeout_action].to_s) unless stub[:dpd_timeout_action].nil?
        xml << Hearth::XML::Node.new('phase1EncryptionAlgorithmSet', Phase1EncryptionAlgorithmsList.stub('item', stub[:phase1_encryption_algorithms])) unless stub[:phase1_encryption_algorithms].nil?
        xml << Hearth::XML::Node.new('phase2EncryptionAlgorithmSet', Phase2EncryptionAlgorithmsList.stub('item', stub[:phase2_encryption_algorithms])) unless stub[:phase2_encryption_algorithms].nil?
        xml << Hearth::XML::Node.new('phase1IntegrityAlgorithmSet', Phase1IntegrityAlgorithmsList.stub('item', stub[:phase1_integrity_algorithms])) unless stub[:phase1_integrity_algorithms].nil?
        xml << Hearth::XML::Node.new('phase2IntegrityAlgorithmSet', Phase2IntegrityAlgorithmsList.stub('item', stub[:phase2_integrity_algorithms])) unless stub[:phase2_integrity_algorithms].nil?
        xml << Hearth::XML::Node.new('phase1DHGroupNumberSet', Phase1DHGroupNumbersList.stub('item', stub[:phase1_dh_group_numbers])) unless stub[:phase1_dh_group_numbers].nil?
        xml << Hearth::XML::Node.new('phase2DHGroupNumberSet', Phase2DHGroupNumbersList.stub('item', stub[:phase2_dh_group_numbers])) unless stub[:phase2_dh_group_numbers].nil?
        xml << Hearth::XML::Node.new('ikeVersionSet', IKEVersionsList.stub('item', stub[:ike_versions])) unless stub[:ike_versions].nil?
        xml << Hearth::XML::Node.new('startupAction', stub[:startup_action].to_s) unless stub[:startup_action].nil?
        xml
      end
    end

    # List Stubber for IKEVersionsList
    class IKEVersionsList
      def self.default(visited=[])
        return nil if visited.include?('IKEVersionsList')
        visited = visited + ['IKEVersionsList']
        [
          IKEVersionsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IKEVersionsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for IKEVersionsListValue
    class IKEVersionsListValue
      def self.default(visited=[])
        return nil if visited.include?('IKEVersionsListValue')
        visited = visited + ['IKEVersionsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # List Stubber for Phase2DHGroupNumbersList
    class Phase2DHGroupNumbersList
      def self.default(visited=[])
        return nil if visited.include?('Phase2DHGroupNumbersList')
        visited = visited + ['Phase2DHGroupNumbersList']
        [
          Phase2DHGroupNumbersListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase2DHGroupNumbersListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Phase2DHGroupNumbersListValue
    class Phase2DHGroupNumbersListValue
      def self.default(visited=[])
        return nil if visited.include?('Phase2DHGroupNumbersListValue')
        visited = visited + ['Phase2DHGroupNumbersListValue']
        {
          value: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # List Stubber for Phase1DHGroupNumbersList
    class Phase1DHGroupNumbersList
      def self.default(visited=[])
        return nil if visited.include?('Phase1DHGroupNumbersList')
        visited = visited + ['Phase1DHGroupNumbersList']
        [
          Phase1DHGroupNumbersListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase1DHGroupNumbersListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Phase1DHGroupNumbersListValue
    class Phase1DHGroupNumbersListValue
      def self.default(visited=[])
        return nil if visited.include?('Phase1DHGroupNumbersListValue')
        visited = visited + ['Phase1DHGroupNumbersListValue']
        {
          value: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # List Stubber for Phase2IntegrityAlgorithmsList
    class Phase2IntegrityAlgorithmsList
      def self.default(visited=[])
        return nil if visited.include?('Phase2IntegrityAlgorithmsList')
        visited = visited + ['Phase2IntegrityAlgorithmsList']
        [
          Phase2IntegrityAlgorithmsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase2IntegrityAlgorithmsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Phase2IntegrityAlgorithmsListValue
    class Phase2IntegrityAlgorithmsListValue
      def self.default(visited=[])
        return nil if visited.include?('Phase2IntegrityAlgorithmsListValue')
        visited = visited + ['Phase2IntegrityAlgorithmsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # List Stubber for Phase1IntegrityAlgorithmsList
    class Phase1IntegrityAlgorithmsList
      def self.default(visited=[])
        return nil if visited.include?('Phase1IntegrityAlgorithmsList')
        visited = visited + ['Phase1IntegrityAlgorithmsList']
        [
          Phase1IntegrityAlgorithmsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase1IntegrityAlgorithmsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Phase1IntegrityAlgorithmsListValue
    class Phase1IntegrityAlgorithmsListValue
      def self.default(visited=[])
        return nil if visited.include?('Phase1IntegrityAlgorithmsListValue')
        visited = visited + ['Phase1IntegrityAlgorithmsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # List Stubber for Phase2EncryptionAlgorithmsList
    class Phase2EncryptionAlgorithmsList
      def self.default(visited=[])
        return nil if visited.include?('Phase2EncryptionAlgorithmsList')
        visited = visited + ['Phase2EncryptionAlgorithmsList']
        [
          Phase2EncryptionAlgorithmsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase2EncryptionAlgorithmsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Phase2EncryptionAlgorithmsListValue
    class Phase2EncryptionAlgorithmsListValue
      def self.default(visited=[])
        return nil if visited.include?('Phase2EncryptionAlgorithmsListValue')
        visited = visited + ['Phase2EncryptionAlgorithmsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # List Stubber for Phase1EncryptionAlgorithmsList
    class Phase1EncryptionAlgorithmsList
      def self.default(visited=[])
        return nil if visited.include?('Phase1EncryptionAlgorithmsList')
        visited = visited + ['Phase1EncryptionAlgorithmsList']
        [
          Phase1EncryptionAlgorithmsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase1EncryptionAlgorithmsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Phase1EncryptionAlgorithmsListValue
    class Phase1EncryptionAlgorithmsListValue
      def self.default(visited=[])
        return nil if visited.include?('Phase1EncryptionAlgorithmsListValue')
        visited = visited + ['Phase1EncryptionAlgorithmsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # Operation Stubber for CreateVpnConnectionRoute
    class CreateVpnConnectionRoute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpnConnectionRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for CreateVpnGateway
    class CreateVpnGateway
      def self.default(visited=[])
        {
          vpn_gateway: VpnGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpnGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnGateway.stub('vpnGateway', stub[:vpn_gateway]) unless stub[:vpn_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for VpnGateway
    class VpnGateway
      def self.default(visited=[])
        return nil if visited.include?('VpnGateway')
        visited = visited + ['VpnGateway']
        {
          availability_zone: 'availability_zone',
          state: 'state',
          type: 'type',
          vpc_attachments: VpcAttachmentList.default(visited),
          vpn_gateway_id: 'vpn_gateway_id',
          amazon_side_asn: 1,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('attachments', VpcAttachmentList.stub('item', stub[:vpc_attachments])) unless stub[:vpc_attachments].nil?
        xml << Hearth::XML::Node.new('vpnGatewayId', stub[:vpn_gateway_id].to_s) unless stub[:vpn_gateway_id].nil?
        xml << Hearth::XML::Node.new('amazonSideAsn', stub[:amazon_side_asn].to_s) unless stub[:amazon_side_asn].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for VpcAttachmentList
    class VpcAttachmentList
      def self.default(visited=[])
        return nil if visited.include?('VpcAttachmentList')
        visited = visited + ['VpcAttachmentList']
        [
          VpcAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DeleteCarrierGateway
    class DeleteCarrierGateway
      def self.default(visited=[])
        {
          carrier_gateway: CarrierGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteCarrierGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CarrierGateway.stub('carrierGateway', stub[:carrier_gateway]) unless stub[:carrier_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteClientVpnEndpoint
    class DeleteClientVpnEndpoint
      def self.default(visited=[])
        {
          status: ClientVpnEndpointStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteClientVpnEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnEndpointStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteClientVpnRoute
    class DeleteClientVpnRoute
      def self.default(visited=[])
        {
          status: ClientVpnRouteStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteClientVpnRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnRouteStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteCustomerGateway
    class DeleteCustomerGateway
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteCustomerGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteDhcpOptions
    class DeleteDhcpOptions
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteDhcpOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteEgressOnlyInternetGateway
    class DeleteEgressOnlyInternetGateway
      def self.default(visited=[])
        {
          return_code: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteEgressOnlyInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('returnCode', stub[:return_code].to_s) unless stub[:return_code].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteFleets
    class DeleteFleets
      def self.default(visited=[])
        {
          successful_fleet_deletions: DeleteFleetSuccessSet.default(visited),
          unsuccessful_fleet_deletions: DeleteFleetErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteFleetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulFleetDeletionSet', DeleteFleetSuccessSet.stub('item', stub[:successful_fleet_deletions])) unless stub[:successful_fleet_deletions].nil?
        xml << Hearth::XML::Node.new('unsuccessfulFleetDeletionSet', DeleteFleetErrorSet.stub('item', stub[:unsuccessful_fleet_deletions])) unless stub[:unsuccessful_fleet_deletions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for DeleteFleetErrorSet
    class DeleteFleetErrorSet
      def self.default(visited=[])
        return nil if visited.include?('DeleteFleetErrorSet')
        visited = visited + ['DeleteFleetErrorSet']
        [
          DeleteFleetErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DeleteFleetErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DeleteFleetErrorItem
    class DeleteFleetErrorItem
      def self.default(visited=[])
        return nil if visited.include?('DeleteFleetErrorItem')
        visited = visited + ['DeleteFleetErrorItem']
        {
          error: DeleteFleetError.default(visited),
          fleet_id: 'fleet_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << DeleteFleetError.stub('error', stub[:error]) unless stub[:error].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml
      end
    end

    # Structure Stubber for DeleteFleetError
    class DeleteFleetError
      def self.default(visited=[])
        return nil if visited.include?('DeleteFleetError')
        visited = visited + ['DeleteFleetError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # List Stubber for DeleteFleetSuccessSet
    class DeleteFleetSuccessSet
      def self.default(visited=[])
        return nil if visited.include?('DeleteFleetSuccessSet')
        visited = visited + ['DeleteFleetSuccessSet']
        [
          DeleteFleetSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DeleteFleetSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DeleteFleetSuccessItem
    class DeleteFleetSuccessItem
      def self.default(visited=[])
        return nil if visited.include?('DeleteFleetSuccessItem')
        visited = visited + ['DeleteFleetSuccessItem']
        {
          current_fleet_state: 'current_fleet_state',
          previous_fleet_state: 'previous_fleet_state',
          fleet_id: 'fleet_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currentFleetState', stub[:current_fleet_state].to_s) unless stub[:current_fleet_state].nil?
        xml << Hearth::XML::Node.new('previousFleetState', stub[:previous_fleet_state].to_s) unless stub[:previous_fleet_state].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml
      end
    end

    # Operation Stubber for DeleteFlowLogs
    class DeleteFlowLogs
      def self.default(visited=[])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteFlowLogsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteFpgaImage
    class DeleteFpgaImage
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteFpgaImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteInstanceEventWindow
    class DeleteInstanceEventWindow
      def self.default(visited=[])
        {
          instance_event_window_state: InstanceEventWindowStateChange.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindowStateChange.stub('instanceEventWindowState', stub[:instance_event_window_state]) unless stub[:instance_event_window_state].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for InstanceEventWindowStateChange
    class InstanceEventWindowStateChange
      def self.default(visited=[])
        return nil if visited.include?('InstanceEventWindowStateChange')
        visited = visited + ['InstanceEventWindowStateChange']
        {
          instance_event_window_id: 'instance_event_window_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceEventWindowId', stub[:instance_event_window_id].to_s) unless stub[:instance_event_window_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for DeleteInternetGateway
    class DeleteInternetGateway
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteIpam
    class DeleteIpam
      def self.default(visited=[])
        {
          ipam: Ipam.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteIpamResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Ipam.stub('ipam', stub[:ipam]) unless stub[:ipam].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteIpamPool
    class DeleteIpamPool
      def self.default(visited=[])
        {
          ipam_pool: IpamPool.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteIpamPoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPool.stub('ipamPool', stub[:ipam_pool]) unless stub[:ipam_pool].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteIpamScope
    class DeleteIpamScope
      def self.default(visited=[])
        {
          ipam_scope: IpamScope.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteIpamScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamScope.stub('ipamScope', stub[:ipam_scope]) unless stub[:ipam_scope].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteKeyPair
    class DeleteKeyPair
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteKeyPairResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteLaunchTemplate
    class DeleteLaunchTemplate
      def self.default(visited=[])
        {
          launch_template: LaunchTemplate.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLaunchTemplateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LaunchTemplate.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteLaunchTemplateVersions
    class DeleteLaunchTemplateVersions
      def self.default(visited=[])
        {
          successfully_deleted_launch_template_versions: DeleteLaunchTemplateVersionsResponseSuccessSet.default(visited),
          unsuccessfully_deleted_launch_template_versions: DeleteLaunchTemplateVersionsResponseErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLaunchTemplateVersionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfullyDeletedLaunchTemplateVersionSet', DeleteLaunchTemplateVersionsResponseSuccessSet.stub('item', stub[:successfully_deleted_launch_template_versions])) unless stub[:successfully_deleted_launch_template_versions].nil?
        xml << Hearth::XML::Node.new('unsuccessfullyDeletedLaunchTemplateVersionSet', DeleteLaunchTemplateVersionsResponseErrorSet.stub('item', stub[:unsuccessfully_deleted_launch_template_versions])) unless stub[:unsuccessfully_deleted_launch_template_versions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for DeleteLaunchTemplateVersionsResponseErrorSet
    class DeleteLaunchTemplateVersionsResponseErrorSet
      def self.default(visited=[])
        return nil if visited.include?('DeleteLaunchTemplateVersionsResponseErrorSet')
        visited = visited + ['DeleteLaunchTemplateVersionsResponseErrorSet']
        [
          DeleteLaunchTemplateVersionsResponseErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DeleteLaunchTemplateVersionsResponseErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DeleteLaunchTemplateVersionsResponseErrorItem
    class DeleteLaunchTemplateVersionsResponseErrorItem
      def self.default(visited=[])
        return nil if visited.include?('DeleteLaunchTemplateVersionsResponseErrorItem')
        visited = visited + ['DeleteLaunchTemplateVersionsResponseErrorItem']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version_number: 1,
          response_error: ResponseError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('versionNumber', stub[:version_number].to_s) unless stub[:version_number].nil?
        xml << ResponseError.stub('responseError', stub[:response_error]) unless stub[:response_error].nil?
        xml
      end
    end

    # Structure Stubber for ResponseError
    class ResponseError
      def self.default(visited=[])
        return nil if visited.include?('ResponseError')
        visited = visited + ['ResponseError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # List Stubber for DeleteLaunchTemplateVersionsResponseSuccessSet
    class DeleteLaunchTemplateVersionsResponseSuccessSet
      def self.default(visited=[])
        return nil if visited.include?('DeleteLaunchTemplateVersionsResponseSuccessSet')
        visited = visited + ['DeleteLaunchTemplateVersionsResponseSuccessSet']
        [
          DeleteLaunchTemplateVersionsResponseSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DeleteLaunchTemplateVersionsResponseSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DeleteLaunchTemplateVersionsResponseSuccessItem
    class DeleteLaunchTemplateVersionsResponseSuccessItem
      def self.default(visited=[])
        return nil if visited.include?('DeleteLaunchTemplateVersionsResponseSuccessItem')
        visited = visited + ['DeleteLaunchTemplateVersionsResponseSuccessItem']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version_number: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('versionNumber', stub[:version_number].to_s) unless stub[:version_number].nil?
        xml
      end
    end

    # Operation Stubber for DeleteLocalGatewayRoute
    class DeleteLocalGatewayRoute
      def self.default(visited=[])
        {
          route: LocalGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLocalGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteLocalGatewayRouteTableVpcAssociation
    class DeleteLocalGatewayRouteTableVpcAssociation
      def self.default(visited=[])
        {
          local_gateway_route_table_vpc_association: LocalGatewayRouteTableVpcAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLocalGatewayRouteTableVpcAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRouteTableVpcAssociation.stub('localGatewayRouteTableVpcAssociation', stub[:local_gateway_route_table_vpc_association]) unless stub[:local_gateway_route_table_vpc_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteManagedPrefixList
    class DeleteManagedPrefixList
      def self.default(visited=[])
        {
          prefix_list: ManagedPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteManagedPrefixListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ManagedPrefixList.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteNatGateway
    class DeleteNatGateway
      def self.default(visited=[])
        {
          nat_gateway_id: 'nat_gateway_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNatGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteNetworkAcl
    class DeleteNetworkAcl
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkAclResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteNetworkAclEntry
    class DeleteNetworkAclEntry
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkAclEntryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteNetworkInsightsAccessScope
    class DeleteNetworkInsightsAccessScope
      def self.default(visited=[])
        {
          network_insights_access_scope_id: 'network_insights_access_scope_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInsightsAccessScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteNetworkInsightsAccessScopeAnalysis
    class DeleteNetworkInsightsAccessScopeAnalysis
      def self.default(visited=[])
        {
          network_insights_access_scope_analysis_id: 'network_insights_access_scope_analysis_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInsightsAccessScopeAnalysisResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisId', stub[:network_insights_access_scope_analysis_id].to_s) unless stub[:network_insights_access_scope_analysis_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteNetworkInsightsAnalysis
    class DeleteNetworkInsightsAnalysis
      def self.default(visited=[])
        {
          network_insights_analysis_id: 'network_insights_analysis_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInsightsAnalysisResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAnalysisId', stub[:network_insights_analysis_id].to_s) unless stub[:network_insights_analysis_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteNetworkInsightsPath
    class DeleteNetworkInsightsPath
      def self.default(visited=[])
        {
          network_insights_path_id: 'network_insights_path_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInsightsPathResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsPathId', stub[:network_insights_path_id].to_s) unless stub[:network_insights_path_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteNetworkInterface
    class DeleteNetworkInterface
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteNetworkInterfacePermission
    class DeleteNetworkInterfacePermission
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInterfacePermissionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeletePlacementGroup
    class DeletePlacementGroup
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeletePlacementGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeletePublicIpv4Pool
    class DeletePublicIpv4Pool
      def self.default(visited=[])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeletePublicIpv4PoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('returnValue', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteQueuedReservedInstances
    class DeleteQueuedReservedInstances
      def self.default(visited=[])
        {
          successful_queued_purchase_deletions: SuccessfulQueuedPurchaseDeletionSet.default(visited),
          failed_queued_purchase_deletions: FailedQueuedPurchaseDeletionSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteQueuedReservedInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulQueuedPurchaseDeletionSet', SuccessfulQueuedPurchaseDeletionSet.stub('item', stub[:successful_queued_purchase_deletions])) unless stub[:successful_queued_purchase_deletions].nil?
        xml << Hearth::XML::Node.new('failedQueuedPurchaseDeletionSet', FailedQueuedPurchaseDeletionSet.stub('item', stub[:failed_queued_purchase_deletions])) unless stub[:failed_queued_purchase_deletions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for FailedQueuedPurchaseDeletionSet
    class FailedQueuedPurchaseDeletionSet
      def self.default(visited=[])
        return nil if visited.include?('FailedQueuedPurchaseDeletionSet')
        visited = visited + ['FailedQueuedPurchaseDeletionSet']
        [
          FailedQueuedPurchaseDeletion.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FailedQueuedPurchaseDeletion.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for FailedQueuedPurchaseDeletion
    class FailedQueuedPurchaseDeletion
      def self.default(visited=[])
        return nil if visited.include?('FailedQueuedPurchaseDeletion')
        visited = visited + ['FailedQueuedPurchaseDeletion']
        {
          error: DeleteQueuedReservedInstancesError.default(visited),
          reserved_instances_id: 'reserved_instances_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << DeleteQueuedReservedInstancesError.stub('error', stub[:error]) unless stub[:error].nil?
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml
      end
    end

    # Structure Stubber for DeleteQueuedReservedInstancesError
    class DeleteQueuedReservedInstancesError
      def self.default(visited=[])
        return nil if visited.include?('DeleteQueuedReservedInstancesError')
        visited = visited + ['DeleteQueuedReservedInstancesError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # List Stubber for SuccessfulQueuedPurchaseDeletionSet
    class SuccessfulQueuedPurchaseDeletionSet
      def self.default(visited=[])
        return nil if visited.include?('SuccessfulQueuedPurchaseDeletionSet')
        visited = visited + ['SuccessfulQueuedPurchaseDeletionSet']
        [
          SuccessfulQueuedPurchaseDeletion.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SuccessfulQueuedPurchaseDeletion.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SuccessfulQueuedPurchaseDeletion
    class SuccessfulQueuedPurchaseDeletion
      def self.default(visited=[])
        return nil if visited.include?('SuccessfulQueuedPurchaseDeletion')
        visited = visited + ['SuccessfulQueuedPurchaseDeletion']
        {
          reserved_instances_id: 'reserved_instances_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml
      end
    end

    # Operation Stubber for DeleteRoute
    class DeleteRoute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteRouteTable
    class DeleteRouteTable
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteSecurityGroup
    class DeleteSecurityGroup
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSecurityGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteSnapshot
    class DeleteSnapshot
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSnapshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteSpotDatafeedSubscription
    class DeleteSpotDatafeedSubscription
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSpotDatafeedSubscriptionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteSubnet
    class DeleteSubnet
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSubnetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteSubnetCidrReservation
    class DeleteSubnetCidrReservation
      def self.default(visited=[])
        {
          deleted_subnet_cidr_reservation: SubnetCidrReservation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSubnetCidrReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SubnetCidrReservation.stub('deletedSubnetCidrReservation', stub[:deleted_subnet_cidr_reservation]) unless stub[:deleted_subnet_cidr_reservation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTags
    class DeleteTags
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTagsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTrafficMirrorFilter
    class DeleteTrafficMirrorFilter
      def self.default(visited=[])
        {
          traffic_mirror_filter_id: 'traffic_mirror_filter_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTrafficMirrorFilterResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorFilterId', stub[:traffic_mirror_filter_id].to_s) unless stub[:traffic_mirror_filter_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTrafficMirrorFilterRule
    class DeleteTrafficMirrorFilterRule
      def self.default(visited=[])
        {
          traffic_mirror_filter_rule_id: 'traffic_mirror_filter_rule_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTrafficMirrorFilterRuleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorFilterRuleId', stub[:traffic_mirror_filter_rule_id].to_s) unless stub[:traffic_mirror_filter_rule_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTrafficMirrorSession
    class DeleteTrafficMirrorSession
      def self.default(visited=[])
        {
          traffic_mirror_session_id: 'traffic_mirror_session_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTrafficMirrorSessionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorSessionId', stub[:traffic_mirror_session_id].to_s) unless stub[:traffic_mirror_session_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTrafficMirrorTarget
    class DeleteTrafficMirrorTarget
      def self.default(visited=[])
        {
          traffic_mirror_target_id: 'traffic_mirror_target_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTrafficMirrorTargetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorTargetId', stub[:traffic_mirror_target_id].to_s) unless stub[:traffic_mirror_target_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTransitGateway
    class DeleteTransitGateway
      def self.default(visited=[])
        {
          transit_gateway: TransitGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGateway.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTransitGatewayConnect
    class DeleteTransitGatewayConnect
      def self.default(visited=[])
        {
          transit_gateway_connect: TransitGatewayConnect.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayConnectResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayConnect.stub('transitGatewayConnect', stub[:transit_gateway_connect]) unless stub[:transit_gateway_connect].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTransitGatewayConnectPeer
    class DeleteTransitGatewayConnectPeer
      def self.default(visited=[])
        {
          transit_gateway_connect_peer: TransitGatewayConnectPeer.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayConnectPeerResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayConnectPeer.stub('transitGatewayConnectPeer', stub[:transit_gateway_connect_peer]) unless stub[:transit_gateway_connect_peer].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTransitGatewayMulticastDomain
    class DeleteTransitGatewayMulticastDomain
      def self.default(visited=[])
        {
          transit_gateway_multicast_domain: TransitGatewayMulticastDomain.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayMulticastDomainResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomain.stub('transitGatewayMulticastDomain', stub[:transit_gateway_multicast_domain]) unless stub[:transit_gateway_multicast_domain].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTransitGatewayPeeringAttachment
    class DeleteTransitGatewayPeeringAttachment
      def self.default(visited=[])
        {
          transit_gateway_peering_attachment: TransitGatewayPeeringAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayPeeringAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPeeringAttachment.stub('transitGatewayPeeringAttachment', stub[:transit_gateway_peering_attachment]) unless stub[:transit_gateway_peering_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTransitGatewayPrefixListReference
    class DeleteTransitGatewayPrefixListReference
      def self.default(visited=[])
        {
          transit_gateway_prefix_list_reference: TransitGatewayPrefixListReference.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayPrefixListReferenceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPrefixListReference.stub('transitGatewayPrefixListReference', stub[:transit_gateway_prefix_list_reference]) unless stub[:transit_gateway_prefix_list_reference].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTransitGatewayRoute
    class DeleteTransitGatewayRoute
      def self.default(visited=[])
        {
          route: TransitGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTransitGatewayRouteTable
    class DeleteTransitGatewayRouteTable
      def self.default(visited=[])
        {
          transit_gateway_route_table: TransitGatewayRouteTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRouteTable.stub('transitGatewayRouteTable', stub[:transit_gateway_route_table]) unless stub[:transit_gateway_route_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteTransitGatewayVpcAttachment
    class DeleteTransitGatewayVpcAttachment
      def self.default(visited=[])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteVolume
    class DeleteVolume
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteVpc
    class DeleteVpc
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteVpcEndpointConnectionNotifications
    class DeleteVpcEndpointConnectionNotifications
      def self.default(visited=[])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcEndpointConnectionNotificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteVpcEndpointServiceConfigurations
    class DeleteVpcEndpointServiceConfigurations
      def self.default(visited=[])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcEndpointServiceConfigurationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteVpcEndpoints
    class DeleteVpcEndpoints
      def self.default(visited=[])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcEndpointsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteVpcPeeringConnection
    class DeleteVpcPeeringConnection
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcPeeringConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteVpnConnection
    class DeleteVpnConnection
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpnConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteVpnConnectionRoute
    class DeleteVpnConnectionRoute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpnConnectionRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeleteVpnGateway
    class DeleteVpnGateway
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpnGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeprovisionByoipCidr
    class DeprovisionByoipCidr
      def self.default(visited=[])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeprovisionByoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeprovisionIpamPoolCidr
    class DeprovisionIpamPoolCidr
      def self.default(visited=[])
        {
          ipam_pool_cidr: IpamPoolCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeprovisionIpamPoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPoolCidr.stub('ipamPoolCidr', stub[:ipam_pool_cidr]) unless stub[:ipam_pool_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for IpamPoolCidr
    class IpamPoolCidr
      def self.default(visited=[])
        return nil if visited.include?('IpamPoolCidr')
        visited = visited + ['IpamPoolCidr']
        {
          cidr: 'cidr',
          state: 'state',
          failure_reason: IpamPoolCidrFailureReason.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << IpamPoolCidrFailureReason.stub('failureReason', stub[:failure_reason]) unless stub[:failure_reason].nil?
        xml
      end
    end

    # Structure Stubber for IpamPoolCidrFailureReason
    class IpamPoolCidrFailureReason
      def self.default(visited=[])
        return nil if visited.include?('IpamPoolCidrFailureReason')
        visited = visited + ['IpamPoolCidrFailureReason']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for DeprovisionPublicIpv4PoolCidr
    class DeprovisionPublicIpv4PoolCidr
      def self.default(visited=[])
        {
          pool_id: 'pool_id',
          deprovisioned_addresses: DeprovisionedAddressSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeprovisionPublicIpv4PoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << Hearth::XML::Node.new('deprovisionedAddressSet', DeprovisionedAddressSet.stub('item', stub[:deprovisioned_addresses])) unless stub[:deprovisioned_addresses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for DeprovisionedAddressSet
    class DeprovisionedAddressSet
      def self.default(visited=[])
        return nil if visited.include?('DeprovisionedAddressSet')
        visited = visited + ['DeprovisionedAddressSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DeregisterImage
    class DeregisterImage
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeregisterImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DeregisterInstanceEventNotificationAttributes
    class DeregisterInstanceEventNotificationAttributes
      def self.default(visited=[])
        {
          instance_tag_attribute: InstanceTagNotificationAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeregisterInstanceEventNotificationAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceTagNotificationAttribute.stub('instanceTagAttribute', stub[:instance_tag_attribute]) unless stub[:instance_tag_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for InstanceTagNotificationAttribute
    class InstanceTagNotificationAttribute
      def self.default(visited=[])
        return nil if visited.include?('InstanceTagNotificationAttribute')
        visited = visited + ['InstanceTagNotificationAttribute']
        {
          instance_tag_keys: InstanceTagKeySet.default(visited),
          include_all_tags_of_instance: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceTagKeySet', InstanceTagKeySet.stub('item', stub[:instance_tag_keys])) unless stub[:instance_tag_keys].nil?
        xml << Hearth::XML::Node.new('includeAllTagsOfInstance', stub[:include_all_tags_of_instance].to_s) unless stub[:include_all_tags_of_instance].nil?
        xml
      end
    end

    # List Stubber for InstanceTagKeySet
    class InstanceTagKeySet
      def self.default(visited=[])
        return nil if visited.include?('InstanceTagKeySet')
        visited = visited + ['InstanceTagKeySet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DeregisterTransitGatewayMulticastGroupMembers
    class DeregisterTransitGatewayMulticastGroupMembers
      def self.default(visited=[])
        {
          deregistered_multicast_group_members: TransitGatewayMulticastDeregisteredGroupMembers.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeregisterTransitGatewayMulticastGroupMembersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDeregisteredGroupMembers.stub('deregisteredMulticastGroupMembers', stub[:deregistered_multicast_group_members]) unless stub[:deregistered_multicast_group_members].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayMulticastDeregisteredGroupMembers
    class TransitGatewayMulticastDeregisteredGroupMembers
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastDeregisteredGroupMembers')
        visited = visited + ['TransitGatewayMulticastDeregisteredGroupMembers']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          deregistered_network_interface_ids: ValueStringList.default(visited),
          group_ip_address: 'group_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('deregisteredNetworkInterfaceIds', ValueStringList.stub('item', stub[:deregistered_network_interface_ids])) unless stub[:deregistered_network_interface_ids].nil?
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml
      end
    end

    # Operation Stubber for DeregisterTransitGatewayMulticastGroupSources
    class DeregisterTransitGatewayMulticastGroupSources
      def self.default(visited=[])
        {
          deregistered_multicast_group_sources: TransitGatewayMulticastDeregisteredGroupSources.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeregisterTransitGatewayMulticastGroupSourcesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDeregisteredGroupSources.stub('deregisteredMulticastGroupSources', stub[:deregistered_multicast_group_sources]) unless stub[:deregistered_multicast_group_sources].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayMulticastDeregisteredGroupSources
    class TransitGatewayMulticastDeregisteredGroupSources
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastDeregisteredGroupSources')
        visited = visited + ['TransitGatewayMulticastDeregisteredGroupSources']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          deregistered_network_interface_ids: ValueStringList.default(visited),
          group_ip_address: 'group_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('deregisteredNetworkInterfaceIds', ValueStringList.stub('item', stub[:deregistered_network_interface_ids])) unless stub[:deregistered_network_interface_ids].nil?
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml
      end
    end

    # Operation Stubber for DescribeAccountAttributes
    class DescribeAccountAttributes
      def self.default(visited=[])
        {
          account_attributes: AccountAttributeList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAccountAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('accountAttributeSet', AccountAttributeList.stub('item', stub[:account_attributes])) unless stub[:account_attributes].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for AccountAttributeList
    class AccountAttributeList
      def self.default(visited=[])
        return nil if visited.include?('AccountAttributeList')
        visited = visited + ['AccountAttributeList']
        [
          AccountAttribute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AccountAttribute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AccountAttribute
    class AccountAttribute
      def self.default(visited=[])
        return nil if visited.include?('AccountAttribute')
        visited = visited + ['AccountAttribute']
        {
          attribute_name: 'attribute_name',
          attribute_values: AccountAttributeValueList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attributeName', stub[:attribute_name].to_s) unless stub[:attribute_name].nil?
        xml << Hearth::XML::Node.new('attributeValueSet', AccountAttributeValueList.stub('item', stub[:attribute_values])) unless stub[:attribute_values].nil?
        xml
      end
    end

    # List Stubber for AccountAttributeValueList
    class AccountAttributeValueList
      def self.default(visited=[])
        return nil if visited.include?('AccountAttributeValueList')
        visited = visited + ['AccountAttributeValueList']
        [
          AccountAttributeValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AccountAttributeValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AccountAttributeValue
    class AccountAttributeValue
      def self.default(visited=[])
        return nil if visited.include?('AccountAttributeValue')
        visited = visited + ['AccountAttributeValue']
        {
          attribute_value: 'attribute_value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attributeValue', stub[:attribute_value].to_s) unless stub[:attribute_value].nil?
        xml
      end
    end

    # Operation Stubber for DescribeAddresses
    class DescribeAddresses
      def self.default(visited=[])
        {
          addresses: AddressList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('addressesSet', AddressList.stub('item', stub[:addresses])) unless stub[:addresses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for AddressList
    class AddressList
      def self.default(visited=[])
        return nil if visited.include?('AddressList')
        visited = visited + ['AddressList']
        [
          Address.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Address.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Address
    class Address
      def self.default(visited=[])
        return nil if visited.include?('Address')
        visited = visited + ['Address']
        {
          instance_id: 'instance_id',
          public_ip: 'public_ip',
          allocation_id: 'allocation_id',
          association_id: 'association_id',
          domain: 'domain',
          network_interface_id: 'network_interface_id',
          network_interface_owner_id: 'network_interface_owner_id',
          private_ip_address: 'private_ip_address',
          tags: TagList.default(visited),
          public_ipv4_pool: 'public_ipv4_pool',
          network_border_group: 'network_border_group',
          customer_owned_ip: 'customer_owned_ip',
          customer_owned_ipv4_pool: 'customer_owned_ipv4_pool',
          carrier_ip: 'carrier_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('domain', stub[:domain].to_s) unless stub[:domain].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceOwnerId', stub[:network_interface_owner_id].to_s) unless stub[:network_interface_owner_id].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('publicIpv4Pool', stub[:public_ipv4_pool].to_s) unless stub[:public_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('customerOwnedIp', stub[:customer_owned_ip].to_s) unless stub[:customer_owned_ip].nil?
        xml << Hearth::XML::Node.new('customerOwnedIpv4Pool', stub[:customer_owned_ipv4_pool].to_s) unless stub[:customer_owned_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('carrierIp', stub[:carrier_ip].to_s) unless stub[:carrier_ip].nil?
        xml
      end
    end

    # Operation Stubber for DescribeAddressesAttribute
    class DescribeAddressesAttribute
      def self.default(visited=[])
        {
          addresses: AddressSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAddressesAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('addressSet', AddressSet.stub('item', stub[:addresses])) unless stub[:addresses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for AddressSet
    class AddressSet
      def self.default(visited=[])
        return nil if visited.include?('AddressSet')
        visited = visited + ['AddressSet']
        [
          AddressAttribute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AddressAttribute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AddressAttribute
    class AddressAttribute
      def self.default(visited=[])
        return nil if visited.include?('AddressAttribute')
        visited = visited + ['AddressAttribute']
        {
          public_ip: 'public_ip',
          allocation_id: 'allocation_id',
          ptr_record: 'ptr_record',
          ptr_record_update: PtrUpdateStatus.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('ptrRecord', stub[:ptr_record].to_s) unless stub[:ptr_record].nil?
        xml << PtrUpdateStatus.stub('ptrRecordUpdate', stub[:ptr_record_update]) unless stub[:ptr_record_update].nil?
        xml
      end
    end

    # Structure Stubber for PtrUpdateStatus
    class PtrUpdateStatus
      def self.default(visited=[])
        return nil if visited.include?('PtrUpdateStatus')
        visited = visited + ['PtrUpdateStatus']
        {
          value: 'value',
          status: 'status',
          reason: 'reason',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('reason', stub[:reason].to_s) unless stub[:reason].nil?
        xml
      end
    end

    # Operation Stubber for DescribeAggregateIdFormat
    class DescribeAggregateIdFormat
      def self.default(visited=[])
        {
          use_long_ids_aggregated: false,
          statuses: IdFormatList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAggregateIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('useLongIdsAggregated', stub[:use_long_ids_aggregated].to_s) unless stub[:use_long_ids_aggregated].nil?
        xml << Hearth::XML::Node.new('statusSet', IdFormatList.stub('item', stub[:statuses])) unless stub[:statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IdFormatList
    class IdFormatList
      def self.default(visited=[])
        return nil if visited.include?('IdFormatList')
        visited = visited + ['IdFormatList']
        [
          IdFormat.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IdFormat.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for IdFormat
    class IdFormat
      def self.default(visited=[])
        return nil if visited.include?('IdFormat')
        visited = visited + ['IdFormat']
        {
          deadline: Time.now,
          resource: 'resource',
          use_long_ids: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deadline', Hearth::TimeHelper.to_date_time(stub[:deadline])) unless stub[:deadline].nil?
        xml << Hearth::XML::Node.new('resource', stub[:resource].to_s) unless stub[:resource].nil?
        xml << Hearth::XML::Node.new('useLongIds', stub[:use_long_ids].to_s) unless stub[:use_long_ids].nil?
        xml
      end
    end

    # Operation Stubber for DescribeAvailabilityZones
    class DescribeAvailabilityZones
      def self.default(visited=[])
        {
          availability_zones: AvailabilityZoneList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAvailabilityZonesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('availabilityZoneInfo', AvailabilityZoneList.stub('item', stub[:availability_zones])) unless stub[:availability_zones].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for AvailabilityZoneList
    class AvailabilityZoneList
      def self.default(visited=[])
        return nil if visited.include?('AvailabilityZoneList')
        visited = visited + ['AvailabilityZoneList']
        [
          AvailabilityZone.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AvailabilityZone.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AvailabilityZone
    class AvailabilityZone
      def self.default(visited=[])
        return nil if visited.include?('AvailabilityZone')
        visited = visited + ['AvailabilityZone']
        {
          state: 'state',
          opt_in_status: 'opt_in_status',
          messages: AvailabilityZoneMessageList.default(visited),
          region_name: 'region_name',
          zone_name: 'zone_name',
          zone_id: 'zone_id',
          group_name: 'group_name',
          network_border_group: 'network_border_group',
          zone_type: 'zone_type',
          parent_zone_name: 'parent_zone_name',
          parent_zone_id: 'parent_zone_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('zoneState', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('optInStatus', stub[:opt_in_status].to_s) unless stub[:opt_in_status].nil?
        xml << Hearth::XML::Node.new('messageSet', AvailabilityZoneMessageList.stub('item', stub[:messages])) unless stub[:messages].nil?
        xml << Hearth::XML::Node.new('regionName', stub[:region_name].to_s) unless stub[:region_name].nil?
        xml << Hearth::XML::Node.new('zoneName', stub[:zone_name].to_s) unless stub[:zone_name].nil?
        xml << Hearth::XML::Node.new('zoneId', stub[:zone_id].to_s) unless stub[:zone_id].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('zoneType', stub[:zone_type].to_s) unless stub[:zone_type].nil?
        xml << Hearth::XML::Node.new('parentZoneName', stub[:parent_zone_name].to_s) unless stub[:parent_zone_name].nil?
        xml << Hearth::XML::Node.new('parentZoneId', stub[:parent_zone_id].to_s) unless stub[:parent_zone_id].nil?
        xml
      end
    end

    # List Stubber for AvailabilityZoneMessageList
    class AvailabilityZoneMessageList
      def self.default(visited=[])
        return nil if visited.include?('AvailabilityZoneMessageList')
        visited = visited + ['AvailabilityZoneMessageList']
        [
          AvailabilityZoneMessage.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AvailabilityZoneMessage.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AvailabilityZoneMessage
    class AvailabilityZoneMessage
      def self.default(visited=[])
        return nil if visited.include?('AvailabilityZoneMessage')
        visited = visited + ['AvailabilityZoneMessage']
        {
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for DescribeBundleTasks
    class DescribeBundleTasks
      def self.default(visited=[])
        {
          bundle_tasks: BundleTaskList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeBundleTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('bundleInstanceTasksSet', BundleTaskList.stub('item', stub[:bundle_tasks])) unless stub[:bundle_tasks].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for BundleTaskList
    class BundleTaskList
      def self.default(visited=[])
        return nil if visited.include?('BundleTaskList')
        visited = visited + ['BundleTaskList']
        [
          BundleTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << BundleTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeByoipCidrs
    class DescribeByoipCidrs
      def self.default(visited=[])
        {
          byoip_cidrs: ByoipCidrSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeByoipCidrsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('byoipCidrSet', ByoipCidrSet.stub('item', stub[:byoip_cidrs])) unless stub[:byoip_cidrs].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ByoipCidrSet
    class ByoipCidrSet
      def self.default(visited=[])
        return nil if visited.include?('ByoipCidrSet')
        visited = visited + ['ByoipCidrSet']
        [
          ByoipCidr.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ByoipCidr.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeCapacityReservationFleets
    class DescribeCapacityReservationFleets
      def self.default(visited=[])
        {
          capacity_reservation_fleets: CapacityReservationFleetSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCapacityReservationFleetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('capacityReservationFleetSet', CapacityReservationFleetSet.stub('item', stub[:capacity_reservation_fleets])) unless stub[:capacity_reservation_fleets].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CapacityReservationFleetSet
    class CapacityReservationFleetSet
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationFleetSet')
        visited = visited + ['CapacityReservationFleetSet']
        [
          CapacityReservationFleet.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CapacityReservationFleet.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CapacityReservationFleet
    class CapacityReservationFleet
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationFleet')
        visited = visited + ['CapacityReservationFleet']
        {
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
          capacity_reservation_fleet_arn: 'capacity_reservation_fleet_arn',
          state: 'state',
          total_target_capacity: 1,
          total_fulfilled_capacity: 1.0,
          tenancy: 'tenancy',
          end_date: Time.now,
          create_time: Time.now,
          instance_match_criteria: 'instance_match_criteria',
          allocation_strategy: 'allocation_strategy',
          instance_type_specifications: FleetCapacityReservationSet.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml << Hearth::XML::Node.new('capacityReservationFleetArn', stub[:capacity_reservation_fleet_arn].to_s) unless stub[:capacity_reservation_fleet_arn].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('totalTargetCapacity', stub[:total_target_capacity].to_s) unless stub[:total_target_capacity].nil?
        xml << Hearth::XML::Node.new('totalFulfilledCapacity', Hearth::NumberHelper.serialize(stub[:total_fulfilled_capacity]).to_s) unless stub[:total_fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('endDate', Hearth::TimeHelper.to_date_time(stub[:end_date])) unless stub[:end_date].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('instanceMatchCriteria', stub[:instance_match_criteria].to_s) unless stub[:instance_match_criteria].nil?
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << Hearth::XML::Node.new('instanceTypeSpecificationSet', FleetCapacityReservationSet.stub('item', stub[:instance_type_specifications])) unless stub[:instance_type_specifications].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for DescribeCapacityReservations
    class DescribeCapacityReservations
      def self.default(visited=[])
        {
          next_token: 'next_token',
          capacity_reservations: CapacityReservationSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCapacityReservationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('capacityReservationSet', CapacityReservationSet.stub('item', stub[:capacity_reservations])) unless stub[:capacity_reservations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CapacityReservationSet
    class CapacityReservationSet
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationSet')
        visited = visited + ['CapacityReservationSet']
        [
          CapacityReservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CapacityReservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeCarrierGateways
    class DescribeCarrierGateways
      def self.default(visited=[])
        {
          carrier_gateways: CarrierGatewaySet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCarrierGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('carrierGatewaySet', CarrierGatewaySet.stub('item', stub[:carrier_gateways])) unless stub[:carrier_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CarrierGatewaySet
    class CarrierGatewaySet
      def self.default(visited=[])
        return nil if visited.include?('CarrierGatewaySet')
        visited = visited + ['CarrierGatewaySet']
        [
          CarrierGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CarrierGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeClassicLinkInstances
    class DescribeClassicLinkInstances
      def self.default(visited=[])
        {
          instances: ClassicLinkInstanceList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClassicLinkInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', ClassicLinkInstanceList.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ClassicLinkInstanceList
    class ClassicLinkInstanceList
      def self.default(visited=[])
        return nil if visited.include?('ClassicLinkInstanceList')
        visited = visited + ['ClassicLinkInstanceList']
        [
          ClassicLinkInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClassicLinkInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ClassicLinkInstance
    class ClassicLinkInstance
      def self.default(visited=[])
        return nil if visited.include?('ClassicLinkInstance')
        visited = visited + ['ClassicLinkInstance']
        {
          groups: GroupIdentifierList.default(visited),
          instance_id: 'instance_id',
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    # Operation Stubber for DescribeClientVpnAuthorizationRules
    class DescribeClientVpnAuthorizationRules
      def self.default(visited=[])
        {
          authorization_rules: AuthorizationRuleSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnAuthorizationRulesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('authorizationRule', AuthorizationRuleSet.stub('item', stub[:authorization_rules])) unless stub[:authorization_rules].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for AuthorizationRuleSet
    class AuthorizationRuleSet
      def self.default(visited=[])
        return nil if visited.include?('AuthorizationRuleSet')
        visited = visited + ['AuthorizationRuleSet']
        [
          AuthorizationRule.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AuthorizationRule.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AuthorizationRule
    class AuthorizationRule
      def self.default(visited=[])
        return nil if visited.include?('AuthorizationRule')
        visited = visited + ['AuthorizationRule']
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          description: 'description',
          group_id: 'group_id',
          access_all: false,
          destination_cidr: 'destination_cidr',
          status: ClientVpnAuthorizationRuleStatus.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('accessAll', stub[:access_all].to_s) unless stub[:access_all].nil?
        xml << Hearth::XML::Node.new('destinationCidr', stub[:destination_cidr].to_s) unless stub[:destination_cidr].nil?
        xml << ClientVpnAuthorizationRuleStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml
      end
    end

    # Operation Stubber for DescribeClientVpnConnections
    class DescribeClientVpnConnections
      def self.default(visited=[])
        {
          connections: ClientVpnConnectionSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('connections', ClientVpnConnectionSet.stub('item', stub[:connections])) unless stub[:connections].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ClientVpnConnectionSet
    class ClientVpnConnectionSet
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnConnectionSet')
        visited = visited + ['ClientVpnConnectionSet']
        [
          ClientVpnConnection.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClientVpnConnection.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ClientVpnConnection
    class ClientVpnConnection
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnConnection')
        visited = visited + ['ClientVpnConnection']
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          timestamp: 'timestamp',
          connection_id: 'connection_id',
          username: 'username',
          connection_established_time: 'connection_established_time',
          ingress_bytes: 'ingress_bytes',
          egress_bytes: 'egress_bytes',
          ingress_packets: 'ingress_packets',
          egress_packets: 'egress_packets',
          client_ip: 'client_ip',
          common_name: 'common_name',
          status: ClientVpnConnectionStatus.default(visited),
          connection_end_time: 'connection_end_time',
          posture_compliance_statuses: ValueStringList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('timestamp', stub[:timestamp].to_s) unless stub[:timestamp].nil?
        xml << Hearth::XML::Node.new('connectionId', stub[:connection_id].to_s) unless stub[:connection_id].nil?
        xml << Hearth::XML::Node.new('username', stub[:username].to_s) unless stub[:username].nil?
        xml << Hearth::XML::Node.new('connectionEstablishedTime', stub[:connection_established_time].to_s) unless stub[:connection_established_time].nil?
        xml << Hearth::XML::Node.new('ingressBytes', stub[:ingress_bytes].to_s) unless stub[:ingress_bytes].nil?
        xml << Hearth::XML::Node.new('egressBytes', stub[:egress_bytes].to_s) unless stub[:egress_bytes].nil?
        xml << Hearth::XML::Node.new('ingressPackets', stub[:ingress_packets].to_s) unless stub[:ingress_packets].nil?
        xml << Hearth::XML::Node.new('egressPackets', stub[:egress_packets].to_s) unless stub[:egress_packets].nil?
        xml << Hearth::XML::Node.new('clientIp', stub[:client_ip].to_s) unless stub[:client_ip].nil?
        xml << Hearth::XML::Node.new('commonName', stub[:common_name].to_s) unless stub[:common_name].nil?
        xml << ClientVpnConnectionStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('connectionEndTime', stub[:connection_end_time].to_s) unless stub[:connection_end_time].nil?
        xml << Hearth::XML::Node.new('postureComplianceStatusSet', ValueStringList.stub('item', stub[:posture_compliance_statuses])) unless stub[:posture_compliance_statuses].nil?
        xml
      end
    end

    # Structure Stubber for ClientVpnConnectionStatus
    class ClientVpnConnectionStatus
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnConnectionStatus')
        visited = visited + ['ClientVpnConnectionStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for DescribeClientVpnEndpoints
    class DescribeClientVpnEndpoints
      def self.default(visited=[])
        {
          client_vpn_endpoints: EndpointSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnEndpointsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientVpnEndpoint', EndpointSet.stub('item', stub[:client_vpn_endpoints])) unless stub[:client_vpn_endpoints].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for EndpointSet
    class EndpointSet
      def self.default(visited=[])
        return nil if visited.include?('EndpointSet')
        visited = visited + ['EndpointSet']
        [
          ClientVpnEndpoint.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClientVpnEndpoint.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ClientVpnEndpoint
    class ClientVpnEndpoint
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnEndpoint')
        visited = visited + ['ClientVpnEndpoint']
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          description: 'description',
          status: ClientVpnEndpointStatus.default(visited),
          creation_time: 'creation_time',
          deletion_time: 'deletion_time',
          dns_name: 'dns_name',
          client_cidr_block: 'client_cidr_block',
          dns_servers: ValueStringList.default(visited),
          split_tunnel: false,
          vpn_protocol: 'vpn_protocol',
          transport_protocol: 'transport_protocol',
          vpn_port: 1,
          associated_target_networks: AssociatedTargetNetworkSet.default(visited),
          server_certificate_arn: 'server_certificate_arn',
          authentication_options: ClientVpnAuthenticationList.default(visited),
          connection_log_options: ConnectionLogResponseOptions.default(visited),
          tags: TagList.default(visited),
          security_group_ids: ClientVpnSecurityGroupIdSet.default(visited),
          vpc_id: 'vpc_id',
          self_service_portal_url: 'self_service_portal_url',
          client_connect_options: ClientConnectResponseOptions.default(visited),
          session_timeout_hours: 1,
          client_login_banner_options: ClientLoginBannerResponseOptions.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << ClientVpnEndpointStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('creationTime', stub[:creation_time].to_s) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('deletionTime', stub[:deletion_time].to_s) unless stub[:deletion_time].nil?
        xml << Hearth::XML::Node.new('dnsName', stub[:dns_name].to_s) unless stub[:dns_name].nil?
        xml << Hearth::XML::Node.new('clientCidrBlock', stub[:client_cidr_block].to_s) unless stub[:client_cidr_block].nil?
        xml << Hearth::XML::Node.new('dnsServer', ValueStringList.stub('item', stub[:dns_servers])) unless stub[:dns_servers].nil?
        xml << Hearth::XML::Node.new('splitTunnel', stub[:split_tunnel].to_s) unless stub[:split_tunnel].nil?
        xml << Hearth::XML::Node.new('vpnProtocol', stub[:vpn_protocol].to_s) unless stub[:vpn_protocol].nil?
        xml << Hearth::XML::Node.new('transportProtocol', stub[:transport_protocol].to_s) unless stub[:transport_protocol].nil?
        xml << Hearth::XML::Node.new('vpnPort', stub[:vpn_port].to_s) unless stub[:vpn_port].nil?
        xml << Hearth::XML::Node.new('associatedTargetNetwork', AssociatedTargetNetworkSet.stub('item', stub[:associated_target_networks])) unless stub[:associated_target_networks].nil?
        xml << Hearth::XML::Node.new('serverCertificateArn', stub[:server_certificate_arn].to_s) unless stub[:server_certificate_arn].nil?
        xml << Hearth::XML::Node.new('authenticationOptions', ClientVpnAuthenticationList.stub('item', stub[:authentication_options])) unless stub[:authentication_options].nil?
        xml << ConnectionLogResponseOptions.stub('connectionLogOptions', stub[:connection_log_options]) unless stub[:connection_log_options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('securityGroupIdSet', ClientVpnSecurityGroupIdSet.stub('item', stub[:security_group_ids])) unless stub[:security_group_ids].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('selfServicePortalUrl', stub[:self_service_portal_url].to_s) unless stub[:self_service_portal_url].nil?
        xml << ClientConnectResponseOptions.stub('clientConnectOptions', stub[:client_connect_options]) unless stub[:client_connect_options].nil?
        xml << Hearth::XML::Node.new('sessionTimeoutHours', stub[:session_timeout_hours].to_s) unless stub[:session_timeout_hours].nil?
        xml << ClientLoginBannerResponseOptions.stub('clientLoginBannerOptions', stub[:client_login_banner_options]) unless stub[:client_login_banner_options].nil?
        xml
      end
    end

    # Structure Stubber for ClientLoginBannerResponseOptions
    class ClientLoginBannerResponseOptions
      def self.default(visited=[])
        return nil if visited.include?('ClientLoginBannerResponseOptions')
        visited = visited + ['ClientLoginBannerResponseOptions']
        {
          enabled: false,
          banner_text: 'banner_text',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml << Hearth::XML::Node.new('bannerText', stub[:banner_text].to_s) unless stub[:banner_text].nil?
        xml
      end
    end

    # Structure Stubber for ClientConnectResponseOptions
    class ClientConnectResponseOptions
      def self.default(visited=[])
        return nil if visited.include?('ClientConnectResponseOptions')
        visited = visited + ['ClientConnectResponseOptions']
        {
          enabled: false,
          lambda_function_arn: 'lambda_function_arn',
          status: ClientVpnEndpointAttributeStatus.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml << Hearth::XML::Node.new('lambdaFunctionArn', stub[:lambda_function_arn].to_s) unless stub[:lambda_function_arn].nil?
        xml << ClientVpnEndpointAttributeStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml
      end
    end

    # Structure Stubber for ClientVpnEndpointAttributeStatus
    class ClientVpnEndpointAttributeStatus
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnEndpointAttributeStatus')
        visited = visited + ['ClientVpnEndpointAttributeStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Structure Stubber for ConnectionLogResponseOptions
    class ConnectionLogResponseOptions
      def self.default(visited=[])
        return nil if visited.include?('ConnectionLogResponseOptions')
        visited = visited + ['ConnectionLogResponseOptions']
        {
          enabled: false,
          cloudwatch_log_group: 'cloudwatch_log_group',
          cloudwatch_log_stream: 'cloudwatch_log_stream',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('Enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml << Hearth::XML::Node.new('CloudwatchLogGroup', stub[:cloudwatch_log_group].to_s) unless stub[:cloudwatch_log_group].nil?
        xml << Hearth::XML::Node.new('CloudwatchLogStream', stub[:cloudwatch_log_stream].to_s) unless stub[:cloudwatch_log_stream].nil?
        xml
      end
    end

    # List Stubber for ClientVpnAuthenticationList
    class ClientVpnAuthenticationList
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnAuthenticationList')
        visited = visited + ['ClientVpnAuthenticationList']
        [
          ClientVpnAuthentication.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClientVpnAuthentication.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ClientVpnAuthentication
    class ClientVpnAuthentication
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnAuthentication')
        visited = visited + ['ClientVpnAuthentication']
        {
          type: 'type',
          active_directory: DirectoryServiceAuthentication.default(visited),
          mutual_authentication: CertificateAuthentication.default(visited),
          federated_authentication: FederatedAuthentication.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << DirectoryServiceAuthentication.stub('activeDirectory', stub[:active_directory]) unless stub[:active_directory].nil?
        xml << CertificateAuthentication.stub('mutualAuthentication', stub[:mutual_authentication]) unless stub[:mutual_authentication].nil?
        xml << FederatedAuthentication.stub('federatedAuthentication', stub[:federated_authentication]) unless stub[:federated_authentication].nil?
        xml
      end
    end

    # Structure Stubber for FederatedAuthentication
    class FederatedAuthentication
      def self.default(visited=[])
        return nil if visited.include?('FederatedAuthentication')
        visited = visited + ['FederatedAuthentication']
        {
          saml_provider_arn: 'saml_provider_arn',
          self_service_saml_provider_arn: 'self_service_saml_provider_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('samlProviderArn', stub[:saml_provider_arn].to_s) unless stub[:saml_provider_arn].nil?
        xml << Hearth::XML::Node.new('selfServiceSamlProviderArn', stub[:self_service_saml_provider_arn].to_s) unless stub[:self_service_saml_provider_arn].nil?
        xml
      end
    end

    # Structure Stubber for CertificateAuthentication
    class CertificateAuthentication
      def self.default(visited=[])
        return nil if visited.include?('CertificateAuthentication')
        visited = visited + ['CertificateAuthentication']
        {
          client_root_certificate_chain: 'client_root_certificate_chain',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientRootCertificateChain', stub[:client_root_certificate_chain].to_s) unless stub[:client_root_certificate_chain].nil?
        xml
      end
    end

    # Structure Stubber for DirectoryServiceAuthentication
    class DirectoryServiceAuthentication
      def self.default(visited=[])
        return nil if visited.include?('DirectoryServiceAuthentication')
        visited = visited + ['DirectoryServiceAuthentication']
        {
          directory_id: 'directory_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('directoryId', stub[:directory_id].to_s) unless stub[:directory_id].nil?
        xml
      end
    end

    # List Stubber for AssociatedTargetNetworkSet
    class AssociatedTargetNetworkSet
      def self.default(visited=[])
        return nil if visited.include?('AssociatedTargetNetworkSet')
        visited = visited + ['AssociatedTargetNetworkSet']
        [
          AssociatedTargetNetwork.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AssociatedTargetNetwork.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AssociatedTargetNetwork
    class AssociatedTargetNetwork
      def self.default(visited=[])
        return nil if visited.include?('AssociatedTargetNetwork')
        visited = visited + ['AssociatedTargetNetwork']
        {
          network_id: 'network_id',
          network_type: 'network_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkId', stub[:network_id].to_s) unless stub[:network_id].nil?
        xml << Hearth::XML::Node.new('networkType', stub[:network_type].to_s) unless stub[:network_type].nil?
        xml
      end
    end

    # Operation Stubber for DescribeClientVpnRoutes
    class DescribeClientVpnRoutes
      def self.default(visited=[])
        {
          routes: ClientVpnRouteSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnRoutesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('routes', ClientVpnRouteSet.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ClientVpnRouteSet
    class ClientVpnRouteSet
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnRouteSet')
        visited = visited + ['ClientVpnRouteSet']
        [
          ClientVpnRoute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClientVpnRoute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ClientVpnRoute
    class ClientVpnRoute
      def self.default(visited=[])
        return nil if visited.include?('ClientVpnRoute')
        visited = visited + ['ClientVpnRoute']
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          destination_cidr: 'destination_cidr',
          target_subnet: 'target_subnet',
          type: 'type',
          origin: 'origin',
          status: ClientVpnRouteStatus.default(visited),
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('destinationCidr', stub[:destination_cidr].to_s) unless stub[:destination_cidr].nil?
        xml << Hearth::XML::Node.new('targetSubnet', stub[:target_subnet].to_s) unless stub[:target_subnet].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('origin', stub[:origin].to_s) unless stub[:origin].nil?
        xml << ClientVpnRouteStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    # Operation Stubber for DescribeClientVpnTargetNetworks
    class DescribeClientVpnTargetNetworks
      def self.default(visited=[])
        {
          client_vpn_target_networks: TargetNetworkSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnTargetNetworksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientVpnTargetNetworks', TargetNetworkSet.stub('item', stub[:client_vpn_target_networks])) unless stub[:client_vpn_target_networks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TargetNetworkSet
    class TargetNetworkSet
      def self.default(visited=[])
        return nil if visited.include?('TargetNetworkSet')
        visited = visited + ['TargetNetworkSet']
        [
          TargetNetwork.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TargetNetwork.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TargetNetwork
    class TargetNetwork
      def self.default(visited=[])
        return nil if visited.include?('TargetNetwork')
        visited = visited + ['TargetNetwork']
        {
          association_id: 'association_id',
          vpc_id: 'vpc_id',
          target_network_id: 'target_network_id',
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          status: AssociationStatus.default(visited),
          security_groups: ValueStringList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('targetNetworkId', stub[:target_network_id].to_s) unless stub[:target_network_id].nil?
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << AssociationStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('securityGroups', ValueStringList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml
      end
    end

    # Operation Stubber for DescribeCoipPools
    class DescribeCoipPools
      def self.default(visited=[])
        {
          coip_pools: CoipPoolSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCoipPoolsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('coipPoolSet', CoipPoolSet.stub('item', stub[:coip_pools])) unless stub[:coip_pools].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CoipPoolSet
    class CoipPoolSet
      def self.default(visited=[])
        return nil if visited.include?('CoipPoolSet')
        visited = visited + ['CoipPoolSet']
        [
          CoipPool.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CoipPool.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CoipPool
    class CoipPool
      def self.default(visited=[])
        return nil if visited.include?('CoipPool')
        visited = visited + ['CoipPool']
        {
          pool_id: 'pool_id',
          pool_cidrs: ValueStringList.default(visited),
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          tags: TagList.default(visited),
          pool_arn: 'pool_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << Hearth::XML::Node.new('poolCidrSet', ValueStringList.stub('item', stub[:pool_cidrs])) unless stub[:pool_cidrs].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('poolArn', stub[:pool_arn].to_s) unless stub[:pool_arn].nil?
        xml
      end
    end

    # Operation Stubber for DescribeConversionTasks
    class DescribeConversionTasks
      def self.default(visited=[])
        {
          conversion_tasks: DescribeConversionTaskList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeConversionTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('conversionTasks', DescribeConversionTaskList.stub('item', stub[:conversion_tasks])) unless stub[:conversion_tasks].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for DescribeConversionTaskList
    class DescribeConversionTaskList
      def self.default(visited=[])
        return nil if visited.include?('DescribeConversionTaskList')
        visited = visited + ['DescribeConversionTaskList']
        [
          ConversionTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ConversionTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ConversionTask
    class ConversionTask
      def self.default(visited=[])
        return nil if visited.include?('ConversionTask')
        visited = visited + ['ConversionTask']
        {
          conversion_task_id: 'conversion_task_id',
          expiration_time: 'expiration_time',
          import_instance: ImportInstanceTaskDetails.default(visited),
          import_volume: ImportVolumeTaskDetails.default(visited),
          state: 'state',
          status_message: 'status_message',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('conversionTaskId', stub[:conversion_task_id].to_s) unless stub[:conversion_task_id].nil?
        xml << Hearth::XML::Node.new('expirationTime', stub[:expiration_time].to_s) unless stub[:expiration_time].nil?
        xml << ImportInstanceTaskDetails.stub('importInstance', stub[:import_instance]) unless stub[:import_instance].nil?
        xml << ImportVolumeTaskDetails.stub('importVolume', stub[:import_volume]) unless stub[:import_volume].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for ImportVolumeTaskDetails
    class ImportVolumeTaskDetails
      def self.default(visited=[])
        return nil if visited.include?('ImportVolumeTaskDetails')
        visited = visited + ['ImportVolumeTaskDetails']
        {
          availability_zone: 'availability_zone',
          bytes_converted: 1,
          description: 'description',
          image: DiskImageDescription.default(visited),
          volume: DiskImageVolumeDescription.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('bytesConverted', stub[:bytes_converted].to_s) unless stub[:bytes_converted].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << DiskImageDescription.stub('image', stub[:image]) unless stub[:image].nil?
        xml << DiskImageVolumeDescription.stub('volume', stub[:volume]) unless stub[:volume].nil?
        xml
      end
    end

    # Structure Stubber for DiskImageVolumeDescription
    class DiskImageVolumeDescription
      def self.default(visited=[])
        return nil if visited.include?('DiskImageVolumeDescription')
        visited = visited + ['DiskImageVolumeDescription']
        {
          id: 'id',
          size: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('id', stub[:id].to_s) unless stub[:id].nil?
        xml << Hearth::XML::Node.new('size', stub[:size].to_s) unless stub[:size].nil?
        xml
      end
    end

    # Structure Stubber for DiskImageDescription
    class DiskImageDescription
      def self.default(visited=[])
        return nil if visited.include?('DiskImageDescription')
        visited = visited + ['DiskImageDescription']
        {
          checksum: 'checksum',
          format: 'format',
          import_manifest_url: 'import_manifest_url',
          size: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('checksum', stub[:checksum].to_s) unless stub[:checksum].nil?
        xml << Hearth::XML::Node.new('format', stub[:format].to_s) unless stub[:format].nil?
        xml << Hearth::XML::Node.new('importManifestUrl', stub[:import_manifest_url].to_s) unless stub[:import_manifest_url].nil?
        xml << Hearth::XML::Node.new('size', stub[:size].to_s) unless stub[:size].nil?
        xml
      end
    end

    # Structure Stubber for ImportInstanceTaskDetails
    class ImportInstanceTaskDetails
      def self.default(visited=[])
        return nil if visited.include?('ImportInstanceTaskDetails')
        visited = visited + ['ImportInstanceTaskDetails']
        {
          description: 'description',
          instance_id: 'instance_id',
          platform: 'platform',
          volumes: ImportInstanceVolumeDetailSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('volumes', ImportInstanceVolumeDetailSet.stub('item', stub[:volumes])) unless stub[:volumes].nil?
        xml
      end
    end

    # List Stubber for ImportInstanceVolumeDetailSet
    class ImportInstanceVolumeDetailSet
      def self.default(visited=[])
        return nil if visited.include?('ImportInstanceVolumeDetailSet')
        visited = visited + ['ImportInstanceVolumeDetailSet']
        [
          ImportInstanceVolumeDetailItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImportInstanceVolumeDetailItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ImportInstanceVolumeDetailItem
    class ImportInstanceVolumeDetailItem
      def self.default(visited=[])
        return nil if visited.include?('ImportInstanceVolumeDetailItem')
        visited = visited + ['ImportInstanceVolumeDetailItem']
        {
          availability_zone: 'availability_zone',
          bytes_converted: 1,
          description: 'description',
          image: DiskImageDescription.default(visited),
          status: 'status',
          status_message: 'status_message',
          volume: DiskImageVolumeDescription.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('bytesConverted', stub[:bytes_converted].to_s) unless stub[:bytes_converted].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << DiskImageDescription.stub('image', stub[:image]) unless stub[:image].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << DiskImageVolumeDescription.stub('volume', stub[:volume]) unless stub[:volume].nil?
        xml
      end
    end

    # Operation Stubber for DescribeCustomerGateways
    class DescribeCustomerGateways
      def self.default(visited=[])
        {
          customer_gateways: CustomerGatewayList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCustomerGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('customerGatewaySet', CustomerGatewayList.stub('item', stub[:customer_gateways])) unless stub[:customer_gateways].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CustomerGatewayList
    class CustomerGatewayList
      def self.default(visited=[])
        return nil if visited.include?('CustomerGatewayList')
        visited = visited + ['CustomerGatewayList']
        [
          CustomerGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CustomerGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeDhcpOptions
    class DescribeDhcpOptions
      def self.default(visited=[])
        {
          dhcp_options: DhcpOptionsList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeDhcpOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('dhcpOptionsSet', DhcpOptionsList.stub('item', stub[:dhcp_options])) unless stub[:dhcp_options].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for DhcpOptionsList
    class DhcpOptionsList
      def self.default(visited=[])
        return nil if visited.include?('DhcpOptionsList')
        visited = visited + ['DhcpOptionsList']
        [
          DhcpOptions.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DhcpOptions.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeEgressOnlyInternetGateways
    class DescribeEgressOnlyInternetGateways
      def self.default(visited=[])
        {
          egress_only_internet_gateways: EgressOnlyInternetGatewayList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeEgressOnlyInternetGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('egressOnlyInternetGatewaySet', EgressOnlyInternetGatewayList.stub('item', stub[:egress_only_internet_gateways])) unless stub[:egress_only_internet_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for EgressOnlyInternetGatewayList
    class EgressOnlyInternetGatewayList
      def self.default(visited=[])
        return nil if visited.include?('EgressOnlyInternetGatewayList')
        visited = visited + ['EgressOnlyInternetGatewayList']
        [
          EgressOnlyInternetGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << EgressOnlyInternetGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeElasticGpus
    class DescribeElasticGpus
      def self.default(visited=[])
        {
          elastic_gpu_set: ElasticGpuSet.default(visited),
          max_results: 1,
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeElasticGpusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('elasticGpuSet', ElasticGpuSet.stub('item', stub[:elastic_gpu_set])) unless stub[:elastic_gpu_set].nil?
        xml << Hearth::XML::Node.new('maxResults', stub[:max_results].to_s) unless stub[:max_results].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ElasticGpuSet
    class ElasticGpuSet
      def self.default(visited=[])
        return nil if visited.include?('ElasticGpuSet')
        visited = visited + ['ElasticGpuSet']
        [
          ElasticGpus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ElasticGpus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ElasticGpus
    class ElasticGpus
      def self.default(visited=[])
        return nil if visited.include?('ElasticGpus')
        visited = visited + ['ElasticGpus']
        {
          elastic_gpu_id: 'elastic_gpu_id',
          availability_zone: 'availability_zone',
          elastic_gpu_type: 'elastic_gpu_type',
          elastic_gpu_health: ElasticGpuHealth.default(visited),
          elastic_gpu_state: 'elastic_gpu_state',
          instance_id: 'instance_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('elasticGpuId', stub[:elastic_gpu_id].to_s) unless stub[:elastic_gpu_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('elasticGpuType', stub[:elastic_gpu_type].to_s) unless stub[:elastic_gpu_type].nil?
        xml << ElasticGpuHealth.stub('elasticGpuHealth', stub[:elastic_gpu_health]) unless stub[:elastic_gpu_health].nil?
        xml << Hearth::XML::Node.new('elasticGpuState', stub[:elastic_gpu_state].to_s) unless stub[:elastic_gpu_state].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for ElasticGpuHealth
    class ElasticGpuHealth
      def self.default(visited=[])
        return nil if visited.include?('ElasticGpuHealth')
        visited = visited + ['ElasticGpuHealth']
        {
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    # Operation Stubber for DescribeExportImageTasks
    class DescribeExportImageTasks
      def self.default(visited=[])
        {
          export_image_tasks: ExportImageTaskList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeExportImageTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('exportImageTaskSet', ExportImageTaskList.stub('item', stub[:export_image_tasks])) unless stub[:export_image_tasks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ExportImageTaskList
    class ExportImageTaskList
      def self.default(visited=[])
        return nil if visited.include?('ExportImageTaskList')
        visited = visited + ['ExportImageTaskList']
        [
          ExportImageTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ExportImageTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ExportImageTask
    class ExportImageTask
      def self.default(visited=[])
        return nil if visited.include?('ExportImageTask')
        visited = visited + ['ExportImageTask']
        {
          description: 'description',
          export_image_task_id: 'export_image_task_id',
          image_id: 'image_id',
          progress: 'progress',
          s3_export_location: ExportTaskS3Location.default(visited),
          status: 'status',
          status_message: 'status_message',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('exportImageTaskId', stub[:export_image_task_id].to_s) unless stub[:export_image_task_id].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << ExportTaskS3Location.stub('s3ExportLocation', stub[:s3_export_location]) unless stub[:s3_export_location].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for ExportTaskS3Location
    class ExportTaskS3Location
      def self.default(visited=[])
        return nil if visited.include?('ExportTaskS3Location')
        visited = visited + ['ExportTaskS3Location']
        {
          s3_bucket: 's3_bucket',
          s3_prefix: 's3_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('s3Bucket', stub[:s3_bucket].to_s) unless stub[:s3_bucket].nil?
        xml << Hearth::XML::Node.new('s3Prefix', stub[:s3_prefix].to_s) unless stub[:s3_prefix].nil?
        xml
      end
    end

    # Operation Stubber for DescribeExportTasks
    class DescribeExportTasks
      def self.default(visited=[])
        {
          export_tasks: ExportTaskList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeExportTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('exportTaskSet', ExportTaskList.stub('item', stub[:export_tasks])) unless stub[:export_tasks].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ExportTaskList
    class ExportTaskList
      def self.default(visited=[])
        return nil if visited.include?('ExportTaskList')
        visited = visited + ['ExportTaskList']
        [
          ExportTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ExportTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeFastLaunchImages
    class DescribeFastLaunchImages
      def self.default(visited=[])
        {
          fast_launch_images: DescribeFastLaunchImagesSuccessSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFastLaunchImagesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fastLaunchImageSet', DescribeFastLaunchImagesSuccessSet.stub('item', stub[:fast_launch_images])) unless stub[:fast_launch_images].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for DescribeFastLaunchImagesSuccessSet
    class DescribeFastLaunchImagesSuccessSet
      def self.default(visited=[])
        return nil if visited.include?('DescribeFastLaunchImagesSuccessSet')
        visited = visited + ['DescribeFastLaunchImagesSuccessSet']
        [
          DescribeFastLaunchImagesSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DescribeFastLaunchImagesSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DescribeFastLaunchImagesSuccessItem
    class DescribeFastLaunchImagesSuccessItem
      def self.default(visited=[])
        return nil if visited.include?('DescribeFastLaunchImagesSuccessItem')
        visited = visited + ['DescribeFastLaunchImagesSuccessItem']
        {
          image_id: 'image_id',
          resource_type: 'resource_type',
          snapshot_configuration: FastLaunchSnapshotConfigurationResponse.default(visited),
          launch_template: FastLaunchLaunchTemplateSpecificationResponse.default(visited),
          max_parallel_launches: 1,
          owner_id: 'owner_id',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          state_transition_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << FastLaunchSnapshotConfigurationResponse.stub('snapshotConfiguration', stub[:snapshot_configuration]) unless stub[:snapshot_configuration].nil?
        xml << FastLaunchLaunchTemplateSpecificationResponse.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        xml << Hearth::XML::Node.new('maxParallelLaunches', stub[:max_parallel_launches].to_s) unless stub[:max_parallel_launches].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('stateTransitionTime', Hearth::TimeHelper.to_date_time(stub[:state_transition_time])) unless stub[:state_transition_time].nil?
        xml
      end
    end

    # Structure Stubber for FastLaunchLaunchTemplateSpecificationResponse
    class FastLaunchLaunchTemplateSpecificationResponse
      def self.default(visited=[])
        return nil if visited.include?('FastLaunchLaunchTemplateSpecificationResponse')
        visited = visited + ['FastLaunchLaunchTemplateSpecificationResponse']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version: 'version',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('version', stub[:version].to_s) unless stub[:version].nil?
        xml
      end
    end

    # Structure Stubber for FastLaunchSnapshotConfigurationResponse
    class FastLaunchSnapshotConfigurationResponse
      def self.default(visited=[])
        return nil if visited.include?('FastLaunchSnapshotConfigurationResponse')
        visited = visited + ['FastLaunchSnapshotConfigurationResponse']
        {
          target_resource_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('targetResourceCount', stub[:target_resource_count].to_s) unless stub[:target_resource_count].nil?
        xml
      end
    end

    # Operation Stubber for DescribeFastSnapshotRestores
    class DescribeFastSnapshotRestores
      def self.default(visited=[])
        {
          fast_snapshot_restores: DescribeFastSnapshotRestoreSuccessSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFastSnapshotRestoresResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fastSnapshotRestoreSet', DescribeFastSnapshotRestoreSuccessSet.stub('item', stub[:fast_snapshot_restores])) unless stub[:fast_snapshot_restores].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for DescribeFastSnapshotRestoreSuccessSet
    class DescribeFastSnapshotRestoreSuccessSet
      def self.default(visited=[])
        return nil if visited.include?('DescribeFastSnapshotRestoreSuccessSet')
        visited = visited + ['DescribeFastSnapshotRestoreSuccessSet']
        [
          DescribeFastSnapshotRestoreSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DescribeFastSnapshotRestoreSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DescribeFastSnapshotRestoreSuccessItem
    class DescribeFastSnapshotRestoreSuccessItem
      def self.default(visited=[])
        return nil if visited.include?('DescribeFastSnapshotRestoreSuccessItem')
        visited = visited + ['DescribeFastSnapshotRestoreSuccessItem']
        {
          snapshot_id: 'snapshot_id',
          availability_zone: 'availability_zone',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          owner_id: 'owner_id',
          owner_alias: 'owner_alias',
          enabling_time: Time.now,
          optimizing_time: Time.now,
          enabled_time: Time.now,
          disabling_time: Time.now,
          disabled_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('enablingTime', Hearth::TimeHelper.to_date_time(stub[:enabling_time])) unless stub[:enabling_time].nil?
        xml << Hearth::XML::Node.new('optimizingTime', Hearth::TimeHelper.to_date_time(stub[:optimizing_time])) unless stub[:optimizing_time].nil?
        xml << Hearth::XML::Node.new('enabledTime', Hearth::TimeHelper.to_date_time(stub[:enabled_time])) unless stub[:enabled_time].nil?
        xml << Hearth::XML::Node.new('disablingTime', Hearth::TimeHelper.to_date_time(stub[:disabling_time])) unless stub[:disabling_time].nil?
        xml << Hearth::XML::Node.new('disabledTime', Hearth::TimeHelper.to_date_time(stub[:disabled_time])) unless stub[:disabled_time].nil?
        xml
      end
    end

    # Operation Stubber for DescribeFleetHistory
    class DescribeFleetHistory
      def self.default(visited=[])
        {
          history_records: HistoryRecordSet.default(visited),
          last_evaluated_time: Time.now,
          next_token: 'next_token',
          fleet_id: 'fleet_id',
          start_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFleetHistoryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('historyRecordSet', HistoryRecordSet.stub('item', stub[:history_records])) unless stub[:history_records].nil?
        xml << Hearth::XML::Node.new('lastEvaluatedTime', Hearth::TimeHelper.to_date_time(stub[:last_evaluated_time])) unless stub[:last_evaluated_time].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for HistoryRecordSet
    class HistoryRecordSet
      def self.default(visited=[])
        return nil if visited.include?('HistoryRecordSet')
        visited = visited + ['HistoryRecordSet']
        [
          HistoryRecordEntry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HistoryRecordEntry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for HistoryRecordEntry
    class HistoryRecordEntry
      def self.default(visited=[])
        return nil if visited.include?('HistoryRecordEntry')
        visited = visited + ['HistoryRecordEntry']
        {
          event_information: EventInformation.default(visited),
          event_type: 'event_type',
          timestamp: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << EventInformation.stub('eventInformation', stub[:event_information]) unless stub[:event_information].nil?
        xml << Hearth::XML::Node.new('eventType', stub[:event_type].to_s) unless stub[:event_type].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        xml
      end
    end

    # Structure Stubber for EventInformation
    class EventInformation
      def self.default(visited=[])
        return nil if visited.include?('EventInformation')
        visited = visited + ['EventInformation']
        {
          event_description: 'event_description',
          event_sub_type: 'event_sub_type',
          instance_id: 'instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('eventDescription', stub[:event_description].to_s) unless stub[:event_description].nil?
        xml << Hearth::XML::Node.new('eventSubType', stub[:event_sub_type].to_s) unless stub[:event_sub_type].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml
      end
    end

    # Operation Stubber for DescribeFleetInstances
    class DescribeFleetInstances
      def self.default(visited=[])
        {
          active_instances: ActiveInstanceSet.default(visited),
          next_token: 'next_token',
          fleet_id: 'fleet_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFleetInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('activeInstanceSet', ActiveInstanceSet.stub('item', stub[:active_instances])) unless stub[:active_instances].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ActiveInstanceSet
    class ActiveInstanceSet
      def self.default(visited=[])
        return nil if visited.include?('ActiveInstanceSet')
        visited = visited + ['ActiveInstanceSet']
        [
          ActiveInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ActiveInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ActiveInstance
    class ActiveInstance
      def self.default(visited=[])
        return nil if visited.include?('ActiveInstance')
        visited = visited + ['ActiveInstance']
        {
          instance_id: 'instance_id',
          instance_type: 'instance_type',
          spot_instance_request_id: 'spot_instance_request_id',
          instance_health: 'instance_health',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('spotInstanceRequestId', stub[:spot_instance_request_id].to_s) unless stub[:spot_instance_request_id].nil?
        xml << Hearth::XML::Node.new('instanceHealth', stub[:instance_health].to_s) unless stub[:instance_health].nil?
        xml
      end
    end

    # Operation Stubber for DescribeFleets
    class DescribeFleets
      def self.default(visited=[])
        {
          next_token: 'next_token',
          fleets: FleetSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFleetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('fleetSet', FleetSet.stub('item', stub[:fleets])) unless stub[:fleets].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for FleetSet
    class FleetSet
      def self.default(visited=[])
        return nil if visited.include?('FleetSet')
        visited = visited + ['FleetSet']
        [
          FleetData.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FleetData.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for FleetData
    class FleetData
      def self.default(visited=[])
        return nil if visited.include?('FleetData')
        visited = visited + ['FleetData']
        {
          activity_status: 'activity_status',
          create_time: Time.now,
          fleet_id: 'fleet_id',
          fleet_state: 'fleet_state',
          client_token: 'client_token',
          excess_capacity_termination_policy: 'excess_capacity_termination_policy',
          fulfilled_capacity: 1.0,
          fulfilled_on_demand_capacity: 1.0,
          launch_template_configs: FleetLaunchTemplateConfigList.default(visited),
          target_capacity_specification: TargetCapacitySpecification.default(visited),
          terminate_instances_with_expiration: false,
          type: 'type',
          valid_from: Time.now,
          valid_until: Time.now,
          replace_unhealthy_instances: false,
          spot_options: SpotOptions.default(visited),
          on_demand_options: OnDemandOptions.default(visited),
          tags: TagList.default(visited),
          errors: DescribeFleetsErrorSet.default(visited),
          instances: DescribeFleetsInstancesSet.default(visited),
          context: 'context',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('activityStatus', stub[:activity_status].to_s) unless stub[:activity_status].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml << Hearth::XML::Node.new('fleetState', stub[:fleet_state].to_s) unless stub[:fleet_state].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('excessCapacityTerminationPolicy', stub[:excess_capacity_termination_policy].to_s) unless stub[:excess_capacity_termination_policy].nil?
        xml << Hearth::XML::Node.new('fulfilledCapacity', Hearth::NumberHelper.serialize(stub[:fulfilled_capacity]).to_s) unless stub[:fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('fulfilledOnDemandCapacity', Hearth::NumberHelper.serialize(stub[:fulfilled_on_demand_capacity]).to_s) unless stub[:fulfilled_on_demand_capacity].nil?
        xml << Hearth::XML::Node.new('launchTemplateConfigs', FleetLaunchTemplateConfigList.stub('item', stub[:launch_template_configs])) unless stub[:launch_template_configs].nil?
        xml << TargetCapacitySpecification.stub('targetCapacitySpecification', stub[:target_capacity_specification]) unless stub[:target_capacity_specification].nil?
        xml << Hearth::XML::Node.new('terminateInstancesWithExpiration', stub[:terminate_instances_with_expiration].to_s) unless stub[:terminate_instances_with_expiration].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('validFrom', Hearth::TimeHelper.to_date_time(stub[:valid_from])) unless stub[:valid_from].nil?
        xml << Hearth::XML::Node.new('validUntil', Hearth::TimeHelper.to_date_time(stub[:valid_until])) unless stub[:valid_until].nil?
        xml << Hearth::XML::Node.new('replaceUnhealthyInstances', stub[:replace_unhealthy_instances].to_s) unless stub[:replace_unhealthy_instances].nil?
        xml << SpotOptions.stub('spotOptions', stub[:spot_options]) unless stub[:spot_options].nil?
        xml << OnDemandOptions.stub('onDemandOptions', stub[:on_demand_options]) unless stub[:on_demand_options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('errorSet', DescribeFleetsErrorSet.stub('item', stub[:errors])) unless stub[:errors].nil?
        xml << Hearth::XML::Node.new('fleetInstanceSet', DescribeFleetsInstancesSet.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('context', stub[:context].to_s) unless stub[:context].nil?
        xml
      end
    end

    # List Stubber for DescribeFleetsInstancesSet
    class DescribeFleetsInstancesSet
      def self.default(visited=[])
        return nil if visited.include?('DescribeFleetsInstancesSet')
        visited = visited + ['DescribeFleetsInstancesSet']
        [
          DescribeFleetsInstances.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DescribeFleetsInstances.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DescribeFleetsInstances
    class DescribeFleetsInstances
      def self.default(visited=[])
        return nil if visited.include?('DescribeFleetsInstances')
        visited = visited + ['DescribeFleetsInstances']
        {
          launch_template_and_overrides: LaunchTemplateAndOverridesResponse.default(visited),
          lifecycle: 'lifecycle',
          instance_ids: InstanceIdsSet.default(visited),
          instance_type: 'instance_type',
          platform: 'platform',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << LaunchTemplateAndOverridesResponse.stub('launchTemplateAndOverrides', stub[:launch_template_and_overrides]) unless stub[:launch_template_and_overrides].nil?
        xml << Hearth::XML::Node.new('lifecycle', stub[:lifecycle].to_s) unless stub[:lifecycle].nil?
        xml << Hearth::XML::Node.new('instanceIds', InstanceIdsSet.stub('item', stub[:instance_ids])) unless stub[:instance_ids].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml
      end
    end

    # List Stubber for DescribeFleetsErrorSet
    class DescribeFleetsErrorSet
      def self.default(visited=[])
        return nil if visited.include?('DescribeFleetsErrorSet')
        visited = visited + ['DescribeFleetsErrorSet']
        [
          DescribeFleetError.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DescribeFleetError.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DescribeFleetError
    class DescribeFleetError
      def self.default(visited=[])
        return nil if visited.include?('DescribeFleetError')
        visited = visited + ['DescribeFleetError']
        {
          launch_template_and_overrides: LaunchTemplateAndOverridesResponse.default(visited),
          lifecycle: 'lifecycle',
          error_code: 'error_code',
          error_message: 'error_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << LaunchTemplateAndOverridesResponse.stub('launchTemplateAndOverrides', stub[:launch_template_and_overrides]) unless stub[:launch_template_and_overrides].nil?
        xml << Hearth::XML::Node.new('lifecycle', stub[:lifecycle].to_s) unless stub[:lifecycle].nil?
        xml << Hearth::XML::Node.new('errorCode', stub[:error_code].to_s) unless stub[:error_code].nil?
        xml << Hearth::XML::Node.new('errorMessage', stub[:error_message].to_s) unless stub[:error_message].nil?
        xml
      end
    end

    # Structure Stubber for OnDemandOptions
    class OnDemandOptions
      def self.default(visited=[])
        return nil if visited.include?('OnDemandOptions')
        visited = visited + ['OnDemandOptions']
        {
          allocation_strategy: 'allocation_strategy',
          capacity_reservation_options: CapacityReservationOptions.default(visited),
          single_instance_type: false,
          single_availability_zone: false,
          min_target_capacity: 1,
          max_total_price: 'max_total_price',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << CapacityReservationOptions.stub('capacityReservationOptions', stub[:capacity_reservation_options]) unless stub[:capacity_reservation_options].nil?
        xml << Hearth::XML::Node.new('singleInstanceType', stub[:single_instance_type].to_s) unless stub[:single_instance_type].nil?
        xml << Hearth::XML::Node.new('singleAvailabilityZone', stub[:single_availability_zone].to_s) unless stub[:single_availability_zone].nil?
        xml << Hearth::XML::Node.new('minTargetCapacity', stub[:min_target_capacity].to_s) unless stub[:min_target_capacity].nil?
        xml << Hearth::XML::Node.new('maxTotalPrice', stub[:max_total_price].to_s) unless stub[:max_total_price].nil?
        xml
      end
    end

    # Structure Stubber for CapacityReservationOptions
    class CapacityReservationOptions
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationOptions')
        visited = visited + ['CapacityReservationOptions']
        {
          usage_strategy: 'usage_strategy',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('usageStrategy', stub[:usage_strategy].to_s) unless stub[:usage_strategy].nil?
        xml
      end
    end

    # Structure Stubber for SpotOptions
    class SpotOptions
      def self.default(visited=[])
        return nil if visited.include?('SpotOptions')
        visited = visited + ['SpotOptions']
        {
          allocation_strategy: 'allocation_strategy',
          maintenance_strategies: FleetSpotMaintenanceStrategies.default(visited),
          instance_interruption_behavior: 'instance_interruption_behavior',
          instance_pools_to_use_count: 1,
          single_instance_type: false,
          single_availability_zone: false,
          min_target_capacity: 1,
          max_total_price: 'max_total_price',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << FleetSpotMaintenanceStrategies.stub('maintenanceStrategies', stub[:maintenance_strategies]) unless stub[:maintenance_strategies].nil?
        xml << Hearth::XML::Node.new('instanceInterruptionBehavior', stub[:instance_interruption_behavior].to_s) unless stub[:instance_interruption_behavior].nil?
        xml << Hearth::XML::Node.new('instancePoolsToUseCount', stub[:instance_pools_to_use_count].to_s) unless stub[:instance_pools_to_use_count].nil?
        xml << Hearth::XML::Node.new('singleInstanceType', stub[:single_instance_type].to_s) unless stub[:single_instance_type].nil?
        xml << Hearth::XML::Node.new('singleAvailabilityZone', stub[:single_availability_zone].to_s) unless stub[:single_availability_zone].nil?
        xml << Hearth::XML::Node.new('minTargetCapacity', stub[:min_target_capacity].to_s) unless stub[:min_target_capacity].nil?
        xml << Hearth::XML::Node.new('maxTotalPrice', stub[:max_total_price].to_s) unless stub[:max_total_price].nil?
        xml
      end
    end

    # Structure Stubber for FleetSpotMaintenanceStrategies
    class FleetSpotMaintenanceStrategies
      def self.default(visited=[])
        return nil if visited.include?('FleetSpotMaintenanceStrategies')
        visited = visited + ['FleetSpotMaintenanceStrategies']
        {
          capacity_rebalance: FleetSpotCapacityRebalance.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << FleetSpotCapacityRebalance.stub('capacityRebalance', stub[:capacity_rebalance]) unless stub[:capacity_rebalance].nil?
        xml
      end
    end

    # Structure Stubber for FleetSpotCapacityRebalance
    class FleetSpotCapacityRebalance
      def self.default(visited=[])
        return nil if visited.include?('FleetSpotCapacityRebalance')
        visited = visited + ['FleetSpotCapacityRebalance']
        {
          replacement_strategy: 'replacement_strategy',
          termination_delay: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('replacementStrategy', stub[:replacement_strategy].to_s) unless stub[:replacement_strategy].nil?
        xml << Hearth::XML::Node.new('terminationDelay', stub[:termination_delay].to_s) unless stub[:termination_delay].nil?
        xml
      end
    end

    # Structure Stubber for TargetCapacitySpecification
    class TargetCapacitySpecification
      def self.default(visited=[])
        return nil if visited.include?('TargetCapacitySpecification')
        visited = visited + ['TargetCapacitySpecification']
        {
          total_target_capacity: 1,
          on_demand_target_capacity: 1,
          spot_target_capacity: 1,
          default_target_capacity_type: 'default_target_capacity_type',
          target_capacity_unit_type: 'target_capacity_unit_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('totalTargetCapacity', stub[:total_target_capacity].to_s) unless stub[:total_target_capacity].nil?
        xml << Hearth::XML::Node.new('onDemandTargetCapacity', stub[:on_demand_target_capacity].to_s) unless stub[:on_demand_target_capacity].nil?
        xml << Hearth::XML::Node.new('spotTargetCapacity', stub[:spot_target_capacity].to_s) unless stub[:spot_target_capacity].nil?
        xml << Hearth::XML::Node.new('defaultTargetCapacityType', stub[:default_target_capacity_type].to_s) unless stub[:default_target_capacity_type].nil?
        xml << Hearth::XML::Node.new('targetCapacityUnitType', stub[:target_capacity_unit_type].to_s) unless stub[:target_capacity_unit_type].nil?
        xml
      end
    end

    # List Stubber for FleetLaunchTemplateConfigList
    class FleetLaunchTemplateConfigList
      def self.default(visited=[])
        return nil if visited.include?('FleetLaunchTemplateConfigList')
        visited = visited + ['FleetLaunchTemplateConfigList']
        [
          FleetLaunchTemplateConfig.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FleetLaunchTemplateConfig.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for FleetLaunchTemplateConfig
    class FleetLaunchTemplateConfig
      def self.default(visited=[])
        return nil if visited.include?('FleetLaunchTemplateConfig')
        visited = visited + ['FleetLaunchTemplateConfig']
        {
          launch_template_specification: FleetLaunchTemplateSpecification.default(visited),
          overrides: FleetLaunchTemplateOverridesList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << FleetLaunchTemplateSpecification.stub('launchTemplateSpecification', stub[:launch_template_specification]) unless stub[:launch_template_specification].nil?
        xml << Hearth::XML::Node.new('overrides', FleetLaunchTemplateOverridesList.stub('item', stub[:overrides])) unless stub[:overrides].nil?
        xml
      end
    end

    # List Stubber for FleetLaunchTemplateOverridesList
    class FleetLaunchTemplateOverridesList
      def self.default(visited=[])
        return nil if visited.include?('FleetLaunchTemplateOverridesList')
        visited = visited + ['FleetLaunchTemplateOverridesList']
        [
          FleetLaunchTemplateOverrides.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FleetLaunchTemplateOverrides.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeFlowLogs
    class DescribeFlowLogs
      def self.default(visited=[])
        {
          flow_logs: FlowLogSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFlowLogsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('flowLogSet', FlowLogSet.stub('item', stub[:flow_logs])) unless stub[:flow_logs].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for FlowLogSet
    class FlowLogSet
      def self.default(visited=[])
        return nil if visited.include?('FlowLogSet')
        visited = visited + ['FlowLogSet']
        [
          FlowLog.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FlowLog.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for FlowLog
    class FlowLog
      def self.default(visited=[])
        return nil if visited.include?('FlowLog')
        visited = visited + ['FlowLog']
        {
          creation_time: Time.now,
          deliver_logs_error_message: 'deliver_logs_error_message',
          deliver_logs_permission_arn: 'deliver_logs_permission_arn',
          deliver_logs_status: 'deliver_logs_status',
          flow_log_id: 'flow_log_id',
          flow_log_status: 'flow_log_status',
          log_group_name: 'log_group_name',
          resource_id: 'resource_id',
          traffic_type: 'traffic_type',
          log_destination_type: 'log_destination_type',
          log_destination: 'log_destination',
          log_format: 'log_format',
          tags: TagList.default(visited),
          max_aggregation_interval: 1,
          destination_options: DestinationOptionsResponse.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('deliverLogsErrorMessage', stub[:deliver_logs_error_message].to_s) unless stub[:deliver_logs_error_message].nil?
        xml << Hearth::XML::Node.new('deliverLogsPermissionArn', stub[:deliver_logs_permission_arn].to_s) unless stub[:deliver_logs_permission_arn].nil?
        xml << Hearth::XML::Node.new('deliverLogsStatus', stub[:deliver_logs_status].to_s) unless stub[:deliver_logs_status].nil?
        xml << Hearth::XML::Node.new('flowLogId', stub[:flow_log_id].to_s) unless stub[:flow_log_id].nil?
        xml << Hearth::XML::Node.new('flowLogStatus', stub[:flow_log_status].to_s) unless stub[:flow_log_status].nil?
        xml << Hearth::XML::Node.new('logGroupName', stub[:log_group_name].to_s) unless stub[:log_group_name].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('trafficType', stub[:traffic_type].to_s) unless stub[:traffic_type].nil?
        xml << Hearth::XML::Node.new('logDestinationType', stub[:log_destination_type].to_s) unless stub[:log_destination_type].nil?
        xml << Hearth::XML::Node.new('logDestination', stub[:log_destination].to_s) unless stub[:log_destination].nil?
        xml << Hearth::XML::Node.new('logFormat', stub[:log_format].to_s) unless stub[:log_format].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('maxAggregationInterval', stub[:max_aggregation_interval].to_s) unless stub[:max_aggregation_interval].nil?
        xml << DestinationOptionsResponse.stub('destinationOptions', stub[:destination_options]) unless stub[:destination_options].nil?
        xml
      end
    end

    # Structure Stubber for DestinationOptionsResponse
    class DestinationOptionsResponse
      def self.default(visited=[])
        return nil if visited.include?('DestinationOptionsResponse')
        visited = visited + ['DestinationOptionsResponse']
        {
          file_format: 'file_format',
          hive_compatible_partitions: false,
          per_hour_partition: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fileFormat', stub[:file_format].to_s) unless stub[:file_format].nil?
        xml << Hearth::XML::Node.new('hiveCompatiblePartitions', stub[:hive_compatible_partitions].to_s) unless stub[:hive_compatible_partitions].nil?
        xml << Hearth::XML::Node.new('perHourPartition', stub[:per_hour_partition].to_s) unless stub[:per_hour_partition].nil?
        xml
      end
    end

    # Operation Stubber for DescribeFpgaImageAttribute
    class DescribeFpgaImageAttribute
      def self.default(visited=[])
        {
          fpga_image_attribute: FpgaImageAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFpgaImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << FpgaImageAttribute.stub('fpgaImageAttribute', stub[:fpga_image_attribute]) unless stub[:fpga_image_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for FpgaImageAttribute
    class FpgaImageAttribute
      def self.default(visited=[])
        return nil if visited.include?('FpgaImageAttribute')
        visited = visited + ['FpgaImageAttribute']
        {
          fpga_image_id: 'fpga_image_id',
          name: 'name',
          description: 'description',
          load_permissions: LoadPermissionList.default(visited),
          product_codes: ProductCodeList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fpgaImageId', stub[:fpga_image_id].to_s) unless stub[:fpga_image_id].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('loadPermissions', LoadPermissionList.stub('item', stub[:load_permissions])) unless stub[:load_permissions].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml
      end
    end

    # List Stubber for ProductCodeList
    class ProductCodeList
      def self.default(visited=[])
        return nil if visited.include?('ProductCodeList')
        visited = visited + ['ProductCodeList']
        [
          ProductCode.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ProductCode.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ProductCode
    class ProductCode
      def self.default(visited=[])
        return nil if visited.include?('ProductCode')
        visited = visited + ['ProductCode']
        {
          product_code_id: 'product_code_id',
          product_code_type: 'product_code_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('productCode', stub[:product_code_id].to_s) unless stub[:product_code_id].nil?
        xml << Hearth::XML::Node.new('type', stub[:product_code_type].to_s) unless stub[:product_code_type].nil?
        xml
      end
    end

    # List Stubber for LoadPermissionList
    class LoadPermissionList
      def self.default(visited=[])
        return nil if visited.include?('LoadPermissionList')
        visited = visited + ['LoadPermissionList']
        [
          LoadPermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LoadPermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LoadPermission
    class LoadPermission
      def self.default(visited=[])
        return nil if visited.include?('LoadPermission')
        visited = visited + ['LoadPermission']
        {
          user_id: 'user_id',
          group: 'group',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml << Hearth::XML::Node.new('group', stub[:group].to_s) unless stub[:group].nil?
        xml
      end
    end

    # Operation Stubber for DescribeFpgaImages
    class DescribeFpgaImages
      def self.default(visited=[])
        {
          fpga_images: FpgaImageList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFpgaImagesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fpgaImageSet', FpgaImageList.stub('item', stub[:fpga_images])) unless stub[:fpga_images].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for FpgaImageList
    class FpgaImageList
      def self.default(visited=[])
        return nil if visited.include?('FpgaImageList')
        visited = visited + ['FpgaImageList']
        [
          FpgaImage.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FpgaImage.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for FpgaImage
    class FpgaImage
      def self.default(visited=[])
        return nil if visited.include?('FpgaImage')
        visited = visited + ['FpgaImage']
        {
          fpga_image_id: 'fpga_image_id',
          fpga_image_global_id: 'fpga_image_global_id',
          name: 'name',
          description: 'description',
          shell_version: 'shell_version',
          pci_id: PciId.default(visited),
          state: FpgaImageState.default(visited),
          create_time: Time.now,
          update_time: Time.now,
          owner_id: 'owner_id',
          owner_alias: 'owner_alias',
          product_codes: ProductCodeList.default(visited),
          tags: TagList.default(visited),
          public: false,
          data_retention_support: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fpgaImageId', stub[:fpga_image_id].to_s) unless stub[:fpga_image_id].nil?
        xml << Hearth::XML::Node.new('fpgaImageGlobalId', stub[:fpga_image_global_id].to_s) unless stub[:fpga_image_global_id].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('shellVersion', stub[:shell_version].to_s) unless stub[:shell_version].nil?
        xml << PciId.stub('pciId', stub[:pci_id]) unless stub[:pci_id].nil?
        xml << FpgaImageState.stub('state', stub[:state]) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('updateTime', Hearth::TimeHelper.to_date_time(stub[:update_time])) unless stub[:update_time].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('tags', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('public', stub[:public].to_s) unless stub[:public].nil?
        xml << Hearth::XML::Node.new('dataRetentionSupport', stub[:data_retention_support].to_s) unless stub[:data_retention_support].nil?
        xml
      end
    end

    # Structure Stubber for FpgaImageState
    class FpgaImageState
      def self.default(visited=[])
        return nil if visited.include?('FpgaImageState')
        visited = visited + ['FpgaImageState']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Structure Stubber for PciId
    class PciId
      def self.default(visited=[])
        return nil if visited.include?('PciId')
        visited = visited + ['PciId']
        {
          device_id: 'device_id',
          vendor_id: 'vendor_id',
          subsystem_id: 'subsystem_id',
          subsystem_vendor_id: 'subsystem_vendor_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('DeviceId', stub[:device_id].to_s) unless stub[:device_id].nil?
        xml << Hearth::XML::Node.new('VendorId', stub[:vendor_id].to_s) unless stub[:vendor_id].nil?
        xml << Hearth::XML::Node.new('SubsystemId', stub[:subsystem_id].to_s) unless stub[:subsystem_id].nil?
        xml << Hearth::XML::Node.new('SubsystemVendorId', stub[:subsystem_vendor_id].to_s) unless stub[:subsystem_vendor_id].nil?
        xml
      end
    end

    # Operation Stubber for DescribeHostReservationOfferings
    class DescribeHostReservationOfferings
      def self.default(visited=[])
        {
          next_token: 'next_token',
          offering_set: HostOfferingSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeHostReservationOfferingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('offeringSet', HostOfferingSet.stub('item', stub[:offering_set])) unless stub[:offering_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for HostOfferingSet
    class HostOfferingSet
      def self.default(visited=[])
        return nil if visited.include?('HostOfferingSet')
        visited = visited + ['HostOfferingSet']
        [
          HostOffering.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HostOffering.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for HostOffering
    class HostOffering
      def self.default(visited=[])
        return nil if visited.include?('HostOffering')
        visited = visited + ['HostOffering']
        {
          currency_code: 'currency_code',
          duration: 1,
          hourly_price: 'hourly_price',
          instance_family: 'instance_family',
          offering_id: 'offering_id',
          payment_option: 'payment_option',
          upfront_price: 'upfront_price',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('offeringId', stub[:offering_id].to_s) unless stub[:offering_id].nil?
        xml << Hearth::XML::Node.new('paymentOption', stub[:payment_option].to_s) unless stub[:payment_option].nil?
        xml << Hearth::XML::Node.new('upfrontPrice', stub[:upfront_price].to_s) unless stub[:upfront_price].nil?
        xml
      end
    end

    # Operation Stubber for DescribeHostReservations
    class DescribeHostReservations
      def self.default(visited=[])
        {
          host_reservation_set: HostReservationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeHostReservationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('hostReservationSet', HostReservationSet.stub('item', stub[:host_reservation_set])) unless stub[:host_reservation_set].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for HostReservationSet
    class HostReservationSet
      def self.default(visited=[])
        return nil if visited.include?('HostReservationSet')
        visited = visited + ['HostReservationSet']
        [
          HostReservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HostReservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for HostReservation
    class HostReservation
      def self.default(visited=[])
        return nil if visited.include?('HostReservation')
        visited = visited + ['HostReservation']
        {
          count: 1,
          currency_code: 'currency_code',
          duration: 1,
          end: Time.now,
          host_id_set: ResponseHostIdSet.default(visited),
          host_reservation_id: 'host_reservation_id',
          hourly_price: 'hourly_price',
          instance_family: 'instance_family',
          offering_id: 'offering_id',
          payment_option: 'payment_option',
          start: Time.now,
          state: 'state',
          upfront_price: 'upfront_price',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('end', Hearth::TimeHelper.to_date_time(stub[:end])) unless stub[:end].nil?
        xml << Hearth::XML::Node.new('hostIdSet', ResponseHostIdSet.stub('item', stub[:host_id_set])) unless stub[:host_id_set].nil?
        xml << Hearth::XML::Node.new('hostReservationId', stub[:host_reservation_id].to_s) unless stub[:host_reservation_id].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('offeringId', stub[:offering_id].to_s) unless stub[:offering_id].nil?
        xml << Hearth::XML::Node.new('paymentOption', stub[:payment_option].to_s) unless stub[:payment_option].nil?
        xml << Hearth::XML::Node.new('start', Hearth::TimeHelper.to_date_time(stub[:start])) unless stub[:start].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('upfrontPrice', stub[:upfront_price].to_s) unless stub[:upfront_price].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for ResponseHostIdSet
    class ResponseHostIdSet
      def self.default(visited=[])
        return nil if visited.include?('ResponseHostIdSet')
        visited = visited + ['ResponseHostIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeHosts
    class DescribeHosts
      def self.default(visited=[])
        {
          hosts: HostList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeHostsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('hostSet', HostList.stub('item', stub[:hosts])) unless stub[:hosts].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for HostList
    class HostList
      def self.default(visited=[])
        return nil if visited.include?('HostList')
        visited = visited + ['HostList']
        [
          Host.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Host.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Host
    class Host
      def self.default(visited=[])
        return nil if visited.include?('Host')
        visited = visited + ['Host']
        {
          auto_placement: 'auto_placement',
          availability_zone: 'availability_zone',
          available_capacity: AvailableCapacity.default(visited),
          client_token: 'client_token',
          host_id: 'host_id',
          host_properties: HostProperties.default(visited),
          host_reservation_id: 'host_reservation_id',
          instances: HostInstanceList.default(visited),
          state: 'state',
          allocation_time: Time.now,
          release_time: Time.now,
          tags: TagList.default(visited),
          host_recovery: 'host_recovery',
          allows_multiple_instance_types: 'allows_multiple_instance_types',
          owner_id: 'owner_id',
          availability_zone_id: 'availability_zone_id',
          member_of_service_linked_resource_group: false,
          outpost_arn: 'outpost_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('autoPlacement', stub[:auto_placement].to_s) unless stub[:auto_placement].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << AvailableCapacity.stub('availableCapacity', stub[:available_capacity]) unless stub[:available_capacity].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('hostId', stub[:host_id].to_s) unless stub[:host_id].nil?
        xml << HostProperties.stub('hostProperties', stub[:host_properties]) unless stub[:host_properties].nil?
        xml << Hearth::XML::Node.new('hostReservationId', stub[:host_reservation_id].to_s) unless stub[:host_reservation_id].nil?
        xml << Hearth::XML::Node.new('instances', HostInstanceList.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('allocationTime', Hearth::TimeHelper.to_date_time(stub[:allocation_time])) unless stub[:allocation_time].nil?
        xml << Hearth::XML::Node.new('releaseTime', Hearth::TimeHelper.to_date_time(stub[:release_time])) unless stub[:release_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('hostRecovery', stub[:host_recovery].to_s) unless stub[:host_recovery].nil?
        xml << Hearth::XML::Node.new('allowsMultipleInstanceTypes', stub[:allows_multiple_instance_types].to_s) unless stub[:allows_multiple_instance_types].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('memberOfServiceLinkedResourceGroup', stub[:member_of_service_linked_resource_group].to_s) unless stub[:member_of_service_linked_resource_group].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml
      end
    end

    # List Stubber for HostInstanceList
    class HostInstanceList
      def self.default(visited=[])
        return nil if visited.include?('HostInstanceList')
        visited = visited + ['HostInstanceList']
        [
          HostInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HostInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for HostInstance
    class HostInstance
      def self.default(visited=[])
        return nil if visited.include?('HostInstance')
        visited = visited + ['HostInstance']
        {
          instance_id: 'instance_id',
          instance_type: 'instance_type',
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    # Structure Stubber for HostProperties
    class HostProperties
      def self.default(visited=[])
        return nil if visited.include?('HostProperties')
        visited = visited + ['HostProperties']
        {
          cores: 1,
          instance_type: 'instance_type',
          instance_family: 'instance_family',
          sockets: 1,
          total_v_cpus: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cores', stub[:cores].to_s) unless stub[:cores].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('sockets', stub[:sockets].to_s) unless stub[:sockets].nil?
        xml << Hearth::XML::Node.new('totalVCpus', stub[:total_v_cpus].to_s) unless stub[:total_v_cpus].nil?
        xml
      end
    end

    # Structure Stubber for AvailableCapacity
    class AvailableCapacity
      def self.default(visited=[])
        return nil if visited.include?('AvailableCapacity')
        visited = visited + ['AvailableCapacity']
        {
          available_instance_capacity: AvailableInstanceCapacityList.default(visited),
          available_v_cpus: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availableInstanceCapacity', AvailableInstanceCapacityList.stub('item', stub[:available_instance_capacity])) unless stub[:available_instance_capacity].nil?
        xml << Hearth::XML::Node.new('availableVCpus', stub[:available_v_cpus].to_s) unless stub[:available_v_cpus].nil?
        xml
      end
    end

    # List Stubber for AvailableInstanceCapacityList
    class AvailableInstanceCapacityList
      def self.default(visited=[])
        return nil if visited.include?('AvailableInstanceCapacityList')
        visited = visited + ['AvailableInstanceCapacityList']
        [
          InstanceCapacity.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceCapacity.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceCapacity
    class InstanceCapacity
      def self.default(visited=[])
        return nil if visited.include?('InstanceCapacity')
        visited = visited + ['InstanceCapacity']
        {
          available_capacity: 1,
          instance_type: 'instance_type',
          total_capacity: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availableCapacity', stub[:available_capacity].to_s) unless stub[:available_capacity].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('totalCapacity', stub[:total_capacity].to_s) unless stub[:total_capacity].nil?
        xml
      end
    end

    # Operation Stubber for DescribeIamInstanceProfileAssociations
    class DescribeIamInstanceProfileAssociations
      def self.default(visited=[])
        {
          iam_instance_profile_associations: IamInstanceProfileAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIamInstanceProfileAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('iamInstanceProfileAssociationSet', IamInstanceProfileAssociationSet.stub('item', stub[:iam_instance_profile_associations])) unless stub[:iam_instance_profile_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IamInstanceProfileAssociationSet
    class IamInstanceProfileAssociationSet
      def self.default(visited=[])
        return nil if visited.include?('IamInstanceProfileAssociationSet')
        visited = visited + ['IamInstanceProfileAssociationSet']
        [
          IamInstanceProfileAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IamInstanceProfileAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeIdFormat
    class DescribeIdFormat
      def self.default(visited=[])
        {
          statuses: IdFormatList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('statusSet', IdFormatList.stub('item', stub[:statuses])) unless stub[:statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeIdentityIdFormat
    class DescribeIdentityIdFormat
      def self.default(visited=[])
        {
          statuses: IdFormatList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIdentityIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('statusSet', IdFormatList.stub('item', stub[:statuses])) unless stub[:statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeImageAttribute
    class DescribeImageAttribute
      def self.default(visited=[])
        {
          block_device_mappings: BlockDeviceMappingList.default(visited),
          image_id: 'image_id',
          launch_permissions: LaunchPermissionList.default(visited),
          product_codes: ProductCodeList.default(visited),
          description: AttributeValue.default(visited),
          kernel_id: AttributeValue.default(visited),
          ramdisk_id: AttributeValue.default(visited),
          sriov_net_support: AttributeValue.default(visited),
          boot_mode: AttributeValue.default(visited),
          tpm_support: AttributeValue.default(visited),
          uefi_data: AttributeValue.default(visited),
          last_launched_time: AttributeValue.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('blockDeviceMapping', BlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('launchPermission', LaunchPermissionList.stub('item', stub[:launch_permissions])) unless stub[:launch_permissions].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << AttributeValue.stub('description', stub[:description]) unless stub[:description].nil?
        xml << AttributeValue.stub('kernel', stub[:kernel_id]) unless stub[:kernel_id].nil?
        xml << AttributeValue.stub('ramdisk', stub[:ramdisk_id]) unless stub[:ramdisk_id].nil?
        xml << AttributeValue.stub('sriovNetSupport', stub[:sriov_net_support]) unless stub[:sriov_net_support].nil?
        xml << AttributeValue.stub('bootMode', stub[:boot_mode]) unless stub[:boot_mode].nil?
        xml << AttributeValue.stub('tpmSupport', stub[:tpm_support]) unless stub[:tpm_support].nil?
        xml << AttributeValue.stub('uefiData', stub[:uefi_data]) unless stub[:uefi_data].nil?
        xml << AttributeValue.stub('lastLaunchedTime', stub[:last_launched_time]) unless stub[:last_launched_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LaunchPermissionList
    class LaunchPermissionList
      def self.default(visited=[])
        return nil if visited.include?('LaunchPermissionList')
        visited = visited + ['LaunchPermissionList']
        [
          LaunchPermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchPermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LaunchPermission
    class LaunchPermission
      def self.default(visited=[])
        return nil if visited.include?('LaunchPermission')
        visited = visited + ['LaunchPermission']
        {
          group: 'group',
          user_id: 'user_id',
          organization_arn: 'organization_arn',
          organizational_unit_arn: 'organizational_unit_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('group', stub[:group].to_s) unless stub[:group].nil?
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml << Hearth::XML::Node.new('organizationArn', stub[:organization_arn].to_s) unless stub[:organization_arn].nil?
        xml << Hearth::XML::Node.new('organizationalUnitArn', stub[:organizational_unit_arn].to_s) unless stub[:organizational_unit_arn].nil?
        xml
      end
    end

    # List Stubber for BlockDeviceMappingList
    class BlockDeviceMappingList
      def self.default(visited=[])
        return nil if visited.include?('BlockDeviceMappingList')
        visited = visited + ['BlockDeviceMappingList']
        [
          BlockDeviceMapping.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << BlockDeviceMapping.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for BlockDeviceMapping
    class BlockDeviceMapping
      def self.default(visited=[])
        return nil if visited.include?('BlockDeviceMapping')
        visited = visited + ['BlockDeviceMapping']
        {
          device_name: 'device_name',
          virtual_name: 'virtual_name',
          ebs: EbsBlockDevice.default(visited),
          no_device: 'no_device',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << Hearth::XML::Node.new('virtualName', stub[:virtual_name].to_s) unless stub[:virtual_name].nil?
        xml << EbsBlockDevice.stub('ebs', stub[:ebs]) unless stub[:ebs].nil?
        xml << Hearth::XML::Node.new('noDevice', stub[:no_device].to_s) unless stub[:no_device].nil?
        xml
      end
    end

    # Structure Stubber for EbsBlockDevice
    class EbsBlockDevice
      def self.default(visited=[])
        return nil if visited.include?('EbsBlockDevice')
        visited = visited + ['EbsBlockDevice']
        {
          delete_on_termination: false,
          iops: 1,
          snapshot_id: 'snapshot_id',
          volume_size: 1,
          volume_type: 'volume_type',
          kms_key_id: 'kms_key_id',
          throughput: 1,
          outpost_arn: 'outpost_arn',
          encrypted: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('iops', stub[:iops].to_s) unless stub[:iops].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('volumeType', stub[:volume_type].to_s) unless stub[:volume_type].nil?
        xml << Hearth::XML::Node.new('KmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('throughput', stub[:throughput].to_s) unless stub[:throughput].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml
      end
    end

    # Operation Stubber for DescribeImages
    class DescribeImages
      def self.default(visited=[])
        {
          images: ImageList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeImagesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imagesSet', ImageList.stub('item', stub[:images])) unless stub[:images].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ImageList
    class ImageList
      def self.default(visited=[])
        return nil if visited.include?('ImageList')
        visited = visited + ['ImageList']
        [
          Image.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Image.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Image
    class Image
      def self.default(visited=[])
        return nil if visited.include?('Image')
        visited = visited + ['Image']
        {
          architecture: 'architecture',
          creation_date: 'creation_date',
          image_id: 'image_id',
          image_location: 'image_location',
          image_type: 'image_type',
          public: false,
          kernel_id: 'kernel_id',
          owner_id: 'owner_id',
          platform: 'platform',
          platform_details: 'platform_details',
          usage_operation: 'usage_operation',
          product_codes: ProductCodeList.default(visited),
          ramdisk_id: 'ramdisk_id',
          state: 'state',
          block_device_mappings: BlockDeviceMappingList.default(visited),
          description: 'description',
          ena_support: false,
          hypervisor: 'hypervisor',
          image_owner_alias: 'image_owner_alias',
          name: 'name',
          root_device_name: 'root_device_name',
          root_device_type: 'root_device_type',
          sriov_net_support: 'sriov_net_support',
          state_reason: StateReason.default(visited),
          tags: TagList.default(visited),
          virtualization_type: 'virtualization_type',
          boot_mode: 'boot_mode',
          tpm_support: 'tpm_support',
          deprecation_time: 'deprecation_time',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('architecture', stub[:architecture].to_s) unless stub[:architecture].nil?
        xml << Hearth::XML::Node.new('creationDate', stub[:creation_date].to_s) unless stub[:creation_date].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('imageLocation', stub[:image_location].to_s) unless stub[:image_location].nil?
        xml << Hearth::XML::Node.new('imageType', stub[:image_type].to_s) unless stub[:image_type].nil?
        xml << Hearth::XML::Node.new('isPublic', stub[:public].to_s) unless stub[:public].nil?
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('imageOwnerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('platformDetails', stub[:platform_details].to_s) unless stub[:platform_details].nil?
        xml << Hearth::XML::Node.new('usageOperation', stub[:usage_operation].to_s) unless stub[:usage_operation].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('ramdiskId', stub[:ramdisk_id].to_s) unless stub[:ramdisk_id].nil?
        xml << Hearth::XML::Node.new('imageState', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', BlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('enaSupport', stub[:ena_support].to_s) unless stub[:ena_support].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << Hearth::XML::Node.new('imageOwnerAlias', stub[:image_owner_alias].to_s) unless stub[:image_owner_alias].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('rootDeviceName', stub[:root_device_name].to_s) unless stub[:root_device_name].nil?
        xml << Hearth::XML::Node.new('rootDeviceType', stub[:root_device_type].to_s) unless stub[:root_device_type].nil?
        xml << Hearth::XML::Node.new('sriovNetSupport', stub[:sriov_net_support].to_s) unless stub[:sriov_net_support].nil?
        xml << StateReason.stub('stateReason', stub[:state_reason]) unless stub[:state_reason].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('virtualizationType', stub[:virtualization_type].to_s) unless stub[:virtualization_type].nil?
        xml << Hearth::XML::Node.new('bootMode', stub[:boot_mode].to_s) unless stub[:boot_mode].nil?
        xml << Hearth::XML::Node.new('tpmSupport', stub[:tpm_support].to_s) unless stub[:tpm_support].nil?
        xml << Hearth::XML::Node.new('deprecationTime', stub[:deprecation_time].to_s) unless stub[:deprecation_time].nil?
        xml
      end
    end

    # Structure Stubber for StateReason
    class StateReason
      def self.default(visited=[])
        return nil if visited.include?('StateReason')
        visited = visited + ['StateReason']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for DescribeImportImageTasks
    class DescribeImportImageTasks
      def self.default(visited=[])
        {
          import_image_tasks: ImportImageTaskList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeImportImageTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('importImageTaskSet', ImportImageTaskList.stub('item', stub[:import_image_tasks])) unless stub[:import_image_tasks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ImportImageTaskList
    class ImportImageTaskList
      def self.default(visited=[])
        return nil if visited.include?('ImportImageTaskList')
        visited = visited + ['ImportImageTaskList']
        [
          ImportImageTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImportImageTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ImportImageTask
    class ImportImageTask
      def self.default(visited=[])
        return nil if visited.include?('ImportImageTask')
        visited = visited + ['ImportImageTask']
        {
          architecture: 'architecture',
          description: 'description',
          encrypted: false,
          hypervisor: 'hypervisor',
          image_id: 'image_id',
          import_task_id: 'import_task_id',
          kms_key_id: 'kms_key_id',
          license_type: 'license_type',
          platform: 'platform',
          progress: 'progress',
          snapshot_details: SnapshotDetailList.default(visited),
          status: 'status',
          status_message: 'status_message',
          tags: TagList.default(visited),
          license_specifications: ImportImageLicenseSpecificationListResponse.default(visited),
          usage_operation: 'usage_operation',
          boot_mode: 'boot_mode',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('architecture', stub[:architecture].to_s) unless stub[:architecture].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('licenseType', stub[:license_type].to_s) unless stub[:license_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotDetailSet', SnapshotDetailList.stub('item', stub[:snapshot_details])) unless stub[:snapshot_details].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('licenseSpecifications', ImportImageLicenseSpecificationListResponse.stub('item', stub[:license_specifications])) unless stub[:license_specifications].nil?
        xml << Hearth::XML::Node.new('usageOperation', stub[:usage_operation].to_s) unless stub[:usage_operation].nil?
        xml << Hearth::XML::Node.new('bootMode', stub[:boot_mode].to_s) unless stub[:boot_mode].nil?
        xml
      end
    end

    # List Stubber for ImportImageLicenseSpecificationListResponse
    class ImportImageLicenseSpecificationListResponse
      def self.default(visited=[])
        return nil if visited.include?('ImportImageLicenseSpecificationListResponse')
        visited = visited + ['ImportImageLicenseSpecificationListResponse']
        [
          ImportImageLicenseConfigurationResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImportImageLicenseConfigurationResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ImportImageLicenseConfigurationResponse
    class ImportImageLicenseConfigurationResponse
      def self.default(visited=[])
        return nil if visited.include?('ImportImageLicenseConfigurationResponse')
        visited = visited + ['ImportImageLicenseConfigurationResponse']
        {
          license_configuration_arn: 'license_configuration_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('licenseConfigurationArn', stub[:license_configuration_arn].to_s) unless stub[:license_configuration_arn].nil?
        xml
      end
    end

    # List Stubber for SnapshotDetailList
    class SnapshotDetailList
      def self.default(visited=[])
        return nil if visited.include?('SnapshotDetailList')
        visited = visited + ['SnapshotDetailList']
        [
          SnapshotDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SnapshotDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SnapshotDetail
    class SnapshotDetail
      def self.default(visited=[])
        return nil if visited.include?('SnapshotDetail')
        visited = visited + ['SnapshotDetail']
        {
          description: 'description',
          device_name: 'device_name',
          disk_image_size: 1.0,
          format: 'format',
          progress: 'progress',
          snapshot_id: 'snapshot_id',
          status: 'status',
          status_message: 'status_message',
          url: 'url',
          user_bucket: UserBucketDetails.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << Hearth::XML::Node.new('diskImageSize', Hearth::NumberHelper.serialize(stub[:disk_image_size]).to_s) unless stub[:disk_image_size].nil?
        xml << Hearth::XML::Node.new('format', stub[:format].to_s) unless stub[:format].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('url', stub[:url].to_s) unless stub[:url].nil?
        xml << UserBucketDetails.stub('userBucket', stub[:user_bucket]) unless stub[:user_bucket].nil?
        xml
      end
    end

    # Structure Stubber for UserBucketDetails
    class UserBucketDetails
      def self.default(visited=[])
        return nil if visited.include?('UserBucketDetails')
        visited = visited + ['UserBucketDetails']
        {
          s3_bucket: 's3_bucket',
          s3_key: 's3_key',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('s3Bucket', stub[:s3_bucket].to_s) unless stub[:s3_bucket].nil?
        xml << Hearth::XML::Node.new('s3Key', stub[:s3_key].to_s) unless stub[:s3_key].nil?
        xml
      end
    end

    # Operation Stubber for DescribeImportSnapshotTasks
    class DescribeImportSnapshotTasks
      def self.default(visited=[])
        {
          import_snapshot_tasks: ImportSnapshotTaskList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeImportSnapshotTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('importSnapshotTaskSet', ImportSnapshotTaskList.stub('item', stub[:import_snapshot_tasks])) unless stub[:import_snapshot_tasks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ImportSnapshotTaskList
    class ImportSnapshotTaskList
      def self.default(visited=[])
        return nil if visited.include?('ImportSnapshotTaskList')
        visited = visited + ['ImportSnapshotTaskList']
        [
          ImportSnapshotTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImportSnapshotTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ImportSnapshotTask
    class ImportSnapshotTask
      def self.default(visited=[])
        return nil if visited.include?('ImportSnapshotTask')
        visited = visited + ['ImportSnapshotTask']
        {
          description: 'description',
          import_task_id: 'import_task_id',
          snapshot_task_detail: SnapshotTaskDetail.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << SnapshotTaskDetail.stub('snapshotTaskDetail', stub[:snapshot_task_detail]) unless stub[:snapshot_task_detail].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for SnapshotTaskDetail
    class SnapshotTaskDetail
      def self.default(visited=[])
        return nil if visited.include?('SnapshotTaskDetail')
        visited = visited + ['SnapshotTaskDetail']
        {
          description: 'description',
          disk_image_size: 1.0,
          encrypted: false,
          format: 'format',
          kms_key_id: 'kms_key_id',
          progress: 'progress',
          snapshot_id: 'snapshot_id',
          status: 'status',
          status_message: 'status_message',
          url: 'url',
          user_bucket: UserBucketDetails.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('diskImageSize', Hearth::NumberHelper.serialize(stub[:disk_image_size]).to_s) unless stub[:disk_image_size].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('format', stub[:format].to_s) unless stub[:format].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('url', stub[:url].to_s) unless stub[:url].nil?
        xml << UserBucketDetails.stub('userBucket', stub[:user_bucket]) unless stub[:user_bucket].nil?
        xml
      end
    end

    # Operation Stubber for DescribeInstanceAttribute
    class DescribeInstanceAttribute
      def self.default(visited=[])
        {
          groups: GroupIdentifierList.default(visited),
          block_device_mappings: InstanceBlockDeviceMappingList.default(visited),
          disable_api_termination: AttributeBooleanValue.default(visited),
          ena_support: AttributeBooleanValue.default(visited),
          enclave_options: EnclaveOptions.default(visited),
          ebs_optimized: AttributeBooleanValue.default(visited),
          instance_id: 'instance_id',
          instance_initiated_shutdown_behavior: AttributeValue.default(visited),
          instance_type: AttributeValue.default(visited),
          kernel_id: AttributeValue.default(visited),
          product_codes: ProductCodeList.default(visited),
          ramdisk_id: AttributeValue.default(visited),
          root_device_name: AttributeValue.default(visited),
          source_dest_check: AttributeBooleanValue.default(visited),
          sriov_net_support: AttributeValue.default(visited),
          user_data: AttributeValue.default(visited),
          disable_api_stop: AttributeBooleanValue.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', InstanceBlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << AttributeBooleanValue.stub('disableApiTermination', stub[:disable_api_termination]) unless stub[:disable_api_termination].nil?
        xml << AttributeBooleanValue.stub('enaSupport', stub[:ena_support]) unless stub[:ena_support].nil?
        xml << EnclaveOptions.stub('enclaveOptions', stub[:enclave_options]) unless stub[:enclave_options].nil?
        xml << AttributeBooleanValue.stub('ebsOptimized', stub[:ebs_optimized]) unless stub[:ebs_optimized].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << AttributeValue.stub('instanceInitiatedShutdownBehavior', stub[:instance_initiated_shutdown_behavior]) unless stub[:instance_initiated_shutdown_behavior].nil?
        xml << AttributeValue.stub('instanceType', stub[:instance_type]) unless stub[:instance_type].nil?
        xml << AttributeValue.stub('kernel', stub[:kernel_id]) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << AttributeValue.stub('ramdisk', stub[:ramdisk_id]) unless stub[:ramdisk_id].nil?
        xml << AttributeValue.stub('rootDeviceName', stub[:root_device_name]) unless stub[:root_device_name].nil?
        xml << AttributeBooleanValue.stub('sourceDestCheck', stub[:source_dest_check]) unless stub[:source_dest_check].nil?
        xml << AttributeValue.stub('sriovNetSupport', stub[:sriov_net_support]) unless stub[:sriov_net_support].nil?
        xml << AttributeValue.stub('userData', stub[:user_data]) unless stub[:user_data].nil?
        xml << AttributeBooleanValue.stub('disableApiStop', stub[:disable_api_stop]) unless stub[:disable_api_stop].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for AttributeBooleanValue
    class AttributeBooleanValue
      def self.default(visited=[])
        return nil if visited.include?('AttributeBooleanValue')
        visited = visited + ['AttributeBooleanValue']
        {
          value: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # Structure Stubber for EnclaveOptions
    class EnclaveOptions
      def self.default(visited=[])
        return nil if visited.include?('EnclaveOptions')
        visited = visited + ['EnclaveOptions']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    # List Stubber for InstanceBlockDeviceMappingList
    class InstanceBlockDeviceMappingList
      def self.default(visited=[])
        return nil if visited.include?('InstanceBlockDeviceMappingList')
        visited = visited + ['InstanceBlockDeviceMappingList']
        [
          InstanceBlockDeviceMapping.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceBlockDeviceMapping.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceBlockDeviceMapping
    class InstanceBlockDeviceMapping
      def self.default(visited=[])
        return nil if visited.include?('InstanceBlockDeviceMapping')
        visited = visited + ['InstanceBlockDeviceMapping']
        {
          device_name: 'device_name',
          ebs: EbsInstanceBlockDevice.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << EbsInstanceBlockDevice.stub('ebs', stub[:ebs]) unless stub[:ebs].nil?
        xml
      end
    end

    # Structure Stubber for EbsInstanceBlockDevice
    class EbsInstanceBlockDevice
      def self.default(visited=[])
        return nil if visited.include?('EbsInstanceBlockDevice')
        visited = visited + ['EbsInstanceBlockDevice']
        {
          attach_time: Time.now,
          delete_on_termination: false,
          status: 'status',
          volume_id: 'volume_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml
      end
    end

    # Operation Stubber for DescribeInstanceCreditSpecifications
    class DescribeInstanceCreditSpecifications
      def self.default(visited=[])
        {
          instance_credit_specifications: InstanceCreditSpecificationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceCreditSpecificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceCreditSpecificationSet', InstanceCreditSpecificationList.stub('item', stub[:instance_credit_specifications])) unless stub[:instance_credit_specifications].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceCreditSpecificationList
    class InstanceCreditSpecificationList
      def self.default(visited=[])
        return nil if visited.include?('InstanceCreditSpecificationList')
        visited = visited + ['InstanceCreditSpecificationList']
        [
          InstanceCreditSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceCreditSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceCreditSpecification
    class InstanceCreditSpecification
      def self.default(visited=[])
        return nil if visited.include?('InstanceCreditSpecification')
        visited = visited + ['InstanceCreditSpecification']
        {
          instance_id: 'instance_id',
          cpu_credits: 'cpu_credits',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('cpuCredits', stub[:cpu_credits].to_s) unless stub[:cpu_credits].nil?
        xml
      end
    end

    # Operation Stubber for DescribeInstanceEventNotificationAttributes
    class DescribeInstanceEventNotificationAttributes
      def self.default(visited=[])
        {
          instance_tag_attribute: InstanceTagNotificationAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceEventNotificationAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceTagNotificationAttribute.stub('instanceTagAttribute', stub[:instance_tag_attribute]) unless stub[:instance_tag_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeInstanceEventWindows
    class DescribeInstanceEventWindows
      def self.default(visited=[])
        {
          instance_event_windows: InstanceEventWindowSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceEventWindowsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceEventWindowSet', InstanceEventWindowSet.stub('item', stub[:instance_event_windows])) unless stub[:instance_event_windows].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceEventWindowSet
    class InstanceEventWindowSet
      def self.default(visited=[])
        return nil if visited.include?('InstanceEventWindowSet')
        visited = visited + ['InstanceEventWindowSet']
        [
          InstanceEventWindow.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceEventWindow.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeInstanceStatus
    class DescribeInstanceStatus
      def self.default(visited=[])
        {
          instance_statuses: InstanceStatusList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceStatusSet', InstanceStatusList.stub('item', stub[:instance_statuses])) unless stub[:instance_statuses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceStatusList
    class InstanceStatusList
      def self.default(visited=[])
        return nil if visited.include?('InstanceStatusList')
        visited = visited + ['InstanceStatusList']
        [
          InstanceStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceStatus
    class InstanceStatus
      def self.default(visited=[])
        return nil if visited.include?('InstanceStatus')
        visited = visited + ['InstanceStatus']
        {
          availability_zone: 'availability_zone',
          outpost_arn: 'outpost_arn',
          events: InstanceStatusEventList.default(visited),
          instance_id: 'instance_id',
          instance_state: InstanceState.default(visited),
          instance_status: InstanceStatusSummary.default(visited),
          system_status: InstanceStatusSummary.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('eventsSet', InstanceStatusEventList.stub('item', stub[:events])) unless stub[:events].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << InstanceState.stub('instanceState', stub[:instance_state]) unless stub[:instance_state].nil?
        xml << InstanceStatusSummary.stub('instanceStatus', stub[:instance_status]) unless stub[:instance_status].nil?
        xml << InstanceStatusSummary.stub('systemStatus', stub[:system_status]) unless stub[:system_status].nil?
        xml
      end
    end

    # Structure Stubber for InstanceStatusSummary
    class InstanceStatusSummary
      def self.default(visited=[])
        return nil if visited.include?('InstanceStatusSummary')
        visited = visited + ['InstanceStatusSummary']
        {
          details: InstanceStatusDetailsList.default(visited),
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('details', InstanceStatusDetailsList.stub('item', stub[:details])) unless stub[:details].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    # List Stubber for InstanceStatusDetailsList
    class InstanceStatusDetailsList
      def self.default(visited=[])
        return nil if visited.include?('InstanceStatusDetailsList')
        visited = visited + ['InstanceStatusDetailsList']
        [
          InstanceStatusDetails.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceStatusDetails.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceStatusDetails
    class InstanceStatusDetails
      def self.default(visited=[])
        return nil if visited.include?('InstanceStatusDetails')
        visited = visited + ['InstanceStatusDetails']
        {
          impaired_since: Time.now,
          name: 'name',
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('impairedSince', Hearth::TimeHelper.to_date_time(stub[:impaired_since])) unless stub[:impaired_since].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    # Structure Stubber for InstanceState
    class InstanceState
      def self.default(visited=[])
        return nil if visited.include?('InstanceState')
        visited = visited + ['InstanceState']
        {
          code: 1,
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    # List Stubber for InstanceStatusEventList
    class InstanceStatusEventList
      def self.default(visited=[])
        return nil if visited.include?('InstanceStatusEventList')
        visited = visited + ['InstanceStatusEventList']
        [
          InstanceStatusEvent.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceStatusEvent.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceStatusEvent
    class InstanceStatusEvent
      def self.default(visited=[])
        return nil if visited.include?('InstanceStatusEvent')
        visited = visited + ['InstanceStatusEvent']
        {
          instance_event_id: 'instance_event_id',
          code: 'code',
          description: 'description',
          not_after: Time.now,
          not_before: Time.now,
          not_before_deadline: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceEventId', stub[:instance_event_id].to_s) unless stub[:instance_event_id].nil?
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('notAfter', Hearth::TimeHelper.to_date_time(stub[:not_after])) unless stub[:not_after].nil?
        xml << Hearth::XML::Node.new('notBefore', Hearth::TimeHelper.to_date_time(stub[:not_before])) unless stub[:not_before].nil?
        xml << Hearth::XML::Node.new('notBeforeDeadline', Hearth::TimeHelper.to_date_time(stub[:not_before_deadline])) unless stub[:not_before_deadline].nil?
        xml
      end
    end

    # Operation Stubber for DescribeInstanceTypeOfferings
    class DescribeInstanceTypeOfferings
      def self.default(visited=[])
        {
          instance_type_offerings: InstanceTypeOfferingsList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceTypeOfferingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceTypeOfferingSet', InstanceTypeOfferingsList.stub('item', stub[:instance_type_offerings])) unless stub[:instance_type_offerings].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceTypeOfferingsList
    class InstanceTypeOfferingsList
      def self.default(visited=[])
        return nil if visited.include?('InstanceTypeOfferingsList')
        visited = visited + ['InstanceTypeOfferingsList']
        [
          InstanceTypeOffering.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceTypeOffering.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceTypeOffering
    class InstanceTypeOffering
      def self.default(visited=[])
        return nil if visited.include?('InstanceTypeOffering')
        visited = visited + ['InstanceTypeOffering']
        {
          instance_type: 'instance_type',
          location_type: 'location_type',
          location: 'location',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('locationType', stub[:location_type].to_s) unless stub[:location_type].nil?
        xml << Hearth::XML::Node.new('location', stub[:location].to_s) unless stub[:location].nil?
        xml
      end
    end

    # Operation Stubber for DescribeInstanceTypes
    class DescribeInstanceTypes
      def self.default(visited=[])
        {
          instance_types: InstanceTypeInfoList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceTypesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceTypeSet', InstanceTypeInfoList.stub('item', stub[:instance_types])) unless stub[:instance_types].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceTypeInfoList
    class InstanceTypeInfoList
      def self.default(visited=[])
        return nil if visited.include?('InstanceTypeInfoList')
        visited = visited + ['InstanceTypeInfoList']
        [
          InstanceTypeInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceTypeInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceTypeInfo
    class InstanceTypeInfo
      def self.default(visited=[])
        return nil if visited.include?('InstanceTypeInfo')
        visited = visited + ['InstanceTypeInfo']
        {
          instance_type: 'instance_type',
          current_generation: false,
          free_tier_eligible: false,
          supported_usage_classes: UsageClassTypeList.default(visited),
          supported_root_device_types: RootDeviceTypeList.default(visited),
          supported_virtualization_types: VirtualizationTypeList.default(visited),
          bare_metal: false,
          hypervisor: 'hypervisor',
          processor_info: ProcessorInfo.default(visited),
          v_cpu_info: VCpuInfo.default(visited),
          memory_info: MemoryInfo.default(visited),
          instance_storage_supported: false,
          instance_storage_info: InstanceStorageInfo.default(visited),
          ebs_info: EbsInfo.default(visited),
          network_info: NetworkInfo.default(visited),
          gpu_info: GpuInfo.default(visited),
          fpga_info: FpgaInfo.default(visited),
          placement_group_info: PlacementGroupInfo.default(visited),
          inference_accelerator_info: InferenceAcceleratorInfo.default(visited),
          hibernation_supported: false,
          burstable_performance_supported: false,
          dedicated_hosts_supported: false,
          auto_recovery_supported: false,
          supported_boot_modes: BootModeTypeList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('currentGeneration', stub[:current_generation].to_s) unless stub[:current_generation].nil?
        xml << Hearth::XML::Node.new('freeTierEligible', stub[:free_tier_eligible].to_s) unless stub[:free_tier_eligible].nil?
        xml << Hearth::XML::Node.new('supportedUsageClasses', UsageClassTypeList.stub('item', stub[:supported_usage_classes])) unless stub[:supported_usage_classes].nil?
        xml << Hearth::XML::Node.new('supportedRootDeviceTypes', RootDeviceTypeList.stub('item', stub[:supported_root_device_types])) unless stub[:supported_root_device_types].nil?
        xml << Hearth::XML::Node.new('supportedVirtualizationTypes', VirtualizationTypeList.stub('item', stub[:supported_virtualization_types])) unless stub[:supported_virtualization_types].nil?
        xml << Hearth::XML::Node.new('bareMetal', stub[:bare_metal].to_s) unless stub[:bare_metal].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << ProcessorInfo.stub('processorInfo', stub[:processor_info]) unless stub[:processor_info].nil?
        xml << VCpuInfo.stub('vCpuInfo', stub[:v_cpu_info]) unless stub[:v_cpu_info].nil?
        xml << MemoryInfo.stub('memoryInfo', stub[:memory_info]) unless stub[:memory_info].nil?
        xml << Hearth::XML::Node.new('instanceStorageSupported', stub[:instance_storage_supported].to_s) unless stub[:instance_storage_supported].nil?
        xml << InstanceStorageInfo.stub('instanceStorageInfo', stub[:instance_storage_info]) unless stub[:instance_storage_info].nil?
        xml << EbsInfo.stub('ebsInfo', stub[:ebs_info]) unless stub[:ebs_info].nil?
        xml << NetworkInfo.stub('networkInfo', stub[:network_info]) unless stub[:network_info].nil?
        xml << GpuInfo.stub('gpuInfo', stub[:gpu_info]) unless stub[:gpu_info].nil?
        xml << FpgaInfo.stub('fpgaInfo', stub[:fpga_info]) unless stub[:fpga_info].nil?
        xml << PlacementGroupInfo.stub('placementGroupInfo', stub[:placement_group_info]) unless stub[:placement_group_info].nil?
        xml << InferenceAcceleratorInfo.stub('inferenceAcceleratorInfo', stub[:inference_accelerator_info]) unless stub[:inference_accelerator_info].nil?
        xml << Hearth::XML::Node.new('hibernationSupported', stub[:hibernation_supported].to_s) unless stub[:hibernation_supported].nil?
        xml << Hearth::XML::Node.new('burstablePerformanceSupported', stub[:burstable_performance_supported].to_s) unless stub[:burstable_performance_supported].nil?
        xml << Hearth::XML::Node.new('dedicatedHostsSupported', stub[:dedicated_hosts_supported].to_s) unless stub[:dedicated_hosts_supported].nil?
        xml << Hearth::XML::Node.new('autoRecoverySupported', stub[:auto_recovery_supported].to_s) unless stub[:auto_recovery_supported].nil?
        xml << Hearth::XML::Node.new('supportedBootModes', BootModeTypeList.stub('item', stub[:supported_boot_modes])) unless stub[:supported_boot_modes].nil?
        xml
      end
    end

    # List Stubber for BootModeTypeList
    class BootModeTypeList
      def self.default(visited=[])
        return nil if visited.include?('BootModeTypeList')
        visited = visited + ['BootModeTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InferenceAcceleratorInfo
    class InferenceAcceleratorInfo
      def self.default(visited=[])
        return nil if visited.include?('InferenceAcceleratorInfo')
        visited = visited + ['InferenceAcceleratorInfo']
        {
          accelerators: InferenceDeviceInfoList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('accelerators', InferenceDeviceInfoList.stub('member', stub[:accelerators])) unless stub[:accelerators].nil?
        xml
      end
    end

    # List Stubber for InferenceDeviceInfoList
    class InferenceDeviceInfoList
      def self.default(visited=[])
        return nil if visited.include?('InferenceDeviceInfoList')
        visited = visited + ['InferenceDeviceInfoList']
        [
          InferenceDeviceInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InferenceDeviceInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InferenceDeviceInfo
    class InferenceDeviceInfo
      def self.default(visited=[])
        return nil if visited.include?('InferenceDeviceInfo')
        visited = visited + ['InferenceDeviceInfo']
        {
          count: 1,
          name: 'name',
          manufacturer: 'manufacturer',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('manufacturer', stub[:manufacturer].to_s) unless stub[:manufacturer].nil?
        xml
      end
    end

    # Structure Stubber for PlacementGroupInfo
    class PlacementGroupInfo
      def self.default(visited=[])
        return nil if visited.include?('PlacementGroupInfo')
        visited = visited + ['PlacementGroupInfo']
        {
          supported_strategies: PlacementGroupStrategyList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('supportedStrategies', PlacementGroupStrategyList.stub('item', stub[:supported_strategies])) unless stub[:supported_strategies].nil?
        xml
      end
    end

    # List Stubber for PlacementGroupStrategyList
    class PlacementGroupStrategyList
      def self.default(visited=[])
        return nil if visited.include?('PlacementGroupStrategyList')
        visited = visited + ['PlacementGroupStrategyList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for FpgaInfo
    class FpgaInfo
      def self.default(visited=[])
        return nil if visited.include?('FpgaInfo')
        visited = visited + ['FpgaInfo']
        {
          fpgas: FpgaDeviceInfoList.default(visited),
          total_fpga_memory_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fpgas', FpgaDeviceInfoList.stub('item', stub[:fpgas])) unless stub[:fpgas].nil?
        xml << Hearth::XML::Node.new('totalFpgaMemoryInMiB', stub[:total_fpga_memory_in_mi_b].to_s) unless stub[:total_fpga_memory_in_mi_b].nil?
        xml
      end
    end

    # List Stubber for FpgaDeviceInfoList
    class FpgaDeviceInfoList
      def self.default(visited=[])
        return nil if visited.include?('FpgaDeviceInfoList')
        visited = visited + ['FpgaDeviceInfoList']
        [
          FpgaDeviceInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FpgaDeviceInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for FpgaDeviceInfo
    class FpgaDeviceInfo
      def self.default(visited=[])
        return nil if visited.include?('FpgaDeviceInfo')
        visited = visited + ['FpgaDeviceInfo']
        {
          name: 'name',
          manufacturer: 'manufacturer',
          count: 1,
          memory_info: FpgaDeviceMemoryInfo.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('manufacturer', stub[:manufacturer].to_s) unless stub[:manufacturer].nil?
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << FpgaDeviceMemoryInfo.stub('memoryInfo', stub[:memory_info]) unless stub[:memory_info].nil?
        xml
      end
    end

    # Structure Stubber for FpgaDeviceMemoryInfo
    class FpgaDeviceMemoryInfo
      def self.default(visited=[])
        return nil if visited.include?('FpgaDeviceMemoryInfo')
        visited = visited + ['FpgaDeviceMemoryInfo']
        {
          size_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sizeInMiB', stub[:size_in_mi_b].to_s) unless stub[:size_in_mi_b].nil?
        xml
      end
    end

    # Structure Stubber for GpuInfo
    class GpuInfo
      def self.default(visited=[])
        return nil if visited.include?('GpuInfo')
        visited = visited + ['GpuInfo']
        {
          gpus: GpuDeviceInfoList.default(visited),
          total_gpu_memory_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('gpus', GpuDeviceInfoList.stub('item', stub[:gpus])) unless stub[:gpus].nil?
        xml << Hearth::XML::Node.new('totalGpuMemoryInMiB', stub[:total_gpu_memory_in_mi_b].to_s) unless stub[:total_gpu_memory_in_mi_b].nil?
        xml
      end
    end

    # List Stubber for GpuDeviceInfoList
    class GpuDeviceInfoList
      def self.default(visited=[])
        return nil if visited.include?('GpuDeviceInfoList')
        visited = visited + ['GpuDeviceInfoList']
        [
          GpuDeviceInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << GpuDeviceInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for GpuDeviceInfo
    class GpuDeviceInfo
      def self.default(visited=[])
        return nil if visited.include?('GpuDeviceInfo')
        visited = visited + ['GpuDeviceInfo']
        {
          name: 'name',
          manufacturer: 'manufacturer',
          count: 1,
          memory_info: GpuDeviceMemoryInfo.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('manufacturer', stub[:manufacturer].to_s) unless stub[:manufacturer].nil?
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << GpuDeviceMemoryInfo.stub('memoryInfo', stub[:memory_info]) unless stub[:memory_info].nil?
        xml
      end
    end

    # Structure Stubber for GpuDeviceMemoryInfo
    class GpuDeviceMemoryInfo
      def self.default(visited=[])
        return nil if visited.include?('GpuDeviceMemoryInfo')
        visited = visited + ['GpuDeviceMemoryInfo']
        {
          size_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sizeInMiB', stub[:size_in_mi_b].to_s) unless stub[:size_in_mi_b].nil?
        xml
      end
    end

    # Structure Stubber for NetworkInfo
    class NetworkInfo
      def self.default(visited=[])
        return nil if visited.include?('NetworkInfo')
        visited = visited + ['NetworkInfo']
        {
          network_performance: 'network_performance',
          maximum_network_interfaces: 1,
          maximum_network_cards: 1,
          default_network_card_index: 1,
          network_cards: NetworkCardInfoList.default(visited),
          ipv4_addresses_per_interface: 1,
          ipv6_addresses_per_interface: 1,
          ipv6_supported: false,
          ena_support: 'ena_support',
          efa_supported: false,
          efa_info: EfaInfo.default(visited),
          encryption_in_transit_supported: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkPerformance', stub[:network_performance].to_s) unless stub[:network_performance].nil?
        xml << Hearth::XML::Node.new('maximumNetworkInterfaces', stub[:maximum_network_interfaces].to_s) unless stub[:maximum_network_interfaces].nil?
        xml << Hearth::XML::Node.new('maximumNetworkCards', stub[:maximum_network_cards].to_s) unless stub[:maximum_network_cards].nil?
        xml << Hearth::XML::Node.new('defaultNetworkCardIndex', stub[:default_network_card_index].to_s) unless stub[:default_network_card_index].nil?
        xml << Hearth::XML::Node.new('networkCards', NetworkCardInfoList.stub('item', stub[:network_cards])) unless stub[:network_cards].nil?
        xml << Hearth::XML::Node.new('ipv4AddressesPerInterface', stub[:ipv4_addresses_per_interface].to_s) unless stub[:ipv4_addresses_per_interface].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesPerInterface', stub[:ipv6_addresses_per_interface].to_s) unless stub[:ipv6_addresses_per_interface].nil?
        xml << Hearth::XML::Node.new('ipv6Supported', stub[:ipv6_supported].to_s) unless stub[:ipv6_supported].nil?
        xml << Hearth::XML::Node.new('enaSupport', stub[:ena_support].to_s) unless stub[:ena_support].nil?
        xml << Hearth::XML::Node.new('efaSupported', stub[:efa_supported].to_s) unless stub[:efa_supported].nil?
        xml << EfaInfo.stub('efaInfo', stub[:efa_info]) unless stub[:efa_info].nil?
        xml << Hearth::XML::Node.new('encryptionInTransitSupported', stub[:encryption_in_transit_supported].to_s) unless stub[:encryption_in_transit_supported].nil?
        xml
      end
    end

    # Structure Stubber for EfaInfo
    class EfaInfo
      def self.default(visited=[])
        return nil if visited.include?('EfaInfo')
        visited = visited + ['EfaInfo']
        {
          maximum_efa_interfaces: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('maximumEfaInterfaces', stub[:maximum_efa_interfaces].to_s) unless stub[:maximum_efa_interfaces].nil?
        xml
      end
    end

    # List Stubber for NetworkCardInfoList
    class NetworkCardInfoList
      def self.default(visited=[])
        return nil if visited.include?('NetworkCardInfoList')
        visited = visited + ['NetworkCardInfoList']
        [
          NetworkCardInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkCardInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NetworkCardInfo
    class NetworkCardInfo
      def self.default(visited=[])
        return nil if visited.include?('NetworkCardInfo')
        visited = visited + ['NetworkCardInfo']
        {
          network_card_index: 1,
          network_performance: 'network_performance',
          maximum_network_interfaces: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml << Hearth::XML::Node.new('networkPerformance', stub[:network_performance].to_s) unless stub[:network_performance].nil?
        xml << Hearth::XML::Node.new('maximumNetworkInterfaces', stub[:maximum_network_interfaces].to_s) unless stub[:maximum_network_interfaces].nil?
        xml
      end
    end

    # Structure Stubber for EbsInfo
    class EbsInfo
      def self.default(visited=[])
        return nil if visited.include?('EbsInfo')
        visited = visited + ['EbsInfo']
        {
          ebs_optimized_support: 'ebs_optimized_support',
          encryption_support: 'encryption_support',
          ebs_optimized_info: EbsOptimizedInfo.default(visited),
          nvme_support: 'nvme_support',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ebsOptimizedSupport', stub[:ebs_optimized_support].to_s) unless stub[:ebs_optimized_support].nil?
        xml << Hearth::XML::Node.new('encryptionSupport', stub[:encryption_support].to_s) unless stub[:encryption_support].nil?
        xml << EbsOptimizedInfo.stub('ebsOptimizedInfo', stub[:ebs_optimized_info]) unless stub[:ebs_optimized_info].nil?
        xml << Hearth::XML::Node.new('nvmeSupport', stub[:nvme_support].to_s) unless stub[:nvme_support].nil?
        xml
      end
    end

    # Structure Stubber for EbsOptimizedInfo
    class EbsOptimizedInfo
      def self.default(visited=[])
        return nil if visited.include?('EbsOptimizedInfo')
        visited = visited + ['EbsOptimizedInfo']
        {
          baseline_bandwidth_in_mbps: 1,
          baseline_throughput_in_m_bps: 1.0,
          baseline_iops: 1,
          maximum_bandwidth_in_mbps: 1,
          maximum_throughput_in_m_bps: 1.0,
          maximum_iops: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('baselineBandwidthInMbps', stub[:baseline_bandwidth_in_mbps].to_s) unless stub[:baseline_bandwidth_in_mbps].nil?
        xml << Hearth::XML::Node.new('baselineThroughputInMBps', Hearth::NumberHelper.serialize(stub[:baseline_throughput_in_m_bps]).to_s) unless stub[:baseline_throughput_in_m_bps].nil?
        xml << Hearth::XML::Node.new('baselineIops', stub[:baseline_iops].to_s) unless stub[:baseline_iops].nil?
        xml << Hearth::XML::Node.new('maximumBandwidthInMbps', stub[:maximum_bandwidth_in_mbps].to_s) unless stub[:maximum_bandwidth_in_mbps].nil?
        xml << Hearth::XML::Node.new('maximumThroughputInMBps', Hearth::NumberHelper.serialize(stub[:maximum_throughput_in_m_bps]).to_s) unless stub[:maximum_throughput_in_m_bps].nil?
        xml << Hearth::XML::Node.new('maximumIops', stub[:maximum_iops].to_s) unless stub[:maximum_iops].nil?
        xml
      end
    end

    # Structure Stubber for InstanceStorageInfo
    class InstanceStorageInfo
      def self.default(visited=[])
        return nil if visited.include?('InstanceStorageInfo')
        visited = visited + ['InstanceStorageInfo']
        {
          total_size_in_gb: 1,
          disks: DiskInfoList.default(visited),
          nvme_support: 'nvme_support',
          encryption_support: 'encryption_support',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('totalSizeInGB', stub[:total_size_in_gb].to_s) unless stub[:total_size_in_gb].nil?
        xml << Hearth::XML::Node.new('disks', DiskInfoList.stub('item', stub[:disks])) unless stub[:disks].nil?
        xml << Hearth::XML::Node.new('nvmeSupport', stub[:nvme_support].to_s) unless stub[:nvme_support].nil?
        xml << Hearth::XML::Node.new('encryptionSupport', stub[:encryption_support].to_s) unless stub[:encryption_support].nil?
        xml
      end
    end

    # List Stubber for DiskInfoList
    class DiskInfoList
      def self.default(visited=[])
        return nil if visited.include?('DiskInfoList')
        visited = visited + ['DiskInfoList']
        [
          DiskInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DiskInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DiskInfo
    class DiskInfo
      def self.default(visited=[])
        return nil if visited.include?('DiskInfo')
        visited = visited + ['DiskInfo']
        {
          size_in_gb: 1,
          count: 1,
          type: 'type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sizeInGB', stub[:size_in_gb].to_s) unless stub[:size_in_gb].nil?
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml
      end
    end

    # Structure Stubber for MemoryInfo
    class MemoryInfo
      def self.default(visited=[])
        return nil if visited.include?('MemoryInfo')
        visited = visited + ['MemoryInfo']
        {
          size_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sizeInMiB', stub[:size_in_mi_b].to_s) unless stub[:size_in_mi_b].nil?
        xml
      end
    end

    # Structure Stubber for VCpuInfo
    class VCpuInfo
      def self.default(visited=[])
        return nil if visited.include?('VCpuInfo')
        visited = visited + ['VCpuInfo']
        {
          default_v_cpus: 1,
          default_cores: 1,
          default_threads_per_core: 1,
          valid_cores: CoreCountList.default(visited),
          valid_threads_per_core: ThreadsPerCoreList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('defaultVCpus', stub[:default_v_cpus].to_s) unless stub[:default_v_cpus].nil?
        xml << Hearth::XML::Node.new('defaultCores', stub[:default_cores].to_s) unless stub[:default_cores].nil?
        xml << Hearth::XML::Node.new('defaultThreadsPerCore', stub[:default_threads_per_core].to_s) unless stub[:default_threads_per_core].nil?
        xml << Hearth::XML::Node.new('validCores', CoreCountList.stub('item', stub[:valid_cores])) unless stub[:valid_cores].nil?
        xml << Hearth::XML::Node.new('validThreadsPerCore', ThreadsPerCoreList.stub('item', stub[:valid_threads_per_core])) unless stub[:valid_threads_per_core].nil?
        xml
      end
    end

    # List Stubber for ThreadsPerCoreList
    class ThreadsPerCoreList
      def self.default(visited=[])
        return nil if visited.include?('ThreadsPerCoreList')
        visited = visited + ['ThreadsPerCoreList']
        [
          1
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for CoreCountList
    class CoreCountList
      def self.default(visited=[])
        return nil if visited.include?('CoreCountList')
        visited = visited + ['CoreCountList']
        [
          1
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ProcessorInfo
    class ProcessorInfo
      def self.default(visited=[])
        return nil if visited.include?('ProcessorInfo')
        visited = visited + ['ProcessorInfo']
        {
          supported_architectures: ArchitectureTypeList.default(visited),
          sustained_clock_speed_in_ghz: 1.0,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('supportedArchitectures', ArchitectureTypeList.stub('item', stub[:supported_architectures])) unless stub[:supported_architectures].nil?
        xml << Hearth::XML::Node.new('sustainedClockSpeedInGhz', Hearth::NumberHelper.serialize(stub[:sustained_clock_speed_in_ghz]).to_s) unless stub[:sustained_clock_speed_in_ghz].nil?
        xml
      end
    end

    # List Stubber for ArchitectureTypeList
    class ArchitectureTypeList
      def self.default(visited=[])
        return nil if visited.include?('ArchitectureTypeList')
        visited = visited + ['ArchitectureTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for VirtualizationTypeList
    class VirtualizationTypeList
      def self.default(visited=[])
        return nil if visited.include?('VirtualizationTypeList')
        visited = visited + ['VirtualizationTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for RootDeviceTypeList
    class RootDeviceTypeList
      def self.default(visited=[])
        return nil if visited.include?('RootDeviceTypeList')
        visited = visited + ['RootDeviceTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for UsageClassTypeList
    class UsageClassTypeList
      def self.default(visited=[])
        return nil if visited.include?('UsageClassTypeList')
        visited = visited + ['UsageClassTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeInstances
    class DescribeInstances
      def self.default(visited=[])
        {
          reservations: ReservationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservationSet', ReservationList.stub('item', stub[:reservations])) unless stub[:reservations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ReservationList
    class ReservationList
      def self.default(visited=[])
        return nil if visited.include?('ReservationList')
        visited = visited + ['ReservationList']
        [
          Reservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Reservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Reservation
    class Reservation
      def self.default(visited=[])
        return nil if visited.include?('Reservation')
        visited = visited + ['Reservation']
        {
          groups: GroupIdentifierList.default(visited),
          instances: InstanceList.default(visited),
          owner_id: 'owner_id',
          requester_id: 'requester_id',
          reservation_id: 'reservation_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('instancesSet', InstanceList.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('requesterId', stub[:requester_id].to_s) unless stub[:requester_id].nil?
        xml << Hearth::XML::Node.new('reservationId', stub[:reservation_id].to_s) unless stub[:reservation_id].nil?
        xml
      end
    end

    # List Stubber for InstanceList
    class InstanceList
      def self.default(visited=[])
        return nil if visited.include?('InstanceList')
        visited = visited + ['InstanceList']
        [
          Instance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Instance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Instance
    class Instance
      def self.default(visited=[])
        return nil if visited.include?('Instance')
        visited = visited + ['Instance']
        {
          ami_launch_index: 1,
          image_id: 'image_id',
          instance_id: 'instance_id',
          instance_type: 'instance_type',
          kernel_id: 'kernel_id',
          key_name: 'key_name',
          launch_time: Time.now,
          monitoring: Monitoring.default(visited),
          placement: Placement.default(visited),
          platform: 'platform',
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
          product_codes: ProductCodeList.default(visited),
          public_dns_name: 'public_dns_name',
          public_ip_address: 'public_ip_address',
          ramdisk_id: 'ramdisk_id',
          state: InstanceState.default(visited),
          state_transition_reason: 'state_transition_reason',
          subnet_id: 'subnet_id',
          vpc_id: 'vpc_id',
          architecture: 'architecture',
          block_device_mappings: InstanceBlockDeviceMappingList.default(visited),
          client_token: 'client_token',
          ebs_optimized: false,
          ena_support: false,
          hypervisor: 'hypervisor',
          iam_instance_profile: IamInstanceProfile.default(visited),
          instance_lifecycle: 'instance_lifecycle',
          elastic_gpu_associations: ElasticGpuAssociationList.default(visited),
          elastic_inference_accelerator_associations: ElasticInferenceAcceleratorAssociationList.default(visited),
          network_interfaces: InstanceNetworkInterfaceList.default(visited),
          outpost_arn: 'outpost_arn',
          root_device_name: 'root_device_name',
          root_device_type: 'root_device_type',
          security_groups: GroupIdentifierList.default(visited),
          source_dest_check: false,
          spot_instance_request_id: 'spot_instance_request_id',
          sriov_net_support: 'sriov_net_support',
          state_reason: StateReason.default(visited),
          tags: TagList.default(visited),
          virtualization_type: 'virtualization_type',
          cpu_options: CpuOptions.default(visited),
          capacity_reservation_id: 'capacity_reservation_id',
          capacity_reservation_specification: CapacityReservationSpecificationResponse.default(visited),
          hibernation_options: HibernationOptions.default(visited),
          licenses: LicenseList.default(visited),
          metadata_options: InstanceMetadataOptionsResponse.default(visited),
          enclave_options: EnclaveOptions.default(visited),
          boot_mode: 'boot_mode',
          platform_details: 'platform_details',
          usage_operation: 'usage_operation',
          usage_operation_update_time: Time.now,
          private_dns_name_options: PrivateDnsNameOptionsResponse.default(visited),
          ipv6_address: 'ipv6_address',
          tpm_support: 'tpm_support',
          maintenance_options: InstanceMaintenanceOptions.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('amiLaunchIndex', stub[:ami_launch_index].to_s) unless stub[:ami_launch_index].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('launchTime', Hearth::TimeHelper.to_date_time(stub[:launch_time])) unless stub[:launch_time].nil?
        xml << Monitoring.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml << Placement.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('dnsName', stub[:public_dns_name].to_s) unless stub[:public_dns_name].nil?
        xml << Hearth::XML::Node.new('ipAddress', stub[:public_ip_address].to_s) unless stub[:public_ip_address].nil?
        xml << Hearth::XML::Node.new('ramdiskId', stub[:ramdisk_id].to_s) unless stub[:ramdisk_id].nil?
        xml << InstanceState.stub('instanceState', stub[:state]) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('reason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('architecture', stub[:architecture].to_s) unless stub[:architecture].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', InstanceBlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << Hearth::XML::Node.new('enaSupport', stub[:ena_support].to_s) unless stub[:ena_support].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << IamInstanceProfile.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('instanceLifecycle', stub[:instance_lifecycle].to_s) unless stub[:instance_lifecycle].nil?
        xml << Hearth::XML::Node.new('elasticGpuAssociationSet', ElasticGpuAssociationList.stub('item', stub[:elastic_gpu_associations])) unless stub[:elastic_gpu_associations].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorAssociationSet', ElasticInferenceAcceleratorAssociationList.stub('item', stub[:elastic_inference_accelerator_associations])) unless stub[:elastic_inference_accelerator_associations].nil?
        xml << Hearth::XML::Node.new('networkInterfaceSet', InstanceNetworkInterfaceList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('rootDeviceName', stub[:root_device_name].to_s) unless stub[:root_device_name].nil?
        xml << Hearth::XML::Node.new('rootDeviceType', stub[:root_device_type].to_s) unless stub[:root_device_type].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << Hearth::XML::Node.new('sourceDestCheck', stub[:source_dest_check].to_s) unless stub[:source_dest_check].nil?
        xml << Hearth::XML::Node.new('spotInstanceRequestId', stub[:spot_instance_request_id].to_s) unless stub[:spot_instance_request_id].nil?
        xml << Hearth::XML::Node.new('sriovNetSupport', stub[:sriov_net_support].to_s) unless stub[:sriov_net_support].nil?
        xml << StateReason.stub('stateReason', stub[:state_reason]) unless stub[:state_reason].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('virtualizationType', stub[:virtualization_type].to_s) unless stub[:virtualization_type].nil?
        xml << CpuOptions.stub('cpuOptions', stub[:cpu_options]) unless stub[:cpu_options].nil?
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << CapacityReservationSpecificationResponse.stub('capacityReservationSpecification', stub[:capacity_reservation_specification]) unless stub[:capacity_reservation_specification].nil?
        xml << HibernationOptions.stub('hibernationOptions', stub[:hibernation_options]) unless stub[:hibernation_options].nil?
        xml << Hearth::XML::Node.new('licenseSet', LicenseList.stub('item', stub[:licenses])) unless stub[:licenses].nil?
        xml << InstanceMetadataOptionsResponse.stub('metadataOptions', stub[:metadata_options]) unless stub[:metadata_options].nil?
        xml << EnclaveOptions.stub('enclaveOptions', stub[:enclave_options]) unless stub[:enclave_options].nil?
        xml << Hearth::XML::Node.new('bootMode', stub[:boot_mode].to_s) unless stub[:boot_mode].nil?
        xml << Hearth::XML::Node.new('platformDetails', stub[:platform_details].to_s) unless stub[:platform_details].nil?
        xml << Hearth::XML::Node.new('usageOperation', stub[:usage_operation].to_s) unless stub[:usage_operation].nil?
        xml << Hearth::XML::Node.new('usageOperationUpdateTime', Hearth::TimeHelper.to_date_time(stub[:usage_operation_update_time])) unless stub[:usage_operation_update_time].nil?
        xml << PrivateDnsNameOptionsResponse.stub('privateDnsNameOptions', stub[:private_dns_name_options]) unless stub[:private_dns_name_options].nil?
        xml << Hearth::XML::Node.new('ipv6Address', stub[:ipv6_address].to_s) unless stub[:ipv6_address].nil?
        xml << Hearth::XML::Node.new('tpmSupport', stub[:tpm_support].to_s) unless stub[:tpm_support].nil?
        xml << InstanceMaintenanceOptions.stub('maintenanceOptions', stub[:maintenance_options]) unless stub[:maintenance_options].nil?
        xml
      end
    end

    # Structure Stubber for InstanceMaintenanceOptions
    class InstanceMaintenanceOptions
      def self.default(visited=[])
        return nil if visited.include?('InstanceMaintenanceOptions')
        visited = visited + ['InstanceMaintenanceOptions']
        {
          auto_recovery: 'auto_recovery',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('autoRecovery', stub[:auto_recovery].to_s) unless stub[:auto_recovery].nil?
        xml
      end
    end

    # Structure Stubber for PrivateDnsNameOptionsResponse
    class PrivateDnsNameOptionsResponse
      def self.default(visited=[])
        return nil if visited.include?('PrivateDnsNameOptionsResponse')
        visited = visited + ['PrivateDnsNameOptionsResponse']
        {
          hostname_type: 'hostname_type',
          enable_resource_name_dns_a_record: false,
          enable_resource_name_dns_aaaa_record: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('hostnameType', stub[:hostname_type].to_s) unless stub[:hostname_type].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsARecord', stub[:enable_resource_name_dns_a_record].to_s) unless stub[:enable_resource_name_dns_a_record].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsAAAARecord', stub[:enable_resource_name_dns_aaaa_record].to_s) unless stub[:enable_resource_name_dns_aaaa_record].nil?
        xml
      end
    end

    # Structure Stubber for InstanceMetadataOptionsResponse
    class InstanceMetadataOptionsResponse
      def self.default(visited=[])
        return nil if visited.include?('InstanceMetadataOptionsResponse')
        visited = visited + ['InstanceMetadataOptionsResponse']
        {
          state: 'state',
          http_tokens: 'http_tokens',
          http_put_response_hop_limit: 1,
          http_endpoint: 'http_endpoint',
          http_protocol_ipv6: 'http_protocol_ipv6',
          instance_metadata_tags: 'instance_metadata_tags',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('httpTokens', stub[:http_tokens].to_s) unless stub[:http_tokens].nil?
        xml << Hearth::XML::Node.new('httpPutResponseHopLimit', stub[:http_put_response_hop_limit].to_s) unless stub[:http_put_response_hop_limit].nil?
        xml << Hearth::XML::Node.new('httpEndpoint', stub[:http_endpoint].to_s) unless stub[:http_endpoint].nil?
        xml << Hearth::XML::Node.new('httpProtocolIpv6', stub[:http_protocol_ipv6].to_s) unless stub[:http_protocol_ipv6].nil?
        xml << Hearth::XML::Node.new('instanceMetadataTags', stub[:instance_metadata_tags].to_s) unless stub[:instance_metadata_tags].nil?
        xml
      end
    end

    # List Stubber for LicenseList
    class LicenseList
      def self.default(visited=[])
        return nil if visited.include?('LicenseList')
        visited = visited + ['LicenseList']
        [
          LicenseConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LicenseConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LicenseConfiguration
    class LicenseConfiguration
      def self.default(visited=[])
        return nil if visited.include?('LicenseConfiguration')
        visited = visited + ['LicenseConfiguration']
        {
          license_configuration_arn: 'license_configuration_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('licenseConfigurationArn', stub[:license_configuration_arn].to_s) unless stub[:license_configuration_arn].nil?
        xml
      end
    end

    # Structure Stubber for HibernationOptions
    class HibernationOptions
      def self.default(visited=[])
        return nil if visited.include?('HibernationOptions')
        visited = visited + ['HibernationOptions']
        {
          configured: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('configured', stub[:configured].to_s) unless stub[:configured].nil?
        xml
      end
    end

    # Structure Stubber for CapacityReservationSpecificationResponse
    class CapacityReservationSpecificationResponse
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationSpecificationResponse')
        visited = visited + ['CapacityReservationSpecificationResponse']
        {
          capacity_reservation_preference: 'capacity_reservation_preference',
          capacity_reservation_target: CapacityReservationTargetResponse.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationPreference', stub[:capacity_reservation_preference].to_s) unless stub[:capacity_reservation_preference].nil?
        xml << CapacityReservationTargetResponse.stub('capacityReservationTarget', stub[:capacity_reservation_target]) unless stub[:capacity_reservation_target].nil?
        xml
      end
    end

    # Structure Stubber for CpuOptions
    class CpuOptions
      def self.default(visited=[])
        return nil if visited.include?('CpuOptions')
        visited = visited + ['CpuOptions']
        {
          core_count: 1,
          threads_per_core: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('coreCount', stub[:core_count].to_s) unless stub[:core_count].nil?
        xml << Hearth::XML::Node.new('threadsPerCore', stub[:threads_per_core].to_s) unless stub[:threads_per_core].nil?
        xml
      end
    end

    # List Stubber for InstanceNetworkInterfaceList
    class InstanceNetworkInterfaceList
      def self.default(visited=[])
        return nil if visited.include?('InstanceNetworkInterfaceList')
        visited = visited + ['InstanceNetworkInterfaceList']
        [
          InstanceNetworkInterface.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceNetworkInterface.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceNetworkInterface
    class InstanceNetworkInterface
      def self.default(visited=[])
        return nil if visited.include?('InstanceNetworkInterface')
        visited = visited + ['InstanceNetworkInterface']
        {
          association: InstanceNetworkInterfaceAssociation.default(visited),
          attachment: InstanceNetworkInterfaceAttachment.default(visited),
          description: 'description',
          groups: GroupIdentifierList.default(visited),
          ipv6_addresses: InstanceIpv6AddressList.default(visited),
          mac_address: 'mac_address',
          network_interface_id: 'network_interface_id',
          owner_id: 'owner_id',
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
          private_ip_addresses: InstancePrivateIpAddressList.default(visited),
          source_dest_check: false,
          status: 'status',
          subnet_id: 'subnet_id',
          vpc_id: 'vpc_id',
          interface_type: 'interface_type',
          ipv4_prefixes: InstanceIpv4PrefixList.default(visited),
          ipv6_prefixes: InstanceIpv6PrefixList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << InstanceNetworkInterfaceAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << InstanceNetworkInterfaceAttachment.stub('attachment', stub[:attachment]) unless stub[:attachment].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesSet', InstanceIpv6AddressList.stub('item', stub[:ipv6_addresses])) unless stub[:ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('macAddress', stub[:mac_address].to_s) unless stub[:mac_address].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('privateIpAddressesSet', InstancePrivateIpAddressList.stub('item', stub[:private_ip_addresses])) unless stub[:private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('sourceDestCheck', stub[:source_dest_check].to_s) unless stub[:source_dest_check].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('interfaceType', stub[:interface_type].to_s) unless stub[:interface_type].nil?
        xml << Hearth::XML::Node.new('ipv4PrefixSet', InstanceIpv4PrefixList.stub('item', stub[:ipv4_prefixes])) unless stub[:ipv4_prefixes].nil?
        xml << Hearth::XML::Node.new('ipv6PrefixSet', InstanceIpv6PrefixList.stub('item', stub[:ipv6_prefixes])) unless stub[:ipv6_prefixes].nil?
        xml
      end
    end

    # List Stubber for InstanceIpv6PrefixList
    class InstanceIpv6PrefixList
      def self.default(visited=[])
        return nil if visited.include?('InstanceIpv6PrefixList')
        visited = visited + ['InstanceIpv6PrefixList']
        [
          InstanceIpv6Prefix.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceIpv6Prefix.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceIpv6Prefix
    class InstanceIpv6Prefix
      def self.default(visited=[])
        return nil if visited.include?('InstanceIpv6Prefix')
        visited = visited + ['InstanceIpv6Prefix']
        {
          ipv6_prefix: 'ipv6_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Prefix', stub[:ipv6_prefix].to_s) unless stub[:ipv6_prefix].nil?
        xml
      end
    end

    # List Stubber for InstanceIpv4PrefixList
    class InstanceIpv4PrefixList
      def self.default(visited=[])
        return nil if visited.include?('InstanceIpv4PrefixList')
        visited = visited + ['InstanceIpv4PrefixList']
        [
          InstanceIpv4Prefix.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceIpv4Prefix.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceIpv4Prefix
    class InstanceIpv4Prefix
      def self.default(visited=[])
        return nil if visited.include?('InstanceIpv4Prefix')
        visited = visited + ['InstanceIpv4Prefix']
        {
          ipv4_prefix: 'ipv4_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv4Prefix', stub[:ipv4_prefix].to_s) unless stub[:ipv4_prefix].nil?
        xml
      end
    end

    # List Stubber for InstancePrivateIpAddressList
    class InstancePrivateIpAddressList
      def self.default(visited=[])
        return nil if visited.include?('InstancePrivateIpAddressList')
        visited = visited + ['InstancePrivateIpAddressList']
        [
          InstancePrivateIpAddress.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstancePrivateIpAddress.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstancePrivateIpAddress
    class InstancePrivateIpAddress
      def self.default(visited=[])
        return nil if visited.include?('InstancePrivateIpAddress')
        visited = visited + ['InstancePrivateIpAddress']
        {
          association: InstanceNetworkInterfaceAssociation.default(visited),
          primary: false,
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << InstanceNetworkInterfaceAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << Hearth::XML::Node.new('primary', stub[:primary].to_s) unless stub[:primary].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml
      end
    end

    # Structure Stubber for InstanceNetworkInterfaceAssociation
    class InstanceNetworkInterfaceAssociation
      def self.default(visited=[])
        return nil if visited.include?('InstanceNetworkInterfaceAssociation')
        visited = visited + ['InstanceNetworkInterfaceAssociation']
        {
          carrier_ip: 'carrier_ip',
          customer_owned_ip: 'customer_owned_ip',
          ip_owner_id: 'ip_owner_id',
          public_dns_name: 'public_dns_name',
          public_ip: 'public_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('carrierIp', stub[:carrier_ip].to_s) unless stub[:carrier_ip].nil?
        xml << Hearth::XML::Node.new('customerOwnedIp', stub[:customer_owned_ip].to_s) unless stub[:customer_owned_ip].nil?
        xml << Hearth::XML::Node.new('ipOwnerId', stub[:ip_owner_id].to_s) unless stub[:ip_owner_id].nil?
        xml << Hearth::XML::Node.new('publicDnsName', stub[:public_dns_name].to_s) unless stub[:public_dns_name].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml
      end
    end

    # Structure Stubber for InstanceNetworkInterfaceAttachment
    class InstanceNetworkInterfaceAttachment
      def self.default(visited=[])
        return nil if visited.include?('InstanceNetworkInterfaceAttachment')
        visited = visited + ['InstanceNetworkInterfaceAttachment']
        {
          attach_time: Time.now,
          attachment_id: 'attachment_id',
          delete_on_termination: false,
          device_index: 1,
          status: 'status',
          network_card_index: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('attachmentId', stub[:attachment_id].to_s) unless stub[:attachment_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('deviceIndex', stub[:device_index].to_s) unless stub[:device_index].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml
      end
    end

    # List Stubber for ElasticInferenceAcceleratorAssociationList
    class ElasticInferenceAcceleratorAssociationList
      def self.default(visited=[])
        return nil if visited.include?('ElasticInferenceAcceleratorAssociationList')
        visited = visited + ['ElasticInferenceAcceleratorAssociationList']
        [
          ElasticInferenceAcceleratorAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ElasticInferenceAcceleratorAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ElasticInferenceAcceleratorAssociation
    class ElasticInferenceAcceleratorAssociation
      def self.default(visited=[])
        return nil if visited.include?('ElasticInferenceAcceleratorAssociation')
        visited = visited + ['ElasticInferenceAcceleratorAssociation']
        {
          elastic_inference_accelerator_arn: 'elastic_inference_accelerator_arn',
          elastic_inference_accelerator_association_id: 'elastic_inference_accelerator_association_id',
          elastic_inference_accelerator_association_state: 'elastic_inference_accelerator_association_state',
          elastic_inference_accelerator_association_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorArn', stub[:elastic_inference_accelerator_arn].to_s) unless stub[:elastic_inference_accelerator_arn].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorAssociationId', stub[:elastic_inference_accelerator_association_id].to_s) unless stub[:elastic_inference_accelerator_association_id].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorAssociationState', stub[:elastic_inference_accelerator_association_state].to_s) unless stub[:elastic_inference_accelerator_association_state].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorAssociationTime', Hearth::TimeHelper.to_date_time(stub[:elastic_inference_accelerator_association_time])) unless stub[:elastic_inference_accelerator_association_time].nil?
        xml
      end
    end

    # List Stubber for ElasticGpuAssociationList
    class ElasticGpuAssociationList
      def self.default(visited=[])
        return nil if visited.include?('ElasticGpuAssociationList')
        visited = visited + ['ElasticGpuAssociationList']
        [
          ElasticGpuAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ElasticGpuAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ElasticGpuAssociation
    class ElasticGpuAssociation
      def self.default(visited=[])
        return nil if visited.include?('ElasticGpuAssociation')
        visited = visited + ['ElasticGpuAssociation']
        {
          elastic_gpu_id: 'elastic_gpu_id',
          elastic_gpu_association_id: 'elastic_gpu_association_id',
          elastic_gpu_association_state: 'elastic_gpu_association_state',
          elastic_gpu_association_time: 'elastic_gpu_association_time',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('elasticGpuId', stub[:elastic_gpu_id].to_s) unless stub[:elastic_gpu_id].nil?
        xml << Hearth::XML::Node.new('elasticGpuAssociationId', stub[:elastic_gpu_association_id].to_s) unless stub[:elastic_gpu_association_id].nil?
        xml << Hearth::XML::Node.new('elasticGpuAssociationState', stub[:elastic_gpu_association_state].to_s) unless stub[:elastic_gpu_association_state].nil?
        xml << Hearth::XML::Node.new('elasticGpuAssociationTime', stub[:elastic_gpu_association_time].to_s) unless stub[:elastic_gpu_association_time].nil?
        xml
      end
    end

    # Structure Stubber for Placement
    class Placement
      def self.default(visited=[])
        return nil if visited.include?('Placement')
        visited = visited + ['Placement']
        {
          availability_zone: 'availability_zone',
          affinity: 'affinity',
          group_name: 'group_name',
          partition_number: 1,
          host_id: 'host_id',
          tenancy: 'tenancy',
          spread_domain: 'spread_domain',
          host_resource_group_arn: 'host_resource_group_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('affinity', stub[:affinity].to_s) unless stub[:affinity].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('partitionNumber', stub[:partition_number].to_s) unless stub[:partition_number].nil?
        xml << Hearth::XML::Node.new('hostId', stub[:host_id].to_s) unless stub[:host_id].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('spreadDomain', stub[:spread_domain].to_s) unless stub[:spread_domain].nil?
        xml << Hearth::XML::Node.new('hostResourceGroupArn', stub[:host_resource_group_arn].to_s) unless stub[:host_resource_group_arn].nil?
        xml
      end
    end

    # Structure Stubber for Monitoring
    class Monitoring
      def self.default(visited=[])
        return nil if visited.include?('Monitoring')
        visited = visited + ['Monitoring']
        {
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for DescribeInternetGateways
    class DescribeInternetGateways
      def self.default(visited=[])
        {
          internet_gateways: InternetGatewayList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInternetGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('internetGatewaySet', InternetGatewayList.stub('item', stub[:internet_gateways])) unless stub[:internet_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InternetGatewayList
    class InternetGatewayList
      def self.default(visited=[])
        return nil if visited.include?('InternetGatewayList')
        visited = visited + ['InternetGatewayList']
        [
          InternetGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InternetGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeIpamPools
    class DescribeIpamPools
      def self.default(visited=[])
        {
          next_token: 'next_token',
          ipam_pools: IpamPoolSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpamPoolsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('ipamPoolSet', IpamPoolSet.stub('item', stub[:ipam_pools])) unless stub[:ipam_pools].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IpamPoolSet
    class IpamPoolSet
      def self.default(visited=[])
        return nil if visited.include?('IpamPoolSet')
        visited = visited + ['IpamPoolSet']
        [
          IpamPool.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamPool.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeIpamScopes
    class DescribeIpamScopes
      def self.default(visited=[])
        {
          next_token: 'next_token',
          ipam_scopes: IpamScopeSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpamScopesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('ipamScopeSet', IpamScopeSet.stub('item', stub[:ipam_scopes])) unless stub[:ipam_scopes].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IpamScopeSet
    class IpamScopeSet
      def self.default(visited=[])
        return nil if visited.include?('IpamScopeSet')
        visited = visited + ['IpamScopeSet']
        [
          IpamScope.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamScope.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeIpams
    class DescribeIpams
      def self.default(visited=[])
        {
          next_token: 'next_token',
          ipams: IpamSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpamsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('ipamSet', IpamSet.stub('item', stub[:ipams])) unless stub[:ipams].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IpamSet
    class IpamSet
      def self.default(visited=[])
        return nil if visited.include?('IpamSet')
        visited = visited + ['IpamSet']
        [
          Ipam.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipam.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeIpv6Pools
    class DescribeIpv6Pools
      def self.default(visited=[])
        {
          ipv6_pools: Ipv6PoolSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpv6PoolsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipv6PoolSet', Ipv6PoolSet.stub('item', stub[:ipv6_pools])) unless stub[:ipv6_pools].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for Ipv6PoolSet
    class Ipv6PoolSet
      def self.default(visited=[])
        return nil if visited.include?('Ipv6PoolSet')
        visited = visited + ['Ipv6PoolSet']
        [
          Ipv6Pool.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6Pool.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv6Pool
    class Ipv6Pool
      def self.default(visited=[])
        return nil if visited.include?('Ipv6Pool')
        visited = visited + ['Ipv6Pool']
        {
          pool_id: 'pool_id',
          description: 'description',
          pool_cidr_blocks: PoolCidrBlocksSet.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('poolCidrBlockSet', PoolCidrBlocksSet.stub('item', stub[:pool_cidr_blocks])) unless stub[:pool_cidr_blocks].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for PoolCidrBlocksSet
    class PoolCidrBlocksSet
      def self.default(visited=[])
        return nil if visited.include?('PoolCidrBlocksSet')
        visited = visited + ['PoolCidrBlocksSet']
        [
          PoolCidrBlock.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PoolCidrBlock.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PoolCidrBlock
    class PoolCidrBlock
      def self.default(visited=[])
        return nil if visited.include?('PoolCidrBlock')
        visited = visited + ['PoolCidrBlock']
        {
          cidr: 'cidr',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('poolCidrBlock', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml
      end
    end

    # Operation Stubber for DescribeKeyPairs
    class DescribeKeyPairs
      def self.default(visited=[])
        {
          key_pairs: KeyPairList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeKeyPairsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('keySet', KeyPairList.stub('item', stub[:key_pairs])) unless stub[:key_pairs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for KeyPairList
    class KeyPairList
      def self.default(visited=[])
        return nil if visited.include?('KeyPairList')
        visited = visited + ['KeyPairList']
        [
          KeyPairInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << KeyPairInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for KeyPairInfo
    class KeyPairInfo
      def self.default(visited=[])
        return nil if visited.include?('KeyPairInfo')
        visited = visited + ['KeyPairInfo']
        {
          key_pair_id: 'key_pair_id',
          key_fingerprint: 'key_fingerprint',
          key_name: 'key_name',
          key_type: 'key_type',
          tags: TagList.default(visited),
          public_key: 'public_key',
          create_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('keyPairId', stub[:key_pair_id].to_s) unless stub[:key_pair_id].nil?
        xml << Hearth::XML::Node.new('keyFingerprint', stub[:key_fingerprint].to_s) unless stub[:key_fingerprint].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('keyType', stub[:key_type].to_s) unless stub[:key_type].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('publicKey', stub[:public_key].to_s) unless stub[:public_key].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml
      end
    end

    # Operation Stubber for DescribeLaunchTemplateVersions
    class DescribeLaunchTemplateVersions
      def self.default(visited=[])
        {
          launch_template_versions: LaunchTemplateVersionSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLaunchTemplateVersionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('launchTemplateVersionSet', LaunchTemplateVersionSet.stub('item', stub[:launch_template_versions])) unless stub[:launch_template_versions].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LaunchTemplateVersionSet
    class LaunchTemplateVersionSet
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateVersionSet')
        visited = visited + ['LaunchTemplateVersionSet']
        [
          LaunchTemplateVersion.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateVersion.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeLaunchTemplates
    class DescribeLaunchTemplates
      def self.default(visited=[])
        {
          launch_templates: LaunchTemplateSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLaunchTemplatesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('launchTemplates', LaunchTemplateSet.stub('item', stub[:launch_templates])) unless stub[:launch_templates].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LaunchTemplateSet
    class LaunchTemplateSet
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateSet')
        visited = visited + ['LaunchTemplateSet']
        [
          LaunchTemplate.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplate.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations
    class DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations
      def self.default(visited=[])
        {
          local_gateway_route_table_virtual_interface_group_associations: LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayRouteTableVirtualInterfaceGroupAssociationSet', LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.stub('item', stub[:local_gateway_route_table_virtual_interface_group_associations])) unless stub[:local_gateway_route_table_virtual_interface_group_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet
    class LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet')
        visited = visited + ['LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet']
        [
          LocalGatewayRouteTableVirtualInterfaceGroupAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayRouteTableVirtualInterfaceGroupAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LocalGatewayRouteTableVirtualInterfaceGroupAssociation
    class LocalGatewayRouteTableVirtualInterfaceGroupAssociation
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayRouteTableVirtualInterfaceGroupAssociation')
        visited = visited + ['LocalGatewayRouteTableVirtualInterfaceGroupAssociation']
        {
          local_gateway_route_table_virtual_interface_group_association_id: 'local_gateway_route_table_virtual_interface_group_association_id',
          local_gateway_virtual_interface_group_id: 'local_gateway_virtual_interface_group_id',
          local_gateway_id: 'local_gateway_id',
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          local_gateway_route_table_arn: 'local_gateway_route_table_arn',
          owner_id: 'owner_id',
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayRouteTableVirtualInterfaceGroupAssociationId', stub[:local_gateway_route_table_virtual_interface_group_association_id].to_s) unless stub[:local_gateway_route_table_virtual_interface_group_association_id].nil?
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceGroupId', stub[:local_gateway_virtual_interface_group_id].to_s) unless stub[:local_gateway_virtual_interface_group_id].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableArn', stub[:local_gateway_route_table_arn].to_s) unless stub[:local_gateway_route_table_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for DescribeLocalGatewayRouteTableVpcAssociations
    class DescribeLocalGatewayRouteTableVpcAssociations
      def self.default(visited=[])
        {
          local_gateway_route_table_vpc_associations: LocalGatewayRouteTableVpcAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayRouteTableVpcAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayRouteTableVpcAssociationSet', LocalGatewayRouteTableVpcAssociationSet.stub('item', stub[:local_gateway_route_table_vpc_associations])) unless stub[:local_gateway_route_table_vpc_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LocalGatewayRouteTableVpcAssociationSet
    class LocalGatewayRouteTableVpcAssociationSet
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayRouteTableVpcAssociationSet')
        visited = visited + ['LocalGatewayRouteTableVpcAssociationSet']
        [
          LocalGatewayRouteTableVpcAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayRouteTableVpcAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeLocalGatewayRouteTables
    class DescribeLocalGatewayRouteTables
      def self.default(visited=[])
        {
          local_gateway_route_tables: LocalGatewayRouteTableSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayRouteTablesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayRouteTableSet', LocalGatewayRouteTableSet.stub('item', stub[:local_gateway_route_tables])) unless stub[:local_gateway_route_tables].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LocalGatewayRouteTableSet
    class LocalGatewayRouteTableSet
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayRouteTableSet')
        visited = visited + ['LocalGatewayRouteTableSet']
        [
          LocalGatewayRouteTable.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayRouteTable.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LocalGatewayRouteTable
    class LocalGatewayRouteTable
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayRouteTable')
        visited = visited + ['LocalGatewayRouteTable']
        {
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          local_gateway_route_table_arn: 'local_gateway_route_table_arn',
          local_gateway_id: 'local_gateway_id',
          outpost_arn: 'outpost_arn',
          owner_id: 'owner_id',
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableArn', stub[:local_gateway_route_table_arn].to_s) unless stub[:local_gateway_route_table_arn].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for DescribeLocalGatewayVirtualInterfaceGroups
    class DescribeLocalGatewayVirtualInterfaceGroups
      def self.default(visited=[])
        {
          local_gateway_virtual_interface_groups: LocalGatewayVirtualInterfaceGroupSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayVirtualInterfaceGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceGroupSet', LocalGatewayVirtualInterfaceGroupSet.stub('item', stub[:local_gateway_virtual_interface_groups])) unless stub[:local_gateway_virtual_interface_groups].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LocalGatewayVirtualInterfaceGroupSet
    class LocalGatewayVirtualInterfaceGroupSet
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayVirtualInterfaceGroupSet')
        visited = visited + ['LocalGatewayVirtualInterfaceGroupSet']
        [
          LocalGatewayVirtualInterfaceGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayVirtualInterfaceGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LocalGatewayVirtualInterfaceGroup
    class LocalGatewayVirtualInterfaceGroup
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayVirtualInterfaceGroup')
        visited = visited + ['LocalGatewayVirtualInterfaceGroup']
        {
          local_gateway_virtual_interface_group_id: 'local_gateway_virtual_interface_group_id',
          local_gateway_virtual_interface_ids: LocalGatewayVirtualInterfaceIdSet.default(visited),
          local_gateway_id: 'local_gateway_id',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceGroupId', stub[:local_gateway_virtual_interface_group_id].to_s) unless stub[:local_gateway_virtual_interface_group_id].nil?
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceIdSet', LocalGatewayVirtualInterfaceIdSet.stub('item', stub[:local_gateway_virtual_interface_ids])) unless stub[:local_gateway_virtual_interface_ids].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for LocalGatewayVirtualInterfaceIdSet
    class LocalGatewayVirtualInterfaceIdSet
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayVirtualInterfaceIdSet')
        visited = visited + ['LocalGatewayVirtualInterfaceIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeLocalGatewayVirtualInterfaces
    class DescribeLocalGatewayVirtualInterfaces
      def self.default(visited=[])
        {
          local_gateway_virtual_interfaces: LocalGatewayVirtualInterfaceSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayVirtualInterfacesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceSet', LocalGatewayVirtualInterfaceSet.stub('item', stub[:local_gateway_virtual_interfaces])) unless stub[:local_gateway_virtual_interfaces].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LocalGatewayVirtualInterfaceSet
    class LocalGatewayVirtualInterfaceSet
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayVirtualInterfaceSet')
        visited = visited + ['LocalGatewayVirtualInterfaceSet']
        [
          LocalGatewayVirtualInterface.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayVirtualInterface.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LocalGatewayVirtualInterface
    class LocalGatewayVirtualInterface
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayVirtualInterface')
        visited = visited + ['LocalGatewayVirtualInterface']
        {
          local_gateway_virtual_interface_id: 'local_gateway_virtual_interface_id',
          local_gateway_id: 'local_gateway_id',
          vlan: 1,
          local_address: 'local_address',
          peer_address: 'peer_address',
          local_bgp_asn: 1,
          peer_bgp_asn: 1,
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceId', stub[:local_gateway_virtual_interface_id].to_s) unless stub[:local_gateway_virtual_interface_id].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('vlan', stub[:vlan].to_s) unless stub[:vlan].nil?
        xml << Hearth::XML::Node.new('localAddress', stub[:local_address].to_s) unless stub[:local_address].nil?
        xml << Hearth::XML::Node.new('peerAddress', stub[:peer_address].to_s) unless stub[:peer_address].nil?
        xml << Hearth::XML::Node.new('localBgpAsn', stub[:local_bgp_asn].to_s) unless stub[:local_bgp_asn].nil?
        xml << Hearth::XML::Node.new('peerBgpAsn', stub[:peer_bgp_asn].to_s) unless stub[:peer_bgp_asn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for DescribeLocalGateways
    class DescribeLocalGateways
      def self.default(visited=[])
        {
          local_gateways: LocalGatewaySet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewaySet', LocalGatewaySet.stub('item', stub[:local_gateways])) unless stub[:local_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LocalGatewaySet
    class LocalGatewaySet
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewaySet')
        visited = visited + ['LocalGatewaySet']
        [
          LocalGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LocalGateway
    class LocalGateway
      def self.default(visited=[])
        return nil if visited.include?('LocalGateway')
        visited = visited + ['LocalGateway']
        {
          local_gateway_id: 'local_gateway_id',
          outpost_arn: 'outpost_arn',
          owner_id: 'owner_id',
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for DescribeManagedPrefixLists
    class DescribeManagedPrefixLists
      def self.default(visited=[])
        {
          next_token: 'next_token',
          prefix_lists: ManagedPrefixListSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeManagedPrefixListsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('prefixListSet', ManagedPrefixListSet.stub('item', stub[:prefix_lists])) unless stub[:prefix_lists].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ManagedPrefixListSet
    class ManagedPrefixListSet
      def self.default(visited=[])
        return nil if visited.include?('ManagedPrefixListSet')
        visited = visited + ['ManagedPrefixListSet']
        [
          ManagedPrefixList.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ManagedPrefixList.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeMovingAddresses
    class DescribeMovingAddresses
      def self.default(visited=[])
        {
          moving_address_statuses: MovingAddressStatusSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeMovingAddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('movingAddressStatusSet', MovingAddressStatusSet.stub('item', stub[:moving_address_statuses])) unless stub[:moving_address_statuses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for MovingAddressStatusSet
    class MovingAddressStatusSet
      def self.default(visited=[])
        return nil if visited.include?('MovingAddressStatusSet')
        visited = visited + ['MovingAddressStatusSet']
        [
          MovingAddressStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << MovingAddressStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for MovingAddressStatus
    class MovingAddressStatus
      def self.default(visited=[])
        return nil if visited.include?('MovingAddressStatus')
        visited = visited + ['MovingAddressStatus']
        {
          move_status: 'move_status',
          public_ip: 'public_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('moveStatus', stub[:move_status].to_s) unless stub[:move_status].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml
      end
    end

    # Operation Stubber for DescribeNatGateways
    class DescribeNatGateways
      def self.default(visited=[])
        {
          nat_gateways: NatGatewayList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNatGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('natGatewaySet', NatGatewayList.stub('item', stub[:nat_gateways])) unless stub[:nat_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for NatGatewayList
    class NatGatewayList
      def self.default(visited=[])
        return nil if visited.include?('NatGatewayList')
        visited = visited + ['NatGatewayList']
        [
          NatGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NatGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeNetworkAcls
    class DescribeNetworkAcls
      def self.default(visited=[])
        {
          network_acls: NetworkAclList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkAclsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkAclSet', NetworkAclList.stub('item', stub[:network_acls])) unless stub[:network_acls].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for NetworkAclList
    class NetworkAclList
      def self.default(visited=[])
        return nil if visited.include?('NetworkAclList')
        visited = visited + ['NetworkAclList']
        [
          NetworkAcl.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkAcl.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeNetworkInsightsAccessScopeAnalyses
    class DescribeNetworkInsightsAccessScopeAnalyses
      def self.default(visited=[])
        {
          network_insights_access_scope_analyses: NetworkInsightsAccessScopeAnalysisList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInsightsAccessScopeAnalysesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisSet', NetworkInsightsAccessScopeAnalysisList.stub('item', stub[:network_insights_access_scope_analyses])) unless stub[:network_insights_access_scope_analyses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for NetworkInsightsAccessScopeAnalysisList
    class NetworkInsightsAccessScopeAnalysisList
      def self.default(visited=[])
        return nil if visited.include?('NetworkInsightsAccessScopeAnalysisList')
        visited = visited + ['NetworkInsightsAccessScopeAnalysisList']
        [
          NetworkInsightsAccessScopeAnalysis.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInsightsAccessScopeAnalysis.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NetworkInsightsAccessScopeAnalysis
    class NetworkInsightsAccessScopeAnalysis
      def self.default(visited=[])
        return nil if visited.include?('NetworkInsightsAccessScopeAnalysis')
        visited = visited + ['NetworkInsightsAccessScopeAnalysis']
        {
          network_insights_access_scope_analysis_id: 'network_insights_access_scope_analysis_id',
          network_insights_access_scope_analysis_arn: 'network_insights_access_scope_analysis_arn',
          network_insights_access_scope_id: 'network_insights_access_scope_id',
          status: 'status',
          status_message: 'status_message',
          warning_message: 'warning_message',
          start_date: Time.now,
          end_date: Time.now,
          findings_found: 'findings_found',
          analyzed_eni_count: 1,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisId', stub[:network_insights_access_scope_analysis_id].to_s) unless stub[:network_insights_access_scope_analysis_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisArn', stub[:network_insights_access_scope_analysis_arn].to_s) unless stub[:network_insights_access_scope_analysis_arn].nil?
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('warningMessage', stub[:warning_message].to_s) unless stub[:warning_message].nil?
        xml << Hearth::XML::Node.new('startDate', Hearth::TimeHelper.to_date_time(stub[:start_date])) unless stub[:start_date].nil?
        xml << Hearth::XML::Node.new('endDate', Hearth::TimeHelper.to_date_time(stub[:end_date])) unless stub[:end_date].nil?
        xml << Hearth::XML::Node.new('findingsFound', stub[:findings_found].to_s) unless stub[:findings_found].nil?
        xml << Hearth::XML::Node.new('analyzedEniCount', stub[:analyzed_eni_count].to_s) unless stub[:analyzed_eni_count].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Operation Stubber for DescribeNetworkInsightsAccessScopes
    class DescribeNetworkInsightsAccessScopes
      def self.default(visited=[])
        {
          network_insights_access_scopes: NetworkInsightsAccessScopeList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInsightsAccessScopesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeSet', NetworkInsightsAccessScopeList.stub('item', stub[:network_insights_access_scopes])) unless stub[:network_insights_access_scopes].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for NetworkInsightsAccessScopeList
    class NetworkInsightsAccessScopeList
      def self.default(visited=[])
        return nil if visited.include?('NetworkInsightsAccessScopeList')
        visited = visited + ['NetworkInsightsAccessScopeList']
        [
          NetworkInsightsAccessScope.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInsightsAccessScope.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeNetworkInsightsAnalyses
    class DescribeNetworkInsightsAnalyses
      def self.default(visited=[])
        {
          network_insights_analyses: NetworkInsightsAnalysisList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInsightsAnalysesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAnalysisSet', NetworkInsightsAnalysisList.stub('item', stub[:network_insights_analyses])) unless stub[:network_insights_analyses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for NetworkInsightsAnalysisList
    class NetworkInsightsAnalysisList
      def self.default(visited=[])
        return nil if visited.include?('NetworkInsightsAnalysisList')
        visited = visited + ['NetworkInsightsAnalysisList']
        [
          NetworkInsightsAnalysis.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInsightsAnalysis.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for NetworkInsightsAnalysis
    class NetworkInsightsAnalysis
      def self.default(visited=[])
        return nil if visited.include?('NetworkInsightsAnalysis')
        visited = visited + ['NetworkInsightsAnalysis']
        {
          network_insights_analysis_id: 'network_insights_analysis_id',
          network_insights_analysis_arn: 'network_insights_analysis_arn',
          network_insights_path_id: 'network_insights_path_id',
          filter_in_arns: ArnList.default(visited),
          start_date: Time.now,
          status: 'status',
          status_message: 'status_message',
          warning_message: 'warning_message',
          network_path_found: false,
          forward_path_components: PathComponentList.default(visited),
          return_path_components: PathComponentList.default(visited),
          explanations: ExplanationList.default(visited),
          alternate_path_hints: AlternatePathHintList.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAnalysisId', stub[:network_insights_analysis_id].to_s) unless stub[:network_insights_analysis_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsAnalysisArn', stub[:network_insights_analysis_arn].to_s) unless stub[:network_insights_analysis_arn].nil?
        xml << Hearth::XML::Node.new('networkInsightsPathId', stub[:network_insights_path_id].to_s) unless stub[:network_insights_path_id].nil?
        xml << Hearth::XML::Node.new('filterInArnSet', ArnList.stub('item', stub[:filter_in_arns])) unless stub[:filter_in_arns].nil?
        xml << Hearth::XML::Node.new('startDate', Hearth::TimeHelper.to_date_time(stub[:start_date])) unless stub[:start_date].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('warningMessage', stub[:warning_message].to_s) unless stub[:warning_message].nil?
        xml << Hearth::XML::Node.new('networkPathFound', stub[:network_path_found].to_s) unless stub[:network_path_found].nil?
        xml << Hearth::XML::Node.new('forwardPathComponentSet', PathComponentList.stub('item', stub[:forward_path_components])) unless stub[:forward_path_components].nil?
        xml << Hearth::XML::Node.new('returnPathComponentSet', PathComponentList.stub('item', stub[:return_path_components])) unless stub[:return_path_components].nil?
        xml << Hearth::XML::Node.new('explanationSet', ExplanationList.stub('item', stub[:explanations])) unless stub[:explanations].nil?
        xml << Hearth::XML::Node.new('alternatePathHintSet', AlternatePathHintList.stub('item', stub[:alternate_path_hints])) unless stub[:alternate_path_hints].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for AlternatePathHintList
    class AlternatePathHintList
      def self.default(visited=[])
        return nil if visited.include?('AlternatePathHintList')
        visited = visited + ['AlternatePathHintList']
        [
          AlternatePathHint.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AlternatePathHint.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AlternatePathHint
    class AlternatePathHint
      def self.default(visited=[])
        return nil if visited.include?('AlternatePathHint')
        visited = visited + ['AlternatePathHint']
        {
          component_id: 'component_id',
          component_arn: 'component_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('componentId', stub[:component_id].to_s) unless stub[:component_id].nil?
        xml << Hearth::XML::Node.new('componentArn', stub[:component_arn].to_s) unless stub[:component_arn].nil?
        xml
      end
    end

    # List Stubber for ExplanationList
    class ExplanationList
      def self.default(visited=[])
        return nil if visited.include?('ExplanationList')
        visited = visited + ['ExplanationList']
        [
          Explanation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Explanation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Explanation
    class Explanation
      def self.default(visited=[])
        return nil if visited.include?('Explanation')
        visited = visited + ['Explanation']
        {
          acl: AnalysisComponent.default(visited),
          acl_rule: AnalysisAclRule.default(visited),
          address: 'address',
          addresses: IpAddressList.default(visited),
          attached_to: AnalysisComponent.default(visited),
          availability_zones: ValueStringList.default(visited),
          cidrs: ValueStringList.default(visited),
          component: AnalysisComponent.default(visited),
          customer_gateway: AnalysisComponent.default(visited),
          destination: AnalysisComponent.default(visited),
          destination_vpc: AnalysisComponent.default(visited),
          direction: 'direction',
          explanation_code: 'explanation_code',
          ingress_route_table: AnalysisComponent.default(visited),
          internet_gateway: AnalysisComponent.default(visited),
          load_balancer_arn: 'load_balancer_arn',
          classic_load_balancer_listener: AnalysisLoadBalancerListener.default(visited),
          load_balancer_listener_port: 1,
          load_balancer_target: AnalysisLoadBalancerTarget.default(visited),
          load_balancer_target_group: AnalysisComponent.default(visited),
          load_balancer_target_groups: AnalysisComponentList.default(visited),
          load_balancer_target_port: 1,
          elastic_load_balancer_listener: AnalysisComponent.default(visited),
          missing_component: 'missing_component',
          nat_gateway: AnalysisComponent.default(visited),
          network_interface: AnalysisComponent.default(visited),
          packet_field: 'packet_field',
          vpc_peering_connection: AnalysisComponent.default(visited),
          port: 1,
          port_ranges: PortRangeList.default(visited),
          prefix_list: AnalysisComponent.default(visited),
          protocols: StringList.default(visited),
          route_table_route: AnalysisRouteTableRoute.default(visited),
          route_table: AnalysisComponent.default(visited),
          security_group: AnalysisComponent.default(visited),
          security_group_rule: AnalysisSecurityGroupRule.default(visited),
          security_groups: AnalysisComponentList.default(visited),
          source_vpc: AnalysisComponent.default(visited),
          state: 'state',
          subnet: AnalysisComponent.default(visited),
          subnet_route_table: AnalysisComponent.default(visited),
          vpc: AnalysisComponent.default(visited),
          vpc_endpoint: AnalysisComponent.default(visited),
          vpn_connection: AnalysisComponent.default(visited),
          vpn_gateway: AnalysisComponent.default(visited),
          transit_gateway: AnalysisComponent.default(visited),
          transit_gateway_route_table: AnalysisComponent.default(visited),
          transit_gateway_route_table_route: TransitGatewayRouteTableRoute.default(visited),
          transit_gateway_attachment: AnalysisComponent.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << AnalysisComponent.stub('acl', stub[:acl]) unless stub[:acl].nil?
        xml << AnalysisAclRule.stub('aclRule', stub[:acl_rule]) unless stub[:acl_rule].nil?
        xml << Hearth::XML::Node.new('address', stub[:address].to_s) unless stub[:address].nil?
        xml << Hearth::XML::Node.new('addressSet', IpAddressList.stub('item', stub[:addresses])) unless stub[:addresses].nil?
        xml << AnalysisComponent.stub('attachedTo', stub[:attached_to]) unless stub[:attached_to].nil?
        xml << Hearth::XML::Node.new('availabilityZoneSet', ValueStringList.stub('item', stub[:availability_zones])) unless stub[:availability_zones].nil?
        xml << Hearth::XML::Node.new('cidrSet', ValueStringList.stub('item', stub[:cidrs])) unless stub[:cidrs].nil?
        xml << AnalysisComponent.stub('component', stub[:component]) unless stub[:component].nil?
        xml << AnalysisComponent.stub('customerGateway', stub[:customer_gateway]) unless stub[:customer_gateway].nil?
        xml << AnalysisComponent.stub('destination', stub[:destination]) unless stub[:destination].nil?
        xml << AnalysisComponent.stub('destinationVpc', stub[:destination_vpc]) unless stub[:destination_vpc].nil?
        xml << Hearth::XML::Node.new('direction', stub[:direction].to_s) unless stub[:direction].nil?
        xml << Hearth::XML::Node.new('explanationCode', stub[:explanation_code].to_s) unless stub[:explanation_code].nil?
        xml << AnalysisComponent.stub('ingressRouteTable', stub[:ingress_route_table]) unless stub[:ingress_route_table].nil?
        xml << AnalysisComponent.stub('internetGateway', stub[:internet_gateway]) unless stub[:internet_gateway].nil?
        xml << Hearth::XML::Node.new('loadBalancerArn', stub[:load_balancer_arn].to_s) unless stub[:load_balancer_arn].nil?
        xml << AnalysisLoadBalancerListener.stub('classicLoadBalancerListener', stub[:classic_load_balancer_listener]) unless stub[:classic_load_balancer_listener].nil?
        xml << Hearth::XML::Node.new('loadBalancerListenerPort', stub[:load_balancer_listener_port].to_s) unless stub[:load_balancer_listener_port].nil?
        xml << AnalysisLoadBalancerTarget.stub('loadBalancerTarget', stub[:load_balancer_target]) unless stub[:load_balancer_target].nil?
        xml << AnalysisComponent.stub('loadBalancerTargetGroup', stub[:load_balancer_target_group]) unless stub[:load_balancer_target_group].nil?
        xml << Hearth::XML::Node.new('loadBalancerTargetGroupSet', AnalysisComponentList.stub('item', stub[:load_balancer_target_groups])) unless stub[:load_balancer_target_groups].nil?
        xml << Hearth::XML::Node.new('loadBalancerTargetPort', stub[:load_balancer_target_port].to_s) unless stub[:load_balancer_target_port].nil?
        xml << AnalysisComponent.stub('elasticLoadBalancerListener', stub[:elastic_load_balancer_listener]) unless stub[:elastic_load_balancer_listener].nil?
        xml << Hearth::XML::Node.new('missingComponent', stub[:missing_component].to_s) unless stub[:missing_component].nil?
        xml << AnalysisComponent.stub('natGateway', stub[:nat_gateway]) unless stub[:nat_gateway].nil?
        xml << AnalysisComponent.stub('networkInterface', stub[:network_interface]) unless stub[:network_interface].nil?
        xml << Hearth::XML::Node.new('packetField', stub[:packet_field].to_s) unless stub[:packet_field].nil?
        xml << AnalysisComponent.stub('vpcPeeringConnection', stub[:vpc_peering_connection]) unless stub[:vpc_peering_connection].nil?
        xml << Hearth::XML::Node.new('port', stub[:port].to_s) unless stub[:port].nil?
        xml << Hearth::XML::Node.new('portRangeSet', PortRangeList.stub('item', stub[:port_ranges])) unless stub[:port_ranges].nil?
        xml << AnalysisComponent.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        xml << Hearth::XML::Node.new('protocolSet', StringList.stub('item', stub[:protocols])) unless stub[:protocols].nil?
        xml << AnalysisRouteTableRoute.stub('routeTableRoute', stub[:route_table_route]) unless stub[:route_table_route].nil?
        xml << AnalysisComponent.stub('routeTable', stub[:route_table]) unless stub[:route_table].nil?
        xml << AnalysisComponent.stub('securityGroup', stub[:security_group]) unless stub[:security_group].nil?
        xml << AnalysisSecurityGroupRule.stub('securityGroupRule', stub[:security_group_rule]) unless stub[:security_group_rule].nil?
        xml << Hearth::XML::Node.new('securityGroupSet', AnalysisComponentList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << AnalysisComponent.stub('sourceVpc', stub[:source_vpc]) unless stub[:source_vpc].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << AnalysisComponent.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        xml << AnalysisComponent.stub('subnetRouteTable', stub[:subnet_route_table]) unless stub[:subnet_route_table].nil?
        xml << AnalysisComponent.stub('vpc', stub[:vpc]) unless stub[:vpc].nil?
        xml << AnalysisComponent.stub('vpcEndpoint', stub[:vpc_endpoint]) unless stub[:vpc_endpoint].nil?
        xml << AnalysisComponent.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        xml << AnalysisComponent.stub('vpnGateway', stub[:vpn_gateway]) unless stub[:vpn_gateway].nil?
        xml << AnalysisComponent.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        xml << AnalysisComponent.stub('transitGatewayRouteTable', stub[:transit_gateway_route_table]) unless stub[:transit_gateway_route_table].nil?
        xml << TransitGatewayRouteTableRoute.stub('transitGatewayRouteTableRoute', stub[:transit_gateway_route_table_route]) unless stub[:transit_gateway_route_table_route].nil?
        xml << AnalysisComponent.stub('transitGatewayAttachment', stub[:transit_gateway_attachment]) unless stub[:transit_gateway_attachment].nil?
        xml
      end
    end

    # Structure Stubber for AnalysisComponent
    class AnalysisComponent
      def self.default(visited=[])
        return nil if visited.include?('AnalysisComponent')
        visited = visited + ['AnalysisComponent']
        {
          id: 'id',
          arn: 'arn',
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('id', stub[:id].to_s) unless stub[:id].nil?
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    # Structure Stubber for TransitGatewayRouteTableRoute
    class TransitGatewayRouteTableRoute
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteTableRoute')
        visited = visited + ['TransitGatewayRouteTableRoute']
        {
          destination_cidr: 'destination_cidr',
          state: 'state',
          route_origin: 'route_origin',
          prefix_list_id: 'prefix_list_id',
          attachment_id: 'attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidr', stub[:destination_cidr].to_s) unless stub[:destination_cidr].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('routeOrigin', stub[:route_origin].to_s) unless stub[:route_origin].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('attachmentId', stub[:attachment_id].to_s) unless stub[:attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml
      end
    end

    # List Stubber for AnalysisComponentList
    class AnalysisComponentList
      def self.default(visited=[])
        return nil if visited.include?('AnalysisComponentList')
        visited = visited + ['AnalysisComponentList']
        [
          AnalysisComponent.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AnalysisComponent.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AnalysisSecurityGroupRule
    class AnalysisSecurityGroupRule
      def self.default(visited=[])
        return nil if visited.include?('AnalysisSecurityGroupRule')
        visited = visited + ['AnalysisSecurityGroupRule']
        {
          cidr: 'cidr',
          direction: 'direction',
          security_group_id: 'security_group_id',
          port_range: PortRange.default(visited),
          prefix_list_id: 'prefix_list_id',
          protocol: 'protocol',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('direction', stub[:direction].to_s) unless stub[:direction].nil?
        xml << Hearth::XML::Node.new('securityGroupId', stub[:security_group_id].to_s) unless stub[:security_group_id].nil?
        xml << PortRange.stub('portRange', stub[:port_range]) unless stub[:port_range].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml
      end
    end

    # Structure Stubber for AnalysisRouteTableRoute
    class AnalysisRouteTableRoute
      def self.default(visited=[])
        return nil if visited.include?('AnalysisRouteTableRoute')
        visited = visited + ['AnalysisRouteTableRoute']
        {
          destination_cidr: 'destination_cidr',
          destination_prefix_list_id: 'destination_prefix_list_id',
          egress_only_internet_gateway_id: 'egress_only_internet_gateway_id',
          gateway_id: 'gateway_id',
          instance_id: 'instance_id',
          nat_gateway_id: 'nat_gateway_id',
          network_interface_id: 'network_interface_id',
          origin: 'origin',
          transit_gateway_id: 'transit_gateway_id',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidr', stub[:destination_cidr].to_s) unless stub[:destination_cidr].nil?
        xml << Hearth::XML::Node.new('destinationPrefixListId', stub[:destination_prefix_list_id].to_s) unless stub[:destination_prefix_list_id].nil?
        xml << Hearth::XML::Node.new('egressOnlyInternetGatewayId', stub[:egress_only_internet_gateway_id].to_s) unless stub[:egress_only_internet_gateway_id].nil?
        xml << Hearth::XML::Node.new('gatewayId', stub[:gateway_id].to_s) unless stub[:gateway_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('origin', stub[:origin].to_s) unless stub[:origin].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml
      end
    end

    # List Stubber for StringList
    class StringList
      def self.default(visited=[])
        return nil if visited.include?('StringList')
        visited = visited + ['StringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for PortRangeList
    class PortRangeList
      def self.default(visited=[])
        return nil if visited.include?('PortRangeList')
        visited = visited + ['PortRangeList']
        [
          PortRange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PortRange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AnalysisLoadBalancerTarget
    class AnalysisLoadBalancerTarget
      def self.default(visited=[])
        return nil if visited.include?('AnalysisLoadBalancerTarget')
        visited = visited + ['AnalysisLoadBalancerTarget']
        {
          address: 'address',
          availability_zone: 'availability_zone',
          instance: AnalysisComponent.default(visited),
          port: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('address', stub[:address].to_s) unless stub[:address].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << AnalysisComponent.stub('instance', stub[:instance]) unless stub[:instance].nil?
        xml << Hearth::XML::Node.new('port', stub[:port].to_s) unless stub[:port].nil?
        xml
      end
    end

    # Structure Stubber for AnalysisLoadBalancerListener
    class AnalysisLoadBalancerListener
      def self.default(visited=[])
        return nil if visited.include?('AnalysisLoadBalancerListener')
        visited = visited + ['AnalysisLoadBalancerListener']
        {
          load_balancer_port: 1,
          instance_port: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('loadBalancerPort', stub[:load_balancer_port].to_s) unless stub[:load_balancer_port].nil?
        xml << Hearth::XML::Node.new('instancePort', stub[:instance_port].to_s) unless stub[:instance_port].nil?
        xml
      end
    end

    # List Stubber for IpAddressList
    class IpAddressList
      def self.default(visited=[])
        return nil if visited.include?('IpAddressList')
        visited = visited + ['IpAddressList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AnalysisAclRule
    class AnalysisAclRule
      def self.default(visited=[])
        return nil if visited.include?('AnalysisAclRule')
        visited = visited + ['AnalysisAclRule']
        {
          cidr: 'cidr',
          egress: false,
          port_range: PortRange.default(visited),
          protocol: 'protocol',
          rule_action: 'rule_action',
          rule_number: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('egress', stub[:egress].to_s) unless stub[:egress].nil?
        xml << PortRange.stub('portRange', stub[:port_range]) unless stub[:port_range].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('ruleAction', stub[:rule_action].to_s) unless stub[:rule_action].nil?
        xml << Hearth::XML::Node.new('ruleNumber', stub[:rule_number].to_s) unless stub[:rule_number].nil?
        xml
      end
    end

    # List Stubber for PathComponentList
    class PathComponentList
      def self.default(visited=[])
        return nil if visited.include?('PathComponentList')
        visited = visited + ['PathComponentList']
        [
          PathComponent.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PathComponent.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PathComponent
    class PathComponent
      def self.default(visited=[])
        return nil if visited.include?('PathComponent')
        visited = visited + ['PathComponent']
        {
          sequence_number: 1,
          acl_rule: AnalysisAclRule.default(visited),
          attached_to: AnalysisComponent.default(visited),
          component: AnalysisComponent.default(visited),
          destination_vpc: AnalysisComponent.default(visited),
          outbound_header: AnalysisPacketHeader.default(visited),
          inbound_header: AnalysisPacketHeader.default(visited),
          route_table_route: AnalysisRouteTableRoute.default(visited),
          security_group_rule: AnalysisSecurityGroupRule.default(visited),
          source_vpc: AnalysisComponent.default(visited),
          subnet: AnalysisComponent.default(visited),
          vpc: AnalysisComponent.default(visited),
          additional_details: AdditionalDetailList.default(visited),
          transit_gateway: AnalysisComponent.default(visited),
          transit_gateway_route_table_route: TransitGatewayRouteTableRoute.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sequenceNumber', stub[:sequence_number].to_s) unless stub[:sequence_number].nil?
        xml << AnalysisAclRule.stub('aclRule', stub[:acl_rule]) unless stub[:acl_rule].nil?
        xml << AnalysisComponent.stub('attachedTo', stub[:attached_to]) unless stub[:attached_to].nil?
        xml << AnalysisComponent.stub('component', stub[:component]) unless stub[:component].nil?
        xml << AnalysisComponent.stub('destinationVpc', stub[:destination_vpc]) unless stub[:destination_vpc].nil?
        xml << AnalysisPacketHeader.stub('outboundHeader', stub[:outbound_header]) unless stub[:outbound_header].nil?
        xml << AnalysisPacketHeader.stub('inboundHeader', stub[:inbound_header]) unless stub[:inbound_header].nil?
        xml << AnalysisRouteTableRoute.stub('routeTableRoute', stub[:route_table_route]) unless stub[:route_table_route].nil?
        xml << AnalysisSecurityGroupRule.stub('securityGroupRule', stub[:security_group_rule]) unless stub[:security_group_rule].nil?
        xml << AnalysisComponent.stub('sourceVpc', stub[:source_vpc]) unless stub[:source_vpc].nil?
        xml << AnalysisComponent.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        xml << AnalysisComponent.stub('vpc', stub[:vpc]) unless stub[:vpc].nil?
        xml << Hearth::XML::Node.new('additionalDetailSet', AdditionalDetailList.stub('item', stub[:additional_details])) unless stub[:additional_details].nil?
        xml << AnalysisComponent.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        xml << TransitGatewayRouteTableRoute.stub('transitGatewayRouteTableRoute', stub[:transit_gateway_route_table_route]) unless stub[:transit_gateway_route_table_route].nil?
        xml
      end
    end

    # List Stubber for AdditionalDetailList
    class AdditionalDetailList
      def self.default(visited=[])
        return nil if visited.include?('AdditionalDetailList')
        visited = visited + ['AdditionalDetailList']
        [
          AdditionalDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AdditionalDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AdditionalDetail
    class AdditionalDetail
      def self.default(visited=[])
        return nil if visited.include?('AdditionalDetail')
        visited = visited + ['AdditionalDetail']
        {
          additional_detail_type: 'additional_detail_type',
          component: AnalysisComponent.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('additionalDetailType', stub[:additional_detail_type].to_s) unless stub[:additional_detail_type].nil?
        xml << AnalysisComponent.stub('component', stub[:component]) unless stub[:component].nil?
        xml
      end
    end

    # Structure Stubber for AnalysisPacketHeader
    class AnalysisPacketHeader
      def self.default(visited=[])
        return nil if visited.include?('AnalysisPacketHeader')
        visited = visited + ['AnalysisPacketHeader']
        {
          destination_addresses: IpAddressList.default(visited),
          destination_port_ranges: PortRangeList.default(visited),
          protocol: 'protocol',
          source_addresses: IpAddressList.default(visited),
          source_port_ranges: PortRangeList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationAddressSet', IpAddressList.stub('item', stub[:destination_addresses])) unless stub[:destination_addresses].nil?
        xml << Hearth::XML::Node.new('destinationPortRangeSet', PortRangeList.stub('item', stub[:destination_port_ranges])) unless stub[:destination_port_ranges].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('sourceAddressSet', IpAddressList.stub('item', stub[:source_addresses])) unless stub[:source_addresses].nil?
        xml << Hearth::XML::Node.new('sourcePortRangeSet', PortRangeList.stub('item', stub[:source_port_ranges])) unless stub[:source_port_ranges].nil?
        xml
      end
    end

    # List Stubber for ArnList
    class ArnList
      def self.default(visited=[])
        return nil if visited.include?('ArnList')
        visited = visited + ['ArnList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeNetworkInsightsPaths
    class DescribeNetworkInsightsPaths
      def self.default(visited=[])
        {
          network_insights_paths: NetworkInsightsPathList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInsightsPathsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsPathSet', NetworkInsightsPathList.stub('item', stub[:network_insights_paths])) unless stub[:network_insights_paths].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for NetworkInsightsPathList
    class NetworkInsightsPathList
      def self.default(visited=[])
        return nil if visited.include?('NetworkInsightsPathList')
        visited = visited + ['NetworkInsightsPathList']
        [
          NetworkInsightsPath.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInsightsPath.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeNetworkInterfaceAttribute
    class DescribeNetworkInterfaceAttribute
      def self.default(visited=[])
        {
          attachment: NetworkInterfaceAttachment.default(visited),
          description: AttributeValue.default(visited),
          groups: GroupIdentifierList.default(visited),
          network_interface_id: 'network_interface_id',
          source_dest_check: AttributeBooleanValue.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInterfaceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInterfaceAttachment.stub('attachment', stub[:attachment]) unless stub[:attachment].nil?
        xml << AttributeValue.stub('description', stub[:description]) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << AttributeBooleanValue.stub('sourceDestCheck', stub[:source_dest_check]) unless stub[:source_dest_check].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeNetworkInterfacePermissions
    class DescribeNetworkInterfacePermissions
      def self.default(visited=[])
        {
          network_interface_permissions: NetworkInterfacePermissionList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInterfacePermissionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInterfacePermissions', NetworkInterfacePermissionList.stub('item', stub[:network_interface_permissions])) unless stub[:network_interface_permissions].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for NetworkInterfacePermissionList
    class NetworkInterfacePermissionList
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfacePermissionList')
        visited = visited + ['NetworkInterfacePermissionList']
        [
          NetworkInterfacePermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInterfacePermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeNetworkInterfaces
    class DescribeNetworkInterfaces
      def self.default(visited=[])
        {
          network_interfaces: NetworkInterfaceList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInterfacesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInterfaceSet', NetworkInterfaceList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for NetworkInterfaceList
    class NetworkInterfaceList
      def self.default(visited=[])
        return nil if visited.include?('NetworkInterfaceList')
        visited = visited + ['NetworkInterfaceList']
        [
          NetworkInterface.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInterface.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribePlacementGroups
    class DescribePlacementGroups
      def self.default(visited=[])
        {
          placement_groups: PlacementGroupList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribePlacementGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('placementGroupSet', PlacementGroupList.stub('item', stub[:placement_groups])) unless stub[:placement_groups].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for PlacementGroupList
    class PlacementGroupList
      def self.default(visited=[])
        return nil if visited.include?('PlacementGroupList')
        visited = visited + ['PlacementGroupList']
        [
          PlacementGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PlacementGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribePrefixLists
    class DescribePrefixLists
      def self.default(visited=[])
        {
          next_token: 'next_token',
          prefix_lists: PrefixListSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribePrefixListsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('prefixListSet', PrefixListSet.stub('item', stub[:prefix_lists])) unless stub[:prefix_lists].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for PrefixListSet
    class PrefixListSet
      def self.default(visited=[])
        return nil if visited.include?('PrefixListSet')
        visited = visited + ['PrefixListSet']
        [
          PrefixList.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrefixList.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PrefixList
    class PrefixList
      def self.default(visited=[])
        return nil if visited.include?('PrefixList')
        visited = visited + ['PrefixList']
        {
          cidrs: ValueStringList.default(visited),
          prefix_list_id: 'prefix_list_id',
          prefix_list_name: 'prefix_list_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrSet', ValueStringList.stub('item', stub[:cidrs])) unless stub[:cidrs].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('prefixListName', stub[:prefix_list_name].to_s) unless stub[:prefix_list_name].nil?
        xml
      end
    end

    # Operation Stubber for DescribePrincipalIdFormat
    class DescribePrincipalIdFormat
      def self.default(visited=[])
        {
          principals: PrincipalIdFormatList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribePrincipalIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('principalSet', PrincipalIdFormatList.stub('item', stub[:principals])) unless stub[:principals].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for PrincipalIdFormatList
    class PrincipalIdFormatList
      def self.default(visited=[])
        return nil if visited.include?('PrincipalIdFormatList')
        visited = visited + ['PrincipalIdFormatList']
        [
          PrincipalIdFormat.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrincipalIdFormat.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PrincipalIdFormat
    class PrincipalIdFormat
      def self.default(visited=[])
        return nil if visited.include?('PrincipalIdFormat')
        visited = visited + ['PrincipalIdFormat']
        {
          arn: 'arn',
          statuses: IdFormatList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('statusSet', IdFormatList.stub('item', stub[:statuses])) unless stub[:statuses].nil?
        xml
      end
    end

    # Operation Stubber for DescribePublicIpv4Pools
    class DescribePublicIpv4Pools
      def self.default(visited=[])
        {
          public_ipv4_pools: PublicIpv4PoolSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribePublicIpv4PoolsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('publicIpv4PoolSet', PublicIpv4PoolSet.stub('item', stub[:public_ipv4_pools])) unless stub[:public_ipv4_pools].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for PublicIpv4PoolSet
    class PublicIpv4PoolSet
      def self.default(visited=[])
        return nil if visited.include?('PublicIpv4PoolSet')
        visited = visited + ['PublicIpv4PoolSet']
        [
          PublicIpv4Pool.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PublicIpv4Pool.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PublicIpv4Pool
    class PublicIpv4Pool
      def self.default(visited=[])
        return nil if visited.include?('PublicIpv4Pool')
        visited = visited + ['PublicIpv4Pool']
        {
          pool_id: 'pool_id',
          description: 'description',
          pool_address_ranges: PublicIpv4PoolRangeSet.default(visited),
          total_address_count: 1,
          total_available_address_count: 1,
          network_border_group: 'network_border_group',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('poolAddressRangeSet', PublicIpv4PoolRangeSet.stub('item', stub[:pool_address_ranges])) unless stub[:pool_address_ranges].nil?
        xml << Hearth::XML::Node.new('totalAddressCount', stub[:total_address_count].to_s) unless stub[:total_address_count].nil?
        xml << Hearth::XML::Node.new('totalAvailableAddressCount', stub[:total_available_address_count].to_s) unless stub[:total_available_address_count].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for PublicIpv4PoolRangeSet
    class PublicIpv4PoolRangeSet
      def self.default(visited=[])
        return nil if visited.include?('PublicIpv4PoolRangeSet')
        visited = visited + ['PublicIpv4PoolRangeSet']
        [
          PublicIpv4PoolRange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PublicIpv4PoolRange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PublicIpv4PoolRange
    class PublicIpv4PoolRange
      def self.default(visited=[])
        return nil if visited.include?('PublicIpv4PoolRange')
        visited = visited + ['PublicIpv4PoolRange']
        {
          first_address: 'first_address',
          last_address: 'last_address',
          address_count: 1,
          available_address_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('firstAddress', stub[:first_address].to_s) unless stub[:first_address].nil?
        xml << Hearth::XML::Node.new('lastAddress', stub[:last_address].to_s) unless stub[:last_address].nil?
        xml << Hearth::XML::Node.new('addressCount', stub[:address_count].to_s) unless stub[:address_count].nil?
        xml << Hearth::XML::Node.new('availableAddressCount', stub[:available_address_count].to_s) unless stub[:available_address_count].nil?
        xml
      end
    end

    # Operation Stubber for DescribeRegions
    class DescribeRegions
      def self.default(visited=[])
        {
          regions: RegionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeRegionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('regionInfo', RegionList.stub('item', stub[:regions])) unless stub[:regions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for RegionList
    class RegionList
      def self.default(visited=[])
        return nil if visited.include?('RegionList')
        visited = visited + ['RegionList']
        [
          Region.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Region.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Region
    class Region
      def self.default(visited=[])
        return nil if visited.include?('Region')
        visited = visited + ['Region']
        {
          endpoint: 'endpoint',
          region_name: 'region_name',
          opt_in_status: 'opt_in_status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('regionEndpoint', stub[:endpoint].to_s) unless stub[:endpoint].nil?
        xml << Hearth::XML::Node.new('regionName', stub[:region_name].to_s) unless stub[:region_name].nil?
        xml << Hearth::XML::Node.new('optInStatus', stub[:opt_in_status].to_s) unless stub[:opt_in_status].nil?
        xml
      end
    end

    # Operation Stubber for DescribeReplaceRootVolumeTasks
    class DescribeReplaceRootVolumeTasks
      def self.default(visited=[])
        {
          replace_root_volume_tasks: ReplaceRootVolumeTasks.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReplaceRootVolumeTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('replaceRootVolumeTaskSet', ReplaceRootVolumeTasks.stub('item', stub[:replace_root_volume_tasks])) unless stub[:replace_root_volume_tasks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ReplaceRootVolumeTasks
    class ReplaceRootVolumeTasks
      def self.default(visited=[])
        return nil if visited.include?('ReplaceRootVolumeTasks')
        visited = visited + ['ReplaceRootVolumeTasks']
        [
          ReplaceRootVolumeTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReplaceRootVolumeTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeReservedInstances
    class DescribeReservedInstances
      def self.default(visited=[])
        {
          reserved_instances: ReservedInstancesList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReservedInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesSet', ReservedInstancesList.stub('item', stub[:reserved_instances])) unless stub[:reserved_instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ReservedInstancesList
    class ReservedInstancesList
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesList')
        visited = visited + ['ReservedInstancesList']
        [
          ReservedInstances.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstances.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ReservedInstances
    class ReservedInstances
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstances')
        visited = visited + ['ReservedInstances']
        {
          availability_zone: 'availability_zone',
          duration: 1,
          end: Time.now,
          fixed_price: 1.0,
          instance_count: 1,
          instance_type: 'instance_type',
          product_description: 'product_description',
          reserved_instances_id: 'reserved_instances_id',
          start: Time.now,
          state: 'state',
          usage_price: 1.0,
          currency_code: 'currency_code',
          instance_tenancy: 'instance_tenancy',
          offering_class: 'offering_class',
          offering_type: 'offering_type',
          recurring_charges: RecurringChargesList.default(visited),
          scope: 'scope',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('end', Hearth::TimeHelper.to_date_time(stub[:end])) unless stub[:end].nil?
        xml << Hearth::XML::Node.new('fixedPrice', Hearth::NumberHelper.serialize(stub[:fixed_price]).to_s) unless stub[:fixed_price].nil?
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('productDescription', stub[:product_description].to_s) unless stub[:product_description].nil?
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml << Hearth::XML::Node.new('start', Hearth::TimeHelper.to_date_time(stub[:start])) unless stub[:start].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('usagePrice', Hearth::NumberHelper.serialize(stub[:usage_price]).to_s) unless stub[:usage_price].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('instanceTenancy', stub[:instance_tenancy].to_s) unless stub[:instance_tenancy].nil?
        xml << Hearth::XML::Node.new('offeringClass', stub[:offering_class].to_s) unless stub[:offering_class].nil?
        xml << Hearth::XML::Node.new('offeringType', stub[:offering_type].to_s) unless stub[:offering_type].nil?
        xml << Hearth::XML::Node.new('recurringCharges', RecurringChargesList.stub('item', stub[:recurring_charges])) unless stub[:recurring_charges].nil?
        xml << Hearth::XML::Node.new('scope', stub[:scope].to_s) unless stub[:scope].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # List Stubber for RecurringChargesList
    class RecurringChargesList
      def self.default(visited=[])
        return nil if visited.include?('RecurringChargesList')
        visited = visited + ['RecurringChargesList']
        [
          RecurringCharge.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << RecurringCharge.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for RecurringCharge
    class RecurringCharge
      def self.default(visited=[])
        return nil if visited.include?('RecurringCharge')
        visited = visited + ['RecurringCharge']
        {
          amount: 1.0,
          frequency: 'frequency',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('amount', Hearth::NumberHelper.serialize(stub[:amount]).to_s) unless stub[:amount].nil?
        xml << Hearth::XML::Node.new('frequency', stub[:frequency].to_s) unless stub[:frequency].nil?
        xml
      end
    end

    # Operation Stubber for DescribeReservedInstancesListings
    class DescribeReservedInstancesListings
      def self.default(visited=[])
        {
          reserved_instances_listings: ReservedInstancesListingList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReservedInstancesListingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesListingsSet', ReservedInstancesListingList.stub('item', stub[:reserved_instances_listings])) unless stub[:reserved_instances_listings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeReservedInstancesModifications
    class DescribeReservedInstancesModifications
      def self.default(visited=[])
        {
          next_token: 'next_token',
          reserved_instances_modifications: ReservedInstancesModificationList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReservedInstancesModificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('reservedInstancesModificationsSet', ReservedInstancesModificationList.stub('item', stub[:reserved_instances_modifications])) unless stub[:reserved_instances_modifications].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ReservedInstancesModificationList
    class ReservedInstancesModificationList
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesModificationList')
        visited = visited + ['ReservedInstancesModificationList']
        [
          ReservedInstancesModification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesModification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ReservedInstancesModification
    class ReservedInstancesModification
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesModification')
        visited = visited + ['ReservedInstancesModification']
        {
          client_token: 'client_token',
          create_date: Time.now,
          effective_date: Time.now,
          modification_results: ReservedInstancesModificationResultList.default(visited),
          reserved_instances_ids: ReservedIntancesIds.default(visited),
          reserved_instances_modification_id: 'reserved_instances_modification_id',
          status: 'status',
          status_message: 'status_message',
          update_date: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('effectiveDate', Hearth::TimeHelper.to_date_time(stub[:effective_date])) unless stub[:effective_date].nil?
        xml << Hearth::XML::Node.new('modificationResultSet', ReservedInstancesModificationResultList.stub('item', stub[:modification_results])) unless stub[:modification_results].nil?
        xml << Hearth::XML::Node.new('reservedInstancesSet', ReservedIntancesIds.stub('item', stub[:reserved_instances_ids])) unless stub[:reserved_instances_ids].nil?
        xml << Hearth::XML::Node.new('reservedInstancesModificationId', stub[:reserved_instances_modification_id].to_s) unless stub[:reserved_instances_modification_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('updateDate', Hearth::TimeHelper.to_date_time(stub[:update_date])) unless stub[:update_date].nil?
        xml
      end
    end

    # List Stubber for ReservedIntancesIds
    class ReservedIntancesIds
      def self.default(visited=[])
        return nil if visited.include?('ReservedIntancesIds')
        visited = visited + ['ReservedIntancesIds']
        [
          ReservedInstancesId.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesId.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ReservedInstancesId
    class ReservedInstancesId
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesId')
        visited = visited + ['ReservedInstancesId']
        {
          reserved_instances_id: 'reserved_instances_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml
      end
    end

    # List Stubber for ReservedInstancesModificationResultList
    class ReservedInstancesModificationResultList
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesModificationResultList')
        visited = visited + ['ReservedInstancesModificationResultList']
        [
          ReservedInstancesModificationResult.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesModificationResult.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ReservedInstancesModificationResult
    class ReservedInstancesModificationResult
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesModificationResult')
        visited = visited + ['ReservedInstancesModificationResult']
        {
          reserved_instances_id: 'reserved_instances_id',
          target_configuration: ReservedInstancesConfiguration.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml << ReservedInstancesConfiguration.stub('targetConfiguration', stub[:target_configuration]) unless stub[:target_configuration].nil?
        xml
      end
    end

    # Structure Stubber for ReservedInstancesConfiguration
    class ReservedInstancesConfiguration
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesConfiguration')
        visited = visited + ['ReservedInstancesConfiguration']
        {
          availability_zone: 'availability_zone',
          instance_count: 1,
          instance_type: 'instance_type',
          platform: 'platform',
          scope: 'scope',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('scope', stub[:scope].to_s) unless stub[:scope].nil?
        xml
      end
    end

    # Operation Stubber for DescribeReservedInstancesOfferings
    class DescribeReservedInstancesOfferings
      def self.default(visited=[])
        {
          reserved_instances_offerings: ReservedInstancesOfferingList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReservedInstancesOfferingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesOfferingsSet', ReservedInstancesOfferingList.stub('item', stub[:reserved_instances_offerings])) unless stub[:reserved_instances_offerings].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ReservedInstancesOfferingList
    class ReservedInstancesOfferingList
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesOfferingList')
        visited = visited + ['ReservedInstancesOfferingList']
        [
          ReservedInstancesOffering.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesOffering.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ReservedInstancesOffering
    class ReservedInstancesOffering
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstancesOffering')
        visited = visited + ['ReservedInstancesOffering']
        {
          availability_zone: 'availability_zone',
          duration: 1,
          fixed_price: 1.0,
          instance_type: 'instance_type',
          product_description: 'product_description',
          reserved_instances_offering_id: 'reserved_instances_offering_id',
          usage_price: 1.0,
          currency_code: 'currency_code',
          instance_tenancy: 'instance_tenancy',
          marketplace: false,
          offering_class: 'offering_class',
          offering_type: 'offering_type',
          pricing_details: PricingDetailsList.default(visited),
          recurring_charges: RecurringChargesList.default(visited),
          scope: 'scope',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('fixedPrice', Hearth::NumberHelper.serialize(stub[:fixed_price]).to_s) unless stub[:fixed_price].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('productDescription', stub[:product_description].to_s) unless stub[:product_description].nil?
        xml << Hearth::XML::Node.new('reservedInstancesOfferingId', stub[:reserved_instances_offering_id].to_s) unless stub[:reserved_instances_offering_id].nil?
        xml << Hearth::XML::Node.new('usagePrice', Hearth::NumberHelper.serialize(stub[:usage_price]).to_s) unless stub[:usage_price].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('instanceTenancy', stub[:instance_tenancy].to_s) unless stub[:instance_tenancy].nil?
        xml << Hearth::XML::Node.new('marketplace', stub[:marketplace].to_s) unless stub[:marketplace].nil?
        xml << Hearth::XML::Node.new('offeringClass', stub[:offering_class].to_s) unless stub[:offering_class].nil?
        xml << Hearth::XML::Node.new('offeringType', stub[:offering_type].to_s) unless stub[:offering_type].nil?
        xml << Hearth::XML::Node.new('pricingDetailsSet', PricingDetailsList.stub('item', stub[:pricing_details])) unless stub[:pricing_details].nil?
        xml << Hearth::XML::Node.new('recurringCharges', RecurringChargesList.stub('item', stub[:recurring_charges])) unless stub[:recurring_charges].nil?
        xml << Hearth::XML::Node.new('scope', stub[:scope].to_s) unless stub[:scope].nil?
        xml
      end
    end

    # List Stubber for PricingDetailsList
    class PricingDetailsList
      def self.default(visited=[])
        return nil if visited.include?('PricingDetailsList')
        visited = visited + ['PricingDetailsList']
        [
          PricingDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PricingDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PricingDetail
    class PricingDetail
      def self.default(visited=[])
        return nil if visited.include?('PricingDetail')
        visited = visited + ['PricingDetail']
        {
          count: 1,
          price: 1.0,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << Hearth::XML::Node.new('price', Hearth::NumberHelper.serialize(stub[:price]).to_s) unless stub[:price].nil?
        xml
      end
    end

    # Operation Stubber for DescribeRouteTables
    class DescribeRouteTables
      def self.default(visited=[])
        {
          route_tables: RouteTableList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeRouteTablesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('routeTableSet', RouteTableList.stub('item', stub[:route_tables])) unless stub[:route_tables].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for RouteTableList
    class RouteTableList
      def self.default(visited=[])
        return nil if visited.include?('RouteTableList')
        visited = visited + ['RouteTableList']
        [
          RouteTable.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << RouteTable.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeScheduledInstanceAvailability
    class DescribeScheduledInstanceAvailability
      def self.default(visited=[])
        {
          next_token: 'next_token',
          scheduled_instance_availability_set: ScheduledInstanceAvailabilitySet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeScheduledInstanceAvailabilityResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('scheduledInstanceAvailabilitySet', ScheduledInstanceAvailabilitySet.stub('item', stub[:scheduled_instance_availability_set])) unless stub[:scheduled_instance_availability_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ScheduledInstanceAvailabilitySet
    class ScheduledInstanceAvailabilitySet
      def self.default(visited=[])
        return nil if visited.include?('ScheduledInstanceAvailabilitySet')
        visited = visited + ['ScheduledInstanceAvailabilitySet']
        [
          ScheduledInstanceAvailability.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ScheduledInstanceAvailability.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ScheduledInstanceAvailability
    class ScheduledInstanceAvailability
      def self.default(visited=[])
        return nil if visited.include?('ScheduledInstanceAvailability')
        visited = visited + ['ScheduledInstanceAvailability']
        {
          availability_zone: 'availability_zone',
          available_instance_count: 1,
          first_slot_start_time: Time.now,
          hourly_price: 'hourly_price',
          instance_type: 'instance_type',
          max_term_duration_in_days: 1,
          min_term_duration_in_days: 1,
          network_platform: 'network_platform',
          platform: 'platform',
          purchase_token: 'purchase_token',
          recurrence: ScheduledInstanceRecurrence.default(visited),
          slot_duration_in_hours: 1,
          total_scheduled_instance_hours: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('availableInstanceCount', stub[:available_instance_count].to_s) unless stub[:available_instance_count].nil?
        xml << Hearth::XML::Node.new('firstSlotStartTime', Hearth::TimeHelper.to_date_time(stub[:first_slot_start_time])) unless stub[:first_slot_start_time].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('maxTermDurationInDays', stub[:max_term_duration_in_days].to_s) unless stub[:max_term_duration_in_days].nil?
        xml << Hearth::XML::Node.new('minTermDurationInDays', stub[:min_term_duration_in_days].to_s) unless stub[:min_term_duration_in_days].nil?
        xml << Hearth::XML::Node.new('networkPlatform', stub[:network_platform].to_s) unless stub[:network_platform].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('purchaseToken', stub[:purchase_token].to_s) unless stub[:purchase_token].nil?
        xml << ScheduledInstanceRecurrence.stub('recurrence', stub[:recurrence]) unless stub[:recurrence].nil?
        xml << Hearth::XML::Node.new('slotDurationInHours', stub[:slot_duration_in_hours].to_s) unless stub[:slot_duration_in_hours].nil?
        xml << Hearth::XML::Node.new('totalScheduledInstanceHours', stub[:total_scheduled_instance_hours].to_s) unless stub[:total_scheduled_instance_hours].nil?
        xml
      end
    end

    # Structure Stubber for ScheduledInstanceRecurrence
    class ScheduledInstanceRecurrence
      def self.default(visited=[])
        return nil if visited.include?('ScheduledInstanceRecurrence')
        visited = visited + ['ScheduledInstanceRecurrence']
        {
          frequency: 'frequency',
          interval: 1,
          occurrence_day_set: OccurrenceDaySet.default(visited),
          occurrence_relative_to_end: false,
          occurrence_unit: 'occurrence_unit',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('frequency', stub[:frequency].to_s) unless stub[:frequency].nil?
        xml << Hearth::XML::Node.new('interval', stub[:interval].to_s) unless stub[:interval].nil?
        xml << Hearth::XML::Node.new('occurrenceDaySet', OccurrenceDaySet.stub('item', stub[:occurrence_day_set])) unless stub[:occurrence_day_set].nil?
        xml << Hearth::XML::Node.new('occurrenceRelativeToEnd', stub[:occurrence_relative_to_end].to_s) unless stub[:occurrence_relative_to_end].nil?
        xml << Hearth::XML::Node.new('occurrenceUnit', stub[:occurrence_unit].to_s) unless stub[:occurrence_unit].nil?
        xml
      end
    end

    # List Stubber for OccurrenceDaySet
    class OccurrenceDaySet
      def self.default(visited=[])
        return nil if visited.include?('OccurrenceDaySet')
        visited = visited + ['OccurrenceDaySet']
        [
          1
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeScheduledInstances
    class DescribeScheduledInstances
      def self.default(visited=[])
        {
          next_token: 'next_token',
          scheduled_instance_set: ScheduledInstanceSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeScheduledInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('scheduledInstanceSet', ScheduledInstanceSet.stub('item', stub[:scheduled_instance_set])) unless stub[:scheduled_instance_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ScheduledInstanceSet
    class ScheduledInstanceSet
      def self.default(visited=[])
        return nil if visited.include?('ScheduledInstanceSet')
        visited = visited + ['ScheduledInstanceSet']
        [
          ScheduledInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ScheduledInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ScheduledInstance
    class ScheduledInstance
      def self.default(visited=[])
        return nil if visited.include?('ScheduledInstance')
        visited = visited + ['ScheduledInstance']
        {
          availability_zone: 'availability_zone',
          create_date: Time.now,
          hourly_price: 'hourly_price',
          instance_count: 1,
          instance_type: 'instance_type',
          network_platform: 'network_platform',
          next_slot_start_time: Time.now,
          platform: 'platform',
          previous_slot_end_time: Time.now,
          recurrence: ScheduledInstanceRecurrence.default(visited),
          scheduled_instance_id: 'scheduled_instance_id',
          slot_duration_in_hours: 1,
          term_end_date: Time.now,
          term_start_date: Time.now,
          total_scheduled_instance_hours: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('networkPlatform', stub[:network_platform].to_s) unless stub[:network_platform].nil?
        xml << Hearth::XML::Node.new('nextSlotStartTime', Hearth::TimeHelper.to_date_time(stub[:next_slot_start_time])) unless stub[:next_slot_start_time].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('previousSlotEndTime', Hearth::TimeHelper.to_date_time(stub[:previous_slot_end_time])) unless stub[:previous_slot_end_time].nil?
        xml << ScheduledInstanceRecurrence.stub('recurrence', stub[:recurrence]) unless stub[:recurrence].nil?
        xml << Hearth::XML::Node.new('scheduledInstanceId', stub[:scheduled_instance_id].to_s) unless stub[:scheduled_instance_id].nil?
        xml << Hearth::XML::Node.new('slotDurationInHours', stub[:slot_duration_in_hours].to_s) unless stub[:slot_duration_in_hours].nil?
        xml << Hearth::XML::Node.new('termEndDate', Hearth::TimeHelper.to_date_time(stub[:term_end_date])) unless stub[:term_end_date].nil?
        xml << Hearth::XML::Node.new('termStartDate', Hearth::TimeHelper.to_date_time(stub[:term_start_date])) unless stub[:term_start_date].nil?
        xml << Hearth::XML::Node.new('totalScheduledInstanceHours', stub[:total_scheduled_instance_hours].to_s) unless stub[:total_scheduled_instance_hours].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSecurityGroupReferences
    class DescribeSecurityGroupReferences
      def self.default(visited=[])
        {
          security_group_reference_set: SecurityGroupReferences.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSecurityGroupReferencesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('securityGroupReferenceSet', SecurityGroupReferences.stub('item', stub[:security_group_reference_set])) unless stub[:security_group_reference_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SecurityGroupReferences
    class SecurityGroupReferences
      def self.default(visited=[])
        return nil if visited.include?('SecurityGroupReferences')
        visited = visited + ['SecurityGroupReferences']
        [
          SecurityGroupReference.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SecurityGroupReference.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SecurityGroupReference
    class SecurityGroupReference
      def self.default(visited=[])
        return nil if visited.include?('SecurityGroupReference')
        visited = visited + ['SecurityGroupReference']
        {
          group_id: 'group_id',
          referencing_vpc_id: 'referencing_vpc_id',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('referencingVpcId', stub[:referencing_vpc_id].to_s) unless stub[:referencing_vpc_id].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSecurityGroupRules
    class DescribeSecurityGroupRules
      def self.default(visited=[])
        {
          security_group_rules: SecurityGroupRuleList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSecurityGroupRulesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('securityGroupRuleSet', SecurityGroupRuleList.stub('item', stub[:security_group_rules])) unless stub[:security_group_rules].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeSecurityGroups
    class DescribeSecurityGroups
      def self.default(visited=[])
        {
          security_groups: SecurityGroupList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSecurityGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('securityGroupInfo', SecurityGroupList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SecurityGroupList
    class SecurityGroupList
      def self.default(visited=[])
        return nil if visited.include?('SecurityGroupList')
        visited = visited + ['SecurityGroupList']
        [
          SecurityGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SecurityGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SecurityGroup
    class SecurityGroup
      def self.default(visited=[])
        return nil if visited.include?('SecurityGroup')
        visited = visited + ['SecurityGroup']
        {
          description: 'description',
          group_name: 'group_name',
          ip_permissions: IpPermissionList.default(visited),
          owner_id: 'owner_id',
          group_id: 'group_id',
          ip_permissions_egress: IpPermissionList.default(visited),
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupDescription', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('ipPermissions', IpPermissionList.stub('item', stub[:ip_permissions])) unless stub[:ip_permissions].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('ipPermissionsEgress', IpPermissionList.stub('item', stub[:ip_permissions_egress])) unless stub[:ip_permissions_egress].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    # List Stubber for IpPermissionList
    class IpPermissionList
      def self.default(visited=[])
        return nil if visited.include?('IpPermissionList')
        visited = visited + ['IpPermissionList']
        [
          IpPermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpPermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for IpPermission
    class IpPermission
      def self.default(visited=[])
        return nil if visited.include?('IpPermission')
        visited = visited + ['IpPermission']
        {
          from_port: 1,
          ip_protocol: 'ip_protocol',
          ip_ranges: IpRangeList.default(visited),
          ipv6_ranges: Ipv6RangeList.default(visited),
          prefix_list_ids: PrefixListIdList.default(visited),
          to_port: 1,
          user_id_group_pairs: UserIdGroupPairList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fromPort', stub[:from_port].to_s) unless stub[:from_port].nil?
        xml << Hearth::XML::Node.new('ipProtocol', stub[:ip_protocol].to_s) unless stub[:ip_protocol].nil?
        xml << Hearth::XML::Node.new('ipRanges', IpRangeList.stub('item', stub[:ip_ranges])) unless stub[:ip_ranges].nil?
        xml << Hearth::XML::Node.new('ipv6Ranges', Ipv6RangeList.stub('item', stub[:ipv6_ranges])) unless stub[:ipv6_ranges].nil?
        xml << Hearth::XML::Node.new('prefixListIds', PrefixListIdList.stub('item', stub[:prefix_list_ids])) unless stub[:prefix_list_ids].nil?
        xml << Hearth::XML::Node.new('toPort', stub[:to_port].to_s) unless stub[:to_port].nil?
        xml << Hearth::XML::Node.new('groups', UserIdGroupPairList.stub('item', stub[:user_id_group_pairs])) unless stub[:user_id_group_pairs].nil?
        xml
      end
    end

    # List Stubber for UserIdGroupPairList
    class UserIdGroupPairList
      def self.default(visited=[])
        return nil if visited.include?('UserIdGroupPairList')
        visited = visited + ['UserIdGroupPairList']
        [
          UserIdGroupPair.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UserIdGroupPair.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for UserIdGroupPair
    class UserIdGroupPair
      def self.default(visited=[])
        return nil if visited.include?('UserIdGroupPair')
        visited = visited + ['UserIdGroupPair']
        {
          description: 'description',
          group_id: 'group_id',
          group_name: 'group_name',
          peering_status: 'peering_status',
          user_id: 'user_id',
          vpc_id: 'vpc_id',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('peeringStatus', stub[:peering_status].to_s) unless stub[:peering_status].nil?
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml
      end
    end

    # List Stubber for PrefixListIdList
    class PrefixListIdList
      def self.default(visited=[])
        return nil if visited.include?('PrefixListIdList')
        visited = visited + ['PrefixListIdList']
        [
          PrefixListId.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrefixListId.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PrefixListId
    class PrefixListId
      def self.default(visited=[])
        return nil if visited.include?('PrefixListId')
        visited = visited + ['PrefixListId']
        {
          description: 'description',
          prefix_list_id: 'prefix_list_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml
      end
    end

    # List Stubber for Ipv6RangeList
    class Ipv6RangeList
      def self.default(visited=[])
        return nil if visited.include?('Ipv6RangeList')
        visited = visited + ['Ipv6RangeList']
        [
          Ipv6Range.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6Range.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv6Range
    class Ipv6Range
      def self.default(visited=[])
        return nil if visited.include?('Ipv6Range')
        visited = visited + ['Ipv6Range']
        {
          cidr_ipv6: 'cidr_ipv6',
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrIpv6', stub[:cidr_ipv6].to_s) unless stub[:cidr_ipv6].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    # List Stubber for IpRangeList
    class IpRangeList
      def self.default(visited=[])
        return nil if visited.include?('IpRangeList')
        visited = visited + ['IpRangeList']
        [
          IpRange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpRange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for IpRange
    class IpRange
      def self.default(visited=[])
        return nil if visited.include?('IpRange')
        visited = visited + ['IpRange']
        {
          cidr_ip: 'cidr_ip',
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrIp', stub[:cidr_ip].to_s) unless stub[:cidr_ip].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSnapshotAttribute
    class DescribeSnapshotAttribute
      def self.default(visited=[])
        {
          create_volume_permissions: CreateVolumePermissionList.default(visited),
          product_codes: ProductCodeList.default(visited),
          snapshot_id: 'snapshot_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSnapshotAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('createVolumePermission', CreateVolumePermissionList.stub('item', stub[:create_volume_permissions])) unless stub[:create_volume_permissions].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CreateVolumePermissionList
    class CreateVolumePermissionList
      def self.default(visited=[])
        return nil if visited.include?('CreateVolumePermissionList')
        visited = visited + ['CreateVolumePermissionList']
        [
          CreateVolumePermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CreateVolumePermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CreateVolumePermission
    class CreateVolumePermission
      def self.default(visited=[])
        return nil if visited.include?('CreateVolumePermission')
        visited = visited + ['CreateVolumePermission']
        {
          group: 'group',
          user_id: 'user_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('group', stub[:group].to_s) unless stub[:group].nil?
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSnapshotTierStatus
    class DescribeSnapshotTierStatus
      def self.default(visited=[])
        {
          snapshot_tier_statuses: SnapshotTierStatusSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSnapshotTierStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotTierStatusSet', SnapshotTierStatusSet.stub('item', stub[:snapshot_tier_statuses])) unless stub[:snapshot_tier_statuses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for snapshotTierStatusSet
    class SnapshotTierStatusSet
      def self.default(visited=[])
        return nil if visited.include?('SnapshotTierStatusSet')
        visited = visited + ['SnapshotTierStatusSet']
        [
          SnapshotTierStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SnapshotTierStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SnapshotTierStatus
    class SnapshotTierStatus
      def self.default(visited=[])
        return nil if visited.include?('SnapshotTierStatus')
        visited = visited + ['SnapshotTierStatus']
        {
          snapshot_id: 'snapshot_id',
          volume_id: 'volume_id',
          status: 'status',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
          storage_tier: 'storage_tier',
          last_tiering_start_time: Time.now,
          last_tiering_progress: 1,
          last_tiering_operation_status: 'last_tiering_operation_status',
          last_tiering_operation_status_detail: 'last_tiering_operation_status_detail',
          archival_complete_time: Time.now,
          restore_expiry_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('storageTier', stub[:storage_tier].to_s) unless stub[:storage_tier].nil?
        xml << Hearth::XML::Node.new('lastTieringStartTime', Hearth::TimeHelper.to_date_time(stub[:last_tiering_start_time])) unless stub[:last_tiering_start_time].nil?
        xml << Hearth::XML::Node.new('lastTieringProgress', stub[:last_tiering_progress].to_s) unless stub[:last_tiering_progress].nil?
        xml << Hearth::XML::Node.new('lastTieringOperationStatus', stub[:last_tiering_operation_status].to_s) unless stub[:last_tiering_operation_status].nil?
        xml << Hearth::XML::Node.new('lastTieringOperationStatusDetail', stub[:last_tiering_operation_status_detail].to_s) unless stub[:last_tiering_operation_status_detail].nil?
        xml << Hearth::XML::Node.new('archivalCompleteTime', Hearth::TimeHelper.to_date_time(stub[:archival_complete_time])) unless stub[:archival_complete_time].nil?
        xml << Hearth::XML::Node.new('restoreExpiryTime', Hearth::TimeHelper.to_date_time(stub[:restore_expiry_time])) unless stub[:restore_expiry_time].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSnapshots
    class DescribeSnapshots
      def self.default(visited=[])
        {
          snapshots: SnapshotList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSnapshotsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotSet', SnapshotList.stub('item', stub[:snapshots])) unless stub[:snapshots].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SnapshotList
    class SnapshotList
      def self.default(visited=[])
        return nil if visited.include?('SnapshotList')
        visited = visited + ['SnapshotList']
        [
          Snapshot.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Snapshot.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Snapshot
    class Snapshot
      def self.default(visited=[])
        return nil if visited.include?('Snapshot')
        visited = visited + ['Snapshot']
        {
          data_encryption_key_id: 'data_encryption_key_id',
          description: 'description',
          encrypted: false,
          kms_key_id: 'kms_key_id',
          owner_id: 'owner_id',
          progress: 'progress',
          snapshot_id: 'snapshot_id',
          start_time: Time.now,
          state: 'state',
          state_message: 'state_message',
          volume_id: 'volume_id',
          volume_size: 1,
          owner_alias: 'owner_alias',
          outpost_arn: 'outpost_arn',
          tags: TagList.default(visited),
          storage_tier: 'storage_tier',
          restore_expiry_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dataEncryptionKeyId', stub[:data_encryption_key_id].to_s) unless stub[:data_encryption_key_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:state_message].to_s) unless stub[:state_message].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('storageTier', stub[:storage_tier].to_s) unless stub[:storage_tier].nil?
        xml << Hearth::XML::Node.new('restoreExpiryTime', Hearth::TimeHelper.to_date_time(stub[:restore_expiry_time])) unless stub[:restore_expiry_time].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSpotDatafeedSubscription
    class DescribeSpotDatafeedSubscription
      def self.default(visited=[])
        {
          spot_datafeed_subscription: SpotDatafeedSubscription.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotDatafeedSubscriptionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SpotDatafeedSubscription.stub('spotDatafeedSubscription', stub[:spot_datafeed_subscription]) unless stub[:spot_datafeed_subscription].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeSpotFleetInstances
    class DescribeSpotFleetInstances
      def self.default(visited=[])
        {
          active_instances: ActiveInstanceSet.default(visited),
          next_token: 'next_token',
          spot_fleet_request_id: 'spot_fleet_request_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotFleetInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('activeInstanceSet', ActiveInstanceSet.stub('item', stub[:active_instances])) unless stub[:active_instances].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeSpotFleetRequestHistory
    class DescribeSpotFleetRequestHistory
      def self.default(visited=[])
        {
          history_records: HistoryRecords.default(visited),
          last_evaluated_time: Time.now,
          next_token: 'next_token',
          spot_fleet_request_id: 'spot_fleet_request_id',
          start_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotFleetRequestHistoryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('historyRecordSet', HistoryRecords.stub('item', stub[:history_records])) unless stub[:history_records].nil?
        xml << Hearth::XML::Node.new('lastEvaluatedTime', Hearth::TimeHelper.to_date_time(stub[:last_evaluated_time])) unless stub[:last_evaluated_time].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for HistoryRecords
    class HistoryRecords
      def self.default(visited=[])
        return nil if visited.include?('HistoryRecords')
        visited = visited + ['HistoryRecords']
        [
          HistoryRecord.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HistoryRecord.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for HistoryRecord
    class HistoryRecord
      def self.default(visited=[])
        return nil if visited.include?('HistoryRecord')
        visited = visited + ['HistoryRecord']
        {
          event_information: EventInformation.default(visited),
          event_type: 'event_type',
          timestamp: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << EventInformation.stub('eventInformation', stub[:event_information]) unless stub[:event_information].nil?
        xml << Hearth::XML::Node.new('eventType', stub[:event_type].to_s) unless stub[:event_type].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSpotFleetRequests
    class DescribeSpotFleetRequests
      def self.default(visited=[])
        {
          next_token: 'next_token',
          spot_fleet_request_configs: SpotFleetRequestConfigSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotFleetRequestsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestConfigSet', SpotFleetRequestConfigSet.stub('item', stub[:spot_fleet_request_configs])) unless stub[:spot_fleet_request_configs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SpotFleetRequestConfigSet
    class SpotFleetRequestConfigSet
      def self.default(visited=[])
        return nil if visited.include?('SpotFleetRequestConfigSet')
        visited = visited + ['SpotFleetRequestConfigSet']
        [
          SpotFleetRequestConfig.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotFleetRequestConfig.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SpotFleetRequestConfig
    class SpotFleetRequestConfig
      def self.default(visited=[])
        return nil if visited.include?('SpotFleetRequestConfig')
        visited = visited + ['SpotFleetRequestConfig']
        {
          activity_status: 'activity_status',
          create_time: Time.now,
          spot_fleet_request_config: SpotFleetRequestConfigData.default(visited),
          spot_fleet_request_id: 'spot_fleet_request_id',
          spot_fleet_request_state: 'spot_fleet_request_state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('activityStatus', stub[:activity_status].to_s) unless stub[:activity_status].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << SpotFleetRequestConfigData.stub('spotFleetRequestConfig', stub[:spot_fleet_request_config]) unless stub[:spot_fleet_request_config].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestState', stub[:spot_fleet_request_state].to_s) unless stub[:spot_fleet_request_state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for SpotFleetRequestConfigData
    class SpotFleetRequestConfigData
      def self.default(visited=[])
        return nil if visited.include?('SpotFleetRequestConfigData')
        visited = visited + ['SpotFleetRequestConfigData']
        {
          allocation_strategy: 'allocation_strategy',
          on_demand_allocation_strategy: 'on_demand_allocation_strategy',
          spot_maintenance_strategies: SpotMaintenanceStrategies.default(visited),
          client_token: 'client_token',
          excess_capacity_termination_policy: 'excess_capacity_termination_policy',
          fulfilled_capacity: 1.0,
          on_demand_fulfilled_capacity: 1.0,
          iam_fleet_role: 'iam_fleet_role',
          launch_specifications: LaunchSpecsList.default(visited),
          launch_template_configs: LaunchTemplateConfigList.default(visited),
          spot_price: 'spot_price',
          target_capacity: 1,
          on_demand_target_capacity: 1,
          on_demand_max_total_price: 'on_demand_max_total_price',
          spot_max_total_price: 'spot_max_total_price',
          terminate_instances_with_expiration: false,
          type: 'type',
          valid_from: Time.now,
          valid_until: Time.now,
          replace_unhealthy_instances: false,
          instance_interruption_behavior: 'instance_interruption_behavior',
          load_balancers_config: LoadBalancersConfig.default(visited),
          instance_pools_to_use_count: 1,
          context: 'context',
          target_capacity_unit_type: 'target_capacity_unit_type',
          tag_specifications: TagSpecificationList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << Hearth::XML::Node.new('onDemandAllocationStrategy', stub[:on_demand_allocation_strategy].to_s) unless stub[:on_demand_allocation_strategy].nil?
        xml << SpotMaintenanceStrategies.stub('spotMaintenanceStrategies', stub[:spot_maintenance_strategies]) unless stub[:spot_maintenance_strategies].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('excessCapacityTerminationPolicy', stub[:excess_capacity_termination_policy].to_s) unless stub[:excess_capacity_termination_policy].nil?
        xml << Hearth::XML::Node.new('fulfilledCapacity', Hearth::NumberHelper.serialize(stub[:fulfilled_capacity]).to_s) unless stub[:fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('onDemandFulfilledCapacity', Hearth::NumberHelper.serialize(stub[:on_demand_fulfilled_capacity]).to_s) unless stub[:on_demand_fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('iamFleetRole', stub[:iam_fleet_role].to_s) unless stub[:iam_fleet_role].nil?
        xml << Hearth::XML::Node.new('launchSpecifications', LaunchSpecsList.stub('item', stub[:launch_specifications])) unless stub[:launch_specifications].nil?
        xml << Hearth::XML::Node.new('launchTemplateConfigs', LaunchTemplateConfigList.stub('item', stub[:launch_template_configs])) unless stub[:launch_template_configs].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('targetCapacity', stub[:target_capacity].to_s) unless stub[:target_capacity].nil?
        xml << Hearth::XML::Node.new('onDemandTargetCapacity', stub[:on_demand_target_capacity].to_s) unless stub[:on_demand_target_capacity].nil?
        xml << Hearth::XML::Node.new('onDemandMaxTotalPrice', stub[:on_demand_max_total_price].to_s) unless stub[:on_demand_max_total_price].nil?
        xml << Hearth::XML::Node.new('spotMaxTotalPrice', stub[:spot_max_total_price].to_s) unless stub[:spot_max_total_price].nil?
        xml << Hearth::XML::Node.new('terminateInstancesWithExpiration', stub[:terminate_instances_with_expiration].to_s) unless stub[:terminate_instances_with_expiration].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('validFrom', Hearth::TimeHelper.to_date_time(stub[:valid_from])) unless stub[:valid_from].nil?
        xml << Hearth::XML::Node.new('validUntil', Hearth::TimeHelper.to_date_time(stub[:valid_until])) unless stub[:valid_until].nil?
        xml << Hearth::XML::Node.new('replaceUnhealthyInstances', stub[:replace_unhealthy_instances].to_s) unless stub[:replace_unhealthy_instances].nil?
        xml << Hearth::XML::Node.new('instanceInterruptionBehavior', stub[:instance_interruption_behavior].to_s) unless stub[:instance_interruption_behavior].nil?
        xml << LoadBalancersConfig.stub('loadBalancersConfig', stub[:load_balancers_config]) unless stub[:load_balancers_config].nil?
        xml << Hearth::XML::Node.new('instancePoolsToUseCount', stub[:instance_pools_to_use_count].to_s) unless stub[:instance_pools_to_use_count].nil?
        xml << Hearth::XML::Node.new('context', stub[:context].to_s) unless stub[:context].nil?
        xml << Hearth::XML::Node.new('targetCapacityUnitType', stub[:target_capacity_unit_type].to_s) unless stub[:target_capacity_unit_type].nil?
        xml << Hearth::XML::Node.new('TagSpecification', TagSpecificationList.stub('item', stub[:tag_specifications])) unless stub[:tag_specifications].nil?
        xml
      end
    end

    # List Stubber for TagSpecificationList
    class TagSpecificationList
      def self.default(visited=[])
        return nil if visited.include?('TagSpecificationList')
        visited = visited + ['TagSpecificationList']
        [
          TagSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TagSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TagSpecification
    class TagSpecification
      def self.default(visited=[])
        return nil if visited.include?('TagSpecification')
        visited = visited + ['TagSpecification']
        {
          resource_type: 'resource_type',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('Tag', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for LoadBalancersConfig
    class LoadBalancersConfig
      def self.default(visited=[])
        return nil if visited.include?('LoadBalancersConfig')
        visited = visited + ['LoadBalancersConfig']
        {
          classic_load_balancers_config: ClassicLoadBalancersConfig.default(visited),
          target_groups_config: TargetGroupsConfig.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << ClassicLoadBalancersConfig.stub('classicLoadBalancersConfig', stub[:classic_load_balancers_config]) unless stub[:classic_load_balancers_config].nil?
        xml << TargetGroupsConfig.stub('targetGroupsConfig', stub[:target_groups_config]) unless stub[:target_groups_config].nil?
        xml
      end
    end

    # Structure Stubber for TargetGroupsConfig
    class TargetGroupsConfig
      def self.default(visited=[])
        return nil if visited.include?('TargetGroupsConfig')
        visited = visited + ['TargetGroupsConfig']
        {
          target_groups: TargetGroups.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('targetGroups', TargetGroups.stub('item', stub[:target_groups])) unless stub[:target_groups].nil?
        xml
      end
    end

    # List Stubber for TargetGroups
    class TargetGroups
      def self.default(visited=[])
        return nil if visited.include?('TargetGroups')
        visited = visited + ['TargetGroups']
        [
          TargetGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TargetGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TargetGroup
    class TargetGroup
      def self.default(visited=[])
        return nil if visited.include?('TargetGroup')
        visited = visited + ['TargetGroup']
        {
          arn: 'arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml
      end
    end

    # Structure Stubber for ClassicLoadBalancersConfig
    class ClassicLoadBalancersConfig
      def self.default(visited=[])
        return nil if visited.include?('ClassicLoadBalancersConfig')
        visited = visited + ['ClassicLoadBalancersConfig']
        {
          classic_load_balancers: ClassicLoadBalancers.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('classicLoadBalancers', ClassicLoadBalancers.stub('item', stub[:classic_load_balancers])) unless stub[:classic_load_balancers].nil?
        xml
      end
    end

    # List Stubber for ClassicLoadBalancers
    class ClassicLoadBalancers
      def self.default(visited=[])
        return nil if visited.include?('ClassicLoadBalancers')
        visited = visited + ['ClassicLoadBalancers']
        [
          ClassicLoadBalancer.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClassicLoadBalancer.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ClassicLoadBalancer
    class ClassicLoadBalancer
      def self.default(visited=[])
        return nil if visited.include?('ClassicLoadBalancer')
        visited = visited + ['ClassicLoadBalancer']
        {
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    # List Stubber for LaunchTemplateConfigList
    class LaunchTemplateConfigList
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateConfigList')
        visited = visited + ['LaunchTemplateConfigList']
        [
          LaunchTemplateConfig.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateConfig.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LaunchTemplateConfig
    class LaunchTemplateConfig
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateConfig')
        visited = visited + ['LaunchTemplateConfig']
        {
          launch_template_specification: FleetLaunchTemplateSpecification.default(visited),
          overrides: LaunchTemplateOverridesList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << FleetLaunchTemplateSpecification.stub('launchTemplateSpecification', stub[:launch_template_specification]) unless stub[:launch_template_specification].nil?
        xml << Hearth::XML::Node.new('overrides', LaunchTemplateOverridesList.stub('item', stub[:overrides])) unless stub[:overrides].nil?
        xml
      end
    end

    # List Stubber for LaunchTemplateOverridesList
    class LaunchTemplateOverridesList
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateOverridesList')
        visited = visited + ['LaunchTemplateOverridesList']
        [
          LaunchTemplateOverrides.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateOverrides.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for LaunchTemplateOverrides
    class LaunchTemplateOverrides
      def self.default(visited=[])
        return nil if visited.include?('LaunchTemplateOverrides')
        visited = visited + ['LaunchTemplateOverrides']
        {
          instance_type: 'instance_type',
          spot_price: 'spot_price',
          subnet_id: 'subnet_id',
          availability_zone: 'availability_zone',
          weighted_capacity: 1.0,
          priority: 1.0,
          instance_requirements: InstanceRequirements.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('weightedCapacity', Hearth::NumberHelper.serialize(stub[:weighted_capacity]).to_s) unless stub[:weighted_capacity].nil?
        xml << Hearth::XML::Node.new('priority', Hearth::NumberHelper.serialize(stub[:priority]).to_s) unless stub[:priority].nil?
        xml << InstanceRequirements.stub('instanceRequirements', stub[:instance_requirements]) unless stub[:instance_requirements].nil?
        xml
      end
    end

    # List Stubber for LaunchSpecsList
    class LaunchSpecsList
      def self.default(visited=[])
        return nil if visited.include?('LaunchSpecsList')
        visited = visited + ['LaunchSpecsList']
        [
          SpotFleetLaunchSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotFleetLaunchSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SpotFleetLaunchSpecification
    class SpotFleetLaunchSpecification
      def self.default(visited=[])
        return nil if visited.include?('SpotFleetLaunchSpecification')
        visited = visited + ['SpotFleetLaunchSpecification']
        {
          security_groups: GroupIdentifierList.default(visited),
          addressing_type: 'addressing_type',
          block_device_mappings: BlockDeviceMappingList.default(visited),
          ebs_optimized: false,
          iam_instance_profile: IamInstanceProfileSpecification.default(visited),
          image_id: 'image_id',
          instance_type: 'instance_type',
          kernel_id: 'kernel_id',
          key_name: 'key_name',
          monitoring: SpotFleetMonitoring.default(visited),
          network_interfaces: InstanceNetworkInterfaceSpecificationList.default(visited),
          placement: SpotPlacement.default(visited),
          ramdisk_id: 'ramdisk_id',
          spot_price: 'spot_price',
          subnet_id: 'subnet_id',
          user_data: 'user_data',
          weighted_capacity: 1.0,
          tag_specifications: SpotFleetTagSpecificationList.default(visited),
          instance_requirements: InstanceRequirements.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << Hearth::XML::Node.new('addressingType', stub[:addressing_type].to_s) unless stub[:addressing_type].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', BlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << IamInstanceProfileSpecification.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << SpotFleetMonitoring.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml << Hearth::XML::Node.new('networkInterfaceSet', InstanceNetworkInterfaceSpecificationList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << SpotPlacement.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << Hearth::XML::Node.new('ramdiskId', stub[:ramdisk_id].to_s) unless stub[:ramdisk_id].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('userData', stub[:user_data].to_s) unless stub[:user_data].nil?
        xml << Hearth::XML::Node.new('weightedCapacity', Hearth::NumberHelper.serialize(stub[:weighted_capacity]).to_s) unless stub[:weighted_capacity].nil?
        xml << Hearth::XML::Node.new('tagSpecificationSet', SpotFleetTagSpecificationList.stub('item', stub[:tag_specifications])) unless stub[:tag_specifications].nil?
        xml << InstanceRequirements.stub('instanceRequirements', stub[:instance_requirements]) unless stub[:instance_requirements].nil?
        xml
      end
    end

    # List Stubber for SpotFleetTagSpecificationList
    class SpotFleetTagSpecificationList
      def self.default(visited=[])
        return nil if visited.include?('SpotFleetTagSpecificationList')
        visited = visited + ['SpotFleetTagSpecificationList']
        [
          SpotFleetTagSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotFleetTagSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SpotFleetTagSpecification
    class SpotFleetTagSpecification
      def self.default(visited=[])
        return nil if visited.include?('SpotFleetTagSpecification')
        visited = visited + ['SpotFleetTagSpecification']
        {
          resource_type: 'resource_type',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('tag', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for SpotPlacement
    class SpotPlacement
      def self.default(visited=[])
        return nil if visited.include?('SpotPlacement')
        visited = visited + ['SpotPlacement']
        {
          availability_zone: 'availability_zone',
          group_name: 'group_name',
          tenancy: 'tenancy',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml
      end
    end

    # List Stubber for InstanceNetworkInterfaceSpecificationList
    class InstanceNetworkInterfaceSpecificationList
      def self.default(visited=[])
        return nil if visited.include?('InstanceNetworkInterfaceSpecificationList')
        visited = visited + ['InstanceNetworkInterfaceSpecificationList']
        [
          InstanceNetworkInterfaceSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceNetworkInterfaceSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceNetworkInterfaceSpecification
    class InstanceNetworkInterfaceSpecification
      def self.default(visited=[])
        return nil if visited.include?('InstanceNetworkInterfaceSpecification')
        visited = visited + ['InstanceNetworkInterfaceSpecification']
        {
          associate_public_ip_address: false,
          delete_on_termination: false,
          description: 'description',
          device_index: 1,
          groups: SecurityGroupIdStringList.default(visited),
          ipv6_address_count: 1,
          ipv6_addresses: InstanceIpv6AddressList.default(visited),
          network_interface_id: 'network_interface_id',
          private_ip_address: 'private_ip_address',
          private_ip_addresses: PrivateIpAddressSpecificationList.default(visited),
          secondary_private_ip_address_count: 1,
          subnet_id: 'subnet_id',
          associate_carrier_ip_address: false,
          interface_type: 'interface_type',
          network_card_index: 1,
          ipv4_prefixes: Ipv4PrefixList.default(visited),
          ipv4_prefix_count: 1,
          ipv6_prefixes: Ipv6PrefixList.default(visited),
          ipv6_prefix_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associatePublicIpAddress', stub[:associate_public_ip_address].to_s) unless stub[:associate_public_ip_address].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('deviceIndex', stub[:device_index].to_s) unless stub[:device_index].nil?
        xml << Hearth::XML::Node.new('SecurityGroupId', SecurityGroupIdStringList.stub('SecurityGroupId', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('ipv6AddressCount', stub[:ipv6_address_count].to_s) unless stub[:ipv6_address_count].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesSet', InstanceIpv6AddressList.stub('item', stub[:ipv6_addresses])) unless stub[:ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('privateIpAddressesSet', PrivateIpAddressSpecificationList.stub('item', stub[:private_ip_addresses])) unless stub[:private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('secondaryPrivateIpAddressCount', stub[:secondary_private_ip_address_count].to_s) unless stub[:secondary_private_ip_address_count].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('AssociateCarrierIpAddress', stub[:associate_carrier_ip_address].to_s) unless stub[:associate_carrier_ip_address].nil?
        xml << Hearth::XML::Node.new('InterfaceType', stub[:interface_type].to_s) unless stub[:interface_type].nil?
        xml << Hearth::XML::Node.new('NetworkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml << Hearth::XML::Node.new('Ipv4Prefix', Ipv4PrefixList.stub('item', stub[:ipv4_prefixes])) unless stub[:ipv4_prefixes].nil?
        xml << Hearth::XML::Node.new('Ipv4PrefixCount', stub[:ipv4_prefix_count].to_s) unless stub[:ipv4_prefix_count].nil?
        xml << Hearth::XML::Node.new('Ipv6Prefix', Ipv6PrefixList.stub('item', stub[:ipv6_prefixes])) unless stub[:ipv6_prefixes].nil?
        xml << Hearth::XML::Node.new('Ipv6PrefixCount', stub[:ipv6_prefix_count].to_s) unless stub[:ipv6_prefix_count].nil?
        xml
      end
    end

    # List Stubber for Ipv6PrefixList
    class Ipv6PrefixList
      def self.default(visited=[])
        return nil if visited.include?('Ipv6PrefixList')
        visited = visited + ['Ipv6PrefixList']
        [
          Ipv6PrefixSpecificationRequest.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6PrefixSpecificationRequest.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv6PrefixSpecificationRequest
    class Ipv6PrefixSpecificationRequest
      def self.default(visited=[])
        return nil if visited.include?('Ipv6PrefixSpecificationRequest')
        visited = visited + ['Ipv6PrefixSpecificationRequest']
        {
          ipv6_prefix: 'ipv6_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('Ipv6Prefix', stub[:ipv6_prefix].to_s) unless stub[:ipv6_prefix].nil?
        xml
      end
    end

    # List Stubber for Ipv4PrefixList
    class Ipv4PrefixList
      def self.default(visited=[])
        return nil if visited.include?('Ipv4PrefixList')
        visited = visited + ['Ipv4PrefixList']
        [
          Ipv4PrefixSpecificationRequest.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv4PrefixSpecificationRequest.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv4PrefixSpecificationRequest
    class Ipv4PrefixSpecificationRequest
      def self.default(visited=[])
        return nil if visited.include?('Ipv4PrefixSpecificationRequest')
        visited = visited + ['Ipv4PrefixSpecificationRequest']
        {
          ipv4_prefix: 'ipv4_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('Ipv4Prefix', stub[:ipv4_prefix].to_s) unless stub[:ipv4_prefix].nil?
        xml
      end
    end

    # List Stubber for SecurityGroupIdStringList
    class SecurityGroupIdStringList
      def self.default(visited=[])
        return nil if visited.include?('SecurityGroupIdStringList')
        visited = visited + ['SecurityGroupIdStringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SpotFleetMonitoring
    class SpotFleetMonitoring
      def self.default(visited=[])
        return nil if visited.include?('SpotFleetMonitoring')
        visited = visited + ['SpotFleetMonitoring']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    # Structure Stubber for IamInstanceProfileSpecification
    class IamInstanceProfileSpecification
      def self.default(visited=[])
        return nil if visited.include?('IamInstanceProfileSpecification')
        visited = visited + ['IamInstanceProfileSpecification']
        {
          arn: 'arn',
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    # Structure Stubber for SpotMaintenanceStrategies
    class SpotMaintenanceStrategies
      def self.default(visited=[])
        return nil if visited.include?('SpotMaintenanceStrategies')
        visited = visited + ['SpotMaintenanceStrategies']
        {
          capacity_rebalance: SpotCapacityRebalance.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << SpotCapacityRebalance.stub('capacityRebalance', stub[:capacity_rebalance]) unless stub[:capacity_rebalance].nil?
        xml
      end
    end

    # Structure Stubber for SpotCapacityRebalance
    class SpotCapacityRebalance
      def self.default(visited=[])
        return nil if visited.include?('SpotCapacityRebalance')
        visited = visited + ['SpotCapacityRebalance']
        {
          replacement_strategy: 'replacement_strategy',
          termination_delay: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('replacementStrategy', stub[:replacement_strategy].to_s) unless stub[:replacement_strategy].nil?
        xml << Hearth::XML::Node.new('terminationDelay', stub[:termination_delay].to_s) unless stub[:termination_delay].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSpotInstanceRequests
    class DescribeSpotInstanceRequests
      def self.default(visited=[])
        {
          spot_instance_requests: SpotInstanceRequestList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotInstanceRequestsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotInstanceRequestSet', SpotInstanceRequestList.stub('item', stub[:spot_instance_requests])) unless stub[:spot_instance_requests].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SpotInstanceRequestList
    class SpotInstanceRequestList
      def self.default(visited=[])
        return nil if visited.include?('SpotInstanceRequestList')
        visited = visited + ['SpotInstanceRequestList']
        [
          SpotInstanceRequest.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotInstanceRequest.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SpotInstanceRequest
    class SpotInstanceRequest
      def self.default(visited=[])
        return nil if visited.include?('SpotInstanceRequest')
        visited = visited + ['SpotInstanceRequest']
        {
          actual_block_hourly_price: 'actual_block_hourly_price',
          availability_zone_group: 'availability_zone_group',
          block_duration_minutes: 1,
          create_time: Time.now,
          fault: SpotInstanceStateFault.default(visited),
          instance_id: 'instance_id',
          launch_group: 'launch_group',
          launch_specification: LaunchSpecification.default(visited),
          launched_availability_zone: 'launched_availability_zone',
          product_description: 'product_description',
          spot_instance_request_id: 'spot_instance_request_id',
          spot_price: 'spot_price',
          state: 'state',
          status: SpotInstanceStatus.default(visited),
          tags: TagList.default(visited),
          type: 'type',
          valid_from: Time.now,
          valid_until: Time.now,
          instance_interruption_behavior: 'instance_interruption_behavior',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('actualBlockHourlyPrice', stub[:actual_block_hourly_price].to_s) unless stub[:actual_block_hourly_price].nil?
        xml << Hearth::XML::Node.new('availabilityZoneGroup', stub[:availability_zone_group].to_s) unless stub[:availability_zone_group].nil?
        xml << Hearth::XML::Node.new('blockDurationMinutes', stub[:block_duration_minutes].to_s) unless stub[:block_duration_minutes].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << SpotInstanceStateFault.stub('fault', stub[:fault]) unless stub[:fault].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('launchGroup', stub[:launch_group].to_s) unless stub[:launch_group].nil?
        xml << LaunchSpecification.stub('launchSpecification', stub[:launch_specification]) unless stub[:launch_specification].nil?
        xml << Hearth::XML::Node.new('launchedAvailabilityZone', stub[:launched_availability_zone].to_s) unless stub[:launched_availability_zone].nil?
        xml << Hearth::XML::Node.new('productDescription', stub[:product_description].to_s) unless stub[:product_description].nil?
        xml << Hearth::XML::Node.new('spotInstanceRequestId', stub[:spot_instance_request_id].to_s) unless stub[:spot_instance_request_id].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << SpotInstanceStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('validFrom', Hearth::TimeHelper.to_date_time(stub[:valid_from])) unless stub[:valid_from].nil?
        xml << Hearth::XML::Node.new('validUntil', Hearth::TimeHelper.to_date_time(stub[:valid_until])) unless stub[:valid_until].nil?
        xml << Hearth::XML::Node.new('instanceInterruptionBehavior', stub[:instance_interruption_behavior].to_s) unless stub[:instance_interruption_behavior].nil?
        xml
      end
    end

    # Structure Stubber for SpotInstanceStatus
    class SpotInstanceStatus
      def self.default(visited=[])
        return nil if visited.include?('SpotInstanceStatus')
        visited = visited + ['SpotInstanceStatus']
        {
          code: 'code',
          message: 'message',
          update_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml << Hearth::XML::Node.new('updateTime', Hearth::TimeHelper.to_date_time(stub[:update_time])) unless stub[:update_time].nil?
        xml
      end
    end

    # Structure Stubber for LaunchSpecification
    class LaunchSpecification
      def self.default(visited=[])
        return nil if visited.include?('LaunchSpecification')
        visited = visited + ['LaunchSpecification']
        {
          user_data: 'user_data',
          security_groups: GroupIdentifierList.default(visited),
          addressing_type: 'addressing_type',
          block_device_mappings: BlockDeviceMappingList.default(visited),
          ebs_optimized: false,
          iam_instance_profile: IamInstanceProfileSpecification.default(visited),
          image_id: 'image_id',
          instance_type: 'instance_type',
          kernel_id: 'kernel_id',
          key_name: 'key_name',
          network_interfaces: InstanceNetworkInterfaceSpecificationList.default(visited),
          placement: SpotPlacement.default(visited),
          ramdisk_id: 'ramdisk_id',
          subnet_id: 'subnet_id',
          monitoring: RunInstancesMonitoringEnabled.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('userData', stub[:user_data].to_s) unless stub[:user_data].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << Hearth::XML::Node.new('addressingType', stub[:addressing_type].to_s) unless stub[:addressing_type].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', BlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << IamInstanceProfileSpecification.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('networkInterfaceSet', InstanceNetworkInterfaceSpecificationList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << SpotPlacement.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << Hearth::XML::Node.new('ramdiskId', stub[:ramdisk_id].to_s) unless stub[:ramdisk_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << RunInstancesMonitoringEnabled.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml
      end
    end

    # Structure Stubber for RunInstancesMonitoringEnabled
    class RunInstancesMonitoringEnabled
      def self.default(visited=[])
        return nil if visited.include?('RunInstancesMonitoringEnabled')
        visited = visited + ['RunInstancesMonitoringEnabled']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSpotPriceHistory
    class DescribeSpotPriceHistory
      def self.default(visited=[])
        {
          next_token: 'next_token',
          spot_price_history: SpotPriceHistoryList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotPriceHistoryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('spotPriceHistorySet', SpotPriceHistoryList.stub('item', stub[:spot_price_history])) unless stub[:spot_price_history].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SpotPriceHistoryList
    class SpotPriceHistoryList
      def self.default(visited=[])
        return nil if visited.include?('SpotPriceHistoryList')
        visited = visited + ['SpotPriceHistoryList']
        [
          SpotPrice.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotPrice.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SpotPrice
    class SpotPrice
      def self.default(visited=[])
        return nil if visited.include?('SpotPrice')
        visited = visited + ['SpotPrice']
        {
          availability_zone: 'availability_zone',
          instance_type: 'instance_type',
          product_description: 'product_description',
          spot_price: 'spot_price',
          timestamp: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('productDescription', stub[:product_description].to_s) unless stub[:product_description].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        xml
      end
    end

    # Operation Stubber for DescribeStaleSecurityGroups
    class DescribeStaleSecurityGroups
      def self.default(visited=[])
        {
          next_token: 'next_token',
          stale_security_group_set: StaleSecurityGroupSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeStaleSecurityGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('staleSecurityGroupSet', StaleSecurityGroupSet.stub('item', stub[:stale_security_group_set])) unless stub[:stale_security_group_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for StaleSecurityGroupSet
    class StaleSecurityGroupSet
      def self.default(visited=[])
        return nil if visited.include?('StaleSecurityGroupSet')
        visited = visited + ['StaleSecurityGroupSet']
        [
          StaleSecurityGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << StaleSecurityGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for StaleSecurityGroup
    class StaleSecurityGroup
      def self.default(visited=[])
        return nil if visited.include?('StaleSecurityGroup')
        visited = visited + ['StaleSecurityGroup']
        {
          description: 'description',
          group_id: 'group_id',
          group_name: 'group_name',
          stale_ip_permissions: StaleIpPermissionSet.default(visited),
          stale_ip_permissions_egress: StaleIpPermissionSet.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('staleIpPermissions', StaleIpPermissionSet.stub('item', stub[:stale_ip_permissions])) unless stub[:stale_ip_permissions].nil?
        xml << Hearth::XML::Node.new('staleIpPermissionsEgress', StaleIpPermissionSet.stub('item', stub[:stale_ip_permissions_egress])) unless stub[:stale_ip_permissions_egress].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    # List Stubber for StaleIpPermissionSet
    class StaleIpPermissionSet
      def self.default(visited=[])
        return nil if visited.include?('StaleIpPermissionSet')
        visited = visited + ['StaleIpPermissionSet']
        [
          StaleIpPermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << StaleIpPermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for StaleIpPermission
    class StaleIpPermission
      def self.default(visited=[])
        return nil if visited.include?('StaleIpPermission')
        visited = visited + ['StaleIpPermission']
        {
          from_port: 1,
          ip_protocol: 'ip_protocol',
          ip_ranges: IpRanges.default(visited),
          prefix_list_ids: PrefixListIdSet.default(visited),
          to_port: 1,
          user_id_group_pairs: UserIdGroupPairSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fromPort', stub[:from_port].to_s) unless stub[:from_port].nil?
        xml << Hearth::XML::Node.new('ipProtocol', stub[:ip_protocol].to_s) unless stub[:ip_protocol].nil?
        xml << Hearth::XML::Node.new('ipRanges', IpRanges.stub('item', stub[:ip_ranges])) unless stub[:ip_ranges].nil?
        xml << Hearth::XML::Node.new('prefixListIds', PrefixListIdSet.stub('item', stub[:prefix_list_ids])) unless stub[:prefix_list_ids].nil?
        xml << Hearth::XML::Node.new('toPort', stub[:to_port].to_s) unless stub[:to_port].nil?
        xml << Hearth::XML::Node.new('groups', UserIdGroupPairSet.stub('item', stub[:user_id_group_pairs])) unless stub[:user_id_group_pairs].nil?
        xml
      end
    end

    # List Stubber for UserIdGroupPairSet
    class UserIdGroupPairSet
      def self.default(visited=[])
        return nil if visited.include?('UserIdGroupPairSet')
        visited = visited + ['UserIdGroupPairSet']
        [
          UserIdGroupPair.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UserIdGroupPair.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for PrefixListIdSet
    class PrefixListIdSet
      def self.default(visited=[])
        return nil if visited.include?('PrefixListIdSet')
        visited = visited + ['PrefixListIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # List Stubber for IpRanges
    class IpRanges
      def self.default(visited=[])
        return nil if visited.include?('IpRanges')
        visited = visited + ['IpRanges']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeStoreImageTasks
    class DescribeStoreImageTasks
      def self.default(visited=[])
        {
          store_image_task_results: StoreImageTaskResultSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeStoreImageTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('storeImageTaskResultSet', StoreImageTaskResultSet.stub('item', stub[:store_image_task_results])) unless stub[:store_image_task_results].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for StoreImageTaskResultSet
    class StoreImageTaskResultSet
      def self.default(visited=[])
        return nil if visited.include?('StoreImageTaskResultSet')
        visited = visited + ['StoreImageTaskResultSet']
        [
          StoreImageTaskResult.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << StoreImageTaskResult.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for StoreImageTaskResult
    class StoreImageTaskResult
      def self.default(visited=[])
        return nil if visited.include?('StoreImageTaskResult')
        visited = visited + ['StoreImageTaskResult']
        {
          ami_id: 'ami_id',
          task_start_time: Time.now,
          bucket: 'bucket',
          s3object_key: 's3object_key',
          progress_percentage: 1,
          store_task_state: 'store_task_state',
          store_task_failure_reason: 'store_task_failure_reason',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('amiId', stub[:ami_id].to_s) unless stub[:ami_id].nil?
        xml << Hearth::XML::Node.new('taskStartTime', Hearth::TimeHelper.to_date_time(stub[:task_start_time])) unless stub[:task_start_time].nil?
        xml << Hearth::XML::Node.new('bucket', stub[:bucket].to_s) unless stub[:bucket].nil?
        xml << Hearth::XML::Node.new('s3objectKey', stub[:s3object_key].to_s) unless stub[:s3object_key].nil?
        xml << Hearth::XML::Node.new('progressPercentage', stub[:progress_percentage].to_s) unless stub[:progress_percentage].nil?
        xml << Hearth::XML::Node.new('storeTaskState', stub[:store_task_state].to_s) unless stub[:store_task_state].nil?
        xml << Hearth::XML::Node.new('storeTaskFailureReason', stub[:store_task_failure_reason].to_s) unless stub[:store_task_failure_reason].nil?
        xml
      end
    end

    # Operation Stubber for DescribeSubnets
    class DescribeSubnets
      def self.default(visited=[])
        {
          subnets: SubnetList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSubnetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('subnetSet', SubnetList.stub('item', stub[:subnets])) unless stub[:subnets].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SubnetList
    class SubnetList
      def self.default(visited=[])
        return nil if visited.include?('SubnetList')
        visited = visited + ['SubnetList']
        [
          Subnet.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Subnet.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTags
    class DescribeTags
      def self.default(visited=[])
        {
          next_token: 'next_token',
          tags: TagDescriptionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTagsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('tagSet', TagDescriptionList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TagDescriptionList
    class TagDescriptionList
      def self.default(visited=[])
        return nil if visited.include?('TagDescriptionList')
        visited = visited + ['TagDescriptionList']
        [
          TagDescription.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TagDescription.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TagDescription
    class TagDescription
      def self.default(visited=[])
        return nil if visited.include?('TagDescription')
        visited = visited + ['TagDescription']
        {
          key: 'key',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('key', stub[:key].to_s) unless stub[:key].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    # Operation Stubber for DescribeTrafficMirrorFilters
    class DescribeTrafficMirrorFilters
      def self.default(visited=[])
        {
          traffic_mirror_filters: TrafficMirrorFilterSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTrafficMirrorFiltersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorFilterSet', TrafficMirrorFilterSet.stub('item', stub[:traffic_mirror_filters])) unless stub[:traffic_mirror_filters].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TrafficMirrorFilterSet
    class TrafficMirrorFilterSet
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorFilterSet')
        visited = visited + ['TrafficMirrorFilterSet']
        [
          TrafficMirrorFilter.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrafficMirrorFilter.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTrafficMirrorSessions
    class DescribeTrafficMirrorSessions
      def self.default(visited=[])
        {
          traffic_mirror_sessions: TrafficMirrorSessionSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTrafficMirrorSessionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorSessionSet', TrafficMirrorSessionSet.stub('item', stub[:traffic_mirror_sessions])) unless stub[:traffic_mirror_sessions].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TrafficMirrorSessionSet
    class TrafficMirrorSessionSet
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorSessionSet')
        visited = visited + ['TrafficMirrorSessionSet']
        [
          TrafficMirrorSession.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrafficMirrorSession.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTrafficMirrorTargets
    class DescribeTrafficMirrorTargets
      def self.default(visited=[])
        {
          traffic_mirror_targets: TrafficMirrorTargetSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTrafficMirrorTargetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorTargetSet', TrafficMirrorTargetSet.stub('item', stub[:traffic_mirror_targets])) unless stub[:traffic_mirror_targets].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TrafficMirrorTargetSet
    class TrafficMirrorTargetSet
      def self.default(visited=[])
        return nil if visited.include?('TrafficMirrorTargetSet')
        visited = visited + ['TrafficMirrorTargetSet']
        [
          TrafficMirrorTarget.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrafficMirrorTarget.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTransitGatewayAttachments
    class DescribeTransitGatewayAttachments
      def self.default(visited=[])
        {
          transit_gateway_attachments: TransitGatewayAttachmentList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayAttachmentsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayAttachments', TransitGatewayAttachmentList.stub('item', stub[:transit_gateway_attachments])) unless stub[:transit_gateway_attachments].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayAttachmentList
    class TransitGatewayAttachmentList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayAttachmentList')
        visited = visited + ['TransitGatewayAttachmentList']
        [
          TransitGatewayAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TransitGatewayAttachment
    class TransitGatewayAttachment
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayAttachment')
        visited = visited + ['TransitGatewayAttachment']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          transit_gateway_id: 'transit_gateway_id',
          transit_gateway_owner_id: 'transit_gateway_owner_id',
          resource_owner_id: 'resource_owner_id',
          resource_type: 'resource_type',
          resource_id: 'resource_id',
          state: 'state',
          association: TransitGatewayAttachmentAssociation.default(visited),
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayOwnerId', stub[:transit_gateway_owner_id].to_s) unless stub[:transit_gateway_owner_id].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << TransitGatewayAttachmentAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    # Structure Stubber for TransitGatewayAttachmentAssociation
    class TransitGatewayAttachmentAssociation
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayAttachmentAssociation')
        visited = visited + ['TransitGatewayAttachmentAssociation']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for DescribeTransitGatewayConnectPeers
    class DescribeTransitGatewayConnectPeers
      def self.default(visited=[])
        {
          transit_gateway_connect_peers: TransitGatewayConnectPeerList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayConnectPeersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayConnectPeerSet', TransitGatewayConnectPeerList.stub('item', stub[:transit_gateway_connect_peers])) unless stub[:transit_gateway_connect_peers].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayConnectPeerList
    class TransitGatewayConnectPeerList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayConnectPeerList')
        visited = visited + ['TransitGatewayConnectPeerList']
        [
          TransitGatewayConnectPeer.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayConnectPeer.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTransitGatewayConnects
    class DescribeTransitGatewayConnects
      def self.default(visited=[])
        {
          transit_gateway_connects: TransitGatewayConnectList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayConnectsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayConnectSet', TransitGatewayConnectList.stub('item', stub[:transit_gateway_connects])) unless stub[:transit_gateway_connects].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayConnectList
    class TransitGatewayConnectList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayConnectList')
        visited = visited + ['TransitGatewayConnectList']
        [
          TransitGatewayConnect.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayConnect.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTransitGatewayMulticastDomains
    class DescribeTransitGatewayMulticastDomains
      def self.default(visited=[])
        {
          transit_gateway_multicast_domains: TransitGatewayMulticastDomainList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayMulticastDomainsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomains', TransitGatewayMulticastDomainList.stub('item', stub[:transit_gateway_multicast_domains])) unless stub[:transit_gateway_multicast_domains].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayMulticastDomainList
    class TransitGatewayMulticastDomainList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastDomainList')
        visited = visited + ['TransitGatewayMulticastDomainList']
        [
          TransitGatewayMulticastDomain.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayMulticastDomain.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTransitGatewayPeeringAttachments
    class DescribeTransitGatewayPeeringAttachments
      def self.default(visited=[])
        {
          transit_gateway_peering_attachments: TransitGatewayPeeringAttachmentList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayPeeringAttachmentsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayPeeringAttachments', TransitGatewayPeeringAttachmentList.stub('item', stub[:transit_gateway_peering_attachments])) unless stub[:transit_gateway_peering_attachments].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayPeeringAttachmentList
    class TransitGatewayPeeringAttachmentList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayPeeringAttachmentList')
        visited = visited + ['TransitGatewayPeeringAttachmentList']
        [
          TransitGatewayPeeringAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayPeeringAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTransitGatewayRouteTables
    class DescribeTransitGatewayRouteTables
      def self.default(visited=[])
        {
          transit_gateway_route_tables: TransitGatewayRouteTableList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayRouteTablesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayRouteTables', TransitGatewayRouteTableList.stub('item', stub[:transit_gateway_route_tables])) unless stub[:transit_gateway_route_tables].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayRouteTableList
    class TransitGatewayRouteTableList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteTableList')
        visited = visited + ['TransitGatewayRouteTableList']
        [
          TransitGatewayRouteTable.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRouteTable.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTransitGatewayVpcAttachments
    class DescribeTransitGatewayVpcAttachments
      def self.default(visited=[])
        {
          transit_gateway_vpc_attachments: TransitGatewayVpcAttachmentList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayVpcAttachmentsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayVpcAttachments', TransitGatewayVpcAttachmentList.stub('item', stub[:transit_gateway_vpc_attachments])) unless stub[:transit_gateway_vpc_attachments].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayVpcAttachmentList
    class TransitGatewayVpcAttachmentList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayVpcAttachmentList')
        visited = visited + ['TransitGatewayVpcAttachmentList']
        [
          TransitGatewayVpcAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayVpcAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTransitGateways
    class DescribeTransitGateways
      def self.default(visited=[])
        {
          transit_gateways: TransitGatewayList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewaySet', TransitGatewayList.stub('item', stub[:transit_gateways])) unless stub[:transit_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayList
    class TransitGatewayList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayList')
        visited = visited + ['TransitGatewayList']
        [
          TransitGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeTrunkInterfaceAssociations
    class DescribeTrunkInterfaceAssociations
      def self.default(visited=[])
        {
          interface_associations: TrunkInterfaceAssociationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTrunkInterfaceAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('interfaceAssociationSet', TrunkInterfaceAssociationList.stub('item', stub[:interface_associations])) unless stub[:interface_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TrunkInterfaceAssociationList
    class TrunkInterfaceAssociationList
      def self.default(visited=[])
        return nil if visited.include?('TrunkInterfaceAssociationList')
        visited = visited + ['TrunkInterfaceAssociationList']
        [
          TrunkInterfaceAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrunkInterfaceAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeVolumeAttribute
    class DescribeVolumeAttribute
      def self.default(visited=[])
        {
          auto_enable_io: AttributeBooleanValue.default(visited),
          product_codes: ProductCodeList.default(visited),
          volume_id: 'volume_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVolumeAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << AttributeBooleanValue.stub('autoEnableIO', stub[:auto_enable_io]) unless stub[:auto_enable_io].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeVolumeStatus
    class DescribeVolumeStatus
      def self.default(visited=[])
        {
          next_token: 'next_token',
          volume_statuses: VolumeStatusList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVolumeStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('volumeStatusSet', VolumeStatusList.stub('item', stub[:volume_statuses])) unless stub[:volume_statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VolumeStatusList
    class VolumeStatusList
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusList')
        visited = visited + ['VolumeStatusList']
        [
          VolumeStatusItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VolumeStatusItem
    class VolumeStatusItem
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusItem')
        visited = visited + ['VolumeStatusItem']
        {
          actions: VolumeStatusActionsList.default(visited),
          availability_zone: 'availability_zone',
          outpost_arn: 'outpost_arn',
          events: VolumeStatusEventsList.default(visited),
          volume_id: 'volume_id',
          volume_status: VolumeStatusInfo.default(visited),
          attachment_statuses: VolumeStatusAttachmentStatusList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('actionsSet', VolumeStatusActionsList.stub('item', stub[:actions])) unless stub[:actions].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('eventsSet', VolumeStatusEventsList.stub('item', stub[:events])) unless stub[:events].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << VolumeStatusInfo.stub('volumeStatus', stub[:volume_status]) unless stub[:volume_status].nil?
        xml << Hearth::XML::Node.new('attachmentStatuses', VolumeStatusAttachmentStatusList.stub('item', stub[:attachment_statuses])) unless stub[:attachment_statuses].nil?
        xml
      end
    end

    # List Stubber for VolumeStatusAttachmentStatusList
    class VolumeStatusAttachmentStatusList
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusAttachmentStatusList')
        visited = visited + ['VolumeStatusAttachmentStatusList']
        [
          VolumeStatusAttachmentStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusAttachmentStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VolumeStatusAttachmentStatus
    class VolumeStatusAttachmentStatus
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusAttachmentStatus')
        visited = visited + ['VolumeStatusAttachmentStatus']
        {
          io_performance: 'io_performance',
          instance_id: 'instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ioPerformance', stub[:io_performance].to_s) unless stub[:io_performance].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml
      end
    end

    # Structure Stubber for VolumeStatusInfo
    class VolumeStatusInfo
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusInfo')
        visited = visited + ['VolumeStatusInfo']
        {
          details: VolumeStatusDetailsList.default(visited),
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('details', VolumeStatusDetailsList.stub('item', stub[:details])) unless stub[:details].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    # List Stubber for VolumeStatusDetailsList
    class VolumeStatusDetailsList
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusDetailsList')
        visited = visited + ['VolumeStatusDetailsList']
        [
          VolumeStatusDetails.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusDetails.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VolumeStatusDetails
    class VolumeStatusDetails
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusDetails')
        visited = visited + ['VolumeStatusDetails']
        {
          name: 'name',
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    # List Stubber for VolumeStatusEventsList
    class VolumeStatusEventsList
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusEventsList')
        visited = visited + ['VolumeStatusEventsList']
        [
          VolumeStatusEvent.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusEvent.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VolumeStatusEvent
    class VolumeStatusEvent
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusEvent')
        visited = visited + ['VolumeStatusEvent']
        {
          description: 'description',
          event_id: 'event_id',
          event_type: 'event_type',
          not_after: Time.now,
          not_before: Time.now,
          instance_id: 'instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('eventId', stub[:event_id].to_s) unless stub[:event_id].nil?
        xml << Hearth::XML::Node.new('eventType', stub[:event_type].to_s) unless stub[:event_type].nil?
        xml << Hearth::XML::Node.new('notAfter', Hearth::TimeHelper.to_date_time(stub[:not_after])) unless stub[:not_after].nil?
        xml << Hearth::XML::Node.new('notBefore', Hearth::TimeHelper.to_date_time(stub[:not_before])) unless stub[:not_before].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml
      end
    end

    # List Stubber for VolumeStatusActionsList
    class VolumeStatusActionsList
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusActionsList')
        visited = visited + ['VolumeStatusActionsList']
        [
          VolumeStatusAction.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusAction.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VolumeStatusAction
    class VolumeStatusAction
      def self.default(visited=[])
        return nil if visited.include?('VolumeStatusAction')
        visited = visited + ['VolumeStatusAction']
        {
          code: 'code',
          description: 'description',
          event_id: 'event_id',
          event_type: 'event_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('eventId', stub[:event_id].to_s) unless stub[:event_id].nil?
        xml << Hearth::XML::Node.new('eventType', stub[:event_type].to_s) unless stub[:event_type].nil?
        xml
      end
    end

    # Operation Stubber for DescribeVolumes
    class DescribeVolumes
      def self.default(visited=[])
        {
          volumes: VolumeList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVolumesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('volumeSet', VolumeList.stub('item', stub[:volumes])) unless stub[:volumes].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VolumeList
    class VolumeList
      def self.default(visited=[])
        return nil if visited.include?('VolumeList')
        visited = visited + ['VolumeList']
        [
          Volume.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Volume.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Volume
    class Volume
      def self.default(visited=[])
        return nil if visited.include?('Volume')
        visited = visited + ['Volume']
        {
          attachments: VolumeAttachmentList.default(visited),
          availability_zone: 'availability_zone',
          create_time: Time.now,
          encrypted: false,
          kms_key_id: 'kms_key_id',
          outpost_arn: 'outpost_arn',
          size: 1,
          snapshot_id: 'snapshot_id',
          state: 'state',
          volume_id: 'volume_id',
          iops: 1,
          tags: TagList.default(visited),
          volume_type: 'volume_type',
          fast_restored: false,
          multi_attach_enabled: false,
          throughput: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachmentSet', VolumeAttachmentList.stub('item', stub[:attachments])) unless stub[:attachments].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('size', stub[:size].to_s) unless stub[:size].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('iops', stub[:iops].to_s) unless stub[:iops].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('volumeType', stub[:volume_type].to_s) unless stub[:volume_type].nil?
        xml << Hearth::XML::Node.new('fastRestored', stub[:fast_restored].to_s) unless stub[:fast_restored].nil?
        xml << Hearth::XML::Node.new('multiAttachEnabled', stub[:multi_attach_enabled].to_s) unless stub[:multi_attach_enabled].nil?
        xml << Hearth::XML::Node.new('throughput', stub[:throughput].to_s) unless stub[:throughput].nil?
        xml
      end
    end

    # Operation Stubber for DescribeVolumesModifications
    class DescribeVolumesModifications
      def self.default(visited=[])
        {
          volumes_modifications: VolumeModificationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVolumesModificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('volumeModificationSet', VolumeModificationList.stub('item', stub[:volumes_modifications])) unless stub[:volumes_modifications].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VolumeModificationList
    class VolumeModificationList
      def self.default(visited=[])
        return nil if visited.include?('VolumeModificationList')
        visited = visited + ['VolumeModificationList']
        [
          VolumeModification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeModification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VolumeModification
    class VolumeModification
      def self.default(visited=[])
        return nil if visited.include?('VolumeModification')
        visited = visited + ['VolumeModification']
        {
          volume_id: 'volume_id',
          modification_state: 'modification_state',
          status_message: 'status_message',
          target_size: 1,
          target_iops: 1,
          target_volume_type: 'target_volume_type',
          target_throughput: 1,
          target_multi_attach_enabled: false,
          original_size: 1,
          original_iops: 1,
          original_volume_type: 'original_volume_type',
          original_throughput: 1,
          original_multi_attach_enabled: false,
          progress: 1,
          start_time: Time.now,
          end_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('modificationState', stub[:modification_state].to_s) unless stub[:modification_state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('targetSize', stub[:target_size].to_s) unless stub[:target_size].nil?
        xml << Hearth::XML::Node.new('targetIops', stub[:target_iops].to_s) unless stub[:target_iops].nil?
        xml << Hearth::XML::Node.new('targetVolumeType', stub[:target_volume_type].to_s) unless stub[:target_volume_type].nil?
        xml << Hearth::XML::Node.new('targetThroughput', stub[:target_throughput].to_s) unless stub[:target_throughput].nil?
        xml << Hearth::XML::Node.new('targetMultiAttachEnabled', stub[:target_multi_attach_enabled].to_s) unless stub[:target_multi_attach_enabled].nil?
        xml << Hearth::XML::Node.new('originalSize', stub[:original_size].to_s) unless stub[:original_size].nil?
        xml << Hearth::XML::Node.new('originalIops', stub[:original_iops].to_s) unless stub[:original_iops].nil?
        xml << Hearth::XML::Node.new('originalVolumeType', stub[:original_volume_type].to_s) unless stub[:original_volume_type].nil?
        xml << Hearth::XML::Node.new('originalThroughput', stub[:original_throughput].to_s) unless stub[:original_throughput].nil?
        xml << Hearth::XML::Node.new('originalMultiAttachEnabled', stub[:original_multi_attach_enabled].to_s) unless stub[:original_multi_attach_enabled].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('endTime', Hearth::TimeHelper.to_date_time(stub[:end_time])) unless stub[:end_time].nil?
        xml
      end
    end

    # Operation Stubber for DescribeVpcAttribute
    class DescribeVpcAttribute
      def self.default(visited=[])
        {
          vpc_id: 'vpc_id',
          enable_dns_hostnames: AttributeBooleanValue.default(visited),
          enable_dns_support: AttributeBooleanValue.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << AttributeBooleanValue.stub('enableDnsHostnames', stub[:enable_dns_hostnames]) unless stub[:enable_dns_hostnames].nil?
        xml << AttributeBooleanValue.stub('enableDnsSupport', stub[:enable_dns_support]) unless stub[:enable_dns_support].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DescribeVpcClassicLink
    class DescribeVpcClassicLink
      def self.default(visited=[])
        {
          vpcs: VpcClassicLinkList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcClassicLinkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcSet', VpcClassicLinkList.stub('item', stub[:vpcs])) unless stub[:vpcs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VpcClassicLinkList
    class VpcClassicLinkList
      def self.default(visited=[])
        return nil if visited.include?('VpcClassicLinkList')
        visited = visited + ['VpcClassicLinkList']
        [
          VpcClassicLink.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcClassicLink.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VpcClassicLink
    class VpcClassicLink
      def self.default(visited=[])
        return nil if visited.include?('VpcClassicLink')
        visited = visited + ['VpcClassicLink']
        {
          classic_link_enabled: false,
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('classicLinkEnabled', stub[:classic_link_enabled].to_s) unless stub[:classic_link_enabled].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    # Operation Stubber for DescribeVpcClassicLinkDnsSupport
    class DescribeVpcClassicLinkDnsSupport
      def self.default(visited=[])
        {
          next_token: 'next_token',
          vpcs: ClassicLinkDnsSupportList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcClassicLinkDnsSupportResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('vpcs', ClassicLinkDnsSupportList.stub('item', stub[:vpcs])) unless stub[:vpcs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ClassicLinkDnsSupportList
    class ClassicLinkDnsSupportList
      def self.default(visited=[])
        return nil if visited.include?('ClassicLinkDnsSupportList')
        visited = visited + ['ClassicLinkDnsSupportList']
        [
          ClassicLinkDnsSupport.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClassicLinkDnsSupport.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ClassicLinkDnsSupport
    class ClassicLinkDnsSupport
      def self.default(visited=[])
        return nil if visited.include?('ClassicLinkDnsSupport')
        visited = visited + ['ClassicLinkDnsSupport']
        {
          classic_link_dns_supported: false,
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('classicLinkDnsSupported', stub[:classic_link_dns_supported].to_s) unless stub[:classic_link_dns_supported].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    # Operation Stubber for DescribeVpcEndpointConnectionNotifications
    class DescribeVpcEndpointConnectionNotifications
      def self.default(visited=[])
        {
          connection_notification_set: ConnectionNotificationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointConnectionNotificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('connectionNotificationSet', ConnectionNotificationSet.stub('item', stub[:connection_notification_set])) unless stub[:connection_notification_set].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ConnectionNotificationSet
    class ConnectionNotificationSet
      def self.default(visited=[])
        return nil if visited.include?('ConnectionNotificationSet')
        visited = visited + ['ConnectionNotificationSet']
        [
          ConnectionNotification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ConnectionNotification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeVpcEndpointConnections
    class DescribeVpcEndpointConnections
      def self.default(visited=[])
        {
          vpc_endpoint_connections: VpcEndpointConnectionSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcEndpointConnectionSet', VpcEndpointConnectionSet.stub('item', stub[:vpc_endpoint_connections])) unless stub[:vpc_endpoint_connections].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VpcEndpointConnectionSet
    class VpcEndpointConnectionSet
      def self.default(visited=[])
        return nil if visited.include?('VpcEndpointConnectionSet')
        visited = visited + ['VpcEndpointConnectionSet']
        [
          VpcEndpointConnection.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcEndpointConnection.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VpcEndpointConnection
    class VpcEndpointConnection
      def self.default(visited=[])
        return nil if visited.include?('VpcEndpointConnection')
        visited = visited + ['VpcEndpointConnection']
        {
          service_id: 'service_id',
          vpc_endpoint_id: 'vpc_endpoint_id',
          vpc_endpoint_owner: 'vpc_endpoint_owner',
          vpc_endpoint_state: 'vpc_endpoint_state',
          creation_timestamp: Time.now,
          dns_entries: DnsEntrySet.default(visited),
          network_load_balancer_arns: ValueStringList.default(visited),
          gateway_load_balancer_arns: ValueStringList.default(visited),
          ip_address_type: 'ip_address_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml << Hearth::XML::Node.new('vpcEndpointId', stub[:vpc_endpoint_id].to_s) unless stub[:vpc_endpoint_id].nil?
        xml << Hearth::XML::Node.new('vpcEndpointOwner', stub[:vpc_endpoint_owner].to_s) unless stub[:vpc_endpoint_owner].nil?
        xml << Hearth::XML::Node.new('vpcEndpointState', stub[:vpc_endpoint_state].to_s) unless stub[:vpc_endpoint_state].nil?
        xml << Hearth::XML::Node.new('creationTimestamp', Hearth::TimeHelper.to_date_time(stub[:creation_timestamp])) unless stub[:creation_timestamp].nil?
        xml << Hearth::XML::Node.new('dnsEntrySet', DnsEntrySet.stub('item', stub[:dns_entries])) unless stub[:dns_entries].nil?
        xml << Hearth::XML::Node.new('networkLoadBalancerArnSet', ValueStringList.stub('item', stub[:network_load_balancer_arns])) unless stub[:network_load_balancer_arns].nil?
        xml << Hearth::XML::Node.new('gatewayLoadBalancerArnSet', ValueStringList.stub('item', stub[:gateway_load_balancer_arns])) unless stub[:gateway_load_balancer_arns].nil?
        xml << Hearth::XML::Node.new('ipAddressType', stub[:ip_address_type].to_s) unless stub[:ip_address_type].nil?
        xml
      end
    end

    # Operation Stubber for DescribeVpcEndpointServiceConfigurations
    class DescribeVpcEndpointServiceConfigurations
      def self.default(visited=[])
        {
          service_configurations: ServiceConfigurationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointServiceConfigurationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serviceConfigurationSet', ServiceConfigurationSet.stub('item', stub[:service_configurations])) unless stub[:service_configurations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ServiceConfigurationSet
    class ServiceConfigurationSet
      def self.default(visited=[])
        return nil if visited.include?('ServiceConfigurationSet')
        visited = visited + ['ServiceConfigurationSet']
        [
          ServiceConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ServiceConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeVpcEndpointServicePermissions
    class DescribeVpcEndpointServicePermissions
      def self.default(visited=[])
        {
          allowed_principals: AllowedPrincipalSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointServicePermissionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('allowedPrincipals', AllowedPrincipalSet.stub('item', stub[:allowed_principals])) unless stub[:allowed_principals].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for AllowedPrincipalSet
    class AllowedPrincipalSet
      def self.default(visited=[])
        return nil if visited.include?('AllowedPrincipalSet')
        visited = visited + ['AllowedPrincipalSet']
        [
          AllowedPrincipal.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AllowedPrincipal.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AllowedPrincipal
    class AllowedPrincipal
      def self.default(visited=[])
        return nil if visited.include?('AllowedPrincipal')
        visited = visited + ['AllowedPrincipal']
        {
          principal_type: 'principal_type',
          principal: 'principal',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('principalType', stub[:principal_type].to_s) unless stub[:principal_type].nil?
        xml << Hearth::XML::Node.new('principal', stub[:principal].to_s) unless stub[:principal].nil?
        xml
      end
    end

    # Operation Stubber for DescribeVpcEndpointServices
    class DescribeVpcEndpointServices
      def self.default(visited=[])
        {
          service_names: ValueStringList.default(visited),
          service_details: ServiceDetailSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointServicesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serviceNameSet', ValueStringList.stub('item', stub[:service_names])) unless stub[:service_names].nil?
        xml << Hearth::XML::Node.new('serviceDetailSet', ServiceDetailSet.stub('item', stub[:service_details])) unless stub[:service_details].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ServiceDetailSet
    class ServiceDetailSet
      def self.default(visited=[])
        return nil if visited.include?('ServiceDetailSet')
        visited = visited + ['ServiceDetailSet']
        [
          ServiceDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ServiceDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ServiceDetail
    class ServiceDetail
      def self.default(visited=[])
        return nil if visited.include?('ServiceDetail')
        visited = visited + ['ServiceDetail']
        {
          service_name: 'service_name',
          service_id: 'service_id',
          service_type: ServiceTypeDetailSet.default(visited),
          availability_zones: ValueStringList.default(visited),
          owner: 'owner',
          base_endpoint_dns_names: ValueStringList.default(visited),
          private_dns_name: 'private_dns_name',
          private_dns_names: PrivateDnsDetailsSet.default(visited),
          vpc_endpoint_policy_supported: false,
          acceptance_required: false,
          manages_vpc_endpoints: false,
          payer_responsibility: 'payer_responsibility',
          tags: TagList.default(visited),
          private_dns_name_verification_state: 'private_dns_name_verification_state',
          supported_ip_address_types: SupportedIpAddressTypes.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('serviceName', stub[:service_name].to_s) unless stub[:service_name].nil?
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml << Hearth::XML::Node.new('serviceType', ServiceTypeDetailSet.stub('item', stub[:service_type])) unless stub[:service_type].nil?
        xml << Hearth::XML::Node.new('availabilityZoneSet', ValueStringList.stub('item', stub[:availability_zones])) unless stub[:availability_zones].nil?
        xml << Hearth::XML::Node.new('owner', stub[:owner].to_s) unless stub[:owner].nil?
        xml << Hearth::XML::Node.new('baseEndpointDnsNameSet', ValueStringList.stub('item', stub[:base_endpoint_dns_names])) unless stub[:base_endpoint_dns_names].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateDnsNameSet', PrivateDnsDetailsSet.stub('item', stub[:private_dns_names])) unless stub[:private_dns_names].nil?
        xml << Hearth::XML::Node.new('vpcEndpointPolicySupported', stub[:vpc_endpoint_policy_supported].to_s) unless stub[:vpc_endpoint_policy_supported].nil?
        xml << Hearth::XML::Node.new('acceptanceRequired', stub[:acceptance_required].to_s) unless stub[:acceptance_required].nil?
        xml << Hearth::XML::Node.new('managesVpcEndpoints', stub[:manages_vpc_endpoints].to_s) unless stub[:manages_vpc_endpoints].nil?
        xml << Hearth::XML::Node.new('payerResponsibility', stub[:payer_responsibility].to_s) unless stub[:payer_responsibility].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('privateDnsNameVerificationState', stub[:private_dns_name_verification_state].to_s) unless stub[:private_dns_name_verification_state].nil?
        xml << Hearth::XML::Node.new('supportedIpAddressTypeSet', SupportedIpAddressTypes.stub('item', stub[:supported_ip_address_types])) unless stub[:supported_ip_address_types].nil?
        xml
      end
    end

    # List Stubber for PrivateDnsDetailsSet
    class PrivateDnsDetailsSet
      def self.default(visited=[])
        return nil if visited.include?('PrivateDnsDetailsSet')
        visited = visited + ['PrivateDnsDetailsSet']
        [
          PrivateDnsDetails.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrivateDnsDetails.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PrivateDnsDetails
    class PrivateDnsDetails
      def self.default(visited=[])
        return nil if visited.include?('PrivateDnsDetails')
        visited = visited + ['PrivateDnsDetails']
        {
          private_dns_name: 'private_dns_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml
      end
    end

    # Operation Stubber for DescribeVpcEndpoints
    class DescribeVpcEndpoints
      def self.default(visited=[])
        {
          vpc_endpoints: VpcEndpointSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcEndpointSet', VpcEndpointSet.stub('item', stub[:vpc_endpoints])) unless stub[:vpc_endpoints].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VpcEndpointSet
    class VpcEndpointSet
      def self.default(visited=[])
        return nil if visited.include?('VpcEndpointSet')
        visited = visited + ['VpcEndpointSet']
        [
          VpcEndpoint.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcEndpoint.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeVpcPeeringConnections
    class DescribeVpcPeeringConnections
      def self.default(visited=[])
        {
          vpc_peering_connections: VpcPeeringConnectionList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcPeeringConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcPeeringConnectionSet', VpcPeeringConnectionList.stub('item', stub[:vpc_peering_connections])) unless stub[:vpc_peering_connections].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VpcPeeringConnectionList
    class VpcPeeringConnectionList
      def self.default(visited=[])
        return nil if visited.include?('VpcPeeringConnectionList')
        visited = visited + ['VpcPeeringConnectionList']
        [
          VpcPeeringConnection.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcPeeringConnection.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeVpcs
    class DescribeVpcs
      def self.default(visited=[])
        {
          vpcs: VpcList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcSet', VpcList.stub('item', stub[:vpcs])) unless stub[:vpcs].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VpcList
    class VpcList
      def self.default(visited=[])
        return nil if visited.include?('VpcList')
        visited = visited + ['VpcList']
        [
          Vpc.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Vpc.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeVpnConnections
    class DescribeVpnConnections
      def self.default(visited=[])
        {
          vpn_connections: VpnConnectionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpnConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpnConnectionSet', VpnConnectionList.stub('item', stub[:vpn_connections])) unless stub[:vpn_connections].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VpnConnectionList
    class VpnConnectionList
      def self.default(visited=[])
        return nil if visited.include?('VpnConnectionList')
        visited = visited + ['VpnConnectionList']
        [
          VpnConnection.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpnConnection.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DescribeVpnGateways
    class DescribeVpnGateways
      def self.default(visited=[])
        {
          vpn_gateways: VpnGatewayList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpnGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpnGatewaySet', VpnGatewayList.stub('item', stub[:vpn_gateways])) unless stub[:vpn_gateways].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VpnGatewayList
    class VpnGatewayList
      def self.default(visited=[])
        return nil if visited.include?('VpnGatewayList')
        visited = visited + ['VpnGatewayList']
        [
          VpnGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpnGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for DetachClassicLinkVpc
    class DetachClassicLinkVpc
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachClassicLinkVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DetachInternetGateway
    class DetachInternetGateway
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DetachNetworkInterface
    class DetachNetworkInterface
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachNetworkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DetachVolume
    class DetachVolume
      def self.default(visited=[])
        {
          attach_time: Time.now,
          device: 'device',
          instance_id: 'instance_id',
          state: 'state',
          volume_id: 'volume_id',
          delete_on_termination: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('device', stub[:device].to_s) unless stub[:device].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DetachVpnGateway
    class DetachVpnGateway
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachVpnGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisableEbsEncryptionByDefault
    class DisableEbsEncryptionByDefault
      def self.default(visited=[])
        {
          ebs_encryption_by_default: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableEbsEncryptionByDefaultResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ebsEncryptionByDefault', stub[:ebs_encryption_by_default].to_s) unless stub[:ebs_encryption_by_default].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisableFastLaunch
    class DisableFastLaunch
      def self.default(visited=[])
        {
          image_id: 'image_id',
          resource_type: 'resource_type',
          snapshot_configuration: FastLaunchSnapshotConfigurationResponse.default(visited),
          launch_template: FastLaunchLaunchTemplateSpecificationResponse.default(visited),
          max_parallel_launches: 1,
          owner_id: 'owner_id',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          state_transition_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableFastLaunchResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << FastLaunchSnapshotConfigurationResponse.stub('snapshotConfiguration', stub[:snapshot_configuration]) unless stub[:snapshot_configuration].nil?
        xml << FastLaunchLaunchTemplateSpecificationResponse.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        xml << Hearth::XML::Node.new('maxParallelLaunches', stub[:max_parallel_launches].to_s) unless stub[:max_parallel_launches].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('stateTransitionTime', Hearth::TimeHelper.to_date_time(stub[:state_transition_time])) unless stub[:state_transition_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisableFastSnapshotRestores
    class DisableFastSnapshotRestores
      def self.default(visited=[])
        {
          successful: DisableFastSnapshotRestoreSuccessSet.default(visited),
          unsuccessful: DisableFastSnapshotRestoreErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableFastSnapshotRestoresResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successful', DisableFastSnapshotRestoreSuccessSet.stub('item', stub[:successful])) unless stub[:successful].nil?
        xml << Hearth::XML::Node.new('unsuccessful', DisableFastSnapshotRestoreErrorSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for DisableFastSnapshotRestoreErrorSet
    class DisableFastSnapshotRestoreErrorSet
      def self.default(visited=[])
        return nil if visited.include?('DisableFastSnapshotRestoreErrorSet')
        visited = visited + ['DisableFastSnapshotRestoreErrorSet']
        [
          DisableFastSnapshotRestoreErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DisableFastSnapshotRestoreErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DisableFastSnapshotRestoreErrorItem
    class DisableFastSnapshotRestoreErrorItem
      def self.default(visited=[])
        return nil if visited.include?('DisableFastSnapshotRestoreErrorItem')
        visited = visited + ['DisableFastSnapshotRestoreErrorItem']
        {
          snapshot_id: 'snapshot_id',
          fast_snapshot_restore_state_errors: DisableFastSnapshotRestoreStateErrorSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('fastSnapshotRestoreStateErrorSet', DisableFastSnapshotRestoreStateErrorSet.stub('item', stub[:fast_snapshot_restore_state_errors])) unless stub[:fast_snapshot_restore_state_errors].nil?
        xml
      end
    end

    # List Stubber for DisableFastSnapshotRestoreStateErrorSet
    class DisableFastSnapshotRestoreStateErrorSet
      def self.default(visited=[])
        return nil if visited.include?('DisableFastSnapshotRestoreStateErrorSet')
        visited = visited + ['DisableFastSnapshotRestoreStateErrorSet']
        [
          DisableFastSnapshotRestoreStateErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DisableFastSnapshotRestoreStateErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DisableFastSnapshotRestoreStateErrorItem
    class DisableFastSnapshotRestoreStateErrorItem
      def self.default(visited=[])
        return nil if visited.include?('DisableFastSnapshotRestoreStateErrorItem')
        visited = visited + ['DisableFastSnapshotRestoreStateErrorItem']
        {
          availability_zone: 'availability_zone',
          error: DisableFastSnapshotRestoreStateError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << DisableFastSnapshotRestoreStateError.stub('error', stub[:error]) unless stub[:error].nil?
        xml
      end
    end

    # Structure Stubber for DisableFastSnapshotRestoreStateError
    class DisableFastSnapshotRestoreStateError
      def self.default(visited=[])
        return nil if visited.include?('DisableFastSnapshotRestoreStateError')
        visited = visited + ['DisableFastSnapshotRestoreStateError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # List Stubber for DisableFastSnapshotRestoreSuccessSet
    class DisableFastSnapshotRestoreSuccessSet
      def self.default(visited=[])
        return nil if visited.include?('DisableFastSnapshotRestoreSuccessSet')
        visited = visited + ['DisableFastSnapshotRestoreSuccessSet']
        [
          DisableFastSnapshotRestoreSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DisableFastSnapshotRestoreSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for DisableFastSnapshotRestoreSuccessItem
    class DisableFastSnapshotRestoreSuccessItem
      def self.default(visited=[])
        return nil if visited.include?('DisableFastSnapshotRestoreSuccessItem')
        visited = visited + ['DisableFastSnapshotRestoreSuccessItem']
        {
          snapshot_id: 'snapshot_id',
          availability_zone: 'availability_zone',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          owner_id: 'owner_id',
          owner_alias: 'owner_alias',
          enabling_time: Time.now,
          optimizing_time: Time.now,
          enabled_time: Time.now,
          disabling_time: Time.now,
          disabled_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('enablingTime', Hearth::TimeHelper.to_date_time(stub[:enabling_time])) unless stub[:enabling_time].nil?
        xml << Hearth::XML::Node.new('optimizingTime', Hearth::TimeHelper.to_date_time(stub[:optimizing_time])) unless stub[:optimizing_time].nil?
        xml << Hearth::XML::Node.new('enabledTime', Hearth::TimeHelper.to_date_time(stub[:enabled_time])) unless stub[:enabled_time].nil?
        xml << Hearth::XML::Node.new('disablingTime', Hearth::TimeHelper.to_date_time(stub[:disabling_time])) unless stub[:disabling_time].nil?
        xml << Hearth::XML::Node.new('disabledTime', Hearth::TimeHelper.to_date_time(stub[:disabled_time])) unless stub[:disabled_time].nil?
        xml
      end
    end

    # Operation Stubber for DisableImageDeprecation
    class DisableImageDeprecation
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableImageDeprecationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisableIpamOrganizationAdminAccount
    class DisableIpamOrganizationAdminAccount
      def self.default(visited=[])
        {
          success: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableIpamOrganizationAdminAccountResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('success', stub[:success].to_s) unless stub[:success].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisableSerialConsoleAccess
    class DisableSerialConsoleAccess
      def self.default(visited=[])
        {
          serial_console_access_enabled: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableSerialConsoleAccessResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serialConsoleAccessEnabled', stub[:serial_console_access_enabled].to_s) unless stub[:serial_console_access_enabled].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisableTransitGatewayRouteTablePropagation
    class DisableTransitGatewayRouteTablePropagation
      def self.default(visited=[])
        {
          propagation: TransitGatewayPropagation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableTransitGatewayRouteTablePropagationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPropagation.stub('propagation', stub[:propagation]) unless stub[:propagation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayPropagation
    class TransitGatewayPropagation
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayPropagation')
        visited = visited + ['TransitGatewayPropagation']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for DisableVgwRoutePropagation
    class DisableVgwRoutePropagation
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableVgwRoutePropagationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisableVpcClassicLink
    class DisableVpcClassicLink
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableVpcClassicLinkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisableVpcClassicLinkDnsSupport
    class DisableVpcClassicLinkDnsSupport
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableVpcClassicLinkDnsSupportResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateAddress
    class DisassociateAddress
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateClientVpnTargetNetwork
    class DisassociateClientVpnTargetNetwork
      def self.default(visited=[])
        {
          association_id: 'association_id',
          status: AssociationStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateClientVpnTargetNetworkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << AssociationStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateEnclaveCertificateIamRole
    class DisassociateEnclaveCertificateIamRole
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateEnclaveCertificateIamRoleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateIamInstanceProfile
    class DisassociateIamInstanceProfile
      def self.default(visited=[])
        {
          iam_instance_profile_association: IamInstanceProfileAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateIamInstanceProfileResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IamInstanceProfileAssociation.stub('iamInstanceProfileAssociation', stub[:iam_instance_profile_association]) unless stub[:iam_instance_profile_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateInstanceEventWindow
    class DisassociateInstanceEventWindow
      def self.default(visited=[])
        {
          instance_event_window: InstanceEventWindow.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindow.stub('instanceEventWindow', stub[:instance_event_window]) unless stub[:instance_event_window].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateRouteTable
    class DisassociateRouteTable
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateSubnetCidrBlock
    class DisassociateSubnetCidrBlock
      def self.default(visited=[])
        {
          ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.default(visited),
          subnet_id: 'subnet_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateSubnetCidrBlockResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SubnetIpv6CidrBlockAssociation.stub('ipv6CidrBlockAssociation', stub[:ipv6_cidr_block_association]) unless stub[:ipv6_cidr_block_association].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateTransitGatewayMulticastDomain
    class DisassociateTransitGatewayMulticastDomain
      def self.default(visited=[])
        {
          associations: TransitGatewayMulticastDomainAssociations.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateTransitGatewayMulticastDomainResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomainAssociations.stub('associations', stub[:associations]) unless stub[:associations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateTransitGatewayRouteTable
    class DisassociateTransitGatewayRouteTable
      def self.default(visited=[])
        {
          association: TransitGatewayAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateTransitGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateTrunkInterface
    class DisassociateTrunkInterface
      def self.default(visited=[])
        {
          return: false,
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateTrunkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for DisassociateVpcCidrBlock
    class DisassociateVpcCidrBlock
      def self.default(visited=[])
        {
          ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.default(visited),
          cidr_block_association: VpcCidrBlockAssociation.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateVpcCidrBlockResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcIpv6CidrBlockAssociation.stub('ipv6CidrBlockAssociation', stub[:ipv6_cidr_block_association]) unless stub[:ipv6_cidr_block_association].nil?
        xml << VpcCidrBlockAssociation.stub('cidrBlockAssociation', stub[:cidr_block_association]) unless stub[:cidr_block_association].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableEbsEncryptionByDefault
    class EnableEbsEncryptionByDefault
      def self.default(visited=[])
        {
          ebs_encryption_by_default: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableEbsEncryptionByDefaultResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ebsEncryptionByDefault', stub[:ebs_encryption_by_default].to_s) unless stub[:ebs_encryption_by_default].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableFastLaunch
    class EnableFastLaunch
      def self.default(visited=[])
        {
          image_id: 'image_id',
          resource_type: 'resource_type',
          snapshot_configuration: FastLaunchSnapshotConfigurationResponse.default(visited),
          launch_template: FastLaunchLaunchTemplateSpecificationResponse.default(visited),
          max_parallel_launches: 1,
          owner_id: 'owner_id',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          state_transition_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableFastLaunchResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << FastLaunchSnapshotConfigurationResponse.stub('snapshotConfiguration', stub[:snapshot_configuration]) unless stub[:snapshot_configuration].nil?
        xml << FastLaunchLaunchTemplateSpecificationResponse.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        xml << Hearth::XML::Node.new('maxParallelLaunches', stub[:max_parallel_launches].to_s) unless stub[:max_parallel_launches].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('stateTransitionTime', Hearth::TimeHelper.to_date_time(stub[:state_transition_time])) unless stub[:state_transition_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableFastSnapshotRestores
    class EnableFastSnapshotRestores
      def self.default(visited=[])
        {
          successful: EnableFastSnapshotRestoreSuccessSet.default(visited),
          unsuccessful: EnableFastSnapshotRestoreErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableFastSnapshotRestoresResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successful', EnableFastSnapshotRestoreSuccessSet.stub('item', stub[:successful])) unless stub[:successful].nil?
        xml << Hearth::XML::Node.new('unsuccessful', EnableFastSnapshotRestoreErrorSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for EnableFastSnapshotRestoreErrorSet
    class EnableFastSnapshotRestoreErrorSet
      def self.default(visited=[])
        return nil if visited.include?('EnableFastSnapshotRestoreErrorSet')
        visited = visited + ['EnableFastSnapshotRestoreErrorSet']
        [
          EnableFastSnapshotRestoreErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << EnableFastSnapshotRestoreErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for EnableFastSnapshotRestoreErrorItem
    class EnableFastSnapshotRestoreErrorItem
      def self.default(visited=[])
        return nil if visited.include?('EnableFastSnapshotRestoreErrorItem')
        visited = visited + ['EnableFastSnapshotRestoreErrorItem']
        {
          snapshot_id: 'snapshot_id',
          fast_snapshot_restore_state_errors: EnableFastSnapshotRestoreStateErrorSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('fastSnapshotRestoreStateErrorSet', EnableFastSnapshotRestoreStateErrorSet.stub('item', stub[:fast_snapshot_restore_state_errors])) unless stub[:fast_snapshot_restore_state_errors].nil?
        xml
      end
    end

    # List Stubber for EnableFastSnapshotRestoreStateErrorSet
    class EnableFastSnapshotRestoreStateErrorSet
      def self.default(visited=[])
        return nil if visited.include?('EnableFastSnapshotRestoreStateErrorSet')
        visited = visited + ['EnableFastSnapshotRestoreStateErrorSet']
        [
          EnableFastSnapshotRestoreStateErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << EnableFastSnapshotRestoreStateErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for EnableFastSnapshotRestoreStateErrorItem
    class EnableFastSnapshotRestoreStateErrorItem
      def self.default(visited=[])
        return nil if visited.include?('EnableFastSnapshotRestoreStateErrorItem')
        visited = visited + ['EnableFastSnapshotRestoreStateErrorItem']
        {
          availability_zone: 'availability_zone',
          error: EnableFastSnapshotRestoreStateError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << EnableFastSnapshotRestoreStateError.stub('error', stub[:error]) unless stub[:error].nil?
        xml
      end
    end

    # Structure Stubber for EnableFastSnapshotRestoreStateError
    class EnableFastSnapshotRestoreStateError
      def self.default(visited=[])
        return nil if visited.include?('EnableFastSnapshotRestoreStateError')
        visited = visited + ['EnableFastSnapshotRestoreStateError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # List Stubber for EnableFastSnapshotRestoreSuccessSet
    class EnableFastSnapshotRestoreSuccessSet
      def self.default(visited=[])
        return nil if visited.include?('EnableFastSnapshotRestoreSuccessSet')
        visited = visited + ['EnableFastSnapshotRestoreSuccessSet']
        [
          EnableFastSnapshotRestoreSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << EnableFastSnapshotRestoreSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for EnableFastSnapshotRestoreSuccessItem
    class EnableFastSnapshotRestoreSuccessItem
      def self.default(visited=[])
        return nil if visited.include?('EnableFastSnapshotRestoreSuccessItem')
        visited = visited + ['EnableFastSnapshotRestoreSuccessItem']
        {
          snapshot_id: 'snapshot_id',
          availability_zone: 'availability_zone',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          owner_id: 'owner_id',
          owner_alias: 'owner_alias',
          enabling_time: Time.now,
          optimizing_time: Time.now,
          enabled_time: Time.now,
          disabling_time: Time.now,
          disabled_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('enablingTime', Hearth::TimeHelper.to_date_time(stub[:enabling_time])) unless stub[:enabling_time].nil?
        xml << Hearth::XML::Node.new('optimizingTime', Hearth::TimeHelper.to_date_time(stub[:optimizing_time])) unless stub[:optimizing_time].nil?
        xml << Hearth::XML::Node.new('enabledTime', Hearth::TimeHelper.to_date_time(stub[:enabled_time])) unless stub[:enabled_time].nil?
        xml << Hearth::XML::Node.new('disablingTime', Hearth::TimeHelper.to_date_time(stub[:disabling_time])) unless stub[:disabling_time].nil?
        xml << Hearth::XML::Node.new('disabledTime', Hearth::TimeHelper.to_date_time(stub[:disabled_time])) unless stub[:disabled_time].nil?
        xml
      end
    end

    # Operation Stubber for EnableImageDeprecation
    class EnableImageDeprecation
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableImageDeprecationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableIpamOrganizationAdminAccount
    class EnableIpamOrganizationAdminAccount
      def self.default(visited=[])
        {
          success: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableIpamOrganizationAdminAccountResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('success', stub[:success].to_s) unless stub[:success].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableSerialConsoleAccess
    class EnableSerialConsoleAccess
      def self.default(visited=[])
        {
          serial_console_access_enabled: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableSerialConsoleAccessResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serialConsoleAccessEnabled', stub[:serial_console_access_enabled].to_s) unless stub[:serial_console_access_enabled].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableTransitGatewayRouteTablePropagation
    class EnableTransitGatewayRouteTablePropagation
      def self.default(visited=[])
        {
          propagation: TransitGatewayPropagation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableTransitGatewayRouteTablePropagationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPropagation.stub('propagation', stub[:propagation]) unless stub[:propagation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableVgwRoutePropagation
    class EnableVgwRoutePropagation
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableVgwRoutePropagationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableVolumeIO
    class EnableVolumeIO
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableVolumeIOResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableVpcClassicLink
    class EnableVpcClassicLink
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableVpcClassicLinkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for EnableVpcClassicLinkDnsSupport
    class EnableVpcClassicLinkDnsSupport
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableVpcClassicLinkDnsSupportResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ExportClientVpnClientCertificateRevocationList
    class ExportClientVpnClientCertificateRevocationList
      def self.default(visited=[])
        {
          certificate_revocation_list: 'certificate_revocation_list',
          status: ClientCertificateRevocationListStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ExportClientVpnClientCertificateRevocationListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('certificateRevocationList', stub[:certificate_revocation_list].to_s) unless stub[:certificate_revocation_list].nil?
        xml << ClientCertificateRevocationListStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for ClientCertificateRevocationListStatus
    class ClientCertificateRevocationListStatus
      def self.default(visited=[])
        return nil if visited.include?('ClientCertificateRevocationListStatus')
        visited = visited + ['ClientCertificateRevocationListStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # Operation Stubber for ExportClientVpnClientConfiguration
    class ExportClientVpnClientConfiguration
      def self.default(visited=[])
        {
          client_configuration: 'client_configuration',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ExportClientVpnClientConfigurationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientConfiguration', stub[:client_configuration].to_s) unless stub[:client_configuration].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ExportImage
    class ExportImage
      def self.default(visited=[])
        {
          description: 'description',
          disk_image_format: 'disk_image_format',
          export_image_task_id: 'export_image_task_id',
          image_id: 'image_id',
          role_name: 'role_name',
          progress: 'progress',
          s3_export_location: ExportTaskS3Location.default(visited),
          status: 'status',
          status_message: 'status_message',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ExportImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('diskImageFormat', stub[:disk_image_format].to_s) unless stub[:disk_image_format].nil?
        xml << Hearth::XML::Node.new('exportImageTaskId', stub[:export_image_task_id].to_s) unless stub[:export_image_task_id].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('roleName', stub[:role_name].to_s) unless stub[:role_name].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << ExportTaskS3Location.stub('s3ExportLocation', stub[:s3_export_location]) unless stub[:s3_export_location].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ExportTransitGatewayRoutes
    class ExportTransitGatewayRoutes
      def self.default(visited=[])
        {
          s3_location: 's3_location',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ExportTransitGatewayRoutesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('s3Location', stub[:s3_location].to_s) unless stub[:s3_location].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetAssociatedEnclaveCertificateIamRoles
    class GetAssociatedEnclaveCertificateIamRoles
      def self.default(visited=[])
        {
          associated_roles: AssociatedRolesList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetAssociatedEnclaveCertificateIamRolesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associatedRoleSet', AssociatedRolesList.stub('item', stub[:associated_roles])) unless stub[:associated_roles].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for AssociatedRolesList
    class AssociatedRolesList
      def self.default(visited=[])
        return nil if visited.include?('AssociatedRolesList')
        visited = visited + ['AssociatedRolesList']
        [
          AssociatedRole.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AssociatedRole.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AssociatedRole
    class AssociatedRole
      def self.default(visited=[])
        return nil if visited.include?('AssociatedRole')
        visited = visited + ['AssociatedRole']
        {
          associated_role_arn: 'associated_role_arn',
          certificate_s3_bucket_name: 'certificate_s3_bucket_name',
          certificate_s3_object_key: 'certificate_s3_object_key',
          encryption_kms_key_id: 'encryption_kms_key_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associatedRoleArn', stub[:associated_role_arn].to_s) unless stub[:associated_role_arn].nil?
        xml << Hearth::XML::Node.new('certificateS3BucketName', stub[:certificate_s3_bucket_name].to_s) unless stub[:certificate_s3_bucket_name].nil?
        xml << Hearth::XML::Node.new('certificateS3ObjectKey', stub[:certificate_s3_object_key].to_s) unless stub[:certificate_s3_object_key].nil?
        xml << Hearth::XML::Node.new('encryptionKmsKeyId', stub[:encryption_kms_key_id].to_s) unless stub[:encryption_kms_key_id].nil?
        xml
      end
    end

    # Operation Stubber for GetAssociatedIpv6PoolCidrs
    class GetAssociatedIpv6PoolCidrs
      def self.default(visited=[])
        {
          ipv6_cidr_associations: Ipv6CidrAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetAssociatedIpv6PoolCidrsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipv6CidrAssociationSet', Ipv6CidrAssociationSet.stub('item', stub[:ipv6_cidr_associations])) unless stub[:ipv6_cidr_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for Ipv6CidrAssociationSet
    class Ipv6CidrAssociationSet
      def self.default(visited=[])
        return nil if visited.include?('Ipv6CidrAssociationSet')
        visited = visited + ['Ipv6CidrAssociationSet']
        [
          Ipv6CidrAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6CidrAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Ipv6CidrAssociation
    class Ipv6CidrAssociation
      def self.default(visited=[])
        return nil if visited.include?('Ipv6CidrAssociation')
        visited = visited + ['Ipv6CidrAssociation']
        {
          ipv6_cidr: 'ipv6_cidr',
          associated_resource: 'associated_resource',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Cidr', stub[:ipv6_cidr].to_s) unless stub[:ipv6_cidr].nil?
        xml << Hearth::XML::Node.new('associatedResource', stub[:associated_resource].to_s) unless stub[:associated_resource].nil?
        xml
      end
    end

    # Operation Stubber for GetCapacityReservationUsage
    class GetCapacityReservationUsage
      def self.default(visited=[])
        {
          next_token: 'next_token',
          capacity_reservation_id: 'capacity_reservation_id',
          instance_type: 'instance_type',
          total_instance_count: 1,
          available_instance_count: 1,
          state: 'state',
          instance_usages: InstanceUsageSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetCapacityReservationUsageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('totalInstanceCount', stub[:total_instance_count].to_s) unless stub[:total_instance_count].nil?
        xml << Hearth::XML::Node.new('availableInstanceCount', stub[:available_instance_count].to_s) unless stub[:available_instance_count].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('instanceUsageSet', InstanceUsageSet.stub('item', stub[:instance_usages])) unless stub[:instance_usages].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceUsageSet
    class InstanceUsageSet
      def self.default(visited=[])
        return nil if visited.include?('InstanceUsageSet')
        visited = visited + ['InstanceUsageSet']
        [
          InstanceUsage.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceUsage.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceUsage
    class InstanceUsage
      def self.default(visited=[])
        return nil if visited.include?('InstanceUsage')
        visited = visited + ['InstanceUsage']
        {
          account_id: 'account_id',
          used_instance_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('accountId', stub[:account_id].to_s) unless stub[:account_id].nil?
        xml << Hearth::XML::Node.new('usedInstanceCount', stub[:used_instance_count].to_s) unless stub[:used_instance_count].nil?
        xml
      end
    end

    # Operation Stubber for GetCoipPoolUsage
    class GetCoipPoolUsage
      def self.default(visited=[])
        {
          coip_pool_id: 'coip_pool_id',
          coip_address_usages: CoipAddressUsageSet.default(visited),
          local_gateway_route_table_id: 'local_gateway_route_table_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetCoipPoolUsageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('coipPoolId', stub[:coip_pool_id].to_s) unless stub[:coip_pool_id].nil?
        xml << Hearth::XML::Node.new('coipAddressUsageSet', CoipAddressUsageSet.stub('item', stub[:coip_address_usages])) unless stub[:coip_address_usages].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CoipAddressUsageSet
    class CoipAddressUsageSet
      def self.default(visited=[])
        return nil if visited.include?('CoipAddressUsageSet')
        visited = visited + ['CoipAddressUsageSet']
        [
          CoipAddressUsage.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CoipAddressUsage.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CoipAddressUsage
    class CoipAddressUsage
      def self.default(visited=[])
        return nil if visited.include?('CoipAddressUsage')
        visited = visited + ['CoipAddressUsage']
        {
          allocation_id: 'allocation_id',
          aws_account_id: 'aws_account_id',
          aws_service: 'aws_service',
          co_ip: 'co_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('awsAccountId', stub[:aws_account_id].to_s) unless stub[:aws_account_id].nil?
        xml << Hearth::XML::Node.new('awsService', stub[:aws_service].to_s) unless stub[:aws_service].nil?
        xml << Hearth::XML::Node.new('coIp', stub[:co_ip].to_s) unless stub[:co_ip].nil?
        xml
      end
    end

    # Operation Stubber for GetConsoleOutput
    class GetConsoleOutput
      def self.default(visited=[])
        {
          instance_id: 'instance_id',
          output: 'output',
          timestamp: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetConsoleOutputResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('output', stub[:output].to_s) unless stub[:output].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetConsoleScreenshot
    class GetConsoleScreenshot
      def self.default(visited=[])
        {
          image_data: 'image_data',
          instance_id: 'instance_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetConsoleScreenshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageData', stub[:image_data].to_s) unless stub[:image_data].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetDefaultCreditSpecification
    class GetDefaultCreditSpecification
      def self.default(visited=[])
        {
          instance_family_credit_specification: InstanceFamilyCreditSpecification.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetDefaultCreditSpecificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceFamilyCreditSpecification.stub('instanceFamilyCreditSpecification', stub[:instance_family_credit_specification]) unless stub[:instance_family_credit_specification].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for InstanceFamilyCreditSpecification
    class InstanceFamilyCreditSpecification
      def self.default(visited=[])
        return nil if visited.include?('InstanceFamilyCreditSpecification')
        visited = visited + ['InstanceFamilyCreditSpecification']
        {
          instance_family: 'instance_family',
          cpu_credits: 'cpu_credits',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('cpuCredits', stub[:cpu_credits].to_s) unless stub[:cpu_credits].nil?
        xml
      end
    end

    # Operation Stubber for GetEbsDefaultKmsKeyId
    class GetEbsDefaultKmsKeyId
      def self.default(visited=[])
        {
          kms_key_id: 'kms_key_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetEbsDefaultKmsKeyIdResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetEbsEncryptionByDefault
    class GetEbsEncryptionByDefault
      def self.default(visited=[])
        {
          ebs_encryption_by_default: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetEbsEncryptionByDefaultResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ebsEncryptionByDefault', stub[:ebs_encryption_by_default].to_s) unless stub[:ebs_encryption_by_default].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetFlowLogsIntegrationTemplate
    class GetFlowLogsIntegrationTemplate
      def self.default(visited=[])
        {
          result: 'result',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetFlowLogsIntegrationTemplateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('result', stub[:result].to_s) unless stub[:result].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetGroupsForCapacityReservation
    class GetGroupsForCapacityReservation
      def self.default(visited=[])
        {
          next_token: 'next_token',
          capacity_reservation_groups: CapacityReservationGroupSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetGroupsForCapacityReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('capacityReservationGroupSet', CapacityReservationGroupSet.stub('item', stub[:capacity_reservation_groups])) unless stub[:capacity_reservation_groups].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for CapacityReservationGroupSet
    class CapacityReservationGroupSet
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationGroupSet')
        visited = visited + ['CapacityReservationGroupSet']
        [
          CapacityReservationGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CapacityReservationGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for CapacityReservationGroup
    class CapacityReservationGroup
      def self.default(visited=[])
        return nil if visited.include?('CapacityReservationGroup')
        visited = visited + ['CapacityReservationGroup']
        {
          group_arn: 'group_arn',
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupArn', stub[:group_arn].to_s) unless stub[:group_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    # Operation Stubber for GetHostReservationPurchasePreview
    class GetHostReservationPurchasePreview
      def self.default(visited=[])
        {
          currency_code: 'currency_code',
          purchase: PurchaseSet.default(visited),
          total_hourly_price: 'total_hourly_price',
          total_upfront_price: 'total_upfront_price',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetHostReservationPurchasePreviewResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('purchase', PurchaseSet.stub('item', stub[:purchase])) unless stub[:purchase].nil?
        xml << Hearth::XML::Node.new('totalHourlyPrice', stub[:total_hourly_price].to_s) unless stub[:total_hourly_price].nil?
        xml << Hearth::XML::Node.new('totalUpfrontPrice', stub[:total_upfront_price].to_s) unless stub[:total_upfront_price].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for PurchaseSet
    class PurchaseSet
      def self.default(visited=[])
        return nil if visited.include?('PurchaseSet')
        visited = visited + ['PurchaseSet']
        [
          Purchase.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Purchase.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for Purchase
    class Purchase
      def self.default(visited=[])
        return nil if visited.include?('Purchase')
        visited = visited + ['Purchase']
        {
          currency_code: 'currency_code',
          duration: 1,
          host_id_set: ResponseHostIdSet.default(visited),
          host_reservation_id: 'host_reservation_id',
          hourly_price: 'hourly_price',
          instance_family: 'instance_family',
          payment_option: 'payment_option',
          upfront_price: 'upfront_price',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('hostIdSet', ResponseHostIdSet.stub('item', stub[:host_id_set])) unless stub[:host_id_set].nil?
        xml << Hearth::XML::Node.new('hostReservationId', stub[:host_reservation_id].to_s) unless stub[:host_reservation_id].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('paymentOption', stub[:payment_option].to_s) unless stub[:payment_option].nil?
        xml << Hearth::XML::Node.new('upfrontPrice', stub[:upfront_price].to_s) unless stub[:upfront_price].nil?
        xml
      end
    end

    # Operation Stubber for GetInstanceTypesFromInstanceRequirements
    class GetInstanceTypesFromInstanceRequirements
      def self.default(visited=[])
        {
          instance_types: InstanceTypeInfoFromInstanceRequirementsSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetInstanceTypesFromInstanceRequirementsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceTypeSet', InstanceTypeInfoFromInstanceRequirementsSet.stub('item', stub[:instance_types])) unless stub[:instance_types].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceTypeInfoFromInstanceRequirementsSet
    class InstanceTypeInfoFromInstanceRequirementsSet
      def self.default(visited=[])
        return nil if visited.include?('InstanceTypeInfoFromInstanceRequirementsSet')
        visited = visited + ['InstanceTypeInfoFromInstanceRequirementsSet']
        [
          InstanceTypeInfoFromInstanceRequirements.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceTypeInfoFromInstanceRequirements.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceTypeInfoFromInstanceRequirements
    class InstanceTypeInfoFromInstanceRequirements
      def self.default(visited=[])
        return nil if visited.include?('InstanceTypeInfoFromInstanceRequirements')
        visited = visited + ['InstanceTypeInfoFromInstanceRequirements']
        {
          instance_type: 'instance_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml
      end
    end

    # Operation Stubber for GetInstanceUefiData
    class GetInstanceUefiData
      def self.default(visited=[])
        {
          instance_id: 'instance_id',
          uefi_data: 'uefi_data',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetInstanceUefiDataResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('uefiData', stub[:uefi_data].to_s) unless stub[:uefi_data].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetIpamAddressHistory
    class GetIpamAddressHistory
      def self.default(visited=[])
        {
          history_records: IpamAddressHistoryRecordSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamAddressHistoryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('historyRecordSet', IpamAddressHistoryRecordSet.stub('item', stub[:history_records])) unless stub[:history_records].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IpamAddressHistoryRecordSet
    class IpamAddressHistoryRecordSet
      def self.default(visited=[])
        return nil if visited.include?('IpamAddressHistoryRecordSet')
        visited = visited + ['IpamAddressHistoryRecordSet']
        [
          IpamAddressHistoryRecord.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamAddressHistoryRecord.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for IpamAddressHistoryRecord
    class IpamAddressHistoryRecord
      def self.default(visited=[])
        return nil if visited.include?('IpamAddressHistoryRecord')
        visited = visited + ['IpamAddressHistoryRecord']
        {
          resource_owner_id: 'resource_owner_id',
          resource_region: 'resource_region',
          resource_type: 'resource_type',
          resource_id: 'resource_id',
          resource_cidr: 'resource_cidr',
          resource_name: 'resource_name',
          resource_compliance_status: 'resource_compliance_status',
          resource_overlap_status: 'resource_overlap_status',
          vpc_id: 'vpc_id',
          sampled_start_time: Time.now,
          sampled_end_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('resourceRegion', stub[:resource_region].to_s) unless stub[:resource_region].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceCidr', stub[:resource_cidr].to_s) unless stub[:resource_cidr].nil?
        xml << Hearth::XML::Node.new('resourceName', stub[:resource_name].to_s) unless stub[:resource_name].nil?
        xml << Hearth::XML::Node.new('resourceComplianceStatus', stub[:resource_compliance_status].to_s) unless stub[:resource_compliance_status].nil?
        xml << Hearth::XML::Node.new('resourceOverlapStatus', stub[:resource_overlap_status].to_s) unless stub[:resource_overlap_status].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('sampledStartTime', Hearth::TimeHelper.to_date_time(stub[:sampled_start_time])) unless stub[:sampled_start_time].nil?
        xml << Hearth::XML::Node.new('sampledEndTime', Hearth::TimeHelper.to_date_time(stub[:sampled_end_time])) unless stub[:sampled_end_time].nil?
        xml
      end
    end

    # Operation Stubber for GetIpamPoolAllocations
    class GetIpamPoolAllocations
      def self.default(visited=[])
        {
          ipam_pool_allocations: IpamPoolAllocationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamPoolAllocationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipamPoolAllocationSet', IpamPoolAllocationSet.stub('item', stub[:ipam_pool_allocations])) unless stub[:ipam_pool_allocations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IpamPoolAllocationSet
    class IpamPoolAllocationSet
      def self.default(visited=[])
        return nil if visited.include?('IpamPoolAllocationSet')
        visited = visited + ['IpamPoolAllocationSet']
        [
          IpamPoolAllocation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamPoolAllocation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for GetIpamPoolCidrs
    class GetIpamPoolCidrs
      def self.default(visited=[])
        {
          ipam_pool_cidrs: IpamPoolCidrSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamPoolCidrsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipamPoolCidrSet', IpamPoolCidrSet.stub('item', stub[:ipam_pool_cidrs])) unless stub[:ipam_pool_cidrs].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IpamPoolCidrSet
    class IpamPoolCidrSet
      def self.default(visited=[])
        return nil if visited.include?('IpamPoolCidrSet')
        visited = visited + ['IpamPoolCidrSet']
        [
          IpamPoolCidr.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamPoolCidr.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for GetIpamResourceCidrs
    class GetIpamResourceCidrs
      def self.default(visited=[])
        {
          next_token: 'next_token',
          ipam_resource_cidrs: IpamResourceCidrSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamResourceCidrsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('ipamResourceCidrSet', IpamResourceCidrSet.stub('item', stub[:ipam_resource_cidrs])) unless stub[:ipam_resource_cidrs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for IpamResourceCidrSet
    class IpamResourceCidrSet
      def self.default(visited=[])
        return nil if visited.include?('IpamResourceCidrSet')
        visited = visited + ['IpamResourceCidrSet']
        [
          IpamResourceCidr.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamResourceCidr.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for IpamResourceCidr
    class IpamResourceCidr
      def self.default(visited=[])
        return nil if visited.include?('IpamResourceCidr')
        visited = visited + ['IpamResourceCidr']
        {
          ipam_id: 'ipam_id',
          ipam_scope_id: 'ipam_scope_id',
          ipam_pool_id: 'ipam_pool_id',
          resource_region: 'resource_region',
          resource_owner_id: 'resource_owner_id',
          resource_id: 'resource_id',
          resource_name: 'resource_name',
          resource_cidr: 'resource_cidr',
          resource_type: 'resource_type',
          resource_tags: IpamResourceTagList.default(visited),
          ip_usage: 1.0,
          compliance_status: 'compliance_status',
          management_state: 'management_state',
          overlap_status: 'overlap_status',
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipamId', stub[:ipam_id].to_s) unless stub[:ipam_id].nil?
        xml << Hearth::XML::Node.new('ipamScopeId', stub[:ipam_scope_id].to_s) unless stub[:ipam_scope_id].nil?
        xml << Hearth::XML::Node.new('ipamPoolId', stub[:ipam_pool_id].to_s) unless stub[:ipam_pool_id].nil?
        xml << Hearth::XML::Node.new('resourceRegion', stub[:resource_region].to_s) unless stub[:resource_region].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceName', stub[:resource_name].to_s) unless stub[:resource_name].nil?
        xml << Hearth::XML::Node.new('resourceCidr', stub[:resource_cidr].to_s) unless stub[:resource_cidr].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceTagSet', IpamResourceTagList.stub('item', stub[:resource_tags])) unless stub[:resource_tags].nil?
        xml << Hearth::XML::Node.new('ipUsage', Hearth::NumberHelper.serialize(stub[:ip_usage]).to_s) unless stub[:ip_usage].nil?
        xml << Hearth::XML::Node.new('complianceStatus', stub[:compliance_status].to_s) unless stub[:compliance_status].nil?
        xml << Hearth::XML::Node.new('managementState', stub[:management_state].to_s) unless stub[:management_state].nil?
        xml << Hearth::XML::Node.new('overlapStatus', stub[:overlap_status].to_s) unless stub[:overlap_status].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    # Operation Stubber for GetLaunchTemplateData
    class GetLaunchTemplateData
      def self.default(visited=[])
        {
          launch_template_data: ResponseLaunchTemplateData.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetLaunchTemplateDataResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ResponseLaunchTemplateData.stub('launchTemplateData', stub[:launch_template_data]) unless stub[:launch_template_data].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetManagedPrefixListAssociations
    class GetManagedPrefixListAssociations
      def self.default(visited=[])
        {
          prefix_list_associations: PrefixListAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetManagedPrefixListAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('prefixListAssociationSet', PrefixListAssociationSet.stub('item', stub[:prefix_list_associations])) unless stub[:prefix_list_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for PrefixListAssociationSet
    class PrefixListAssociationSet
      def self.default(visited=[])
        return nil if visited.include?('PrefixListAssociationSet')
        visited = visited + ['PrefixListAssociationSet']
        [
          PrefixListAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrefixListAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PrefixListAssociation
    class PrefixListAssociation
      def self.default(visited=[])
        return nil if visited.include?('PrefixListAssociation')
        visited = visited + ['PrefixListAssociation']
        {
          resource_id: 'resource_id',
          resource_owner: 'resource_owner',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceOwner', stub[:resource_owner].to_s) unless stub[:resource_owner].nil?
        xml
      end
    end

    # Operation Stubber for GetManagedPrefixListEntries
    class GetManagedPrefixListEntries
      def self.default(visited=[])
        {
          entries: PrefixListEntrySet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetManagedPrefixListEntriesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('entrySet', PrefixListEntrySet.stub('item', stub[:entries])) unless stub[:entries].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for PrefixListEntrySet
    class PrefixListEntrySet
      def self.default(visited=[])
        return nil if visited.include?('PrefixListEntrySet')
        visited = visited + ['PrefixListEntrySet']
        [
          PrefixListEntry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrefixListEntry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for PrefixListEntry
    class PrefixListEntry
      def self.default(visited=[])
        return nil if visited.include?('PrefixListEntry')
        visited = visited + ['PrefixListEntry']
        {
          cidr: 'cidr',
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    # Operation Stubber for GetNetworkInsightsAccessScopeAnalysisFindings
    class GetNetworkInsightsAccessScopeAnalysisFindings
      def self.default(visited=[])
        {
          network_insights_access_scope_analysis_id: 'network_insights_access_scope_analysis_id',
          analysis_status: 'analysis_status',
          analysis_findings: AccessScopeAnalysisFindingList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetNetworkInsightsAccessScopeAnalysisFindingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisId', stub[:network_insights_access_scope_analysis_id].to_s) unless stub[:network_insights_access_scope_analysis_id].nil?
        xml << Hearth::XML::Node.new('analysisStatus', stub[:analysis_status].to_s) unless stub[:analysis_status].nil?
        xml << Hearth::XML::Node.new('analysisFindingSet', AccessScopeAnalysisFindingList.stub('item', stub[:analysis_findings])) unless stub[:analysis_findings].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for AccessScopeAnalysisFindingList
    class AccessScopeAnalysisFindingList
      def self.default(visited=[])
        return nil if visited.include?('AccessScopeAnalysisFindingList')
        visited = visited + ['AccessScopeAnalysisFindingList']
        [
          AccessScopeAnalysisFinding.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AccessScopeAnalysisFinding.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for AccessScopeAnalysisFinding
    class AccessScopeAnalysisFinding
      def self.default(visited=[])
        return nil if visited.include?('AccessScopeAnalysisFinding')
        visited = visited + ['AccessScopeAnalysisFinding']
        {
          network_insights_access_scope_analysis_id: 'network_insights_access_scope_analysis_id',
          network_insights_access_scope_id: 'network_insights_access_scope_id',
          finding_id: 'finding_id',
          finding_components: PathComponentList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisId', stub[:network_insights_access_scope_analysis_id].to_s) unless stub[:network_insights_access_scope_analysis_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        xml << Hearth::XML::Node.new('findingId', stub[:finding_id].to_s) unless stub[:finding_id].nil?
        xml << Hearth::XML::Node.new('findingComponentSet', PathComponentList.stub('item', stub[:finding_components])) unless stub[:finding_components].nil?
        xml
      end
    end

    # Operation Stubber for GetNetworkInsightsAccessScopeContent
    class GetNetworkInsightsAccessScopeContent
      def self.default(visited=[])
        {
          network_insights_access_scope_content: NetworkInsightsAccessScopeContent.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetNetworkInsightsAccessScopeContentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsAccessScopeContent.stub('networkInsightsAccessScopeContent', stub[:network_insights_access_scope_content]) unless stub[:network_insights_access_scope_content].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetPasswordData
    class GetPasswordData
      def self.default(visited=[])
        {
          instance_id: 'instance_id',
          password_data: 'password_data',
          timestamp: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetPasswordDataResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('passwordData', stub[:password_data].to_s) unless stub[:password_data].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetReservedInstancesExchangeQuote
    class GetReservedInstancesExchangeQuote
      def self.default(visited=[])
        {
          currency_code: 'currency_code',
          is_valid_exchange: false,
          output_reserved_instances_will_expire_at: Time.now,
          payment_due: 'payment_due',
          reserved_instance_value_rollup: ReservationValue.default(visited),
          reserved_instance_value_set: ReservedInstanceReservationValueSet.default(visited),
          target_configuration_value_rollup: ReservationValue.default(visited),
          target_configuration_value_set: TargetReservationValueSet.default(visited),
          validation_failure_reason: 'validation_failure_reason',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetReservedInstancesExchangeQuoteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('isValidExchange', stub[:is_valid_exchange].to_s) unless stub[:is_valid_exchange].nil?
        xml << Hearth::XML::Node.new('outputReservedInstancesWillExpireAt', Hearth::TimeHelper.to_date_time(stub[:output_reserved_instances_will_expire_at])) unless stub[:output_reserved_instances_will_expire_at].nil?
        xml << Hearth::XML::Node.new('paymentDue', stub[:payment_due].to_s) unless stub[:payment_due].nil?
        xml << ReservationValue.stub('reservedInstanceValueRollup', stub[:reserved_instance_value_rollup]) unless stub[:reserved_instance_value_rollup].nil?
        xml << Hearth::XML::Node.new('reservedInstanceValueSet', ReservedInstanceReservationValueSet.stub('item', stub[:reserved_instance_value_set])) unless stub[:reserved_instance_value_set].nil?
        xml << ReservationValue.stub('targetConfigurationValueRollup', stub[:target_configuration_value_rollup]) unless stub[:target_configuration_value_rollup].nil?
        xml << Hearth::XML::Node.new('targetConfigurationValueSet', TargetReservationValueSet.stub('item', stub[:target_configuration_value_set])) unless stub[:target_configuration_value_set].nil?
        xml << Hearth::XML::Node.new('validationFailureReason', stub[:validation_failure_reason].to_s) unless stub[:validation_failure_reason].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TargetReservationValueSet
    class TargetReservationValueSet
      def self.default(visited=[])
        return nil if visited.include?('TargetReservationValueSet')
        visited = visited + ['TargetReservationValueSet']
        [
          TargetReservationValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TargetReservationValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TargetReservationValue
    class TargetReservationValue
      def self.default(visited=[])
        return nil if visited.include?('TargetReservationValue')
        visited = visited + ['TargetReservationValue']
        {
          reservation_value: ReservationValue.default(visited),
          target_configuration: TargetConfiguration.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << ReservationValue.stub('reservationValue', stub[:reservation_value]) unless stub[:reservation_value].nil?
        xml << TargetConfiguration.stub('targetConfiguration', stub[:target_configuration]) unless stub[:target_configuration].nil?
        xml
      end
    end

    # Structure Stubber for TargetConfiguration
    class TargetConfiguration
      def self.default(visited=[])
        return nil if visited.include?('TargetConfiguration')
        visited = visited + ['TargetConfiguration']
        {
          instance_count: 1,
          offering_id: 'offering_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('offeringId', stub[:offering_id].to_s) unless stub[:offering_id].nil?
        xml
      end
    end

    # Structure Stubber for ReservationValue
    class ReservationValue
      def self.default(visited=[])
        return nil if visited.include?('ReservationValue')
        visited = visited + ['ReservationValue']
        {
          hourly_price: 'hourly_price',
          remaining_total_value: 'remaining_total_value',
          remaining_upfront_value: 'remaining_upfront_value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('remainingTotalValue', stub[:remaining_total_value].to_s) unless stub[:remaining_total_value].nil?
        xml << Hearth::XML::Node.new('remainingUpfrontValue', stub[:remaining_upfront_value].to_s) unless stub[:remaining_upfront_value].nil?
        xml
      end
    end

    # List Stubber for ReservedInstanceReservationValueSet
    class ReservedInstanceReservationValueSet
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstanceReservationValueSet')
        visited = visited + ['ReservedInstanceReservationValueSet']
        [
          ReservedInstanceReservationValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstanceReservationValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ReservedInstanceReservationValue
    class ReservedInstanceReservationValue
      def self.default(visited=[])
        return nil if visited.include?('ReservedInstanceReservationValue')
        visited = visited + ['ReservedInstanceReservationValue']
        {
          reservation_value: ReservationValue.default(visited),
          reserved_instance_id: 'reserved_instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << ReservationValue.stub('reservationValue', stub[:reservation_value]) unless stub[:reservation_value].nil?
        xml << Hearth::XML::Node.new('reservedInstanceId', stub[:reserved_instance_id].to_s) unless stub[:reserved_instance_id].nil?
        xml
      end
    end

    # Operation Stubber for GetSerialConsoleAccessStatus
    class GetSerialConsoleAccessStatus
      def self.default(visited=[])
        {
          serial_console_access_enabled: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetSerialConsoleAccessStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serialConsoleAccessEnabled', stub[:serial_console_access_enabled].to_s) unless stub[:serial_console_access_enabled].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetSpotPlacementScores
    class GetSpotPlacementScores
      def self.default(visited=[])
        {
          spot_placement_scores: SpotPlacementScores.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetSpotPlacementScoresResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotPlacementScoreSet', SpotPlacementScores.stub('item', stub[:spot_placement_scores])) unless stub[:spot_placement_scores].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SpotPlacementScores
    class SpotPlacementScores
      def self.default(visited=[])
        return nil if visited.include?('SpotPlacementScores')
        visited = visited + ['SpotPlacementScores']
        [
          SpotPlacementScore.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotPlacementScore.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SpotPlacementScore
    class SpotPlacementScore
      def self.default(visited=[])
        return nil if visited.include?('SpotPlacementScore')
        visited = visited + ['SpotPlacementScore']
        {
          region: 'region',
          availability_zone_id: 'availability_zone_id',
          score: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('region', stub[:region].to_s) unless stub[:region].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('score', stub[:score].to_s) unless stub[:score].nil?
        xml
      end
    end

    # Operation Stubber for GetSubnetCidrReservations
    class GetSubnetCidrReservations
      def self.default(visited=[])
        {
          subnet_ipv4_cidr_reservations: SubnetCidrReservationList.default(visited),
          subnet_ipv6_cidr_reservations: SubnetCidrReservationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetSubnetCidrReservationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('subnetIpv4CidrReservationSet', SubnetCidrReservationList.stub('item', stub[:subnet_ipv4_cidr_reservations])) unless stub[:subnet_ipv4_cidr_reservations].nil?
        xml << Hearth::XML::Node.new('subnetIpv6CidrReservationSet', SubnetCidrReservationList.stub('item', stub[:subnet_ipv6_cidr_reservations])) unless stub[:subnet_ipv6_cidr_reservations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SubnetCidrReservationList
    class SubnetCidrReservationList
      def self.default(visited=[])
        return nil if visited.include?('SubnetCidrReservationList')
        visited = visited + ['SubnetCidrReservationList']
        [
          SubnetCidrReservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SubnetCidrReservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for GetTransitGatewayAttachmentPropagations
    class GetTransitGatewayAttachmentPropagations
      def self.default(visited=[])
        {
          transit_gateway_attachment_propagations: TransitGatewayAttachmentPropagationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayAttachmentPropagationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayAttachmentPropagations', TransitGatewayAttachmentPropagationList.stub('item', stub[:transit_gateway_attachment_propagations])) unless stub[:transit_gateway_attachment_propagations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayAttachmentPropagationList
    class TransitGatewayAttachmentPropagationList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayAttachmentPropagationList')
        visited = visited + ['TransitGatewayAttachmentPropagationList']
        [
          TransitGatewayAttachmentPropagation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayAttachmentPropagation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TransitGatewayAttachmentPropagation
    class TransitGatewayAttachmentPropagation
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayAttachmentPropagation')
        visited = visited + ['TransitGatewayAttachmentPropagation']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for GetTransitGatewayMulticastDomainAssociations
    class GetTransitGatewayMulticastDomainAssociations
      def self.default(visited=[])
        {
          multicast_domain_associations: TransitGatewayMulticastDomainAssociationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayMulticastDomainAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('multicastDomainAssociations', TransitGatewayMulticastDomainAssociationList.stub('item', stub[:multicast_domain_associations])) unless stub[:multicast_domain_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayMulticastDomainAssociationList
    class TransitGatewayMulticastDomainAssociationList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastDomainAssociationList')
        visited = visited + ['TransitGatewayMulticastDomainAssociationList']
        [
          TransitGatewayMulticastDomainAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayMulticastDomainAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TransitGatewayMulticastDomainAssociation
    class TransitGatewayMulticastDomainAssociation
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastDomainAssociation')
        visited = visited + ['TransitGatewayMulticastDomainAssociation']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          resource_owner_id: 'resource_owner_id',
          subnet: SubnetAssociation.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << SubnetAssociation.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        xml
      end
    end

    # Operation Stubber for GetTransitGatewayPrefixListReferences
    class GetTransitGatewayPrefixListReferences
      def self.default(visited=[])
        {
          transit_gateway_prefix_list_references: TransitGatewayPrefixListReferenceSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayPrefixListReferencesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayPrefixListReferenceSet', TransitGatewayPrefixListReferenceSet.stub('item', stub[:transit_gateway_prefix_list_references])) unless stub[:transit_gateway_prefix_list_references].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayPrefixListReferenceSet
    class TransitGatewayPrefixListReferenceSet
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayPrefixListReferenceSet')
        visited = visited + ['TransitGatewayPrefixListReferenceSet']
        [
          TransitGatewayPrefixListReference.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayPrefixListReference.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for GetTransitGatewayRouteTableAssociations
    class GetTransitGatewayRouteTableAssociations
      def self.default(visited=[])
        {
          associations: TransitGatewayRouteTableAssociationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayRouteTableAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associations', TransitGatewayRouteTableAssociationList.stub('item', stub[:associations])) unless stub[:associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayRouteTableAssociationList
    class TransitGatewayRouteTableAssociationList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteTableAssociationList')
        visited = visited + ['TransitGatewayRouteTableAssociationList']
        [
          TransitGatewayRouteTableAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRouteTableAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TransitGatewayRouteTableAssociation
    class TransitGatewayRouteTableAssociation
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteTableAssociation')
        visited = visited + ['TransitGatewayRouteTableAssociation']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for GetTransitGatewayRouteTablePropagations
    class GetTransitGatewayRouteTablePropagations
      def self.default(visited=[])
        {
          transit_gateway_route_table_propagations: TransitGatewayRouteTablePropagationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayRouteTablePropagationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayRouteTablePropagations', TransitGatewayRouteTablePropagationList.stub('item', stub[:transit_gateway_route_table_propagations])) unless stub[:transit_gateway_route_table_propagations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayRouteTablePropagationList
    class TransitGatewayRouteTablePropagationList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteTablePropagationList')
        visited = visited + ['TransitGatewayRouteTablePropagationList']
        [
          TransitGatewayRouteTablePropagation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRouteTablePropagation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TransitGatewayRouteTablePropagation
    class TransitGatewayRouteTablePropagation
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteTablePropagation')
        visited = visited + ['TransitGatewayRouteTablePropagation']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    # Operation Stubber for GetVpnConnectionDeviceSampleConfiguration
    class GetVpnConnectionDeviceSampleConfiguration
      def self.default(visited=[])
        {
          vpn_connection_device_sample_configuration: 'vpn_connection_device_sample_configuration',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetVpnConnectionDeviceSampleConfigurationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpnConnectionDeviceSampleConfiguration', stub[:vpn_connection_device_sample_configuration].to_s) unless stub[:vpn_connection_device_sample_configuration].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for GetVpnConnectionDeviceTypes
    class GetVpnConnectionDeviceTypes
      def self.default(visited=[])
        {
          vpn_connection_device_types: VpnConnectionDeviceTypeList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetVpnConnectionDeviceTypesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpnConnectionDeviceTypeSet', VpnConnectionDeviceTypeList.stub('item', stub[:vpn_connection_device_types])) unless stub[:vpn_connection_device_types].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for VpnConnectionDeviceTypeList
    class VpnConnectionDeviceTypeList
      def self.default(visited=[])
        return nil if visited.include?('VpnConnectionDeviceTypeList')
        visited = visited + ['VpnConnectionDeviceTypeList']
        [
          VpnConnectionDeviceType.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpnConnectionDeviceType.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for VpnConnectionDeviceType
    class VpnConnectionDeviceType
      def self.default(visited=[])
        return nil if visited.include?('VpnConnectionDeviceType')
        visited = visited + ['VpnConnectionDeviceType']
        {
          vpn_connection_device_type_id: 'vpn_connection_device_type_id',
          vendor: 'vendor',
          platform: 'platform',
          software: 'software',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('vpnConnectionDeviceTypeId', stub[:vpn_connection_device_type_id].to_s) unless stub[:vpn_connection_device_type_id].nil?
        xml << Hearth::XML::Node.new('vendor', stub[:vendor].to_s) unless stub[:vendor].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('software', stub[:software].to_s) unless stub[:software].nil?
        xml
      end
    end

    # Operation Stubber for ImportClientVpnClientCertificateRevocationList
    class ImportClientVpnClientCertificateRevocationList
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportClientVpnClientCertificateRevocationListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ImportImage
    class ImportImage
      def self.default(visited=[])
        {
          architecture: 'architecture',
          description: 'description',
          encrypted: false,
          hypervisor: 'hypervisor',
          image_id: 'image_id',
          import_task_id: 'import_task_id',
          kms_key_id: 'kms_key_id',
          license_type: 'license_type',
          platform: 'platform',
          progress: 'progress',
          snapshot_details: SnapshotDetailList.default(visited),
          status: 'status',
          status_message: 'status_message',
          license_specifications: ImportImageLicenseSpecificationListResponse.default(visited),
          tags: TagList.default(visited),
          usage_operation: 'usage_operation',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('architecture', stub[:architecture].to_s) unless stub[:architecture].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('licenseType', stub[:license_type].to_s) unless stub[:license_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotDetailSet', SnapshotDetailList.stub('item', stub[:snapshot_details])) unless stub[:snapshot_details].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('licenseSpecifications', ImportImageLicenseSpecificationListResponse.stub('item', stub[:license_specifications])) unless stub[:license_specifications].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('usageOperation', stub[:usage_operation].to_s) unless stub[:usage_operation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ImportInstance
    class ImportInstance
      def self.default(visited=[])
        {
          conversion_task: ConversionTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportInstanceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ConversionTask.stub('conversionTask', stub[:conversion_task]) unless stub[:conversion_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ImportKeyPair
    class ImportKeyPair
      def self.default(visited=[])
        {
          key_fingerprint: 'key_fingerprint',
          key_name: 'key_name',
          key_pair_id: 'key_pair_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportKeyPairResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('keyFingerprint', stub[:key_fingerprint].to_s) unless stub[:key_fingerprint].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('keyPairId', stub[:key_pair_id].to_s) unless stub[:key_pair_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ImportSnapshot
    class ImportSnapshot
      def self.default(visited=[])
        {
          description: 'description',
          import_task_id: 'import_task_id',
          snapshot_task_detail: SnapshotTaskDetail.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportSnapshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << SnapshotTaskDetail.stub('snapshotTaskDetail', stub[:snapshot_task_detail]) unless stub[:snapshot_task_detail].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ImportVolume
    class ImportVolume
      def self.default(visited=[])
        {
          conversion_task: ConversionTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ConversionTask.stub('conversionTask', stub[:conversion_task]) unless stub[:conversion_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ListImagesInRecycleBin
    class ListImagesInRecycleBin
      def self.default(visited=[])
        {
          images: ImageRecycleBinInfoList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ListImagesInRecycleBinResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageSet', ImageRecycleBinInfoList.stub('item', stub[:images])) unless stub[:images].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for ImageRecycleBinInfoList
    class ImageRecycleBinInfoList
      def self.default(visited=[])
        return nil if visited.include?('ImageRecycleBinInfoList')
        visited = visited + ['ImageRecycleBinInfoList']
        [
          ImageRecycleBinInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImageRecycleBinInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for ImageRecycleBinInfo
    class ImageRecycleBinInfo
      def self.default(visited=[])
        return nil if visited.include?('ImageRecycleBinInfo')
        visited = visited + ['ImageRecycleBinInfo']
        {
          image_id: 'image_id',
          name: 'name',
          description: 'description',
          recycle_bin_enter_time: Time.now,
          recycle_bin_exit_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('recycleBinEnterTime', Hearth::TimeHelper.to_date_time(stub[:recycle_bin_enter_time])) unless stub[:recycle_bin_enter_time].nil?
        xml << Hearth::XML::Node.new('recycleBinExitTime', Hearth::TimeHelper.to_date_time(stub[:recycle_bin_exit_time])) unless stub[:recycle_bin_exit_time].nil?
        xml
      end
    end

    # Operation Stubber for ListSnapshotsInRecycleBin
    class ListSnapshotsInRecycleBin
      def self.default(visited=[])
        {
          snapshots: SnapshotRecycleBinInfoList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ListSnapshotsInRecycleBinResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotSet', SnapshotRecycleBinInfoList.stub('item', stub[:snapshots])) unless stub[:snapshots].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for SnapshotRecycleBinInfoList
    class SnapshotRecycleBinInfoList
      def self.default(visited=[])
        return nil if visited.include?('SnapshotRecycleBinInfoList')
        visited = visited + ['SnapshotRecycleBinInfoList']
        [
          SnapshotRecycleBinInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SnapshotRecycleBinInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SnapshotRecycleBinInfo
    class SnapshotRecycleBinInfo
      def self.default(visited=[])
        return nil if visited.include?('SnapshotRecycleBinInfo')
        visited = visited + ['SnapshotRecycleBinInfo']
        {
          snapshot_id: 'snapshot_id',
          recycle_bin_enter_time: Time.now,
          recycle_bin_exit_time: Time.now,
          description: 'description',
          volume_id: 'volume_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('recycleBinEnterTime', Hearth::TimeHelper.to_date_time(stub[:recycle_bin_enter_time])) unless stub[:recycle_bin_enter_time].nil?
        xml << Hearth::XML::Node.new('recycleBinExitTime', Hearth::TimeHelper.to_date_time(stub[:recycle_bin_exit_time])) unless stub[:recycle_bin_exit_time].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml
      end
    end

    # Operation Stubber for ModifyAddressAttribute
    class ModifyAddressAttribute
      def self.default(visited=[])
        {
          address: AddressAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyAddressAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << AddressAttribute.stub('address', stub[:address]) unless stub[:address].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyAvailabilityZoneGroup
    class ModifyAvailabilityZoneGroup
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyAvailabilityZoneGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyCapacityReservation
    class ModifyCapacityReservation
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyCapacityReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyCapacityReservationFleet
    class ModifyCapacityReservationFleet
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyCapacityReservationFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyClientVpnEndpoint
    class ModifyClientVpnEndpoint
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyClientVpnEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyDefaultCreditSpecification
    class ModifyDefaultCreditSpecification
      def self.default(visited=[])
        {
          instance_family_credit_specification: InstanceFamilyCreditSpecification.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyDefaultCreditSpecificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceFamilyCreditSpecification.stub('instanceFamilyCreditSpecification', stub[:instance_family_credit_specification]) unless stub[:instance_family_credit_specification].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyEbsDefaultKmsKeyId
    class ModifyEbsDefaultKmsKeyId
      def self.default(visited=[])
        {
          kms_key_id: 'kms_key_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyEbsDefaultKmsKeyIdResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyFleet
    class ModifyFleet
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyFpgaImageAttribute
    class ModifyFpgaImageAttribute
      def self.default(visited=[])
        {
          fpga_image_attribute: FpgaImageAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyFpgaImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << FpgaImageAttribute.stub('fpgaImageAttribute', stub[:fpga_image_attribute]) unless stub[:fpga_image_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyHosts
    class ModifyHosts
      def self.default(visited=[])
        {
          successful: ResponseHostIdList.default(visited),
          unsuccessful: UnsuccessfulItemList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyHostsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successful', ResponseHostIdList.stub('item', stub[:successful])) unless stub[:successful].nil?
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemList.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for UnsuccessfulItemList
    class UnsuccessfulItemList
      def self.default(visited=[])
        return nil if visited.include?('UnsuccessfulItemList')
        visited = visited + ['UnsuccessfulItemList']
        [
          UnsuccessfulItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UnsuccessfulItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for ModifyIdFormat
    class ModifyIdFormat
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyIdentityIdFormat
    class ModifyIdentityIdFormat
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIdentityIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyImageAttribute
    class ModifyImageAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyInstanceAttribute
    class ModifyInstanceAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyInstanceCapacityReservationAttributes
    class ModifyInstanceCapacityReservationAttributes
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceCapacityReservationAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyInstanceCreditSpecification
    class ModifyInstanceCreditSpecification
      def self.default(visited=[])
        {
          successful_instance_credit_specifications: SuccessfulInstanceCreditSpecificationSet.default(visited),
          unsuccessful_instance_credit_specifications: UnsuccessfulInstanceCreditSpecificationSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceCreditSpecificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulInstanceCreditSpecificationSet', SuccessfulInstanceCreditSpecificationSet.stub('item', stub[:successful_instance_credit_specifications])) unless stub[:successful_instance_credit_specifications].nil?
        xml << Hearth::XML::Node.new('unsuccessfulInstanceCreditSpecificationSet', UnsuccessfulInstanceCreditSpecificationSet.stub('item', stub[:unsuccessful_instance_credit_specifications])) unless stub[:unsuccessful_instance_credit_specifications].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for UnsuccessfulInstanceCreditSpecificationSet
    class UnsuccessfulInstanceCreditSpecificationSet
      def self.default(visited=[])
        return nil if visited.include?('UnsuccessfulInstanceCreditSpecificationSet')
        visited = visited + ['UnsuccessfulInstanceCreditSpecificationSet']
        [
          UnsuccessfulInstanceCreditSpecificationItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UnsuccessfulInstanceCreditSpecificationItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for UnsuccessfulInstanceCreditSpecificationItem
    class UnsuccessfulInstanceCreditSpecificationItem
      def self.default(visited=[])
        return nil if visited.include?('UnsuccessfulInstanceCreditSpecificationItem')
        visited = visited + ['UnsuccessfulInstanceCreditSpecificationItem']
        {
          instance_id: 'instance_id',
          error: UnsuccessfulInstanceCreditSpecificationItemError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << UnsuccessfulInstanceCreditSpecificationItemError.stub('error', stub[:error]) unless stub[:error].nil?
        xml
      end
    end

    # Structure Stubber for UnsuccessfulInstanceCreditSpecificationItemError
    class UnsuccessfulInstanceCreditSpecificationItemError
      def self.default(visited=[])
        return nil if visited.include?('UnsuccessfulInstanceCreditSpecificationItemError')
        visited = visited + ['UnsuccessfulInstanceCreditSpecificationItemError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    # List Stubber for SuccessfulInstanceCreditSpecificationSet
    class SuccessfulInstanceCreditSpecificationSet
      def self.default(visited=[])
        return nil if visited.include?('SuccessfulInstanceCreditSpecificationSet')
        visited = visited + ['SuccessfulInstanceCreditSpecificationSet']
        [
          SuccessfulInstanceCreditSpecificationItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SuccessfulInstanceCreditSpecificationItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for SuccessfulInstanceCreditSpecificationItem
    class SuccessfulInstanceCreditSpecificationItem
      def self.default(visited=[])
        return nil if visited.include?('SuccessfulInstanceCreditSpecificationItem')
        visited = visited + ['SuccessfulInstanceCreditSpecificationItem']
        {
          instance_id: 'instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml
      end
    end

    # Operation Stubber for ModifyInstanceEventStartTime
    class ModifyInstanceEventStartTime
      def self.default(visited=[])
        {
          event: InstanceStatusEvent.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceEventStartTimeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceStatusEvent.stub('event', stub[:event]) unless stub[:event].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyInstanceEventWindow
    class ModifyInstanceEventWindow
      def self.default(visited=[])
        {
          instance_event_window: InstanceEventWindow.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindow.stub('instanceEventWindow', stub[:instance_event_window]) unless stub[:instance_event_window].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyInstanceMaintenanceOptions
    class ModifyInstanceMaintenanceOptions
      def self.default(visited=[])
        {
          instance_id: 'instance_id',
          auto_recovery: 'auto_recovery',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceMaintenanceOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('autoRecovery', stub[:auto_recovery].to_s) unless stub[:auto_recovery].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyInstanceMetadataOptions
    class ModifyInstanceMetadataOptions
      def self.default(visited=[])
        {
          instance_id: 'instance_id',
          instance_metadata_options: InstanceMetadataOptionsResponse.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceMetadataOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << InstanceMetadataOptionsResponse.stub('instanceMetadataOptions', stub[:instance_metadata_options]) unless stub[:instance_metadata_options].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyInstancePlacement
    class ModifyInstancePlacement
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstancePlacementResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyIpam
    class ModifyIpam
      def self.default(visited=[])
        {
          ipam: Ipam.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIpamResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Ipam.stub('ipam', stub[:ipam]) unless stub[:ipam].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyIpamPool
    class ModifyIpamPool
      def self.default(visited=[])
        {
          ipam_pool: IpamPool.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIpamPoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPool.stub('ipamPool', stub[:ipam_pool]) unless stub[:ipam_pool].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyIpamResourceCidr
    class ModifyIpamResourceCidr
      def self.default(visited=[])
        {
          ipam_resource_cidr: IpamResourceCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIpamResourceCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamResourceCidr.stub('ipamResourceCidr', stub[:ipam_resource_cidr]) unless stub[:ipam_resource_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyIpamScope
    class ModifyIpamScope
      def self.default(visited=[])
        {
          ipam_scope: IpamScope.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIpamScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamScope.stub('ipamScope', stub[:ipam_scope]) unless stub[:ipam_scope].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyLaunchTemplate
    class ModifyLaunchTemplate
      def self.default(visited=[])
        {
          launch_template: LaunchTemplate.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyLaunchTemplateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LaunchTemplate.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyManagedPrefixList
    class ModifyManagedPrefixList
      def self.default(visited=[])
        {
          prefix_list: ManagedPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyManagedPrefixListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ManagedPrefixList.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyNetworkInterfaceAttribute
    class ModifyNetworkInterfaceAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyNetworkInterfaceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyPrivateDnsNameOptions
    class ModifyPrivateDnsNameOptions
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyPrivateDnsNameOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyReservedInstances
    class ModifyReservedInstances
      def self.default(visited=[])
        {
          reserved_instances_modification_id: 'reserved_instances_modification_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyReservedInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesModificationId', stub[:reserved_instances_modification_id].to_s) unless stub[:reserved_instances_modification_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifySecurityGroupRules
    class ModifySecurityGroupRules
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySecurityGroupRulesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifySnapshotAttribute
    class ModifySnapshotAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySnapshotAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifySnapshotTier
    class ModifySnapshotTier
      def self.default(visited=[])
        {
          snapshot_id: 'snapshot_id',
          tiering_start_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySnapshotTierResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('tieringStartTime', Hearth::TimeHelper.to_date_time(stub[:tiering_start_time])) unless stub[:tiering_start_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifySpotFleetRequest
    class ModifySpotFleetRequest
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySpotFleetRequestResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifySubnetAttribute
    class ModifySubnetAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySubnetAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyTrafficMirrorFilterNetworkServices
    class ModifyTrafficMirrorFilterNetworkServices
      def self.default(visited=[])
        {
          traffic_mirror_filter: TrafficMirrorFilter.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTrafficMirrorFilterNetworkServicesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorFilter.stub('trafficMirrorFilter', stub[:traffic_mirror_filter]) unless stub[:traffic_mirror_filter].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyTrafficMirrorFilterRule
    class ModifyTrafficMirrorFilterRule
      def self.default(visited=[])
        {
          traffic_mirror_filter_rule: TrafficMirrorFilterRule.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTrafficMirrorFilterRuleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorFilterRule.stub('trafficMirrorFilterRule', stub[:traffic_mirror_filter_rule]) unless stub[:traffic_mirror_filter_rule].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyTrafficMirrorSession
    class ModifyTrafficMirrorSession
      def self.default(visited=[])
        {
          traffic_mirror_session: TrafficMirrorSession.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTrafficMirrorSessionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorSession.stub('trafficMirrorSession', stub[:traffic_mirror_session]) unless stub[:traffic_mirror_session].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyTransitGateway
    class ModifyTransitGateway
      def self.default(visited=[])
        {
          transit_gateway: TransitGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTransitGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGateway.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyTransitGatewayPrefixListReference
    class ModifyTransitGatewayPrefixListReference
      def self.default(visited=[])
        {
          transit_gateway_prefix_list_reference: TransitGatewayPrefixListReference.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTransitGatewayPrefixListReferenceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPrefixListReference.stub('transitGatewayPrefixListReference', stub[:transit_gateway_prefix_list_reference]) unless stub[:transit_gateway_prefix_list_reference].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyTransitGatewayVpcAttachment
    class ModifyTransitGatewayVpcAttachment
      def self.default(visited=[])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVolume
    class ModifyVolume
      def self.default(visited=[])
        {
          volume_modification: VolumeModification.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VolumeModification.stub('volumeModification', stub[:volume_modification]) unless stub[:volume_modification].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVolumeAttribute
    class ModifyVolumeAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVolumeAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpcAttribute
    class ModifyVpcAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpcEndpoint
    class ModifyVpcEndpoint
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpcEndpointConnectionNotification
    class ModifyVpcEndpointConnectionNotification
      def self.default(visited=[])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointConnectionNotificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpcEndpointServiceConfiguration
    class ModifyVpcEndpointServiceConfiguration
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointServiceConfigurationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpcEndpointServicePayerResponsibility
    class ModifyVpcEndpointServicePayerResponsibility
      def self.default(visited=[])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointServicePayerResponsibilityResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpcEndpointServicePermissions
    class ModifyVpcEndpointServicePermissions
      def self.default(visited=[])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointServicePermissionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpcPeeringConnectionOptions
    class ModifyVpcPeeringConnectionOptions
      def self.default(visited=[])
        {
          accepter_peering_connection_options: PeeringConnectionOptions.default(visited),
          requester_peering_connection_options: PeeringConnectionOptions.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcPeeringConnectionOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << PeeringConnectionOptions.stub('accepterPeeringConnectionOptions', stub[:accepter_peering_connection_options]) unless stub[:accepter_peering_connection_options].nil?
        xml << PeeringConnectionOptions.stub('requesterPeeringConnectionOptions', stub[:requester_peering_connection_options]) unless stub[:requester_peering_connection_options].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for PeeringConnectionOptions
    class PeeringConnectionOptions
      def self.default(visited=[])
        return nil if visited.include?('PeeringConnectionOptions')
        visited = visited + ['PeeringConnectionOptions']
        {
          allow_dns_resolution_from_remote_vpc: false,
          allow_egress_from_local_classic_link_to_remote_vpc: false,
          allow_egress_from_local_vpc_to_remote_classic_link: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allowDnsResolutionFromRemoteVpc', stub[:allow_dns_resolution_from_remote_vpc].to_s) unless stub[:allow_dns_resolution_from_remote_vpc].nil?
        xml << Hearth::XML::Node.new('allowEgressFromLocalClassicLinkToRemoteVpc', stub[:allow_egress_from_local_classic_link_to_remote_vpc].to_s) unless stub[:allow_egress_from_local_classic_link_to_remote_vpc].nil?
        xml << Hearth::XML::Node.new('allowEgressFromLocalVpcToRemoteClassicLink', stub[:allow_egress_from_local_vpc_to_remote_classic_link].to_s) unless stub[:allow_egress_from_local_vpc_to_remote_classic_link].nil?
        xml
      end
    end

    # Operation Stubber for ModifyVpcTenancy
    class ModifyVpcTenancy
      def self.default(visited=[])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcTenancyResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpnConnection
    class ModifyVpnConnection
      def self.default(visited=[])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpnConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpnConnectionOptions
    class ModifyVpnConnectionOptions
      def self.default(visited=[])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpnConnectionOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpnTunnelCertificate
    class ModifyVpnTunnelCertificate
      def self.default(visited=[])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpnTunnelCertificateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ModifyVpnTunnelOptions
    class ModifyVpnTunnelOptions
      def self.default(visited=[])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpnTunnelOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for MonitorInstances
    class MonitorInstances
      def self.default(visited=[])
        {
          instance_monitorings: InstanceMonitoringList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('MonitorInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceMonitoringList.stub('item', stub[:instance_monitorings])) unless stub[:instance_monitorings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceMonitoringList
    class InstanceMonitoringList
      def self.default(visited=[])
        return nil if visited.include?('InstanceMonitoringList')
        visited = visited + ['InstanceMonitoringList']
        [
          InstanceMonitoring.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceMonitoring.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceMonitoring
    class InstanceMonitoring
      def self.default(visited=[])
        return nil if visited.include?('InstanceMonitoring')
        visited = visited + ['InstanceMonitoring']
        {
          instance_id: 'instance_id',
          monitoring: Monitoring.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Monitoring.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml
      end
    end

    # Operation Stubber for MoveAddressToVpc
    class MoveAddressToVpc
      def self.default(visited=[])
        {
          allocation_id: 'allocation_id',
          status: 'status',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('MoveAddressToVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for MoveByoipCidrToIpam
    class MoveByoipCidrToIpam
      def self.default(visited=[])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('MoveByoipCidrToIpamResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ProvisionByoipCidr
    class ProvisionByoipCidr
      def self.default(visited=[])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ProvisionByoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ProvisionIpamPoolCidr
    class ProvisionIpamPoolCidr
      def self.default(visited=[])
        {
          ipam_pool_cidr: IpamPoolCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ProvisionIpamPoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPoolCidr.stub('ipamPoolCidr', stub[:ipam_pool_cidr]) unless stub[:ipam_pool_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ProvisionPublicIpv4PoolCidr
    class ProvisionPublicIpv4PoolCidr
      def self.default(visited=[])
        {
          pool_id: 'pool_id',
          pool_address_range: PublicIpv4PoolRange.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ProvisionPublicIpv4PoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << PublicIpv4PoolRange.stub('poolAddressRange', stub[:pool_address_range]) unless stub[:pool_address_range].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for PurchaseHostReservation
    class PurchaseHostReservation
      def self.default(visited=[])
        {
          client_token: 'client_token',
          currency_code: 'currency_code',
          purchase: PurchaseSet.default(visited),
          total_hourly_price: 'total_hourly_price',
          total_upfront_price: 'total_upfront_price',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('PurchaseHostReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('purchase', PurchaseSet.stub('item', stub[:purchase])) unless stub[:purchase].nil?
        xml << Hearth::XML::Node.new('totalHourlyPrice', stub[:total_hourly_price].to_s) unless stub[:total_hourly_price].nil?
        xml << Hearth::XML::Node.new('totalUpfrontPrice', stub[:total_upfront_price].to_s) unless stub[:total_upfront_price].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for PurchaseReservedInstancesOffering
    class PurchaseReservedInstancesOffering
      def self.default(visited=[])
        {
          reserved_instances_id: 'reserved_instances_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('PurchaseReservedInstancesOfferingResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for PurchaseScheduledInstances
    class PurchaseScheduledInstances
      def self.default(visited=[])
        {
          scheduled_instance_set: PurchasedScheduledInstanceSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('PurchaseScheduledInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('scheduledInstanceSet', PurchasedScheduledInstanceSet.stub('item', stub[:scheduled_instance_set])) unless stub[:scheduled_instance_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for PurchasedScheduledInstanceSet
    class PurchasedScheduledInstanceSet
      def self.default(visited=[])
        return nil if visited.include?('PurchasedScheduledInstanceSet')
        visited = visited + ['PurchasedScheduledInstanceSet']
        [
          ScheduledInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ScheduledInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for RebootInstances
    class RebootInstances
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RebootInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RegisterImage
    class RegisterImage
      def self.default(visited=[])
        {
          image_id: 'image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RegisterImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RegisterInstanceEventNotificationAttributes
    class RegisterInstanceEventNotificationAttributes
      def self.default(visited=[])
        {
          instance_tag_attribute: InstanceTagNotificationAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RegisterInstanceEventNotificationAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceTagNotificationAttribute.stub('instanceTagAttribute', stub[:instance_tag_attribute]) unless stub[:instance_tag_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RegisterTransitGatewayMulticastGroupMembers
    class RegisterTransitGatewayMulticastGroupMembers
      def self.default(visited=[])
        {
          registered_multicast_group_members: TransitGatewayMulticastRegisteredGroupMembers.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RegisterTransitGatewayMulticastGroupMembersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastRegisteredGroupMembers.stub('registeredMulticastGroupMembers', stub[:registered_multicast_group_members]) unless stub[:registered_multicast_group_members].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayMulticastRegisteredGroupMembers
    class TransitGatewayMulticastRegisteredGroupMembers
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastRegisteredGroupMembers')
        visited = visited + ['TransitGatewayMulticastRegisteredGroupMembers']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          registered_network_interface_ids: ValueStringList.default(visited),
          group_ip_address: 'group_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('registeredNetworkInterfaceIds', ValueStringList.stub('item', stub[:registered_network_interface_ids])) unless stub[:registered_network_interface_ids].nil?
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml
      end
    end

    # Operation Stubber for RegisterTransitGatewayMulticastGroupSources
    class RegisterTransitGatewayMulticastGroupSources
      def self.default(visited=[])
        {
          registered_multicast_group_sources: TransitGatewayMulticastRegisteredGroupSources.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RegisterTransitGatewayMulticastGroupSourcesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastRegisteredGroupSources.stub('registeredMulticastGroupSources', stub[:registered_multicast_group_sources]) unless stub[:registered_multicast_group_sources].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Structure Stubber for TransitGatewayMulticastRegisteredGroupSources
    class TransitGatewayMulticastRegisteredGroupSources
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastRegisteredGroupSources')
        visited = visited + ['TransitGatewayMulticastRegisteredGroupSources']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          registered_network_interface_ids: ValueStringList.default(visited),
          group_ip_address: 'group_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('registeredNetworkInterfaceIds', ValueStringList.stub('item', stub[:registered_network_interface_ids])) unless stub[:registered_network_interface_ids].nil?
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml
      end
    end

    # Operation Stubber for RejectTransitGatewayMulticastDomainAssociations
    class RejectTransitGatewayMulticastDomainAssociations
      def self.default(visited=[])
        {
          associations: TransitGatewayMulticastDomainAssociations.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectTransitGatewayMulticastDomainAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomainAssociations.stub('associations', stub[:associations]) unless stub[:associations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RejectTransitGatewayPeeringAttachment
    class RejectTransitGatewayPeeringAttachment
      def self.default(visited=[])
        {
          transit_gateway_peering_attachment: TransitGatewayPeeringAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectTransitGatewayPeeringAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPeeringAttachment.stub('transitGatewayPeeringAttachment', stub[:transit_gateway_peering_attachment]) unless stub[:transit_gateway_peering_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RejectTransitGatewayVpcAttachment
    class RejectTransitGatewayVpcAttachment
      def self.default(visited=[])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RejectVpcEndpointConnections
    class RejectVpcEndpointConnections
      def self.default(visited=[])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectVpcEndpointConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RejectVpcPeeringConnection
    class RejectVpcPeeringConnection
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectVpcPeeringConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReleaseAddress
    class ReleaseAddress
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReleaseAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReleaseHosts
    class ReleaseHosts
      def self.default(visited=[])
        {
          successful: ResponseHostIdList.default(visited),
          unsuccessful: UnsuccessfulItemList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReleaseHostsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successful', ResponseHostIdList.stub('item', stub[:successful])) unless stub[:successful].nil?
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemList.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReleaseIpamPoolAllocation
    class ReleaseIpamPoolAllocation
      def self.default(visited=[])
        {
          success: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReleaseIpamPoolAllocationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('success', stub[:success].to_s) unless stub[:success].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReplaceIamInstanceProfileAssociation
    class ReplaceIamInstanceProfileAssociation
      def self.default(visited=[])
        {
          iam_instance_profile_association: IamInstanceProfileAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceIamInstanceProfileAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IamInstanceProfileAssociation.stub('iamInstanceProfileAssociation', stub[:iam_instance_profile_association]) unless stub[:iam_instance_profile_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReplaceNetworkAclAssociation
    class ReplaceNetworkAclAssociation
      def self.default(visited=[])
        {
          new_association_id: 'new_association_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceNetworkAclAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('newAssociationId', stub[:new_association_id].to_s) unless stub[:new_association_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReplaceNetworkAclEntry
    class ReplaceNetworkAclEntry
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceNetworkAclEntryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReplaceRoute
    class ReplaceRoute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReplaceRouteTableAssociation
    class ReplaceRouteTableAssociation
      def self.default(visited=[])
        {
          new_association_id: 'new_association_id',
          association_state: RouteTableAssociationState.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceRouteTableAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('newAssociationId', stub[:new_association_id].to_s) unless stub[:new_association_id].nil?
        xml << RouteTableAssociationState.stub('associationState', stub[:association_state]) unless stub[:association_state].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReplaceTransitGatewayRoute
    class ReplaceTransitGatewayRoute
      def self.default(visited=[])
        {
          route: TransitGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceTransitGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ReportInstanceStatus
    class ReportInstanceStatus
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReportInstanceStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RequestSpotFleet
    class RequestSpotFleet
      def self.default(visited=[])
        {
          spot_fleet_request_id: 'spot_fleet_request_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RequestSpotFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RequestSpotInstances
    class RequestSpotInstances
      def self.default(visited=[])
        {
          spot_instance_requests: SpotInstanceRequestList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RequestSpotInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotInstanceRequestSet', SpotInstanceRequestList.stub('item', stub[:spot_instance_requests])) unless stub[:spot_instance_requests].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ResetAddressAttribute
    class ResetAddressAttribute
      def self.default(visited=[])
        {
          address: AddressAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetAddressAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << AddressAttribute.stub('address', stub[:address]) unless stub[:address].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ResetEbsDefaultKmsKeyId
    class ResetEbsDefaultKmsKeyId
      def self.default(visited=[])
        {
          kms_key_id: 'kms_key_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetEbsDefaultKmsKeyIdResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ResetFpgaImageAttribute
    class ResetFpgaImageAttribute
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetFpgaImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ResetImageAttribute
    class ResetImageAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ResetInstanceAttribute
    class ResetInstanceAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetInstanceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ResetNetworkInterfaceAttribute
    class ResetNetworkInterfaceAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetNetworkInterfaceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for ResetSnapshotAttribute
    class ResetSnapshotAttribute
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetSnapshotAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RestoreAddressToClassic
    class RestoreAddressToClassic
      def self.default(visited=[])
        {
          public_ip: 'public_ip',
          status: 'status',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreAddressToClassicResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RestoreImageFromRecycleBin
    class RestoreImageFromRecycleBin
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreImageFromRecycleBinResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RestoreManagedPrefixListVersion
    class RestoreManagedPrefixListVersion
      def self.default(visited=[])
        {
          prefix_list: ManagedPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreManagedPrefixListVersionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ManagedPrefixList.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RestoreSnapshotFromRecycleBin
    class RestoreSnapshotFromRecycleBin
      def self.default(visited=[])
        {
          snapshot_id: 'snapshot_id',
          outpost_arn: 'outpost_arn',
          description: 'description',
          encrypted: false,
          owner_id: 'owner_id',
          progress: 'progress',
          start_time: Time.now,
          state: 'state',
          volume_id: 'volume_id',
          volume_size: 1,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreSnapshotFromRecycleBinResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RestoreSnapshotTier
    class RestoreSnapshotTier
      def self.default(visited=[])
        {
          snapshot_id: 'snapshot_id',
          restore_start_time: Time.now,
          restore_duration: 1,
          is_permanent_restore: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreSnapshotTierResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('restoreStartTime', Hearth::TimeHelper.to_date_time(stub[:restore_start_time])) unless stub[:restore_start_time].nil?
        xml << Hearth::XML::Node.new('restoreDuration', stub[:restore_duration].to_s) unless stub[:restore_duration].nil?
        xml << Hearth::XML::Node.new('isPermanentRestore', stub[:is_permanent_restore].to_s) unless stub[:is_permanent_restore].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RevokeClientVpnIngress
    class RevokeClientVpnIngress
      def self.default(visited=[])
        {
          status: ClientVpnAuthorizationRuleStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RevokeClientVpnIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnAuthorizationRuleStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RevokeSecurityGroupEgress
    class RevokeSecurityGroupEgress
      def self.default(visited=[])
        {
          return: false,
          unknown_ip_permissions: IpPermissionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RevokeSecurityGroupEgressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('unknownIpPermissionSet', IpPermissionList.stub('item', stub[:unknown_ip_permissions])) unless stub[:unknown_ip_permissions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RevokeSecurityGroupIngress
    class RevokeSecurityGroupIngress
      def self.default(visited=[])
        {
          return: false,
          unknown_ip_permissions: IpPermissionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RevokeSecurityGroupIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('unknownIpPermissionSet', IpPermissionList.stub('item', stub[:unknown_ip_permissions])) unless stub[:unknown_ip_permissions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RunInstances
    class RunInstances
      def self.default(visited=[])
        {
          groups: GroupIdentifierList.default(visited),
          instances: InstanceList.default(visited),
          owner_id: 'owner_id',
          requester_id: 'requester_id',
          reservation_id: 'reservation_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RunInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('instancesSet', InstanceList.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('requesterId', stub[:requester_id].to_s) unless stub[:requester_id].nil?
        xml << Hearth::XML::Node.new('reservationId', stub[:reservation_id].to_s) unless stub[:reservation_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for RunScheduledInstances
    class RunScheduledInstances
      def self.default(visited=[])
        {
          instance_id_set: InstanceIdSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RunScheduledInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceIdSet', InstanceIdSet.stub('item', stub[:instance_id_set])) unless stub[:instance_id_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceIdSet
    class InstanceIdSet
      def self.default(visited=[])
        return nil if visited.include?('InstanceIdSet')
        visited = visited + ['InstanceIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for SearchLocalGatewayRoutes
    class SearchLocalGatewayRoutes
      def self.default(visited=[])
        {
          routes: LocalGatewayRouteList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('SearchLocalGatewayRoutesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('routeSet', LocalGatewayRouteList.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for LocalGatewayRouteList
    class LocalGatewayRouteList
      def self.default(visited=[])
        return nil if visited.include?('LocalGatewayRouteList')
        visited = visited + ['LocalGatewayRouteList']
        [
          LocalGatewayRoute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayRoute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for SearchTransitGatewayMulticastGroups
    class SearchTransitGatewayMulticastGroups
      def self.default(visited=[])
        {
          multicast_groups: TransitGatewayMulticastGroupList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('SearchTransitGatewayMulticastGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('multicastGroups', TransitGatewayMulticastGroupList.stub('item', stub[:multicast_groups])) unless stub[:multicast_groups].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayMulticastGroupList
    class TransitGatewayMulticastGroupList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastGroupList')
        visited = visited + ['TransitGatewayMulticastGroupList']
        [
          TransitGatewayMulticastGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayMulticastGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TransitGatewayMulticastGroup
    class TransitGatewayMulticastGroup
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayMulticastGroup')
        visited = visited + ['TransitGatewayMulticastGroup']
        {
          group_ip_address: 'group_ip_address',
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          subnet_id: 'subnet_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          resource_owner_id: 'resource_owner_id',
          network_interface_id: 'network_interface_id',
          group_member: false,
          group_source: false,
          member_type: 'member_type',
          source_type: 'source_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('groupMember', stub[:group_member].to_s) unless stub[:group_member].nil?
        xml << Hearth::XML::Node.new('groupSource', stub[:group_source].to_s) unless stub[:group_source].nil?
        xml << Hearth::XML::Node.new('memberType', stub[:member_type].to_s) unless stub[:member_type].nil?
        xml << Hearth::XML::Node.new('sourceType', stub[:source_type].to_s) unless stub[:source_type].nil?
        xml
      end
    end

    # Operation Stubber for SearchTransitGatewayRoutes
    class SearchTransitGatewayRoutes
      def self.default(visited=[])
        {
          routes: TransitGatewayRouteList.default(visited),
          additional_routes_available: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('SearchTransitGatewayRoutesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('routeSet', TransitGatewayRouteList.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('additionalRoutesAvailable', stub[:additional_routes_available].to_s) unless stub[:additional_routes_available].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TransitGatewayRouteList
    class TransitGatewayRouteList
      def self.default(visited=[])
        return nil if visited.include?('TransitGatewayRouteList')
        visited = visited + ['TransitGatewayRouteList']
        [
          TransitGatewayRoute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRoute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Operation Stubber for SendDiagnosticInterrupt
    class SendDiagnosticInterrupt
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('SendDiagnosticInterruptResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for StartInstances
    class StartInstances
      def self.default(visited=[])
        {
          starting_instances: InstanceStateChangeList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StartInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceStateChangeList.stub('item', stub[:starting_instances])) unless stub[:starting_instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for InstanceStateChangeList
    class InstanceStateChangeList
      def self.default(visited=[])
        return nil if visited.include?('InstanceStateChangeList')
        visited = visited + ['InstanceStateChangeList']
        [
          InstanceStateChange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceStateChange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for InstanceStateChange
    class InstanceStateChange
      def self.default(visited=[])
        return nil if visited.include?('InstanceStateChange')
        visited = visited + ['InstanceStateChange']
        {
          current_state: InstanceState.default(visited),
          instance_id: 'instance_id',
          previous_state: InstanceState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << InstanceState.stub('currentState', stub[:current_state]) unless stub[:current_state].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << InstanceState.stub('previousState', stub[:previous_state]) unless stub[:previous_state].nil?
        xml
      end
    end

    # Operation Stubber for StartNetworkInsightsAccessScopeAnalysis
    class StartNetworkInsightsAccessScopeAnalysis
      def self.default(visited=[])
        {
          network_insights_access_scope_analysis: NetworkInsightsAccessScopeAnalysis.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StartNetworkInsightsAccessScopeAnalysisResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsAccessScopeAnalysis.stub('networkInsightsAccessScopeAnalysis', stub[:network_insights_access_scope_analysis]) unless stub[:network_insights_access_scope_analysis].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for StartNetworkInsightsAnalysis
    class StartNetworkInsightsAnalysis
      def self.default(visited=[])
        {
          network_insights_analysis: NetworkInsightsAnalysis.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StartNetworkInsightsAnalysisResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsAnalysis.stub('networkInsightsAnalysis', stub[:network_insights_analysis]) unless stub[:network_insights_analysis].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for StartVpcEndpointServicePrivateDnsVerification
    class StartVpcEndpointServicePrivateDnsVerification
      def self.default(visited=[])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StartVpcEndpointServicePrivateDnsVerificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for StopInstances
    class StopInstances
      def self.default(visited=[])
        {
          stopping_instances: InstanceStateChangeList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StopInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceStateChangeList.stub('item', stub[:stopping_instances])) unless stub[:stopping_instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for TerminateClientVpnConnections
    class TerminateClientVpnConnections
      def self.default(visited=[])
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          username: 'username',
          connection_statuses: TerminateConnectionStatusSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('TerminateClientVpnConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('username', stub[:username].to_s) unless stub[:username].nil?
        xml << Hearth::XML::Node.new('connectionStatuses', TerminateConnectionStatusSet.stub('item', stub[:connection_statuses])) unless stub[:connection_statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # List Stubber for TerminateConnectionStatusSet
    class TerminateConnectionStatusSet
      def self.default(visited=[])
        return nil if visited.include?('TerminateConnectionStatusSet')
        visited = visited + ['TerminateConnectionStatusSet']
        [
          TerminateConnectionStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TerminateConnectionStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    # Structure Stubber for TerminateConnectionStatus
    class TerminateConnectionStatus
      def self.default(visited=[])
        return nil if visited.include?('TerminateConnectionStatus')
        visited = visited + ['TerminateConnectionStatus']
        {
          connection_id: 'connection_id',
          previous_status: ClientVpnConnectionStatus.default(visited),
          current_status: ClientVpnConnectionStatus.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('connectionId', stub[:connection_id].to_s) unless stub[:connection_id].nil?
        xml << ClientVpnConnectionStatus.stub('previousStatus', stub[:previous_status]) unless stub[:previous_status].nil?
        xml << ClientVpnConnectionStatus.stub('currentStatus', stub[:current_status]) unless stub[:current_status].nil?
        xml
      end
    end

    # Operation Stubber for TerminateInstances
    class TerminateInstances
      def self.default(visited=[])
        {
          terminating_instances: InstanceStateChangeList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('TerminateInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceStateChangeList.stub('item', stub[:terminating_instances])) unless stub[:terminating_instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for UnassignIpv6Addresses
    class UnassignIpv6Addresses
      def self.default(visited=[])
        {
          network_interface_id: 'network_interface_id',
          unassigned_ipv6_addresses: Ipv6AddressList.default(visited),
          unassigned_ipv6_prefixes: IpPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UnassignIpv6AddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('unassignedIpv6Addresses', Ipv6AddressList.stub('item', stub[:unassigned_ipv6_addresses])) unless stub[:unassigned_ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('unassignedIpv6PrefixSet', IpPrefixList.stub('item', stub[:unassigned_ipv6_prefixes])) unless stub[:unassigned_ipv6_prefixes].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for UnassignPrivateIpAddresses
    class UnassignPrivateIpAddresses
      def self.default(visited=[])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UnassignPrivateIpAddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for UnmonitorInstances
    class UnmonitorInstances
      def self.default(visited=[])
        {
          instance_monitorings: InstanceMonitoringList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UnmonitorInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceMonitoringList.stub('item', stub[:instance_monitorings])) unless stub[:instance_monitorings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for UpdateSecurityGroupRuleDescriptionsEgress
    class UpdateSecurityGroupRuleDescriptionsEgress
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UpdateSecurityGroupRuleDescriptionsEgressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for UpdateSecurityGroupRuleDescriptionsIngress
    class UpdateSecurityGroupRuleDescriptionsIngress
      def self.default(visited=[])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UpdateSecurityGroupRuleDescriptionsIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    # Operation Stubber for WithdrawByoipCidr
    class WithdrawByoipCidr
      def self.default(visited=[])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('WithdrawByoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end
  end
end
