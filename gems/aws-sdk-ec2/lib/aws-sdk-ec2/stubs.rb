# frozen_string_literal: true

# WARNING ABOUT GENERATED CODE
#
# This file was code generated using smithy-ruby.
# https://github.com/awslabs/smithy-ruby
#
# WARNING ABOUT GENERATED CODE

require 'base64'
require 'stringio'

module AWS::SDK::EC2
  # @api private
  module Stubs

    class AcceleratorCount
      def self.default(visited = [])
        return nil if visited.include?('AcceleratorCount')
        visited = visited + ['AcceleratorCount']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    class AcceleratorManufacturerSet
      def self.default(visited = [])
        return nil if visited.include?('AcceleratorManufacturerSet')
        visited = visited + ['AcceleratorManufacturerSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class AcceleratorNameSet
      def self.default(visited = [])
        return nil if visited.include?('AcceleratorNameSet')
        visited = visited + ['AcceleratorNameSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class AcceleratorTotalMemoryMiB
      def self.default(visited = [])
        return nil if visited.include?('AcceleratorTotalMemoryMiB')
        visited = visited + ['AcceleratorTotalMemoryMiB']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    class AcceleratorTypeSet
      def self.default(visited = [])
        return nil if visited.include?('AcceleratorTypeSet')
        visited = visited + ['AcceleratorTypeSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class AcceptAddressTransfer
      def self.build(params, context:)
        Params::AcceptAddressTransferOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AcceptAddressTransferOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          address_transfer: AddressTransfer.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptAddressTransferResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << AddressTransfer.stub('addressTransfer', stub[:address_transfer]) unless stub[:address_transfer].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AcceptReservedInstancesExchangeQuote
      def self.build(params, context:)
        Params::AcceptReservedInstancesExchangeQuoteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AcceptReservedInstancesExchangeQuoteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          exchange_id: 'exchange_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptReservedInstancesExchangeQuoteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('exchangeId', stub[:exchange_id].to_s) unless stub[:exchange_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AcceptTransitGatewayMulticastDomainAssociations
      def self.build(params, context:)
        Params::AcceptTransitGatewayMulticastDomainAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AcceptTransitGatewayMulticastDomainAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          associations: TransitGatewayMulticastDomainAssociations.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptTransitGatewayMulticastDomainAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomainAssociations.stub('associations', stub[:associations]) unless stub[:associations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AcceptTransitGatewayPeeringAttachment
      def self.build(params, context:)
        Params::AcceptTransitGatewayPeeringAttachmentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AcceptTransitGatewayPeeringAttachmentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_peering_attachment: TransitGatewayPeeringAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptTransitGatewayPeeringAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPeeringAttachment.stub('transitGatewayPeeringAttachment', stub[:transit_gateway_peering_attachment]) unless stub[:transit_gateway_peering_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AcceptTransitGatewayVpcAttachment
      def self.build(params, context:)
        Params::AcceptTransitGatewayVpcAttachmentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AcceptTransitGatewayVpcAttachmentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AcceptVpcEndpointConnections
      def self.build(params, context:)
        Params::AcceptVpcEndpointConnectionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AcceptVpcEndpointConnectionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptVpcEndpointConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AcceptVpcPeeringConnection
      def self.build(params, context:)
        Params::AcceptVpcPeeringConnectionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AcceptVpcPeeringConnectionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc_peering_connection: VpcPeeringConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AcceptVpcPeeringConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcPeeringConnection.stub('vpcPeeringConnection', stub[:vpc_peering_connection]) unless stub[:vpc_peering_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AccessScopeAnalysisFinding
      def self.default(visited = [])
        return nil if visited.include?('AccessScopeAnalysisFinding')
        visited = visited + ['AccessScopeAnalysisFinding']
        {
          network_insights_access_scope_analysis_id: 'network_insights_access_scope_analysis_id',
          network_insights_access_scope_id: 'network_insights_access_scope_id',
          finding_id: 'finding_id',
          finding_components: PathComponentList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisId', stub[:network_insights_access_scope_analysis_id].to_s) unless stub[:network_insights_access_scope_analysis_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        xml << Hearth::XML::Node.new('findingId', stub[:finding_id].to_s) unless stub[:finding_id].nil?
        xml << Hearth::XML::Node.new('findingComponentSet', PathComponentList.stub('item', stub[:finding_components])) unless stub[:finding_components].nil?
        xml
      end
    end

    class AccessScopeAnalysisFindingList
      def self.default(visited = [])
        return nil if visited.include?('AccessScopeAnalysisFindingList')
        visited = visited + ['AccessScopeAnalysisFindingList']
        [
          AccessScopeAnalysisFinding.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AccessScopeAnalysisFinding.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AccessScopePath
      def self.default(visited = [])
        return nil if visited.include?('AccessScopePath')
        visited = visited + ['AccessScopePath']
        {
          source: PathStatement.default(visited),
          destination: PathStatement.default(visited),
          through_resources: ThroughResourcesStatementList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << PathStatement.stub('source', stub[:source]) unless stub[:source].nil?
        xml << PathStatement.stub('destination', stub[:destination]) unless stub[:destination].nil?
        xml << Hearth::XML::Node.new('throughResourceSet', ThroughResourcesStatementList.stub('item', stub[:through_resources])) unless stub[:through_resources].nil?
        xml
      end
    end

    class AccessScopePathList
      def self.default(visited = [])
        return nil if visited.include?('AccessScopePathList')
        visited = visited + ['AccessScopePathList']
        [
          AccessScopePath.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AccessScopePath.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AccountAttribute
      def self.default(visited = [])
        return nil if visited.include?('AccountAttribute')
        visited = visited + ['AccountAttribute']
        {
          attribute_name: 'attribute_name',
          attribute_values: AccountAttributeValueList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attributeName', stub[:attribute_name].to_s) unless stub[:attribute_name].nil?
        xml << Hearth::XML::Node.new('attributeValueSet', AccountAttributeValueList.stub('item', stub[:attribute_values])) unless stub[:attribute_values].nil?
        xml
      end
    end

    class AccountAttributeList
      def self.default(visited = [])
        return nil if visited.include?('AccountAttributeList')
        visited = visited + ['AccountAttributeList']
        [
          AccountAttribute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AccountAttribute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AccountAttributeValue
      def self.default(visited = [])
        return nil if visited.include?('AccountAttributeValue')
        visited = visited + ['AccountAttributeValue']
        {
          attribute_value: 'attribute_value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attributeValue', stub[:attribute_value].to_s) unless stub[:attribute_value].nil?
        xml
      end
    end

    class AccountAttributeValueList
      def self.default(visited = [])
        return nil if visited.include?('AccountAttributeValueList')
        visited = visited + ['AccountAttributeValueList']
        [
          AccountAttributeValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AccountAttributeValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ActiveInstance
      def self.default(visited = [])
        return nil if visited.include?('ActiveInstance')
        visited = visited + ['ActiveInstance']
        {
          instance_id: 'instance_id',
          instance_type: 'instance_type',
          spot_instance_request_id: 'spot_instance_request_id',
          instance_health: 'instance_health',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('spotInstanceRequestId', stub[:spot_instance_request_id].to_s) unless stub[:spot_instance_request_id].nil?
        xml << Hearth::XML::Node.new('instanceHealth', stub[:instance_health].to_s) unless stub[:instance_health].nil?
        xml
      end
    end

    class ActiveInstanceSet
      def self.default(visited = [])
        return nil if visited.include?('ActiveInstanceSet')
        visited = visited + ['ActiveInstanceSet']
        [
          ActiveInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ActiveInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AddedPrincipal
      def self.default(visited = [])
        return nil if visited.include?('AddedPrincipal')
        visited = visited + ['AddedPrincipal']
        {
          principal_type: 'principal_type',
          principal: 'principal',
          service_permission_id: 'service_permission_id',
          service_id: 'service_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('principalType', stub[:principal_type].to_s) unless stub[:principal_type].nil?
        xml << Hearth::XML::Node.new('principal', stub[:principal].to_s) unless stub[:principal].nil?
        xml << Hearth::XML::Node.new('servicePermissionId', stub[:service_permission_id].to_s) unless stub[:service_permission_id].nil?
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml
      end
    end

    class AddedPrincipalSet
      def self.default(visited = [])
        return nil if visited.include?('AddedPrincipalSet')
        visited = visited + ['AddedPrincipalSet']
        [
          AddedPrincipal.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AddedPrincipal.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AdditionalDetail
      def self.default(visited = [])
        return nil if visited.include?('AdditionalDetail')
        visited = visited + ['AdditionalDetail']
        {
          additional_detail_type: 'additional_detail_type',
          component: AnalysisComponent.default(visited),
          vpc_endpoint_service: AnalysisComponent.default(visited),
          rule_options: RuleOptionList.default(visited),
          rule_group_type_pairs: RuleGroupTypePairList.default(visited),
          rule_group_rule_options_pairs: RuleGroupRuleOptionsPairList.default(visited),
          service_name: 'service_name',
          load_balancers: AnalysisComponentList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('additionalDetailType', stub[:additional_detail_type].to_s) unless stub[:additional_detail_type].nil?
        xml << AnalysisComponent.stub('component', stub[:component]) unless stub[:component].nil?
        xml << AnalysisComponent.stub('vpcEndpointService', stub[:vpc_endpoint_service]) unless stub[:vpc_endpoint_service].nil?
        xml << Hearth::XML::Node.new('ruleOptionSet', RuleOptionList.stub('item', stub[:rule_options])) unless stub[:rule_options].nil?
        xml << Hearth::XML::Node.new('ruleGroupTypePairSet', RuleGroupTypePairList.stub('item', stub[:rule_group_type_pairs])) unless stub[:rule_group_type_pairs].nil?
        xml << Hearth::XML::Node.new('ruleGroupRuleOptionsPairSet', RuleGroupRuleOptionsPairList.stub('item', stub[:rule_group_rule_options_pairs])) unless stub[:rule_group_rule_options_pairs].nil?
        xml << Hearth::XML::Node.new('serviceName', stub[:service_name].to_s) unless stub[:service_name].nil?
        xml << Hearth::XML::Node.new('loadBalancerSet', AnalysisComponentList.stub('item', stub[:load_balancers])) unless stub[:load_balancers].nil?
        xml
      end
    end

    class AdditionalDetailList
      def self.default(visited = [])
        return nil if visited.include?('AdditionalDetailList')
        visited = visited + ['AdditionalDetailList']
        [
          AdditionalDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AdditionalDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Address
      def self.default(visited = [])
        return nil if visited.include?('Address')
        visited = visited + ['Address']
        {
          instance_id: 'instance_id',
          public_ip: 'public_ip',
          allocation_id: 'allocation_id',
          association_id: 'association_id',
          domain: 'domain',
          network_interface_id: 'network_interface_id',
          network_interface_owner_id: 'network_interface_owner_id',
          private_ip_address: 'private_ip_address',
          tags: TagList.default(visited),
          public_ipv4_pool: 'public_ipv4_pool',
          network_border_group: 'network_border_group',
          customer_owned_ip: 'customer_owned_ip',
          customer_owned_ipv4_pool: 'customer_owned_ipv4_pool',
          carrier_ip: 'carrier_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('domain', stub[:domain].to_s) unless stub[:domain].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceOwnerId', stub[:network_interface_owner_id].to_s) unless stub[:network_interface_owner_id].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('publicIpv4Pool', stub[:public_ipv4_pool].to_s) unless stub[:public_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('customerOwnedIp', stub[:customer_owned_ip].to_s) unless stub[:customer_owned_ip].nil?
        xml << Hearth::XML::Node.new('customerOwnedIpv4Pool', stub[:customer_owned_ipv4_pool].to_s) unless stub[:customer_owned_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('carrierIp', stub[:carrier_ip].to_s) unless stub[:carrier_ip].nil?
        xml
      end
    end

    class AddressAttribute
      def self.default(visited = [])
        return nil if visited.include?('AddressAttribute')
        visited = visited + ['AddressAttribute']
        {
          public_ip: 'public_ip',
          allocation_id: 'allocation_id',
          ptr_record: 'ptr_record',
          ptr_record_update: PtrUpdateStatus.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('ptrRecord', stub[:ptr_record].to_s) unless stub[:ptr_record].nil?
        xml << PtrUpdateStatus.stub('ptrRecordUpdate', stub[:ptr_record_update]) unless stub[:ptr_record_update].nil?
        xml
      end
    end

    class AddressList
      def self.default(visited = [])
        return nil if visited.include?('AddressList')
        visited = visited + ['AddressList']
        [
          Address.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Address.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AddressSet
      def self.default(visited = [])
        return nil if visited.include?('AddressSet')
        visited = visited + ['AddressSet']
        [
          AddressAttribute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AddressAttribute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AddressTransfer
      def self.default(visited = [])
        return nil if visited.include?('AddressTransfer')
        visited = visited + ['AddressTransfer']
        {
          public_ip: 'public_ip',
          allocation_id: 'allocation_id',
          transfer_account_id: 'transfer_account_id',
          transfer_offer_expiration_timestamp: Time.now,
          transfer_offer_accepted_timestamp: Time.now,
          address_transfer_status: 'address_transfer_status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('transferAccountId', stub[:transfer_account_id].to_s) unless stub[:transfer_account_id].nil?
        xml << Hearth::XML::Node.new('transferOfferExpirationTimestamp', Hearth::TimeHelper.to_date_time(stub[:transfer_offer_expiration_timestamp])) unless stub[:transfer_offer_expiration_timestamp].nil?
        xml << Hearth::XML::Node.new('transferOfferAcceptedTimestamp', Hearth::TimeHelper.to_date_time(stub[:transfer_offer_accepted_timestamp])) unless stub[:transfer_offer_accepted_timestamp].nil?
        xml << Hearth::XML::Node.new('addressTransferStatus', stub[:address_transfer_status].to_s) unless stub[:address_transfer_status].nil?
        xml
      end
    end

    class AddressTransferList
      def self.default(visited = [])
        return nil if visited.include?('AddressTransferList')
        visited = visited + ['AddressTransferList']
        [
          AddressTransfer.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AddressTransfer.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AdvertiseByoipCidr
      def self.build(params, context:)
        Params::AdvertiseByoipCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AdvertiseByoipCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AdvertiseByoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AllocateAddress
      def self.build(params, context:)
        Params::AllocateAddressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AllocateAddressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          public_ip: 'public_ip',
          allocation_id: 'allocation_id',
          public_ipv4_pool: 'public_ipv4_pool',
          network_border_group: 'network_border_group',
          domain: 'domain',
          customer_owned_ip: 'customer_owned_ip',
          customer_owned_ipv4_pool: 'customer_owned_ipv4_pool',
          carrier_ip: 'carrier_ip',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AllocateAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('publicIpv4Pool', stub[:public_ipv4_pool].to_s) unless stub[:public_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('domain', stub[:domain].to_s) unless stub[:domain].nil?
        xml << Hearth::XML::Node.new('customerOwnedIp', stub[:customer_owned_ip].to_s) unless stub[:customer_owned_ip].nil?
        xml << Hearth::XML::Node.new('customerOwnedIpv4Pool', stub[:customer_owned_ipv4_pool].to_s) unless stub[:customer_owned_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('carrierIp', stub[:carrier_ip].to_s) unless stub[:carrier_ip].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AllocateHosts
      def self.build(params, context:)
        Params::AllocateHostsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AllocateHostsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          host_ids: ResponseHostIdList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AllocateHostsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('hostIdSet', ResponseHostIdList.stub('item', stub[:host_ids])) unless stub[:host_ids].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AllocateIpamPoolCidr
      def self.build(params, context:)
        Params::AllocateIpamPoolCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AllocateIpamPoolCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_pool_allocation: IpamPoolAllocation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AllocateIpamPoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPoolAllocation.stub('ipamPoolAllocation', stub[:ipam_pool_allocation]) unless stub[:ipam_pool_allocation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AllowedInstanceTypeSet
      def self.default(visited = [])
        return nil if visited.include?('AllowedInstanceTypeSet')
        visited = visited + ['AllowedInstanceTypeSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class AllowedPrincipal
      def self.default(visited = [])
        return nil if visited.include?('AllowedPrincipal')
        visited = visited + ['AllowedPrincipal']
        {
          principal_type: 'principal_type',
          principal: 'principal',
          service_permission_id: 'service_permission_id',
          tags: TagList.default(visited),
          service_id: 'service_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('principalType', stub[:principal_type].to_s) unless stub[:principal_type].nil?
        xml << Hearth::XML::Node.new('principal', stub[:principal].to_s) unless stub[:principal].nil?
        xml << Hearth::XML::Node.new('servicePermissionId', stub[:service_permission_id].to_s) unless stub[:service_permission_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml
      end
    end

    class AllowedPrincipalSet
      def self.default(visited = [])
        return nil if visited.include?('AllowedPrincipalSet')
        visited = visited + ['AllowedPrincipalSet']
        [
          AllowedPrincipal.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AllowedPrincipal.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AlternatePathHint
      def self.default(visited = [])
        return nil if visited.include?('AlternatePathHint')
        visited = visited + ['AlternatePathHint']
        {
          component_id: 'component_id',
          component_arn: 'component_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('componentId', stub[:component_id].to_s) unless stub[:component_id].nil?
        xml << Hearth::XML::Node.new('componentArn', stub[:component_arn].to_s) unless stub[:component_arn].nil?
        xml
      end
    end

    class AlternatePathHintList
      def self.default(visited = [])
        return nil if visited.include?('AlternatePathHintList')
        visited = visited + ['AlternatePathHintList']
        [
          AlternatePathHint.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AlternatePathHint.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AnalysisAclRule
      def self.default(visited = [])
        return nil if visited.include?('AnalysisAclRule')
        visited = visited + ['AnalysisAclRule']
        {
          cidr: 'cidr',
          egress: false,
          port_range: PortRange.default(visited),
          protocol: 'protocol',
          rule_action: 'rule_action',
          rule_number: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('egress', stub[:egress].to_s) unless stub[:egress].nil?
        xml << PortRange.stub('portRange', stub[:port_range]) unless stub[:port_range].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('ruleAction', stub[:rule_action].to_s) unless stub[:rule_action].nil?
        xml << Hearth::XML::Node.new('ruleNumber', stub[:rule_number].to_s) unless stub[:rule_number].nil?
        xml
      end
    end

    class AnalysisComponent
      def self.default(visited = [])
        return nil if visited.include?('AnalysisComponent')
        visited = visited + ['AnalysisComponent']
        {
          id: 'id',
          arn: 'arn',
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('id', stub[:id].to_s) unless stub[:id].nil?
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    class AnalysisComponentList
      def self.default(visited = [])
        return nil if visited.include?('AnalysisComponentList')
        visited = visited + ['AnalysisComponentList']
        [
          AnalysisComponent.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AnalysisComponent.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AnalysisLoadBalancerListener
      def self.default(visited = [])
        return nil if visited.include?('AnalysisLoadBalancerListener')
        visited = visited + ['AnalysisLoadBalancerListener']
        {
          load_balancer_port: 1,
          instance_port: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('loadBalancerPort', stub[:load_balancer_port].to_s) unless stub[:load_balancer_port].nil?
        xml << Hearth::XML::Node.new('instancePort', stub[:instance_port].to_s) unless stub[:instance_port].nil?
        xml
      end
    end

    class AnalysisLoadBalancerTarget
      def self.default(visited = [])
        return nil if visited.include?('AnalysisLoadBalancerTarget')
        visited = visited + ['AnalysisLoadBalancerTarget']
        {
          address: 'address',
          availability_zone: 'availability_zone',
          instance: AnalysisComponent.default(visited),
          port: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('address', stub[:address].to_s) unless stub[:address].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << AnalysisComponent.stub('instance', stub[:instance]) unless stub[:instance].nil?
        xml << Hearth::XML::Node.new('port', stub[:port].to_s) unless stub[:port].nil?
        xml
      end
    end

    class AnalysisPacketHeader
      def self.default(visited = [])
        return nil if visited.include?('AnalysisPacketHeader')
        visited = visited + ['AnalysisPacketHeader']
        {
          destination_addresses: IpAddressList.default(visited),
          destination_port_ranges: PortRangeList.default(visited),
          protocol: 'protocol',
          source_addresses: IpAddressList.default(visited),
          source_port_ranges: PortRangeList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationAddressSet', IpAddressList.stub('item', stub[:destination_addresses])) unless stub[:destination_addresses].nil?
        xml << Hearth::XML::Node.new('destinationPortRangeSet', PortRangeList.stub('item', stub[:destination_port_ranges])) unless stub[:destination_port_ranges].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('sourceAddressSet', IpAddressList.stub('item', stub[:source_addresses])) unless stub[:source_addresses].nil?
        xml << Hearth::XML::Node.new('sourcePortRangeSet', PortRangeList.stub('item', stub[:source_port_ranges])) unless stub[:source_port_ranges].nil?
        xml
      end
    end

    class AnalysisRouteTableRoute
      def self.default(visited = [])
        return nil if visited.include?('AnalysisRouteTableRoute')
        visited = visited + ['AnalysisRouteTableRoute']
        {
          destination_cidr: 'destination_cidr',
          destination_prefix_list_id: 'destination_prefix_list_id',
          egress_only_internet_gateway_id: 'egress_only_internet_gateway_id',
          gateway_id: 'gateway_id',
          instance_id: 'instance_id',
          nat_gateway_id: 'nat_gateway_id',
          network_interface_id: 'network_interface_id',
          origin: 'origin',
          transit_gateway_id: 'transit_gateway_id',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
          state: 'state',
          carrier_gateway_id: 'carrier_gateway_id',
          core_network_arn: 'core_network_arn',
          local_gateway_id: 'local_gateway_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidr', stub[:destination_cidr].to_s) unless stub[:destination_cidr].nil?
        xml << Hearth::XML::Node.new('destinationPrefixListId', stub[:destination_prefix_list_id].to_s) unless stub[:destination_prefix_list_id].nil?
        xml << Hearth::XML::Node.new('egressOnlyInternetGatewayId', stub[:egress_only_internet_gateway_id].to_s) unless stub[:egress_only_internet_gateway_id].nil?
        xml << Hearth::XML::Node.new('gatewayId', stub[:gateway_id].to_s) unless stub[:gateway_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('origin', stub[:origin].to_s) unless stub[:origin].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('carrierGatewayId', stub[:carrier_gateway_id].to_s) unless stub[:carrier_gateway_id].nil?
        xml << Hearth::XML::Node.new('coreNetworkArn', stub[:core_network_arn].to_s) unless stub[:core_network_arn].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml
      end
    end

    class AnalysisSecurityGroupRule
      def self.default(visited = [])
        return nil if visited.include?('AnalysisSecurityGroupRule')
        visited = visited + ['AnalysisSecurityGroupRule']
        {
          cidr: 'cidr',
          direction: 'direction',
          security_group_id: 'security_group_id',
          port_range: PortRange.default(visited),
          prefix_list_id: 'prefix_list_id',
          protocol: 'protocol',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('direction', stub[:direction].to_s) unless stub[:direction].nil?
        xml << Hearth::XML::Node.new('securityGroupId', stub[:security_group_id].to_s) unless stub[:security_group_id].nil?
        xml << PortRange.stub('portRange', stub[:port_range]) unless stub[:port_range].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml
      end
    end

    class ApplySecurityGroupsToClientVpnTargetNetwork
      def self.build(params, context:)
        Params::ApplySecurityGroupsToClientVpnTargetNetworkOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ApplySecurityGroupsToClientVpnTargetNetworkOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          security_group_ids: ClientVpnSecurityGroupIdSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ApplySecurityGroupsToClientVpnTargetNetworkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('securityGroupIds', ClientVpnSecurityGroupIdSet.stub('item', stub[:security_group_ids])) unless stub[:security_group_ids].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ArchitectureTypeList
      def self.default(visited = [])
        return nil if visited.include?('ArchitectureTypeList')
        visited = visited + ['ArchitectureTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class ArnList
      def self.default(visited = [])
        return nil if visited.include?('ArnList')
        visited = visited + ['ArnList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class AssignIpv6Addresses
      def self.build(params, context:)
        Params::AssignIpv6AddressesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssignIpv6AddressesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          assigned_ipv6_addresses: Ipv6AddressList.default(visited),
          assigned_ipv6_prefixes: IpPrefixList.default(visited),
          network_interface_id: 'network_interface_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssignIpv6AddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('assignedIpv6Addresses', Ipv6AddressList.stub('item', stub[:assigned_ipv6_addresses])) unless stub[:assigned_ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('assignedIpv6PrefixSet', IpPrefixList.stub('item', stub[:assigned_ipv6_prefixes])) unless stub[:assigned_ipv6_prefixes].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssignPrivateIpAddresses
      def self.build(params, context:)
        Params::AssignPrivateIpAddressesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssignPrivateIpAddressesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_interface_id: 'network_interface_id',
          assigned_private_ip_addresses: AssignedPrivateIpAddressList.default(visited),
          assigned_ipv4_prefixes: Ipv4PrefixesList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssignPrivateIpAddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('assignedPrivateIpAddressesSet', AssignedPrivateIpAddressList.stub('item', stub[:assigned_private_ip_addresses])) unless stub[:assigned_private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('assignedIpv4PrefixSet', Ipv4PrefixesList.stub('item', stub[:assigned_ipv4_prefixes])) unless stub[:assigned_ipv4_prefixes].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssignPrivateNatGatewayAddress
      def self.build(params, context:)
        Params::AssignPrivateNatGatewayAddressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssignPrivateNatGatewayAddressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          nat_gateway_id: 'nat_gateway_id',
          nat_gateway_addresses: NatGatewayAddressList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssignPrivateNatGatewayAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << Hearth::XML::Node.new('natGatewayAddressSet', NatGatewayAddressList.stub('item', stub[:nat_gateway_addresses])) unless stub[:nat_gateway_addresses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssignedPrivateIpAddress
      def self.default(visited = [])
        return nil if visited.include?('AssignedPrivateIpAddress')
        visited = visited + ['AssignedPrivateIpAddress']
        {
          private_ip_address: 'private_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml
      end
    end

    class AssignedPrivateIpAddressList
      def self.default(visited = [])
        return nil if visited.include?('AssignedPrivateIpAddressList')
        visited = visited + ['AssignedPrivateIpAddressList']
        [
          AssignedPrivateIpAddress.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AssignedPrivateIpAddress.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AssociateAddress
      def self.build(params, context:)
        Params::AssociateAddressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateAddressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          association_id: 'association_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateClientVpnTargetNetwork
      def self.build(params, context:)
        Params::AssociateClientVpnTargetNetworkOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateClientVpnTargetNetworkOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          association_id: 'association_id',
          status: AssociationStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateClientVpnTargetNetworkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << AssociationStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateDhcpOptions
      def self.build(params, context:)
        Params::AssociateDhcpOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateDhcpOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateDhcpOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateEnclaveCertificateIamRole
      def self.build(params, context:)
        Params::AssociateEnclaveCertificateIamRoleOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateEnclaveCertificateIamRoleOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          certificate_s3_bucket_name: 'certificate_s3_bucket_name',
          certificate_s3_object_key: 'certificate_s3_object_key',
          encryption_kms_key_id: 'encryption_kms_key_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateEnclaveCertificateIamRoleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('certificateS3BucketName', stub[:certificate_s3_bucket_name].to_s) unless stub[:certificate_s3_bucket_name].nil?
        xml << Hearth::XML::Node.new('certificateS3ObjectKey', stub[:certificate_s3_object_key].to_s) unless stub[:certificate_s3_object_key].nil?
        xml << Hearth::XML::Node.new('encryptionKmsKeyId', stub[:encryption_kms_key_id].to_s) unless stub[:encryption_kms_key_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateIamInstanceProfile
      def self.build(params, context:)
        Params::AssociateIamInstanceProfileOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateIamInstanceProfileOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          iam_instance_profile_association: IamInstanceProfileAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateIamInstanceProfileResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IamInstanceProfileAssociation.stub('iamInstanceProfileAssociation', stub[:iam_instance_profile_association]) unless stub[:iam_instance_profile_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateInstanceEventWindow
      def self.build(params, context:)
        Params::AssociateInstanceEventWindowOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateInstanceEventWindowOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_event_window: InstanceEventWindow.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindow.stub('instanceEventWindow', stub[:instance_event_window]) unless stub[:instance_event_window].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateIpamResourceDiscovery
      def self.build(params, context:)
        Params::AssociateIpamResourceDiscoveryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateIpamResourceDiscoveryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_resource_discovery_association: IpamResourceDiscoveryAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateIpamResourceDiscoveryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamResourceDiscoveryAssociation.stub('ipamResourceDiscoveryAssociation', stub[:ipam_resource_discovery_association]) unless stub[:ipam_resource_discovery_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateNatGatewayAddress
      def self.build(params, context:)
        Params::AssociateNatGatewayAddressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateNatGatewayAddressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          nat_gateway_id: 'nat_gateway_id',
          nat_gateway_addresses: NatGatewayAddressList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateNatGatewayAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << Hearth::XML::Node.new('natGatewayAddressSet', NatGatewayAddressList.stub('item', stub[:nat_gateway_addresses])) unless stub[:nat_gateway_addresses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateRouteTable
      def self.build(params, context:)
        Params::AssociateRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          association_id: 'association_id',
          association_state: RouteTableAssociationState.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << RouteTableAssociationState.stub('associationState', stub[:association_state]) unless stub[:association_state].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateSubnetCidrBlock
      def self.build(params, context:)
        Params::AssociateSubnetCidrBlockOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateSubnetCidrBlockOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.default(visited),
          subnet_id: 'subnet_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateSubnetCidrBlockResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SubnetIpv6CidrBlockAssociation.stub('ipv6CidrBlockAssociation', stub[:ipv6_cidr_block_association]) unless stub[:ipv6_cidr_block_association].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateTransitGatewayMulticastDomain
      def self.build(params, context:)
        Params::AssociateTransitGatewayMulticastDomainOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateTransitGatewayMulticastDomainOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          associations: TransitGatewayMulticastDomainAssociations.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateTransitGatewayMulticastDomainResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomainAssociations.stub('associations', stub[:associations]) unless stub[:associations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateTransitGatewayPolicyTable
      def self.build(params, context:)
        Params::AssociateTransitGatewayPolicyTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateTransitGatewayPolicyTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          association: TransitGatewayPolicyTableAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateTransitGatewayPolicyTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPolicyTableAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateTransitGatewayRouteTable
      def self.build(params, context:)
        Params::AssociateTransitGatewayRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateTransitGatewayRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          association: TransitGatewayAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateTransitGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateTrunkInterface
      def self.build(params, context:)
        Params::AssociateTrunkInterfaceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateTrunkInterfaceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          interface_association: TrunkInterfaceAssociation.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateTrunkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrunkInterfaceAssociation.stub('interfaceAssociation', stub[:interface_association]) unless stub[:interface_association].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociateVpcCidrBlock
      def self.build(params, context:)
        Params::AssociateVpcCidrBlockOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AssociateVpcCidrBlockOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.default(visited),
          cidr_block_association: VpcCidrBlockAssociation.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AssociateVpcCidrBlockResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcIpv6CidrBlockAssociation.stub('ipv6CidrBlockAssociation', stub[:ipv6_cidr_block_association]) unless stub[:ipv6_cidr_block_association].nil?
        xml << VpcCidrBlockAssociation.stub('cidrBlockAssociation', stub[:cidr_block_association]) unless stub[:cidr_block_association].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AssociatedRole
      def self.default(visited = [])
        return nil if visited.include?('AssociatedRole')
        visited = visited + ['AssociatedRole']
        {
          associated_role_arn: 'associated_role_arn',
          certificate_s3_bucket_name: 'certificate_s3_bucket_name',
          certificate_s3_object_key: 'certificate_s3_object_key',
          encryption_kms_key_id: 'encryption_kms_key_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associatedRoleArn', stub[:associated_role_arn].to_s) unless stub[:associated_role_arn].nil?
        xml << Hearth::XML::Node.new('certificateS3BucketName', stub[:certificate_s3_bucket_name].to_s) unless stub[:certificate_s3_bucket_name].nil?
        xml << Hearth::XML::Node.new('certificateS3ObjectKey', stub[:certificate_s3_object_key].to_s) unless stub[:certificate_s3_object_key].nil?
        xml << Hearth::XML::Node.new('encryptionKmsKeyId', stub[:encryption_kms_key_id].to_s) unless stub[:encryption_kms_key_id].nil?
        xml
      end
    end

    class AssociatedRolesList
      def self.default(visited = [])
        return nil if visited.include?('AssociatedRolesList')
        visited = visited + ['AssociatedRolesList']
        [
          AssociatedRole.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AssociatedRole.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AssociatedTargetNetwork
      def self.default(visited = [])
        return nil if visited.include?('AssociatedTargetNetwork')
        visited = visited + ['AssociatedTargetNetwork']
        {
          network_id: 'network_id',
          network_type: 'network_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkId', stub[:network_id].to_s) unless stub[:network_id].nil?
        xml << Hearth::XML::Node.new('networkType', stub[:network_type].to_s) unless stub[:network_type].nil?
        xml
      end
    end

    class AssociatedTargetNetworkSet
      def self.default(visited = [])
        return nil if visited.include?('AssociatedTargetNetworkSet')
        visited = visited + ['AssociatedTargetNetworkSet']
        [
          AssociatedTargetNetwork.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AssociatedTargetNetwork.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AssociationStatus
      def self.default(visited = [])
        return nil if visited.include?('AssociationStatus')
        visited = visited + ['AssociationStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class AttachClassicLinkVpc
      def self.build(params, context:)
        Params::AttachClassicLinkVpcOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AttachClassicLinkVpcOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachClassicLinkVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AttachInternetGateway
      def self.build(params, context:)
        Params::AttachInternetGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AttachInternetGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AttachNetworkInterface
      def self.build(params, context:)
        Params::AttachNetworkInterfaceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AttachNetworkInterfaceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          attachment_id: 'attachment_id',
          network_card_index: 1,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachNetworkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('attachmentId', stub[:attachment_id].to_s) unless stub[:attachment_id].nil?
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AttachVerifiedAccessTrustProvider
      def self.build(params, context:)
        Params::AttachVerifiedAccessTrustProviderOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AttachVerifiedAccessTrustProviderOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_trust_provider: VerifiedAccessTrustProvider.default(visited),
          verified_access_instance: VerifiedAccessInstance.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachVerifiedAccessTrustProviderResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessTrustProvider.stub('verifiedAccessTrustProvider', stub[:verified_access_trust_provider]) unless stub[:verified_access_trust_provider].nil?
        xml << VerifiedAccessInstance.stub('verifiedAccessInstance', stub[:verified_access_instance]) unless stub[:verified_access_instance].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AttachVolume
      def self.build(params, context:)
        Params::AttachVolumeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AttachVolumeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          attach_time: Time.now,
          device: 'device',
          instance_id: 'instance_id',
          state: 'state',
          volume_id: 'volume_id',
          delete_on_termination: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('device', stub[:device].to_s) unless stub[:device].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AttachVpnGateway
      def self.build(params, context:)
        Params::AttachVpnGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AttachVpnGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc_attachment: VpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AttachVpnGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcAttachment.stub('attachment', stub[:vpc_attachment]) unless stub[:vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AttachmentEnaSrdSpecification
      def self.default(visited = [])
        return nil if visited.include?('AttachmentEnaSrdSpecification')
        visited = visited + ['AttachmentEnaSrdSpecification']
        {
          ena_srd_enabled: false,
          ena_srd_udp_specification: AttachmentEnaSrdUdpSpecification.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enaSrdEnabled', stub[:ena_srd_enabled].to_s) unless stub[:ena_srd_enabled].nil?
        xml << AttachmentEnaSrdUdpSpecification.stub('enaSrdUdpSpecification', stub[:ena_srd_udp_specification]) unless stub[:ena_srd_udp_specification].nil?
        xml
      end
    end

    class AttachmentEnaSrdUdpSpecification
      def self.default(visited = [])
        return nil if visited.include?('AttachmentEnaSrdUdpSpecification')
        visited = visited + ['AttachmentEnaSrdUdpSpecification']
        {
          ena_srd_udp_enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enaSrdUdpEnabled', stub[:ena_srd_udp_enabled].to_s) unless stub[:ena_srd_udp_enabled].nil?
        xml
      end
    end

    class AttributeBooleanValue
      def self.default(visited = [])
        return nil if visited.include?('AttributeBooleanValue')
        visited = visited + ['AttributeBooleanValue']
        {
          value: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class AttributeValue
      def self.default(visited = [])
        return nil if visited.include?('AttributeValue')
        visited = visited + ['AttributeValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class AuthorizationRule
      def self.default(visited = [])
        return nil if visited.include?('AuthorizationRule')
        visited = visited + ['AuthorizationRule']
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          description: 'description',
          group_id: 'group_id',
          access_all: false,
          destination_cidr: 'destination_cidr',
          status: ClientVpnAuthorizationRuleStatus.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('accessAll', stub[:access_all].to_s) unless stub[:access_all].nil?
        xml << Hearth::XML::Node.new('destinationCidr', stub[:destination_cidr].to_s) unless stub[:destination_cidr].nil?
        xml << ClientVpnAuthorizationRuleStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml
      end
    end

    class AuthorizationRuleSet
      def self.default(visited = [])
        return nil if visited.include?('AuthorizationRuleSet')
        visited = visited + ['AuthorizationRuleSet']
        [
          AuthorizationRule.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AuthorizationRule.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AuthorizeClientVpnIngress
      def self.build(params, context:)
        Params::AuthorizeClientVpnIngressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AuthorizeClientVpnIngressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          status: ClientVpnAuthorizationRuleStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AuthorizeClientVpnIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnAuthorizationRuleStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AuthorizeSecurityGroupEgress
      def self.build(params, context:)
        Params::AuthorizeSecurityGroupEgressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AuthorizeSecurityGroupEgressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
          security_group_rules: SecurityGroupRuleList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AuthorizeSecurityGroupEgressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('securityGroupRuleSet', SecurityGroupRuleList.stub('item', stub[:security_group_rules])) unless stub[:security_group_rules].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AuthorizeSecurityGroupIngress
      def self.build(params, context:)
        Params::AuthorizeSecurityGroupIngressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::AuthorizeSecurityGroupIngressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
          security_group_rules: SecurityGroupRuleList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('AuthorizeSecurityGroupIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('securityGroupRuleSet', SecurityGroupRuleList.stub('item', stub[:security_group_rules])) unless stub[:security_group_rules].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class AvailabilityZone
      def self.default(visited = [])
        return nil if visited.include?('AvailabilityZone')
        visited = visited + ['AvailabilityZone']
        {
          state: 'state',
          opt_in_status: 'opt_in_status',
          messages: AvailabilityZoneMessageList.default(visited),
          region_name: 'region_name',
          zone_name: 'zone_name',
          zone_id: 'zone_id',
          group_name: 'group_name',
          network_border_group: 'network_border_group',
          zone_type: 'zone_type',
          parent_zone_name: 'parent_zone_name',
          parent_zone_id: 'parent_zone_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('zoneState', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('optInStatus', stub[:opt_in_status].to_s) unless stub[:opt_in_status].nil?
        xml << Hearth::XML::Node.new('messageSet', AvailabilityZoneMessageList.stub('item', stub[:messages])) unless stub[:messages].nil?
        xml << Hearth::XML::Node.new('regionName', stub[:region_name].to_s) unless stub[:region_name].nil?
        xml << Hearth::XML::Node.new('zoneName', stub[:zone_name].to_s) unless stub[:zone_name].nil?
        xml << Hearth::XML::Node.new('zoneId', stub[:zone_id].to_s) unless stub[:zone_id].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('zoneType', stub[:zone_type].to_s) unless stub[:zone_type].nil?
        xml << Hearth::XML::Node.new('parentZoneName', stub[:parent_zone_name].to_s) unless stub[:parent_zone_name].nil?
        xml << Hearth::XML::Node.new('parentZoneId', stub[:parent_zone_id].to_s) unless stub[:parent_zone_id].nil?
        xml
      end
    end

    class AvailabilityZoneList
      def self.default(visited = [])
        return nil if visited.include?('AvailabilityZoneList')
        visited = visited + ['AvailabilityZoneList']
        [
          AvailabilityZone.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AvailabilityZone.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AvailabilityZoneMessage
      def self.default(visited = [])
        return nil if visited.include?('AvailabilityZoneMessage')
        visited = visited + ['AvailabilityZoneMessage']
        {
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class AvailabilityZoneMessageList
      def self.default(visited = [])
        return nil if visited.include?('AvailabilityZoneMessageList')
        visited = visited + ['AvailabilityZoneMessageList']
        [
          AvailabilityZoneMessage.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AvailabilityZoneMessage.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class AvailableCapacity
      def self.default(visited = [])
        return nil if visited.include?('AvailableCapacity')
        visited = visited + ['AvailableCapacity']
        {
          available_instance_capacity: AvailableInstanceCapacityList.default(visited),
          available_v_cpus: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availableInstanceCapacity', AvailableInstanceCapacityList.stub('item', stub[:available_instance_capacity])) unless stub[:available_instance_capacity].nil?
        xml << Hearth::XML::Node.new('availableVCpus', stub[:available_v_cpus].to_s) unless stub[:available_v_cpus].nil?
        xml
      end
    end

    class AvailableInstanceCapacityList
      def self.default(visited = [])
        return nil if visited.include?('AvailableInstanceCapacityList')
        visited = visited + ['AvailableInstanceCapacityList']
        [
          InstanceCapacity.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceCapacity.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class BaselineEbsBandwidthMbps
      def self.default(visited = [])
        return nil if visited.include?('BaselineEbsBandwidthMbps')
        visited = visited + ['BaselineEbsBandwidthMbps']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    class BlockDeviceMapping
      def self.default(visited = [])
        return nil if visited.include?('BlockDeviceMapping')
        visited = visited + ['BlockDeviceMapping']
        {
          device_name: 'device_name',
          virtual_name: 'virtual_name',
          ebs: EbsBlockDevice.default(visited),
          no_device: 'no_device',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << Hearth::XML::Node.new('virtualName', stub[:virtual_name].to_s) unless stub[:virtual_name].nil?
        xml << EbsBlockDevice.stub('ebs', stub[:ebs]) unless stub[:ebs].nil?
        xml << Hearth::XML::Node.new('noDevice', stub[:no_device].to_s) unless stub[:no_device].nil?
        xml
      end
    end

    class BlockDeviceMappingList
      def self.default(visited = [])
        return nil if visited.include?('BlockDeviceMappingList')
        visited = visited + ['BlockDeviceMappingList']
        [
          BlockDeviceMapping.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << BlockDeviceMapping.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class BootModeTypeList
      def self.default(visited = [])
        return nil if visited.include?('BootModeTypeList')
        visited = visited + ['BootModeTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class BundleInstance
      def self.build(params, context:)
        Params::BundleInstanceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::BundleInstanceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          bundle_task: BundleTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('BundleInstanceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << BundleTask.stub('bundleInstanceTask', stub[:bundle_task]) unless stub[:bundle_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class BundleTask
      def self.default(visited = [])
        return nil if visited.include?('BundleTask')
        visited = visited + ['BundleTask']
        {
          bundle_id: 'bundle_id',
          bundle_task_error: BundleTaskError.default(visited),
          instance_id: 'instance_id',
          progress: 'progress',
          start_time: Time.now,
          state: 'state',
          storage: Storage.default(visited),
          update_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('bundleId', stub[:bundle_id].to_s) unless stub[:bundle_id].nil?
        xml << BundleTaskError.stub('error', stub[:bundle_task_error]) unless stub[:bundle_task_error].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Storage.stub('storage', stub[:storage]) unless stub[:storage].nil?
        xml << Hearth::XML::Node.new('updateTime', Hearth::TimeHelper.to_date_time(stub[:update_time])) unless stub[:update_time].nil?
        xml
      end
    end

    class BundleTaskError
      def self.default(visited = [])
        return nil if visited.include?('BundleTaskError')
        visited = visited + ['BundleTaskError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class BundleTaskList
      def self.default(visited = [])
        return nil if visited.include?('BundleTaskList')
        visited = visited + ['BundleTaskList']
        [
          BundleTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << BundleTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ByoipCidr
      def self.default(visited = [])
        return nil if visited.include?('ByoipCidr')
        visited = visited + ['ByoipCidr']
        {
          cidr: 'cidr',
          description: 'description',
          status_message: 'status_message',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class ByoipCidrSet
      def self.default(visited = [])
        return nil if visited.include?('ByoipCidrSet')
        visited = visited + ['ByoipCidrSet']
        [
          ByoipCidr.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ByoipCidr.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CancelBundleTask
      def self.build(params, context:)
        Params::CancelBundleTaskOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelBundleTaskOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          bundle_task: BundleTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelBundleTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << BundleTask.stub('bundleInstanceTask', stub[:bundle_task]) unless stub[:bundle_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelCapacityReservation
      def self.build(params, context:)
        Params::CancelCapacityReservationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelCapacityReservationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelCapacityReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelCapacityReservationFleetError
      def self.default(visited = [])
        return nil if visited.include?('CancelCapacityReservationFleetError')
        visited = visited + ['CancelCapacityReservationFleetError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class CancelCapacityReservationFleets
      def self.build(params, context:)
        Params::CancelCapacityReservationFleetsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelCapacityReservationFleetsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successful_fleet_cancellations: CapacityReservationFleetCancellationStateSet.default(visited),
          failed_fleet_cancellations: FailedCapacityReservationFleetCancellationResultSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelCapacityReservationFleetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulFleetCancellationSet', CapacityReservationFleetCancellationStateSet.stub('item', stub[:successful_fleet_cancellations])) unless stub[:successful_fleet_cancellations].nil?
        xml << Hearth::XML::Node.new('failedFleetCancellationSet', FailedCapacityReservationFleetCancellationResultSet.stub('item', stub[:failed_fleet_cancellations])) unless stub[:failed_fleet_cancellations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelConversionTask
      def self.build(params, context:)
        Params::CancelConversionTaskOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelConversionTaskOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelConversionTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelExportTask
      def self.build(params, context:)
        Params::CancelExportTaskOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelExportTaskOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelExportTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelImageLaunchPermission
      def self.build(params, context:)
        Params::CancelImageLaunchPermissionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelImageLaunchPermissionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelImageLaunchPermissionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelImportTask
      def self.build(params, context:)
        Params::CancelImportTaskOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelImportTaskOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          import_task_id: 'import_task_id',
          previous_state: 'previous_state',
          state: 'state',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelImportTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << Hearth::XML::Node.new('previousState', stub[:previous_state].to_s) unless stub[:previous_state].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelReservedInstancesListing
      def self.build(params, context:)
        Params::CancelReservedInstancesListingOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelReservedInstancesListingOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          reserved_instances_listings: ReservedInstancesListingList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelReservedInstancesListingResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesListingsSet', ReservedInstancesListingList.stub('item', stub[:reserved_instances_listings])) unless stub[:reserved_instances_listings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelSpotFleetRequests
      def self.build(params, context:)
        Params::CancelSpotFleetRequestsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelSpotFleetRequestsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successful_fleet_requests: CancelSpotFleetRequestsSuccessSet.default(visited),
          unsuccessful_fleet_requests: CancelSpotFleetRequestsErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelSpotFleetRequestsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulFleetRequestSet', CancelSpotFleetRequestsSuccessSet.stub('item', stub[:successful_fleet_requests])) unless stub[:successful_fleet_requests].nil?
        xml << Hearth::XML::Node.new('unsuccessfulFleetRequestSet', CancelSpotFleetRequestsErrorSet.stub('item', stub[:unsuccessful_fleet_requests])) unless stub[:unsuccessful_fleet_requests].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelSpotFleetRequestsError
      def self.default(visited = [])
        return nil if visited.include?('CancelSpotFleetRequestsError')
        visited = visited + ['CancelSpotFleetRequestsError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class CancelSpotFleetRequestsErrorItem
      def self.default(visited = [])
        return nil if visited.include?('CancelSpotFleetRequestsErrorItem')
        visited = visited + ['CancelSpotFleetRequestsErrorItem']
        {
          error: CancelSpotFleetRequestsError.default(visited),
          spot_fleet_request_id: 'spot_fleet_request_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << CancelSpotFleetRequestsError.stub('error', stub[:error]) unless stub[:error].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        xml
      end
    end

    class CancelSpotFleetRequestsErrorSet
      def self.default(visited = [])
        return nil if visited.include?('CancelSpotFleetRequestsErrorSet')
        visited = visited + ['CancelSpotFleetRequestsErrorSet']
        [
          CancelSpotFleetRequestsErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CancelSpotFleetRequestsErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CancelSpotFleetRequestsSuccessItem
      def self.default(visited = [])
        return nil if visited.include?('CancelSpotFleetRequestsSuccessItem')
        visited = visited + ['CancelSpotFleetRequestsSuccessItem']
        {
          current_spot_fleet_request_state: 'current_spot_fleet_request_state',
          previous_spot_fleet_request_state: 'previous_spot_fleet_request_state',
          spot_fleet_request_id: 'spot_fleet_request_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currentSpotFleetRequestState', stub[:current_spot_fleet_request_state].to_s) unless stub[:current_spot_fleet_request_state].nil?
        xml << Hearth::XML::Node.new('previousSpotFleetRequestState', stub[:previous_spot_fleet_request_state].to_s) unless stub[:previous_spot_fleet_request_state].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        xml
      end
    end

    class CancelSpotFleetRequestsSuccessSet
      def self.default(visited = [])
        return nil if visited.include?('CancelSpotFleetRequestsSuccessSet')
        visited = visited + ['CancelSpotFleetRequestsSuccessSet']
        [
          CancelSpotFleetRequestsSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CancelSpotFleetRequestsSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CancelSpotInstanceRequests
      def self.build(params, context:)
        Params::CancelSpotInstanceRequestsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CancelSpotInstanceRequestsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          cancelled_spot_instance_requests: CancelledSpotInstanceRequestList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CancelSpotInstanceRequestsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotInstanceRequestSet', CancelledSpotInstanceRequestList.stub('item', stub[:cancelled_spot_instance_requests])) unless stub[:cancelled_spot_instance_requests].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CancelledSpotInstanceRequest
      def self.default(visited = [])
        return nil if visited.include?('CancelledSpotInstanceRequest')
        visited = visited + ['CancelledSpotInstanceRequest']
        {
          spot_instance_request_id: 'spot_instance_request_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('spotInstanceRequestId', stub[:spot_instance_request_id].to_s) unless stub[:spot_instance_request_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class CancelledSpotInstanceRequestList
      def self.default(visited = [])
        return nil if visited.include?('CancelledSpotInstanceRequestList')
        visited = visited + ['CancelledSpotInstanceRequestList']
        [
          CancelledSpotInstanceRequest.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CancelledSpotInstanceRequest.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CapacityAllocation
      def self.default(visited = [])
        return nil if visited.include?('CapacityAllocation')
        visited = visited + ['CapacityAllocation']
        {
          allocation_type: 'allocation_type',
          count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationType', stub[:allocation_type].to_s) unless stub[:allocation_type].nil?
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml
      end
    end

    class CapacityAllocations
      def self.default(visited = [])
        return nil if visited.include?('CapacityAllocations')
        visited = visited + ['CapacityAllocations']
        [
          CapacityAllocation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CapacityAllocation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CapacityReservation
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservation')
        visited = visited + ['CapacityReservation']
        {
          capacity_reservation_id: 'capacity_reservation_id',
          owner_id: 'owner_id',
          capacity_reservation_arn: 'capacity_reservation_arn',
          availability_zone_id: 'availability_zone_id',
          instance_type: 'instance_type',
          instance_platform: 'instance_platform',
          availability_zone: 'availability_zone',
          tenancy: 'tenancy',
          total_instance_count: 1,
          available_instance_count: 1,
          ebs_optimized: false,
          ephemeral_storage: false,
          state: 'state',
          start_date: Time.now,
          end_date: Time.now,
          end_date_type: 'end_date_type',
          instance_match_criteria: 'instance_match_criteria',
          create_date: Time.now,
          tags: TagList.default(visited),
          outpost_arn: 'outpost_arn',
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
          placement_group_arn: 'placement_group_arn',
          capacity_allocations: CapacityAllocations.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('capacityReservationArn', stub[:capacity_reservation_arn].to_s) unless stub[:capacity_reservation_arn].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('instancePlatform', stub[:instance_platform].to_s) unless stub[:instance_platform].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('totalInstanceCount', stub[:total_instance_count].to_s) unless stub[:total_instance_count].nil?
        xml << Hearth::XML::Node.new('availableInstanceCount', stub[:available_instance_count].to_s) unless stub[:available_instance_count].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << Hearth::XML::Node.new('ephemeralStorage', stub[:ephemeral_storage].to_s) unless stub[:ephemeral_storage].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('startDate', Hearth::TimeHelper.to_date_time(stub[:start_date])) unless stub[:start_date].nil?
        xml << Hearth::XML::Node.new('endDate', Hearth::TimeHelper.to_date_time(stub[:end_date])) unless stub[:end_date].nil?
        xml << Hearth::XML::Node.new('endDateType', stub[:end_date_type].to_s) unless stub[:end_date_type].nil?
        xml << Hearth::XML::Node.new('instanceMatchCriteria', stub[:instance_match_criteria].to_s) unless stub[:instance_match_criteria].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml << Hearth::XML::Node.new('placementGroupArn', stub[:placement_group_arn].to_s) unless stub[:placement_group_arn].nil?
        xml << Hearth::XML::Node.new('capacityAllocationSet', CapacityAllocations.stub('item', stub[:capacity_allocations])) unless stub[:capacity_allocations].nil?
        xml
      end
    end

    class CapacityReservationFleet
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationFleet')
        visited = visited + ['CapacityReservationFleet']
        {
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
          capacity_reservation_fleet_arn: 'capacity_reservation_fleet_arn',
          state: 'state',
          total_target_capacity: 1,
          total_fulfilled_capacity: 1.0,
          tenancy: 'tenancy',
          end_date: Time.now,
          create_time: Time.now,
          instance_match_criteria: 'instance_match_criteria',
          allocation_strategy: 'allocation_strategy',
          instance_type_specifications: FleetCapacityReservationSet.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml << Hearth::XML::Node.new('capacityReservationFleetArn', stub[:capacity_reservation_fleet_arn].to_s) unless stub[:capacity_reservation_fleet_arn].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('totalTargetCapacity', stub[:total_target_capacity].to_s) unless stub[:total_target_capacity].nil?
        xml << Hearth::XML::Node.new('totalFulfilledCapacity', Hearth::NumberHelper.serialize(stub[:total_fulfilled_capacity]).to_s) unless stub[:total_fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('endDate', Hearth::TimeHelper.to_date_time(stub[:end_date])) unless stub[:end_date].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('instanceMatchCriteria', stub[:instance_match_criteria].to_s) unless stub[:instance_match_criteria].nil?
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << Hearth::XML::Node.new('instanceTypeSpecificationSet', FleetCapacityReservationSet.stub('item', stub[:instance_type_specifications])) unless stub[:instance_type_specifications].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class CapacityReservationFleetCancellationState
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationFleetCancellationState')
        visited = visited + ['CapacityReservationFleetCancellationState']
        {
          current_fleet_state: 'current_fleet_state',
          previous_fleet_state: 'previous_fleet_state',
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currentFleetState', stub[:current_fleet_state].to_s) unless stub[:current_fleet_state].nil?
        xml << Hearth::XML::Node.new('previousFleetState', stub[:previous_fleet_state].to_s) unless stub[:previous_fleet_state].nil?
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml
      end
    end

    class CapacityReservationFleetCancellationStateSet
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationFleetCancellationStateSet')
        visited = visited + ['CapacityReservationFleetCancellationStateSet']
        [
          CapacityReservationFleetCancellationState.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CapacityReservationFleetCancellationState.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CapacityReservationFleetSet
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationFleetSet')
        visited = visited + ['CapacityReservationFleetSet']
        [
          CapacityReservationFleet.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CapacityReservationFleet.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CapacityReservationGroup
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationGroup')
        visited = visited + ['CapacityReservationGroup']
        {
          group_arn: 'group_arn',
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupArn', stub[:group_arn].to_s) unless stub[:group_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    class CapacityReservationGroupSet
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationGroupSet')
        visited = visited + ['CapacityReservationGroupSet']
        [
          CapacityReservationGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CapacityReservationGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CapacityReservationOptions
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationOptions')
        visited = visited + ['CapacityReservationOptions']
        {
          usage_strategy: 'usage_strategy',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('usageStrategy', stub[:usage_strategy].to_s) unless stub[:usage_strategy].nil?
        xml
      end
    end

    class CapacityReservationSet
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationSet')
        visited = visited + ['CapacityReservationSet']
        [
          CapacityReservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CapacityReservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CapacityReservationSpecificationResponse
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationSpecificationResponse')
        visited = visited + ['CapacityReservationSpecificationResponse']
        {
          capacity_reservation_preference: 'capacity_reservation_preference',
          capacity_reservation_target: CapacityReservationTargetResponse.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationPreference', stub[:capacity_reservation_preference].to_s) unless stub[:capacity_reservation_preference].nil?
        xml << CapacityReservationTargetResponse.stub('capacityReservationTarget', stub[:capacity_reservation_target]) unless stub[:capacity_reservation_target].nil?
        xml
      end
    end

    class CapacityReservationTargetResponse
      def self.default(visited = [])
        return nil if visited.include?('CapacityReservationTargetResponse')
        visited = visited + ['CapacityReservationTargetResponse']
        {
          capacity_reservation_id: 'capacity_reservation_id',
          capacity_reservation_resource_group_arn: 'capacity_reservation_resource_group_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << Hearth::XML::Node.new('capacityReservationResourceGroupArn', stub[:capacity_reservation_resource_group_arn].to_s) unless stub[:capacity_reservation_resource_group_arn].nil?
        xml
      end
    end

    class CarrierGateway
      def self.default(visited = [])
        return nil if visited.include?('CarrierGateway')
        visited = visited + ['CarrierGateway']
        {
          carrier_gateway_id: 'carrier_gateway_id',
          vpc_id: 'vpc_id',
          state: 'state',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('carrierGatewayId', stub[:carrier_gateway_id].to_s) unless stub[:carrier_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class CarrierGatewaySet
      def self.default(visited = [])
        return nil if visited.include?('CarrierGatewaySet')
        visited = visited + ['CarrierGatewaySet']
        [
          CarrierGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CarrierGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CertificateAuthentication
      def self.default(visited = [])
        return nil if visited.include?('CertificateAuthentication')
        visited = visited + ['CertificateAuthentication']
        {
          client_root_certificate_chain: 'client_root_certificate_chain',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientRootCertificateChain', stub[:client_root_certificate_chain].to_s) unless stub[:client_root_certificate_chain].nil?
        xml
      end
    end

    class CidrBlock
      def self.default(visited = [])
        return nil if visited.include?('CidrBlock')
        visited = visited + ['CidrBlock']
        {
          cidr_block: 'cidr_block',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml
      end
    end

    class CidrBlockSet
      def self.default(visited = [])
        return nil if visited.include?('CidrBlockSet')
        visited = visited + ['CidrBlockSet']
        [
          CidrBlock.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CidrBlock.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ClassicLinkDnsSupport
      def self.default(visited = [])
        return nil if visited.include?('ClassicLinkDnsSupport')
        visited = visited + ['ClassicLinkDnsSupport']
        {
          classic_link_dns_supported: false,
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('classicLinkDnsSupported', stub[:classic_link_dns_supported].to_s) unless stub[:classic_link_dns_supported].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    class ClassicLinkDnsSupportList
      def self.default(visited = [])
        return nil if visited.include?('ClassicLinkDnsSupportList')
        visited = visited + ['ClassicLinkDnsSupportList']
        [
          ClassicLinkDnsSupport.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClassicLinkDnsSupport.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ClassicLinkInstance
      def self.default(visited = [])
        return nil if visited.include?('ClassicLinkInstance')
        visited = visited + ['ClassicLinkInstance']
        {
          groups: GroupIdentifierList.default(visited),
          instance_id: 'instance_id',
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    class ClassicLinkInstanceList
      def self.default(visited = [])
        return nil if visited.include?('ClassicLinkInstanceList')
        visited = visited + ['ClassicLinkInstanceList']
        [
          ClassicLinkInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClassicLinkInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ClassicLoadBalancer
      def self.default(visited = [])
        return nil if visited.include?('ClassicLoadBalancer')
        visited = visited + ['ClassicLoadBalancer']
        {
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    class ClassicLoadBalancers
      def self.default(visited = [])
        return nil if visited.include?('ClassicLoadBalancers')
        visited = visited + ['ClassicLoadBalancers']
        [
          ClassicLoadBalancer.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClassicLoadBalancer.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ClassicLoadBalancersConfig
      def self.default(visited = [])
        return nil if visited.include?('ClassicLoadBalancersConfig')
        visited = visited + ['ClassicLoadBalancersConfig']
        {
          classic_load_balancers: ClassicLoadBalancers.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('classicLoadBalancers', ClassicLoadBalancers.stub('item', stub[:classic_load_balancers])) unless stub[:classic_load_balancers].nil?
        xml
      end
    end

    class ClientCertificateRevocationListStatus
      def self.default(visited = [])
        return nil if visited.include?('ClientCertificateRevocationListStatus')
        visited = visited + ['ClientCertificateRevocationListStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class ClientConnectResponseOptions
      def self.default(visited = [])
        return nil if visited.include?('ClientConnectResponseOptions')
        visited = visited + ['ClientConnectResponseOptions']
        {
          enabled: false,
          lambda_function_arn: 'lambda_function_arn',
          status: ClientVpnEndpointAttributeStatus.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml << Hearth::XML::Node.new('lambdaFunctionArn', stub[:lambda_function_arn].to_s) unless stub[:lambda_function_arn].nil?
        xml << ClientVpnEndpointAttributeStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml
      end
    end

    class ClientLoginBannerResponseOptions
      def self.default(visited = [])
        return nil if visited.include?('ClientLoginBannerResponseOptions')
        visited = visited + ['ClientLoginBannerResponseOptions']
        {
          enabled: false,
          banner_text: 'banner_text',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml << Hearth::XML::Node.new('bannerText', stub[:banner_text].to_s) unless stub[:banner_text].nil?
        xml
      end
    end

    class ClientVpnAuthentication
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnAuthentication')
        visited = visited + ['ClientVpnAuthentication']
        {
          type: 'type',
          active_directory: DirectoryServiceAuthentication.default(visited),
          mutual_authentication: CertificateAuthentication.default(visited),
          federated_authentication: FederatedAuthentication.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << DirectoryServiceAuthentication.stub('activeDirectory', stub[:active_directory]) unless stub[:active_directory].nil?
        xml << CertificateAuthentication.stub('mutualAuthentication', stub[:mutual_authentication]) unless stub[:mutual_authentication].nil?
        xml << FederatedAuthentication.stub('federatedAuthentication', stub[:federated_authentication]) unless stub[:federated_authentication].nil?
        xml
      end
    end

    class ClientVpnAuthenticationList
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnAuthenticationList')
        visited = visited + ['ClientVpnAuthenticationList']
        [
          ClientVpnAuthentication.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClientVpnAuthentication.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ClientVpnAuthorizationRuleStatus
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnAuthorizationRuleStatus')
        visited = visited + ['ClientVpnAuthorizationRuleStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class ClientVpnConnection
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnConnection')
        visited = visited + ['ClientVpnConnection']
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          timestamp: 'timestamp',
          connection_id: 'connection_id',
          username: 'username',
          connection_established_time: 'connection_established_time',
          ingress_bytes: 'ingress_bytes',
          egress_bytes: 'egress_bytes',
          ingress_packets: 'ingress_packets',
          egress_packets: 'egress_packets',
          client_ip: 'client_ip',
          common_name: 'common_name',
          status: ClientVpnConnectionStatus.default(visited),
          connection_end_time: 'connection_end_time',
          posture_compliance_statuses: ValueStringList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('timestamp', stub[:timestamp].to_s) unless stub[:timestamp].nil?
        xml << Hearth::XML::Node.new('connectionId', stub[:connection_id].to_s) unless stub[:connection_id].nil?
        xml << Hearth::XML::Node.new('username', stub[:username].to_s) unless stub[:username].nil?
        xml << Hearth::XML::Node.new('connectionEstablishedTime', stub[:connection_established_time].to_s) unless stub[:connection_established_time].nil?
        xml << Hearth::XML::Node.new('ingressBytes', stub[:ingress_bytes].to_s) unless stub[:ingress_bytes].nil?
        xml << Hearth::XML::Node.new('egressBytes', stub[:egress_bytes].to_s) unless stub[:egress_bytes].nil?
        xml << Hearth::XML::Node.new('ingressPackets', stub[:ingress_packets].to_s) unless stub[:ingress_packets].nil?
        xml << Hearth::XML::Node.new('egressPackets', stub[:egress_packets].to_s) unless stub[:egress_packets].nil?
        xml << Hearth::XML::Node.new('clientIp', stub[:client_ip].to_s) unless stub[:client_ip].nil?
        xml << Hearth::XML::Node.new('commonName', stub[:common_name].to_s) unless stub[:common_name].nil?
        xml << ClientVpnConnectionStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('connectionEndTime', stub[:connection_end_time].to_s) unless stub[:connection_end_time].nil?
        xml << Hearth::XML::Node.new('postureComplianceStatusSet', ValueStringList.stub('item', stub[:posture_compliance_statuses])) unless stub[:posture_compliance_statuses].nil?
        xml
      end
    end

    class ClientVpnConnectionSet
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnConnectionSet')
        visited = visited + ['ClientVpnConnectionSet']
        [
          ClientVpnConnection.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClientVpnConnection.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ClientVpnConnectionStatus
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnConnectionStatus')
        visited = visited + ['ClientVpnConnectionStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class ClientVpnEndpoint
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnEndpoint')
        visited = visited + ['ClientVpnEndpoint']
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          description: 'description',
          status: ClientVpnEndpointStatus.default(visited),
          creation_time: 'creation_time',
          deletion_time: 'deletion_time',
          dns_name: 'dns_name',
          client_cidr_block: 'client_cidr_block',
          dns_servers: ValueStringList.default(visited),
          split_tunnel: false,
          vpn_protocol: 'vpn_protocol',
          transport_protocol: 'transport_protocol',
          vpn_port: 1,
          associated_target_networks: AssociatedTargetNetworkSet.default(visited),
          server_certificate_arn: 'server_certificate_arn',
          authentication_options: ClientVpnAuthenticationList.default(visited),
          connection_log_options: ConnectionLogResponseOptions.default(visited),
          tags: TagList.default(visited),
          security_group_ids: ClientVpnSecurityGroupIdSet.default(visited),
          vpc_id: 'vpc_id',
          self_service_portal_url: 'self_service_portal_url',
          client_connect_options: ClientConnectResponseOptions.default(visited),
          session_timeout_hours: 1,
          client_login_banner_options: ClientLoginBannerResponseOptions.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << ClientVpnEndpointStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('creationTime', stub[:creation_time].to_s) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('deletionTime', stub[:deletion_time].to_s) unless stub[:deletion_time].nil?
        xml << Hearth::XML::Node.new('dnsName', stub[:dns_name].to_s) unless stub[:dns_name].nil?
        xml << Hearth::XML::Node.new('clientCidrBlock', stub[:client_cidr_block].to_s) unless stub[:client_cidr_block].nil?
        xml << Hearth::XML::Node.new('dnsServer', ValueStringList.stub('item', stub[:dns_servers])) unless stub[:dns_servers].nil?
        xml << Hearth::XML::Node.new('splitTunnel', stub[:split_tunnel].to_s) unless stub[:split_tunnel].nil?
        xml << Hearth::XML::Node.new('vpnProtocol', stub[:vpn_protocol].to_s) unless stub[:vpn_protocol].nil?
        xml << Hearth::XML::Node.new('transportProtocol', stub[:transport_protocol].to_s) unless stub[:transport_protocol].nil?
        xml << Hearth::XML::Node.new('vpnPort', stub[:vpn_port].to_s) unless stub[:vpn_port].nil?
        xml << Hearth::XML::Node.new('associatedTargetNetwork', AssociatedTargetNetworkSet.stub('item', stub[:associated_target_networks])) unless stub[:associated_target_networks].nil?
        xml << Hearth::XML::Node.new('serverCertificateArn', stub[:server_certificate_arn].to_s) unless stub[:server_certificate_arn].nil?
        xml << Hearth::XML::Node.new('authenticationOptions', ClientVpnAuthenticationList.stub('item', stub[:authentication_options])) unless stub[:authentication_options].nil?
        xml << ConnectionLogResponseOptions.stub('connectionLogOptions', stub[:connection_log_options]) unless stub[:connection_log_options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('securityGroupIdSet', ClientVpnSecurityGroupIdSet.stub('item', stub[:security_group_ids])) unless stub[:security_group_ids].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('selfServicePortalUrl', stub[:self_service_portal_url].to_s) unless stub[:self_service_portal_url].nil?
        xml << ClientConnectResponseOptions.stub('clientConnectOptions', stub[:client_connect_options]) unless stub[:client_connect_options].nil?
        xml << Hearth::XML::Node.new('sessionTimeoutHours', stub[:session_timeout_hours].to_s) unless stub[:session_timeout_hours].nil?
        xml << ClientLoginBannerResponseOptions.stub('clientLoginBannerOptions', stub[:client_login_banner_options]) unless stub[:client_login_banner_options].nil?
        xml
      end
    end

    class ClientVpnEndpointAttributeStatus
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnEndpointAttributeStatus')
        visited = visited + ['ClientVpnEndpointAttributeStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class ClientVpnEndpointStatus
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnEndpointStatus')
        visited = visited + ['ClientVpnEndpointStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class ClientVpnRoute
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnRoute')
        visited = visited + ['ClientVpnRoute']
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          destination_cidr: 'destination_cidr',
          target_subnet: 'target_subnet',
          type: 'type',
          origin: 'origin',
          status: ClientVpnRouteStatus.default(visited),
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('destinationCidr', stub[:destination_cidr].to_s) unless stub[:destination_cidr].nil?
        xml << Hearth::XML::Node.new('targetSubnet', stub[:target_subnet].to_s) unless stub[:target_subnet].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('origin', stub[:origin].to_s) unless stub[:origin].nil?
        xml << ClientVpnRouteStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    class ClientVpnRouteSet
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnRouteSet')
        visited = visited + ['ClientVpnRouteSet']
        [
          ClientVpnRoute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClientVpnRoute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ClientVpnRouteStatus
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnRouteStatus')
        visited = visited + ['ClientVpnRouteStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class ClientVpnSecurityGroupIdSet
      def self.default(visited = [])
        return nil if visited.include?('ClientVpnSecurityGroupIdSet')
        visited = visited + ['ClientVpnSecurityGroupIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class CloudWatchLogOptions
      def self.default(visited = [])
        return nil if visited.include?('CloudWatchLogOptions')
        visited = visited + ['CloudWatchLogOptions']
        {
          log_enabled: false,
          log_group_arn: 'log_group_arn',
          log_output_format: 'log_output_format',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('logEnabled', stub[:log_enabled].to_s) unless stub[:log_enabled].nil?
        xml << Hearth::XML::Node.new('logGroupArn', stub[:log_group_arn].to_s) unless stub[:log_group_arn].nil?
        xml << Hearth::XML::Node.new('logOutputFormat', stub[:log_output_format].to_s) unless stub[:log_output_format].nil?
        xml
      end
    end

    class CoipAddressUsage
      def self.default(visited = [])
        return nil if visited.include?('CoipAddressUsage')
        visited = visited + ['CoipAddressUsage']
        {
          allocation_id: 'allocation_id',
          aws_account_id: 'aws_account_id',
          aws_service: 'aws_service',
          co_ip: 'co_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('awsAccountId', stub[:aws_account_id].to_s) unless stub[:aws_account_id].nil?
        xml << Hearth::XML::Node.new('awsService', stub[:aws_service].to_s) unless stub[:aws_service].nil?
        xml << Hearth::XML::Node.new('coIp', stub[:co_ip].to_s) unless stub[:co_ip].nil?
        xml
      end
    end

    class CoipAddressUsageSet
      def self.default(visited = [])
        return nil if visited.include?('CoipAddressUsageSet')
        visited = visited + ['CoipAddressUsageSet']
        [
          CoipAddressUsage.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CoipAddressUsage.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CoipCidr
      def self.default(visited = [])
        return nil if visited.include?('CoipCidr')
        visited = visited + ['CoipCidr']
        {
          cidr: 'cidr',
          coip_pool_id: 'coip_pool_id',
          local_gateway_route_table_id: 'local_gateway_route_table_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('coipPoolId', stub[:coip_pool_id].to_s) unless stub[:coip_pool_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml
      end
    end

    class CoipPool
      def self.default(visited = [])
        return nil if visited.include?('CoipPool')
        visited = visited + ['CoipPool']
        {
          pool_id: 'pool_id',
          pool_cidrs: ValueStringList.default(visited),
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          tags: TagList.default(visited),
          pool_arn: 'pool_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << Hearth::XML::Node.new('poolCidrSet', ValueStringList.stub('item', stub[:pool_cidrs])) unless stub[:pool_cidrs].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('poolArn', stub[:pool_arn].to_s) unless stub[:pool_arn].nil?
        xml
      end
    end

    class CoipPoolSet
      def self.default(visited = [])
        return nil if visited.include?('CoipPoolSet')
        visited = visited + ['CoipPoolSet']
        [
          CoipPool.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CoipPool.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ConfirmProductInstance
      def self.build(params, context:)
        Params::ConfirmProductInstanceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ConfirmProductInstanceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          owner_id: 'owner_id',
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ConfirmProductInstanceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ConnectionLogResponseOptions
      def self.default(visited = [])
        return nil if visited.include?('ConnectionLogResponseOptions')
        visited = visited + ['ConnectionLogResponseOptions']
        {
          enabled: false,
          cloudwatch_log_group: 'cloudwatch_log_group',
          cloudwatch_log_stream: 'cloudwatch_log_stream',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('Enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml << Hearth::XML::Node.new('CloudwatchLogGroup', stub[:cloudwatch_log_group].to_s) unless stub[:cloudwatch_log_group].nil?
        xml << Hearth::XML::Node.new('CloudwatchLogStream', stub[:cloudwatch_log_stream].to_s) unless stub[:cloudwatch_log_stream].nil?
        xml
      end
    end

    class ConnectionNotification
      def self.default(visited = [])
        return nil if visited.include?('ConnectionNotification')
        visited = visited + ['ConnectionNotification']
        {
          connection_notification_id: 'connection_notification_id',
          service_id: 'service_id',
          vpc_endpoint_id: 'vpc_endpoint_id',
          connection_notification_type: 'connection_notification_type',
          connection_notification_arn: 'connection_notification_arn',
          connection_events: ValueStringList.default(visited),
          connection_notification_state: 'connection_notification_state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('connectionNotificationId', stub[:connection_notification_id].to_s) unless stub[:connection_notification_id].nil?
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml << Hearth::XML::Node.new('vpcEndpointId', stub[:vpc_endpoint_id].to_s) unless stub[:vpc_endpoint_id].nil?
        xml << Hearth::XML::Node.new('connectionNotificationType', stub[:connection_notification_type].to_s) unless stub[:connection_notification_type].nil?
        xml << Hearth::XML::Node.new('connectionNotificationArn', stub[:connection_notification_arn].to_s) unless stub[:connection_notification_arn].nil?
        xml << Hearth::XML::Node.new('connectionEvents', ValueStringList.stub('item', stub[:connection_events])) unless stub[:connection_events].nil?
        xml << Hearth::XML::Node.new('connectionNotificationState', stub[:connection_notification_state].to_s) unless stub[:connection_notification_state].nil?
        xml
      end
    end

    class ConnectionNotificationSet
      def self.default(visited = [])
        return nil if visited.include?('ConnectionNotificationSet')
        visited = visited + ['ConnectionNotificationSet']
        [
          ConnectionNotification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ConnectionNotification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ConversionTask
      def self.default(visited = [])
        return nil if visited.include?('ConversionTask')
        visited = visited + ['ConversionTask']
        {
          conversion_task_id: 'conversion_task_id',
          expiration_time: 'expiration_time',
          import_instance: ImportInstanceTaskDetails.default(visited),
          import_volume: ImportVolumeTaskDetails.default(visited),
          state: 'state',
          status_message: 'status_message',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('conversionTaskId', stub[:conversion_task_id].to_s) unless stub[:conversion_task_id].nil?
        xml << Hearth::XML::Node.new('expirationTime', stub[:expiration_time].to_s) unless stub[:expiration_time].nil?
        xml << ImportInstanceTaskDetails.stub('importInstance', stub[:import_instance]) unless stub[:import_instance].nil?
        xml << ImportVolumeTaskDetails.stub('importVolume', stub[:import_volume]) unless stub[:import_volume].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class CopyFpgaImage
      def self.build(params, context:)
        Params::CopyFpgaImageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CopyFpgaImageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          fpga_image_id: 'fpga_image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CopyFpgaImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fpgaImageId', stub[:fpga_image_id].to_s) unless stub[:fpga_image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CopyImage
      def self.build(params, context:)
        Params::CopyImageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CopyImageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          image_id: 'image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CopyImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CopySnapshot
      def self.build(params, context:)
        Params::CopySnapshotOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CopySnapshotOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          snapshot_id: 'snapshot_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CopySnapshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CoreCountList
      def self.default(visited = [])
        return nil if visited.include?('CoreCountList')
        visited = visited + ['CoreCountList']
        [
          1
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class CpuManufacturerSet
      def self.default(visited = [])
        return nil if visited.include?('CpuManufacturerSet')
        visited = visited + ['CpuManufacturerSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class CpuOptions
      def self.default(visited = [])
        return nil if visited.include?('CpuOptions')
        visited = visited + ['CpuOptions']
        {
          core_count: 1,
          threads_per_core: 1,
          amd_sev_snp: 'amd_sev_snp',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('coreCount', stub[:core_count].to_s) unless stub[:core_count].nil?
        xml << Hearth::XML::Node.new('threadsPerCore', stub[:threads_per_core].to_s) unless stub[:threads_per_core].nil?
        xml << Hearth::XML::Node.new('amdSevSnp', stub[:amd_sev_snp].to_s) unless stub[:amd_sev_snp].nil?
        xml
      end
    end

    class CreateCapacityReservation
      def self.build(params, context:)
        Params::CreateCapacityReservationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateCapacityReservationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          capacity_reservation: CapacityReservation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCapacityReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CapacityReservation.stub('capacityReservation', stub[:capacity_reservation]) unless stub[:capacity_reservation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateCapacityReservationFleet
      def self.build(params, context:)
        Params::CreateCapacityReservationFleetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateCapacityReservationFleetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
          state: 'state',
          total_target_capacity: 1,
          total_fulfilled_capacity: 1.0,
          instance_match_criteria: 'instance_match_criteria',
          allocation_strategy: 'allocation_strategy',
          create_time: Time.now,
          end_date: Time.now,
          tenancy: 'tenancy',
          fleet_capacity_reservations: FleetCapacityReservationSet.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCapacityReservationFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('totalTargetCapacity', stub[:total_target_capacity].to_s) unless stub[:total_target_capacity].nil?
        xml << Hearth::XML::Node.new('totalFulfilledCapacity', Hearth::NumberHelper.serialize(stub[:total_fulfilled_capacity]).to_s) unless stub[:total_fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('instanceMatchCriteria', stub[:instance_match_criteria].to_s) unless stub[:instance_match_criteria].nil?
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('endDate', Hearth::TimeHelper.to_date_time(stub[:end_date])) unless stub[:end_date].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('fleetCapacityReservationSet', FleetCapacityReservationSet.stub('item', stub[:fleet_capacity_reservations])) unless stub[:fleet_capacity_reservations].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateCarrierGateway
      def self.build(params, context:)
        Params::CreateCarrierGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateCarrierGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          carrier_gateway: CarrierGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCarrierGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CarrierGateway.stub('carrierGateway', stub[:carrier_gateway]) unless stub[:carrier_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateClientVpnEndpoint
      def self.build(params, context:)
        Params::CreateClientVpnEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateClientVpnEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          status: ClientVpnEndpointStatus.default(visited),
          dns_name: 'dns_name',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateClientVpnEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << ClientVpnEndpointStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('dnsName', stub[:dns_name].to_s) unless stub[:dns_name].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateClientVpnRoute
      def self.build(params, context:)
        Params::CreateClientVpnRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateClientVpnRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          status: ClientVpnRouteStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateClientVpnRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnRouteStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateCoipCidr
      def self.build(params, context:)
        Params::CreateCoipCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateCoipCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          coip_cidr: CoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CoipCidr.stub('coipCidr', stub[:coip_cidr]) unless stub[:coip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateCoipPool
      def self.build(params, context:)
        Params::CreateCoipPoolOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateCoipPoolOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          coip_pool: CoipPool.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCoipPoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CoipPool.stub('coipPool', stub[:coip_pool]) unless stub[:coip_pool].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateCustomerGateway
      def self.build(params, context:)
        Params::CreateCustomerGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateCustomerGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          customer_gateway: CustomerGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateCustomerGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CustomerGateway.stub('customerGateway', stub[:customer_gateway]) unless stub[:customer_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateDefaultSubnet
      def self.build(params, context:)
        Params::CreateDefaultSubnetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateDefaultSubnetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          subnet: Subnet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateDefaultSubnetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Subnet.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateDefaultVpc
      def self.build(params, context:)
        Params::CreateDefaultVpcOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateDefaultVpcOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc: Vpc.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateDefaultVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Vpc.stub('vpc', stub[:vpc]) unless stub[:vpc].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateDhcpOptions
      def self.build(params, context:)
        Params::CreateDhcpOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateDhcpOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          dhcp_options: DhcpOptions.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateDhcpOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << DhcpOptions.stub('dhcpOptions', stub[:dhcp_options]) unless stub[:dhcp_options].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateEgressOnlyInternetGateway
      def self.build(params, context:)
        Params::CreateEgressOnlyInternetGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateEgressOnlyInternetGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          client_token: 'client_token',
          egress_only_internet_gateway: EgressOnlyInternetGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateEgressOnlyInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << EgressOnlyInternetGateway.stub('egressOnlyInternetGateway', stub[:egress_only_internet_gateway]) unless stub[:egress_only_internet_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateFleet
      def self.build(params, context:)
        Params::CreateFleetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateFleetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          fleet_id: 'fleet_id',
          errors: CreateFleetErrorsSet.default(visited),
          instances: CreateFleetInstancesSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml << Hearth::XML::Node.new('errorSet', CreateFleetErrorsSet.stub('item', stub[:errors])) unless stub[:errors].nil?
        xml << Hearth::XML::Node.new('fleetInstanceSet', CreateFleetInstancesSet.stub('item', stub[:instances])) unless stub[:instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateFleetError
      def self.default(visited = [])
        return nil if visited.include?('CreateFleetError')
        visited = visited + ['CreateFleetError']
        {
          launch_template_and_overrides: LaunchTemplateAndOverridesResponse.default(visited),
          lifecycle: 'lifecycle',
          error_code: 'error_code',
          error_message: 'error_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << LaunchTemplateAndOverridesResponse.stub('launchTemplateAndOverrides', stub[:launch_template_and_overrides]) unless stub[:launch_template_and_overrides].nil?
        xml << Hearth::XML::Node.new('lifecycle', stub[:lifecycle].to_s) unless stub[:lifecycle].nil?
        xml << Hearth::XML::Node.new('errorCode', stub[:error_code].to_s) unless stub[:error_code].nil?
        xml << Hearth::XML::Node.new('errorMessage', stub[:error_message].to_s) unless stub[:error_message].nil?
        xml
      end
    end

    class CreateFleetErrorsSet
      def self.default(visited = [])
        return nil if visited.include?('CreateFleetErrorsSet')
        visited = visited + ['CreateFleetErrorsSet']
        [
          CreateFleetError.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CreateFleetError.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CreateFleetInstance
      def self.default(visited = [])
        return nil if visited.include?('CreateFleetInstance')
        visited = visited + ['CreateFleetInstance']
        {
          launch_template_and_overrides: LaunchTemplateAndOverridesResponse.default(visited),
          lifecycle: 'lifecycle',
          instance_ids: InstanceIdsSet.default(visited),
          instance_type: 'instance_type',
          platform: 'platform',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << LaunchTemplateAndOverridesResponse.stub('launchTemplateAndOverrides', stub[:launch_template_and_overrides]) unless stub[:launch_template_and_overrides].nil?
        xml << Hearth::XML::Node.new('lifecycle', stub[:lifecycle].to_s) unless stub[:lifecycle].nil?
        xml << Hearth::XML::Node.new('instanceIds', InstanceIdsSet.stub('item', stub[:instance_ids])) unless stub[:instance_ids].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml
      end
    end

    class CreateFleetInstancesSet
      def self.default(visited = [])
        return nil if visited.include?('CreateFleetInstancesSet')
        visited = visited + ['CreateFleetInstancesSet']
        [
          CreateFleetInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CreateFleetInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CreateFlowLogs
      def self.build(params, context:)
        Params::CreateFlowLogsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateFlowLogsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          client_token: 'client_token',
          flow_log_ids: ValueStringList.default(visited),
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateFlowLogsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('flowLogIdSet', ValueStringList.stub('item', stub[:flow_log_ids])) unless stub[:flow_log_ids].nil?
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateFpgaImage
      def self.build(params, context:)
        Params::CreateFpgaImageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateFpgaImageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          fpga_image_id: 'fpga_image_id',
          fpga_image_global_id: 'fpga_image_global_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateFpgaImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fpgaImageId', stub[:fpga_image_id].to_s) unless stub[:fpga_image_id].nil?
        xml << Hearth::XML::Node.new('fpgaImageGlobalId', stub[:fpga_image_global_id].to_s) unless stub[:fpga_image_global_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateImage
      def self.build(params, context:)
        Params::CreateImageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateImageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          image_id: 'image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateInstanceConnectEndpoint
      def self.build(params, context:)
        Params::CreateInstanceConnectEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateInstanceConnectEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_connect_endpoint: Ec2InstanceConnectEndpoint.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateInstanceConnectEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Ec2InstanceConnectEndpoint.stub('instanceConnectEndpoint', stub[:instance_connect_endpoint]) unless stub[:instance_connect_endpoint].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateInstanceEventWindow
      def self.build(params, context:)
        Params::CreateInstanceEventWindowOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateInstanceEventWindowOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_event_window: InstanceEventWindow.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindow.stub('instanceEventWindow', stub[:instance_event_window]) unless stub[:instance_event_window].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateInstanceExportTask
      def self.build(params, context:)
        Params::CreateInstanceExportTaskOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateInstanceExportTaskOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          export_task: ExportTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateInstanceExportTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ExportTask.stub('exportTask', stub[:export_task]) unless stub[:export_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateInternetGateway
      def self.build(params, context:)
        Params::CreateInternetGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateInternetGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          internet_gateway: InternetGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InternetGateway.stub('internetGateway', stub[:internet_gateway]) unless stub[:internet_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateIpam
      def self.build(params, context:)
        Params::CreateIpamOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateIpamOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam: Ipam.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateIpamResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Ipam.stub('ipam', stub[:ipam]) unless stub[:ipam].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateIpamPool
      def self.build(params, context:)
        Params::CreateIpamPoolOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateIpamPoolOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_pool: IpamPool.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateIpamPoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPool.stub('ipamPool', stub[:ipam_pool]) unless stub[:ipam_pool].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateIpamResourceDiscovery
      def self.build(params, context:)
        Params::CreateIpamResourceDiscoveryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateIpamResourceDiscoveryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_resource_discovery: IpamResourceDiscovery.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateIpamResourceDiscoveryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamResourceDiscovery.stub('ipamResourceDiscovery', stub[:ipam_resource_discovery]) unless stub[:ipam_resource_discovery].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateIpamScope
      def self.build(params, context:)
        Params::CreateIpamScopeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateIpamScopeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_scope: IpamScope.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateIpamScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamScope.stub('ipamScope', stub[:ipam_scope]) unless stub[:ipam_scope].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateKeyPair
      def self.build(params, context:)
        Params::CreateKeyPairOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateKeyPairOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          key_fingerprint: 'key_fingerprint',
          key_material: 'key_material',
          key_name: 'key_name',
          key_pair_id: 'key_pair_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateKeyPairResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('keyFingerprint', stub[:key_fingerprint].to_s) unless stub[:key_fingerprint].nil?
        xml << Hearth::XML::Node.new('keyMaterial', stub[:key_material].to_s) unless stub[:key_material].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('keyPairId', stub[:key_pair_id].to_s) unless stub[:key_pair_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateLaunchTemplate
      def self.build(params, context:)
        Params::CreateLaunchTemplateOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateLaunchTemplateOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          launch_template: LaunchTemplate.default(visited),
          warning: ValidationWarning.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLaunchTemplateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LaunchTemplate.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        xml << ValidationWarning.stub('warning', stub[:warning]) unless stub[:warning].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateLaunchTemplateVersion
      def self.build(params, context:)
        Params::CreateLaunchTemplateVersionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateLaunchTemplateVersionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          launch_template_version: LaunchTemplateVersion.default(visited),
          warning: ValidationWarning.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLaunchTemplateVersionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LaunchTemplateVersion.stub('launchTemplateVersion', stub[:launch_template_version]) unless stub[:launch_template_version].nil?
        xml << ValidationWarning.stub('warning', stub[:warning]) unless stub[:warning].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateLocalGatewayRoute
      def self.build(params, context:)
        Params::CreateLocalGatewayRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateLocalGatewayRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          route: LocalGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLocalGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateLocalGatewayRouteTable
      def self.build(params, context:)
        Params::CreateLocalGatewayRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateLocalGatewayRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_route_table: LocalGatewayRouteTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLocalGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRouteTable.stub('localGatewayRouteTable', stub[:local_gateway_route_table]) unless stub[:local_gateway_route_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociation
      def self.build(params, context:)
        Params::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_route_table_virtual_interface_group_association: LocalGatewayRouteTableVirtualInterfaceGroupAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRouteTableVirtualInterfaceGroupAssociation.stub('localGatewayRouteTableVirtualInterfaceGroupAssociation', stub[:local_gateway_route_table_virtual_interface_group_association]) unless stub[:local_gateway_route_table_virtual_interface_group_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateLocalGatewayRouteTableVpcAssociation
      def self.build(params, context:)
        Params::CreateLocalGatewayRouteTableVpcAssociationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateLocalGatewayRouteTableVpcAssociationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_route_table_vpc_association: LocalGatewayRouteTableVpcAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateLocalGatewayRouteTableVpcAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRouteTableVpcAssociation.stub('localGatewayRouteTableVpcAssociation', stub[:local_gateway_route_table_vpc_association]) unless stub[:local_gateway_route_table_vpc_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateManagedPrefixList
      def self.build(params, context:)
        Params::CreateManagedPrefixListOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateManagedPrefixListOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          prefix_list: ManagedPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateManagedPrefixListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ManagedPrefixList.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateNatGateway
      def self.build(params, context:)
        Params::CreateNatGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateNatGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          client_token: 'client_token',
          nat_gateway: NatGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNatGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << NatGateway.stub('natGateway', stub[:nat_gateway]) unless stub[:nat_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateNetworkAcl
      def self.build(params, context:)
        Params::CreateNetworkAclOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateNetworkAclOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_acl: NetworkAcl.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkAclResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkAcl.stub('networkAcl', stub[:network_acl]) unless stub[:network_acl].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateNetworkAclEntry
      def self.build(params, context:)
        Params::CreateNetworkAclEntryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateNetworkAclEntryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkAclEntryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateNetworkInsightsAccessScope
      def self.build(params, context:)
        Params::CreateNetworkInsightsAccessScopeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateNetworkInsightsAccessScopeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_access_scope: NetworkInsightsAccessScope.default(visited),
          network_insights_access_scope_content: NetworkInsightsAccessScopeContent.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkInsightsAccessScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsAccessScope.stub('networkInsightsAccessScope', stub[:network_insights_access_scope]) unless stub[:network_insights_access_scope].nil?
        xml << NetworkInsightsAccessScopeContent.stub('networkInsightsAccessScopeContent', stub[:network_insights_access_scope_content]) unless stub[:network_insights_access_scope_content].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateNetworkInsightsPath
      def self.build(params, context:)
        Params::CreateNetworkInsightsPathOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateNetworkInsightsPathOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_path: NetworkInsightsPath.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkInsightsPathResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsPath.stub('networkInsightsPath', stub[:network_insights_path]) unless stub[:network_insights_path].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateNetworkInterface
      def self.build(params, context:)
        Params::CreateNetworkInterfaceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateNetworkInterfaceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_interface: NetworkInterface.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInterface.stub('networkInterface', stub[:network_interface]) unless stub[:network_interface].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateNetworkInterfacePermission
      def self.build(params, context:)
        Params::CreateNetworkInterfacePermissionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateNetworkInterfacePermissionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          interface_permission: NetworkInterfacePermission.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateNetworkInterfacePermissionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInterfacePermission.stub('interfacePermission', stub[:interface_permission]) unless stub[:interface_permission].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreatePlacementGroup
      def self.build(params, context:)
        Params::CreatePlacementGroupOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreatePlacementGroupOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          placement_group: PlacementGroup.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreatePlacementGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << PlacementGroup.stub('placementGroup', stub[:placement_group]) unless stub[:placement_group].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreatePublicIpv4Pool
      def self.build(params, context:)
        Params::CreatePublicIpv4PoolOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreatePublicIpv4PoolOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          pool_id: 'pool_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreatePublicIpv4PoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateReplaceRootVolumeTask
      def self.build(params, context:)
        Params::CreateReplaceRootVolumeTaskOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateReplaceRootVolumeTaskOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          replace_root_volume_task: ReplaceRootVolumeTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateReplaceRootVolumeTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ReplaceRootVolumeTask.stub('replaceRootVolumeTask', stub[:replace_root_volume_task]) unless stub[:replace_root_volume_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateReservedInstancesListing
      def self.build(params, context:)
        Params::CreateReservedInstancesListingOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateReservedInstancesListingOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          reserved_instances_listings: ReservedInstancesListingList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateReservedInstancesListingResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesListingsSet', ReservedInstancesListingList.stub('item', stub[:reserved_instances_listings])) unless stub[:reserved_instances_listings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateRestoreImageTask
      def self.build(params, context:)
        Params::CreateRestoreImageTaskOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateRestoreImageTaskOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          image_id: 'image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateRestoreImageTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateRoute
      def self.build(params, context:)
        Params::CreateRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateRouteTable
      def self.build(params, context:)
        Params::CreateRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          route_table: RouteTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << RouteTable.stub('routeTable', stub[:route_table]) unless stub[:route_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateSecurityGroup
      def self.build(params, context:)
        Params::CreateSecurityGroupOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateSecurityGroupOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          group_id: 'group_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSecurityGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateSnapshot
      def self.build(params, context:)
        Params::CreateSnapshotOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateSnapshotOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          data_encryption_key_id: 'data_encryption_key_id',
          description: 'description',
          encrypted: false,
          kms_key_id: 'kms_key_id',
          owner_id: 'owner_id',
          progress: 'progress',
          snapshot_id: 'snapshot_id',
          start_time: Time.now,
          state: 'state',
          state_message: 'state_message',
          volume_id: 'volume_id',
          volume_size: 1,
          owner_alias: 'owner_alias',
          outpost_arn: 'outpost_arn',
          tags: TagList.default(visited),
          storage_tier: 'storage_tier',
          restore_expiry_time: Time.now,
          sse_type: 'sse_type',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSnapshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('dataEncryptionKeyId', stub[:data_encryption_key_id].to_s) unless stub[:data_encryption_key_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:state_message].to_s) unless stub[:state_message].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('storageTier', stub[:storage_tier].to_s) unless stub[:storage_tier].nil?
        xml << Hearth::XML::Node.new('restoreExpiryTime', Hearth::TimeHelper.to_date_time(stub[:restore_expiry_time])) unless stub[:restore_expiry_time].nil?
        xml << Hearth::XML::Node.new('sseType', stub[:sse_type].to_s) unless stub[:sse_type].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateSnapshots
      def self.build(params, context:)
        Params::CreateSnapshotsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateSnapshotsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          snapshots: SnapshotSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSnapshotsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotSet', SnapshotSet.stub('item', stub[:snapshots])) unless stub[:snapshots].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateSpotDatafeedSubscription
      def self.build(params, context:)
        Params::CreateSpotDatafeedSubscriptionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateSpotDatafeedSubscriptionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          spot_datafeed_subscription: SpotDatafeedSubscription.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSpotDatafeedSubscriptionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SpotDatafeedSubscription.stub('spotDatafeedSubscription', stub[:spot_datafeed_subscription]) unless stub[:spot_datafeed_subscription].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateStoreImageTask
      def self.build(params, context:)
        Params::CreateStoreImageTaskOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateStoreImageTaskOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          object_key: 'object_key',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateStoreImageTaskResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('objectKey', stub[:object_key].to_s) unless stub[:object_key].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateSubnet
      def self.build(params, context:)
        Params::CreateSubnetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateSubnetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          subnet: Subnet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSubnetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Subnet.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateSubnetCidrReservation
      def self.build(params, context:)
        Params::CreateSubnetCidrReservationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateSubnetCidrReservationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          subnet_cidr_reservation: SubnetCidrReservation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateSubnetCidrReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SubnetCidrReservation.stub('subnetCidrReservation', stub[:subnet_cidr_reservation]) unless stub[:subnet_cidr_reservation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTags
      def self.build(params, context:)
        Params::CreateTagsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTagsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTagsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTrafficMirrorFilter
      def self.build(params, context:)
        Params::CreateTrafficMirrorFilterOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTrafficMirrorFilterOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_filter: TrafficMirrorFilter.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTrafficMirrorFilterResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorFilter.stub('trafficMirrorFilter', stub[:traffic_mirror_filter]) unless stub[:traffic_mirror_filter].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTrafficMirrorFilterRule
      def self.build(params, context:)
        Params::CreateTrafficMirrorFilterRuleOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTrafficMirrorFilterRuleOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_filter_rule: TrafficMirrorFilterRule.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTrafficMirrorFilterRuleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorFilterRule.stub('trafficMirrorFilterRule', stub[:traffic_mirror_filter_rule]) unless stub[:traffic_mirror_filter_rule].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTrafficMirrorSession
      def self.build(params, context:)
        Params::CreateTrafficMirrorSessionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTrafficMirrorSessionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_session: TrafficMirrorSession.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTrafficMirrorSessionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorSession.stub('trafficMirrorSession', stub[:traffic_mirror_session]) unless stub[:traffic_mirror_session].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTrafficMirrorTarget
      def self.build(params, context:)
        Params::CreateTrafficMirrorTargetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTrafficMirrorTargetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_target: TrafficMirrorTarget.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTrafficMirrorTargetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorTarget.stub('trafficMirrorTarget', stub[:traffic_mirror_target]) unless stub[:traffic_mirror_target].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGateway
      def self.build(params, context:)
        Params::CreateTransitGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway: TransitGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGateway.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayConnect
      def self.build(params, context:)
        Params::CreateTransitGatewayConnectOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayConnectOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_connect: TransitGatewayConnect.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayConnectResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayConnect.stub('transitGatewayConnect', stub[:transit_gateway_connect]) unless stub[:transit_gateway_connect].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayConnectPeer
      def self.build(params, context:)
        Params::CreateTransitGatewayConnectPeerOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayConnectPeerOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_connect_peer: TransitGatewayConnectPeer.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayConnectPeerResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayConnectPeer.stub('transitGatewayConnectPeer', stub[:transit_gateway_connect_peer]) unless stub[:transit_gateway_connect_peer].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayMulticastDomain
      def self.build(params, context:)
        Params::CreateTransitGatewayMulticastDomainOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayMulticastDomainOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_multicast_domain: TransitGatewayMulticastDomain.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayMulticastDomainResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomain.stub('transitGatewayMulticastDomain', stub[:transit_gateway_multicast_domain]) unless stub[:transit_gateway_multicast_domain].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayPeeringAttachment
      def self.build(params, context:)
        Params::CreateTransitGatewayPeeringAttachmentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayPeeringAttachmentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_peering_attachment: TransitGatewayPeeringAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayPeeringAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPeeringAttachment.stub('transitGatewayPeeringAttachment', stub[:transit_gateway_peering_attachment]) unless stub[:transit_gateway_peering_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayPolicyTable
      def self.build(params, context:)
        Params::CreateTransitGatewayPolicyTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayPolicyTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_policy_table: TransitGatewayPolicyTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayPolicyTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPolicyTable.stub('transitGatewayPolicyTable', stub[:transit_gateway_policy_table]) unless stub[:transit_gateway_policy_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayPrefixListReference
      def self.build(params, context:)
        Params::CreateTransitGatewayPrefixListReferenceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayPrefixListReferenceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_prefix_list_reference: TransitGatewayPrefixListReference.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayPrefixListReferenceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPrefixListReference.stub('transitGatewayPrefixListReference', stub[:transit_gateway_prefix_list_reference]) unless stub[:transit_gateway_prefix_list_reference].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayRoute
      def self.build(params, context:)
        Params::CreateTransitGatewayRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          route: TransitGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayRouteTable
      def self.build(params, context:)
        Params::CreateTransitGatewayRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_route_table: TransitGatewayRouteTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRouteTable.stub('transitGatewayRouteTable', stub[:transit_gateway_route_table]) unless stub[:transit_gateway_route_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayRouteTableAnnouncement
      def self.build(params, context:)
        Params::CreateTransitGatewayRouteTableAnnouncementOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayRouteTableAnnouncementOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_route_table_announcement: TransitGatewayRouteTableAnnouncement.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayRouteTableAnnouncementResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRouteTableAnnouncement.stub('transitGatewayRouteTableAnnouncement', stub[:transit_gateway_route_table_announcement]) unless stub[:transit_gateway_route_table_announcement].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateTransitGatewayVpcAttachment
      def self.build(params, context:)
        Params::CreateTransitGatewayVpcAttachmentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateTransitGatewayVpcAttachmentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVerifiedAccessEndpoint
      def self.build(params, context:)
        Params::CreateVerifiedAccessEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVerifiedAccessEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_endpoint: VerifiedAccessEndpoint.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVerifiedAccessEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessEndpoint.stub('verifiedAccessEndpoint', stub[:verified_access_endpoint]) unless stub[:verified_access_endpoint].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVerifiedAccessGroup
      def self.build(params, context:)
        Params::CreateVerifiedAccessGroupOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVerifiedAccessGroupOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_group: VerifiedAccessGroup.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVerifiedAccessGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessGroup.stub('verifiedAccessGroup', stub[:verified_access_group]) unless stub[:verified_access_group].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVerifiedAccessInstance
      def self.build(params, context:)
        Params::CreateVerifiedAccessInstanceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVerifiedAccessInstanceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_instance: VerifiedAccessInstance.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVerifiedAccessInstanceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessInstance.stub('verifiedAccessInstance', stub[:verified_access_instance]) unless stub[:verified_access_instance].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVerifiedAccessTrustProvider
      def self.build(params, context:)
        Params::CreateVerifiedAccessTrustProviderOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVerifiedAccessTrustProviderOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_trust_provider: VerifiedAccessTrustProvider.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVerifiedAccessTrustProviderResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessTrustProvider.stub('verifiedAccessTrustProvider', stub[:verified_access_trust_provider]) unless stub[:verified_access_trust_provider].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVolume
      def self.build(params, context:)
        Params::CreateVolumeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVolumeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          attachments: VolumeAttachmentList.default(visited),
          availability_zone: 'availability_zone',
          create_time: Time.now,
          encrypted: false,
          kms_key_id: 'kms_key_id',
          outpost_arn: 'outpost_arn',
          size: 1,
          snapshot_id: 'snapshot_id',
          state: 'state',
          volume_id: 'volume_id',
          iops: 1,
          tags: TagList.default(visited),
          volume_type: 'volume_type',
          fast_restored: false,
          multi_attach_enabled: false,
          throughput: 1,
          sse_type: 'sse_type',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('attachmentSet', VolumeAttachmentList.stub('item', stub[:attachments])) unless stub[:attachments].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('size', stub[:size].to_s) unless stub[:size].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('iops', stub[:iops].to_s) unless stub[:iops].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('volumeType', stub[:volume_type].to_s) unless stub[:volume_type].nil?
        xml << Hearth::XML::Node.new('fastRestored', stub[:fast_restored].to_s) unless stub[:fast_restored].nil?
        xml << Hearth::XML::Node.new('multiAttachEnabled', stub[:multi_attach_enabled].to_s) unless stub[:multi_attach_enabled].nil?
        xml << Hearth::XML::Node.new('throughput', stub[:throughput].to_s) unless stub[:throughput].nil?
        xml << Hearth::XML::Node.new('sseType', stub[:sse_type].to_s) unless stub[:sse_type].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVolumePermission
      def self.default(visited = [])
        return nil if visited.include?('CreateVolumePermission')
        visited = visited + ['CreateVolumePermission']
        {
          group: 'group',
          user_id: 'user_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('group', stub[:group].to_s) unless stub[:group].nil?
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml
      end
    end

    class CreateVolumePermissionList
      def self.default(visited = [])
        return nil if visited.include?('CreateVolumePermissionList')
        visited = visited + ['CreateVolumePermissionList']
        [
          CreateVolumePermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CreateVolumePermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class CreateVpc
      def self.build(params, context:)
        Params::CreateVpcOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVpcOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc: Vpc.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Vpc.stub('vpc', stub[:vpc]) unless stub[:vpc].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVpcEndpoint
      def self.build(params, context:)
        Params::CreateVpcEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVpcEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc_endpoint: VpcEndpoint.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcEndpoint.stub('vpcEndpoint', stub[:vpc_endpoint]) unless stub[:vpc_endpoint].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVpcEndpointConnectionNotification
      def self.build(params, context:)
        Params::CreateVpcEndpointConnectionNotificationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVpcEndpointConnectionNotificationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          connection_notification: ConnectionNotification.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcEndpointConnectionNotificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ConnectionNotification.stub('connectionNotification', stub[:connection_notification]) unless stub[:connection_notification].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVpcEndpointServiceConfiguration
      def self.build(params, context:)
        Params::CreateVpcEndpointServiceConfigurationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVpcEndpointServiceConfigurationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          service_configuration: ServiceConfiguration.default(visited),
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcEndpointServiceConfigurationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ServiceConfiguration.stub('serviceConfiguration', stub[:service_configuration]) unless stub[:service_configuration].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVpcPeeringConnection
      def self.build(params, context:)
        Params::CreateVpcPeeringConnectionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVpcPeeringConnectionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc_peering_connection: VpcPeeringConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpcPeeringConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcPeeringConnection.stub('vpcPeeringConnection', stub[:vpc_peering_connection]) unless stub[:vpc_peering_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVpnConnection
      def self.build(params, context:)
        Params::CreateVpnConnectionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVpnConnectionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpnConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVpnConnectionRoute
      def self.build(params, context:)
        Params::CreateVpnConnectionRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVpnConnectionRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpnConnectionRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreateVpnGateway
      def self.build(params, context:)
        Params::CreateVpnGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::CreateVpnGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_gateway: VpnGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('CreateVpnGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnGateway.stub('vpnGateway', stub[:vpn_gateway]) unless stub[:vpn_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class CreditSpecification
      def self.default(visited = [])
        return nil if visited.include?('CreditSpecification')
        visited = visited + ['CreditSpecification']
        {
          cpu_credits: 'cpu_credits',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cpuCredits', stub[:cpu_credits].to_s) unless stub[:cpu_credits].nil?
        xml
      end
    end

    class CustomerGateway
      def self.default(visited = [])
        return nil if visited.include?('CustomerGateway')
        visited = visited + ['CustomerGateway']
        {
          bgp_asn: 'bgp_asn',
          customer_gateway_id: 'customer_gateway_id',
          ip_address: 'ip_address',
          certificate_arn: 'certificate_arn',
          state: 'state',
          type: 'type',
          device_name: 'device_name',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('bgpAsn', stub[:bgp_asn].to_s) unless stub[:bgp_asn].nil?
        xml << Hearth::XML::Node.new('customerGatewayId', stub[:customer_gateway_id].to_s) unless stub[:customer_gateway_id].nil?
        xml << Hearth::XML::Node.new('ipAddress', stub[:ip_address].to_s) unless stub[:ip_address].nil?
        xml << Hearth::XML::Node.new('certificateArn', stub[:certificate_arn].to_s) unless stub[:certificate_arn].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class CustomerGatewayList
      def self.default(visited = [])
        return nil if visited.include?('CustomerGatewayList')
        visited = visited + ['CustomerGatewayList']
        [
          CustomerGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << CustomerGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DataResponse
      def self.default(visited = [])
        return nil if visited.include?('DataResponse')
        visited = visited + ['DataResponse']
        {
          id: 'id',
          source: 'source',
          destination: 'destination',
          metric: 'metric',
          statistic: 'statistic',
          period: 'period',
          metric_points: MetricPoints.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('id', stub[:id].to_s) unless stub[:id].nil?
        xml << Hearth::XML::Node.new('source', stub[:source].to_s) unless stub[:source].nil?
        xml << Hearth::XML::Node.new('destination', stub[:destination].to_s) unless stub[:destination].nil?
        xml << Hearth::XML::Node.new('metric', stub[:metric].to_s) unless stub[:metric].nil?
        xml << Hearth::XML::Node.new('statistic', stub[:statistic].to_s) unless stub[:statistic].nil?
        xml << Hearth::XML::Node.new('period', stub[:period].to_s) unless stub[:period].nil?
        xml << Hearth::XML::Node.new('metricPointSet', MetricPoints.stub('item', stub[:metric_points])) unless stub[:metric_points].nil?
        xml
      end
    end

    class DataResponses
      def self.default(visited = [])
        return nil if visited.include?('DataResponses')
        visited = visited + ['DataResponses']
        [
          DataResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DataResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DedicatedHostIdList
      def self.default(visited = [])
        return nil if visited.include?('DedicatedHostIdList')
        visited = visited + ['DedicatedHostIdList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class DeleteCarrierGateway
      def self.build(params, context:)
        Params::DeleteCarrierGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteCarrierGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          carrier_gateway: CarrierGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteCarrierGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CarrierGateway.stub('carrierGateway', stub[:carrier_gateway]) unless stub[:carrier_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteClientVpnEndpoint
      def self.build(params, context:)
        Params::DeleteClientVpnEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteClientVpnEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          status: ClientVpnEndpointStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteClientVpnEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnEndpointStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteClientVpnRoute
      def self.build(params, context:)
        Params::DeleteClientVpnRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteClientVpnRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          status: ClientVpnRouteStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteClientVpnRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnRouteStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteCoipCidr
      def self.build(params, context:)
        Params::DeleteCoipCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteCoipCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          coip_cidr: CoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteCoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CoipCidr.stub('coipCidr', stub[:coip_cidr]) unless stub[:coip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteCoipPool
      def self.build(params, context:)
        Params::DeleteCoipPoolOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteCoipPoolOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          coip_pool: CoipPool.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteCoipPoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << CoipPool.stub('coipPool', stub[:coip_pool]) unless stub[:coip_pool].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteCustomerGateway
      def self.build(params, context:)
        Params::DeleteCustomerGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteCustomerGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteCustomerGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteDhcpOptions
      def self.build(params, context:)
        Params::DeleteDhcpOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteDhcpOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteDhcpOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteEgressOnlyInternetGateway
      def self.build(params, context:)
        Params::DeleteEgressOnlyInternetGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteEgressOnlyInternetGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return_code: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteEgressOnlyInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('returnCode', stub[:return_code].to_s) unless stub[:return_code].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteFleetError
      def self.default(visited = [])
        return nil if visited.include?('DeleteFleetError')
        visited = visited + ['DeleteFleetError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class DeleteFleetErrorItem
      def self.default(visited = [])
        return nil if visited.include?('DeleteFleetErrorItem')
        visited = visited + ['DeleteFleetErrorItem']
        {
          error: DeleteFleetError.default(visited),
          fleet_id: 'fleet_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << DeleteFleetError.stub('error', stub[:error]) unless stub[:error].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml
      end
    end

    class DeleteFleetErrorSet
      def self.default(visited = [])
        return nil if visited.include?('DeleteFleetErrorSet')
        visited = visited + ['DeleteFleetErrorSet']
        [
          DeleteFleetErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DeleteFleetErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DeleteFleetSuccessItem
      def self.default(visited = [])
        return nil if visited.include?('DeleteFleetSuccessItem')
        visited = visited + ['DeleteFleetSuccessItem']
        {
          current_fleet_state: 'current_fleet_state',
          previous_fleet_state: 'previous_fleet_state',
          fleet_id: 'fleet_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currentFleetState', stub[:current_fleet_state].to_s) unless stub[:current_fleet_state].nil?
        xml << Hearth::XML::Node.new('previousFleetState', stub[:previous_fleet_state].to_s) unless stub[:previous_fleet_state].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml
      end
    end

    class DeleteFleetSuccessSet
      def self.default(visited = [])
        return nil if visited.include?('DeleteFleetSuccessSet')
        visited = visited + ['DeleteFleetSuccessSet']
        [
          DeleteFleetSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DeleteFleetSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DeleteFleets
      def self.build(params, context:)
        Params::DeleteFleetsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteFleetsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successful_fleet_deletions: DeleteFleetSuccessSet.default(visited),
          unsuccessful_fleet_deletions: DeleteFleetErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteFleetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulFleetDeletionSet', DeleteFleetSuccessSet.stub('item', stub[:successful_fleet_deletions])) unless stub[:successful_fleet_deletions].nil?
        xml << Hearth::XML::Node.new('unsuccessfulFleetDeletionSet', DeleteFleetErrorSet.stub('item', stub[:unsuccessful_fleet_deletions])) unless stub[:unsuccessful_fleet_deletions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteFlowLogs
      def self.build(params, context:)
        Params::DeleteFlowLogsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteFlowLogsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteFlowLogsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteFpgaImage
      def self.build(params, context:)
        Params::DeleteFpgaImageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteFpgaImageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteFpgaImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteInstanceConnectEndpoint
      def self.build(params, context:)
        Params::DeleteInstanceConnectEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteInstanceConnectEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_connect_endpoint: Ec2InstanceConnectEndpoint.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteInstanceConnectEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Ec2InstanceConnectEndpoint.stub('instanceConnectEndpoint', stub[:instance_connect_endpoint]) unless stub[:instance_connect_endpoint].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteInstanceEventWindow
      def self.build(params, context:)
        Params::DeleteInstanceEventWindowOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteInstanceEventWindowOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_event_window_state: InstanceEventWindowStateChange.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindowStateChange.stub('instanceEventWindowState', stub[:instance_event_window_state]) unless stub[:instance_event_window_state].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteInternetGateway
      def self.build(params, context:)
        Params::DeleteInternetGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteInternetGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteIpam
      def self.build(params, context:)
        Params::DeleteIpamOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteIpamOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam: Ipam.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteIpamResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Ipam.stub('ipam', stub[:ipam]) unless stub[:ipam].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteIpamPool
      def self.build(params, context:)
        Params::DeleteIpamPoolOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteIpamPoolOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_pool: IpamPool.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteIpamPoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPool.stub('ipamPool', stub[:ipam_pool]) unless stub[:ipam_pool].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteIpamResourceDiscovery
      def self.build(params, context:)
        Params::DeleteIpamResourceDiscoveryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteIpamResourceDiscoveryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_resource_discovery: IpamResourceDiscovery.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteIpamResourceDiscoveryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamResourceDiscovery.stub('ipamResourceDiscovery', stub[:ipam_resource_discovery]) unless stub[:ipam_resource_discovery].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteIpamScope
      def self.build(params, context:)
        Params::DeleteIpamScopeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteIpamScopeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_scope: IpamScope.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteIpamScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamScope.stub('ipamScope', stub[:ipam_scope]) unless stub[:ipam_scope].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteKeyPair
      def self.build(params, context:)
        Params::DeleteKeyPairOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteKeyPairOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteKeyPairResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteLaunchTemplate
      def self.build(params, context:)
        Params::DeleteLaunchTemplateOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteLaunchTemplateOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          launch_template: LaunchTemplate.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLaunchTemplateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LaunchTemplate.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteLaunchTemplateVersions
      def self.build(params, context:)
        Params::DeleteLaunchTemplateVersionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteLaunchTemplateVersionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successfully_deleted_launch_template_versions: DeleteLaunchTemplateVersionsResponseSuccessSet.default(visited),
          unsuccessfully_deleted_launch_template_versions: DeleteLaunchTemplateVersionsResponseErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLaunchTemplateVersionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfullyDeletedLaunchTemplateVersionSet', DeleteLaunchTemplateVersionsResponseSuccessSet.stub('item', stub[:successfully_deleted_launch_template_versions])) unless stub[:successfully_deleted_launch_template_versions].nil?
        xml << Hearth::XML::Node.new('unsuccessfullyDeletedLaunchTemplateVersionSet', DeleteLaunchTemplateVersionsResponseErrorSet.stub('item', stub[:unsuccessfully_deleted_launch_template_versions])) unless stub[:unsuccessfully_deleted_launch_template_versions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteLaunchTemplateVersionsResponseErrorItem
      def self.default(visited = [])
        return nil if visited.include?('DeleteLaunchTemplateVersionsResponseErrorItem')
        visited = visited + ['DeleteLaunchTemplateVersionsResponseErrorItem']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version_number: 1,
          response_error: ResponseError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('versionNumber', stub[:version_number].to_s) unless stub[:version_number].nil?
        xml << ResponseError.stub('responseError', stub[:response_error]) unless stub[:response_error].nil?
        xml
      end
    end

    class DeleteLaunchTemplateVersionsResponseErrorSet
      def self.default(visited = [])
        return nil if visited.include?('DeleteLaunchTemplateVersionsResponseErrorSet')
        visited = visited + ['DeleteLaunchTemplateVersionsResponseErrorSet']
        [
          DeleteLaunchTemplateVersionsResponseErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DeleteLaunchTemplateVersionsResponseErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DeleteLaunchTemplateVersionsResponseSuccessItem
      def self.default(visited = [])
        return nil if visited.include?('DeleteLaunchTemplateVersionsResponseSuccessItem')
        visited = visited + ['DeleteLaunchTemplateVersionsResponseSuccessItem']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version_number: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('versionNumber', stub[:version_number].to_s) unless stub[:version_number].nil?
        xml
      end
    end

    class DeleteLaunchTemplateVersionsResponseSuccessSet
      def self.default(visited = [])
        return nil if visited.include?('DeleteLaunchTemplateVersionsResponseSuccessSet')
        visited = visited + ['DeleteLaunchTemplateVersionsResponseSuccessSet']
        [
          DeleteLaunchTemplateVersionsResponseSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DeleteLaunchTemplateVersionsResponseSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DeleteLocalGatewayRoute
      def self.build(params, context:)
        Params::DeleteLocalGatewayRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteLocalGatewayRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          route: LocalGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLocalGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteLocalGatewayRouteTable
      def self.build(params, context:)
        Params::DeleteLocalGatewayRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteLocalGatewayRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_route_table: LocalGatewayRouteTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLocalGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRouteTable.stub('localGatewayRouteTable', stub[:local_gateway_route_table]) unless stub[:local_gateway_route_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociation
      def self.build(params, context:)
        Params::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_route_table_virtual_interface_group_association: LocalGatewayRouteTableVirtualInterfaceGroupAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRouteTableVirtualInterfaceGroupAssociation.stub('localGatewayRouteTableVirtualInterfaceGroupAssociation', stub[:local_gateway_route_table_virtual_interface_group_association]) unless stub[:local_gateway_route_table_virtual_interface_group_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteLocalGatewayRouteTableVpcAssociation
      def self.build(params, context:)
        Params::DeleteLocalGatewayRouteTableVpcAssociationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteLocalGatewayRouteTableVpcAssociationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_route_table_vpc_association: LocalGatewayRouteTableVpcAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteLocalGatewayRouteTableVpcAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRouteTableVpcAssociation.stub('localGatewayRouteTableVpcAssociation', stub[:local_gateway_route_table_vpc_association]) unless stub[:local_gateway_route_table_vpc_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteManagedPrefixList
      def self.build(params, context:)
        Params::DeleteManagedPrefixListOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteManagedPrefixListOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          prefix_list: ManagedPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteManagedPrefixListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ManagedPrefixList.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteNatGateway
      def self.build(params, context:)
        Params::DeleteNatGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteNatGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          nat_gateway_id: 'nat_gateway_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNatGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteNetworkAcl
      def self.build(params, context:)
        Params::DeleteNetworkAclOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteNetworkAclOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkAclResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteNetworkAclEntry
      def self.build(params, context:)
        Params::DeleteNetworkAclEntryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteNetworkAclEntryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkAclEntryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteNetworkInsightsAccessScope
      def self.build(params, context:)
        Params::DeleteNetworkInsightsAccessScopeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteNetworkInsightsAccessScopeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_access_scope_id: 'network_insights_access_scope_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInsightsAccessScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteNetworkInsightsAccessScopeAnalysis
      def self.build(params, context:)
        Params::DeleteNetworkInsightsAccessScopeAnalysisOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteNetworkInsightsAccessScopeAnalysisOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_access_scope_analysis_id: 'network_insights_access_scope_analysis_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInsightsAccessScopeAnalysisResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisId', stub[:network_insights_access_scope_analysis_id].to_s) unless stub[:network_insights_access_scope_analysis_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteNetworkInsightsAnalysis
      def self.build(params, context:)
        Params::DeleteNetworkInsightsAnalysisOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteNetworkInsightsAnalysisOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_analysis_id: 'network_insights_analysis_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInsightsAnalysisResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAnalysisId', stub[:network_insights_analysis_id].to_s) unless stub[:network_insights_analysis_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteNetworkInsightsPath
      def self.build(params, context:)
        Params::DeleteNetworkInsightsPathOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteNetworkInsightsPathOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_path_id: 'network_insights_path_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInsightsPathResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsPathId', stub[:network_insights_path_id].to_s) unless stub[:network_insights_path_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteNetworkInterface
      def self.build(params, context:)
        Params::DeleteNetworkInterfaceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteNetworkInterfaceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteNetworkInterfacePermission
      def self.build(params, context:)
        Params::DeleteNetworkInterfacePermissionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteNetworkInterfacePermissionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteNetworkInterfacePermissionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeletePlacementGroup
      def self.build(params, context:)
        Params::DeletePlacementGroupOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeletePlacementGroupOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeletePlacementGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeletePublicIpv4Pool
      def self.build(params, context:)
        Params::DeletePublicIpv4PoolOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeletePublicIpv4PoolOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeletePublicIpv4PoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('returnValue', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteQueuedReservedInstances
      def self.build(params, context:)
        Params::DeleteQueuedReservedInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteQueuedReservedInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successful_queued_purchase_deletions: SuccessfulQueuedPurchaseDeletionSet.default(visited),
          failed_queued_purchase_deletions: FailedQueuedPurchaseDeletionSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteQueuedReservedInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulQueuedPurchaseDeletionSet', SuccessfulQueuedPurchaseDeletionSet.stub('item', stub[:successful_queued_purchase_deletions])) unless stub[:successful_queued_purchase_deletions].nil?
        xml << Hearth::XML::Node.new('failedQueuedPurchaseDeletionSet', FailedQueuedPurchaseDeletionSet.stub('item', stub[:failed_queued_purchase_deletions])) unless stub[:failed_queued_purchase_deletions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteQueuedReservedInstancesError
      def self.default(visited = [])
        return nil if visited.include?('DeleteQueuedReservedInstancesError')
        visited = visited + ['DeleteQueuedReservedInstancesError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class DeleteRoute
      def self.build(params, context:)
        Params::DeleteRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteRouteTable
      def self.build(params, context:)
        Params::DeleteRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteSecurityGroup
      def self.build(params, context:)
        Params::DeleteSecurityGroupOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteSecurityGroupOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSecurityGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteSnapshot
      def self.build(params, context:)
        Params::DeleteSnapshotOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteSnapshotOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSnapshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteSpotDatafeedSubscription
      def self.build(params, context:)
        Params::DeleteSpotDatafeedSubscriptionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteSpotDatafeedSubscriptionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSpotDatafeedSubscriptionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteSubnet
      def self.build(params, context:)
        Params::DeleteSubnetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteSubnetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSubnetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteSubnetCidrReservation
      def self.build(params, context:)
        Params::DeleteSubnetCidrReservationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteSubnetCidrReservationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          deleted_subnet_cidr_reservation: SubnetCidrReservation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteSubnetCidrReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SubnetCidrReservation.stub('deletedSubnetCidrReservation', stub[:deleted_subnet_cidr_reservation]) unless stub[:deleted_subnet_cidr_reservation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTags
      def self.build(params, context:)
        Params::DeleteTagsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTagsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTagsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTrafficMirrorFilter
      def self.build(params, context:)
        Params::DeleteTrafficMirrorFilterOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTrafficMirrorFilterOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_filter_id: 'traffic_mirror_filter_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTrafficMirrorFilterResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorFilterId', stub[:traffic_mirror_filter_id].to_s) unless stub[:traffic_mirror_filter_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTrafficMirrorFilterRule
      def self.build(params, context:)
        Params::DeleteTrafficMirrorFilterRuleOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTrafficMirrorFilterRuleOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_filter_rule_id: 'traffic_mirror_filter_rule_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTrafficMirrorFilterRuleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorFilterRuleId', stub[:traffic_mirror_filter_rule_id].to_s) unless stub[:traffic_mirror_filter_rule_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTrafficMirrorSession
      def self.build(params, context:)
        Params::DeleteTrafficMirrorSessionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTrafficMirrorSessionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_session_id: 'traffic_mirror_session_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTrafficMirrorSessionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorSessionId', stub[:traffic_mirror_session_id].to_s) unless stub[:traffic_mirror_session_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTrafficMirrorTarget
      def self.build(params, context:)
        Params::DeleteTrafficMirrorTargetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTrafficMirrorTargetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_target_id: 'traffic_mirror_target_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTrafficMirrorTargetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorTargetId', stub[:traffic_mirror_target_id].to_s) unless stub[:traffic_mirror_target_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGateway
      def self.build(params, context:)
        Params::DeleteTransitGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway: TransitGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGateway.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayConnect
      def self.build(params, context:)
        Params::DeleteTransitGatewayConnectOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayConnectOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_connect: TransitGatewayConnect.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayConnectResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayConnect.stub('transitGatewayConnect', stub[:transit_gateway_connect]) unless stub[:transit_gateway_connect].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayConnectPeer
      def self.build(params, context:)
        Params::DeleteTransitGatewayConnectPeerOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayConnectPeerOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_connect_peer: TransitGatewayConnectPeer.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayConnectPeerResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayConnectPeer.stub('transitGatewayConnectPeer', stub[:transit_gateway_connect_peer]) unless stub[:transit_gateway_connect_peer].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayMulticastDomain
      def self.build(params, context:)
        Params::DeleteTransitGatewayMulticastDomainOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayMulticastDomainOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_multicast_domain: TransitGatewayMulticastDomain.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayMulticastDomainResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomain.stub('transitGatewayMulticastDomain', stub[:transit_gateway_multicast_domain]) unless stub[:transit_gateway_multicast_domain].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayPeeringAttachment
      def self.build(params, context:)
        Params::DeleteTransitGatewayPeeringAttachmentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayPeeringAttachmentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_peering_attachment: TransitGatewayPeeringAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayPeeringAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPeeringAttachment.stub('transitGatewayPeeringAttachment', stub[:transit_gateway_peering_attachment]) unless stub[:transit_gateway_peering_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayPolicyTable
      def self.build(params, context:)
        Params::DeleteTransitGatewayPolicyTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayPolicyTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_policy_table: TransitGatewayPolicyTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayPolicyTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPolicyTable.stub('transitGatewayPolicyTable', stub[:transit_gateway_policy_table]) unless stub[:transit_gateway_policy_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayPrefixListReference
      def self.build(params, context:)
        Params::DeleteTransitGatewayPrefixListReferenceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayPrefixListReferenceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_prefix_list_reference: TransitGatewayPrefixListReference.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayPrefixListReferenceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPrefixListReference.stub('transitGatewayPrefixListReference', stub[:transit_gateway_prefix_list_reference]) unless stub[:transit_gateway_prefix_list_reference].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayRoute
      def self.build(params, context:)
        Params::DeleteTransitGatewayRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          route: TransitGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayRouteTable
      def self.build(params, context:)
        Params::DeleteTransitGatewayRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_route_table: TransitGatewayRouteTable.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRouteTable.stub('transitGatewayRouteTable', stub[:transit_gateway_route_table]) unless stub[:transit_gateway_route_table].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayRouteTableAnnouncement
      def self.build(params, context:)
        Params::DeleteTransitGatewayRouteTableAnnouncementOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayRouteTableAnnouncementOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_route_table_announcement: TransitGatewayRouteTableAnnouncement.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayRouteTableAnnouncementResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRouteTableAnnouncement.stub('transitGatewayRouteTableAnnouncement', stub[:transit_gateway_route_table_announcement]) unless stub[:transit_gateway_route_table_announcement].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteTransitGatewayVpcAttachment
      def self.build(params, context:)
        Params::DeleteTransitGatewayVpcAttachmentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteTransitGatewayVpcAttachmentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVerifiedAccessEndpoint
      def self.build(params, context:)
        Params::DeleteVerifiedAccessEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVerifiedAccessEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_endpoint: VerifiedAccessEndpoint.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVerifiedAccessEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessEndpoint.stub('verifiedAccessEndpoint', stub[:verified_access_endpoint]) unless stub[:verified_access_endpoint].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVerifiedAccessGroup
      def self.build(params, context:)
        Params::DeleteVerifiedAccessGroupOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVerifiedAccessGroupOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_group: VerifiedAccessGroup.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVerifiedAccessGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessGroup.stub('verifiedAccessGroup', stub[:verified_access_group]) unless stub[:verified_access_group].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVerifiedAccessInstance
      def self.build(params, context:)
        Params::DeleteVerifiedAccessInstanceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVerifiedAccessInstanceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_instance: VerifiedAccessInstance.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVerifiedAccessInstanceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessInstance.stub('verifiedAccessInstance', stub[:verified_access_instance]) unless stub[:verified_access_instance].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVerifiedAccessTrustProvider
      def self.build(params, context:)
        Params::DeleteVerifiedAccessTrustProviderOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVerifiedAccessTrustProviderOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_trust_provider: VerifiedAccessTrustProvider.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVerifiedAccessTrustProviderResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessTrustProvider.stub('verifiedAccessTrustProvider', stub[:verified_access_trust_provider]) unless stub[:verified_access_trust_provider].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVolume
      def self.build(params, context:)
        Params::DeleteVolumeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVolumeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVpc
      def self.build(params, context:)
        Params::DeleteVpcOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVpcOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVpcEndpointConnectionNotifications
      def self.build(params, context:)
        Params::DeleteVpcEndpointConnectionNotificationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVpcEndpointConnectionNotificationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcEndpointConnectionNotificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVpcEndpointServiceConfigurations
      def self.build(params, context:)
        Params::DeleteVpcEndpointServiceConfigurationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVpcEndpointServiceConfigurationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcEndpointServiceConfigurationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVpcEndpoints
      def self.build(params, context:)
        Params::DeleteVpcEndpointsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVpcEndpointsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcEndpointsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVpcPeeringConnection
      def self.build(params, context:)
        Params::DeleteVpcPeeringConnectionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVpcPeeringConnectionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpcPeeringConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVpnConnection
      def self.build(params, context:)
        Params::DeleteVpnConnectionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVpnConnectionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpnConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVpnConnectionRoute
      def self.build(params, context:)
        Params::DeleteVpnConnectionRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVpnConnectionRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpnConnectionRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeleteVpnGateway
      def self.build(params, context:)
        Params::DeleteVpnGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeleteVpnGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeleteVpnGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeprovisionByoipCidr
      def self.build(params, context:)
        Params::DeprovisionByoipCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeprovisionByoipCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeprovisionByoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeprovisionIpamPoolCidr
      def self.build(params, context:)
        Params::DeprovisionIpamPoolCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeprovisionIpamPoolCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_pool_cidr: IpamPoolCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeprovisionIpamPoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPoolCidr.stub('ipamPoolCidr', stub[:ipam_pool_cidr]) unless stub[:ipam_pool_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeprovisionPublicIpv4PoolCidr
      def self.build(params, context:)
        Params::DeprovisionPublicIpv4PoolCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeprovisionPublicIpv4PoolCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          pool_id: 'pool_id',
          deprovisioned_addresses: DeprovisionedAddressSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeprovisionPublicIpv4PoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << Hearth::XML::Node.new('deprovisionedAddressSet', DeprovisionedAddressSet.stub('item', stub[:deprovisioned_addresses])) unless stub[:deprovisioned_addresses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeprovisionedAddressSet
      def self.default(visited = [])
        return nil if visited.include?('DeprovisionedAddressSet')
        visited = visited + ['DeprovisionedAddressSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class DeregisterImage
      def self.build(params, context:)
        Params::DeregisterImageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeregisterImageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeregisterImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeregisterInstanceEventNotificationAttributes
      def self.build(params, context:)
        Params::DeregisterInstanceEventNotificationAttributesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeregisterInstanceEventNotificationAttributesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_tag_attribute: InstanceTagNotificationAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeregisterInstanceEventNotificationAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceTagNotificationAttribute.stub('instanceTagAttribute', stub[:instance_tag_attribute]) unless stub[:instance_tag_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeregisterTransitGatewayMulticastGroupMembers
      def self.build(params, context:)
        Params::DeregisterTransitGatewayMulticastGroupMembersOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeregisterTransitGatewayMulticastGroupMembersOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          deregistered_multicast_group_members: TransitGatewayMulticastDeregisteredGroupMembers.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeregisterTransitGatewayMulticastGroupMembersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDeregisteredGroupMembers.stub('deregisteredMulticastGroupMembers', stub[:deregistered_multicast_group_members]) unless stub[:deregistered_multicast_group_members].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeregisterTransitGatewayMulticastGroupSources
      def self.build(params, context:)
        Params::DeregisterTransitGatewayMulticastGroupSourcesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DeregisterTransitGatewayMulticastGroupSourcesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          deregistered_multicast_group_sources: TransitGatewayMulticastDeregisteredGroupSources.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DeregisterTransitGatewayMulticastGroupSourcesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDeregisteredGroupSources.stub('deregisteredMulticastGroupSources', stub[:deregistered_multicast_group_sources]) unless stub[:deregistered_multicast_group_sources].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeAccountAttributes
      def self.build(params, context:)
        Params::DescribeAccountAttributesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeAccountAttributesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          account_attributes: AccountAttributeList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAccountAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('accountAttributeSet', AccountAttributeList.stub('item', stub[:account_attributes])) unless stub[:account_attributes].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeAddressTransfers
      def self.build(params, context:)
        Params::DescribeAddressTransfersOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeAddressTransfersOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          address_transfers: AddressTransferList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAddressTransfersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('addressTransferSet', AddressTransferList.stub('item', stub[:address_transfers])) unless stub[:address_transfers].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeAddresses
      def self.build(params, context:)
        Params::DescribeAddressesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeAddressesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          addresses: AddressList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('addressesSet', AddressList.stub('item', stub[:addresses])) unless stub[:addresses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeAddressesAttribute
      def self.build(params, context:)
        Params::DescribeAddressesAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeAddressesAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          addresses: AddressSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAddressesAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('addressSet', AddressSet.stub('item', stub[:addresses])) unless stub[:addresses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeAggregateIdFormat
      def self.build(params, context:)
        Params::DescribeAggregateIdFormatOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeAggregateIdFormatOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          use_long_ids_aggregated: false,
          statuses: IdFormatList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAggregateIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('useLongIdsAggregated', stub[:use_long_ids_aggregated].to_s) unless stub[:use_long_ids_aggregated].nil?
        xml << Hearth::XML::Node.new('statusSet', IdFormatList.stub('item', stub[:statuses])) unless stub[:statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeAvailabilityZones
      def self.build(params, context:)
        Params::DescribeAvailabilityZonesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeAvailabilityZonesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          availability_zones: AvailabilityZoneList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAvailabilityZonesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('availabilityZoneInfo', AvailabilityZoneList.stub('item', stub[:availability_zones])) unless stub[:availability_zones].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeAwsNetworkPerformanceMetricSubscriptions
      def self.build(params, context:)
        Params::DescribeAwsNetworkPerformanceMetricSubscriptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeAwsNetworkPerformanceMetricSubscriptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          subscriptions: SubscriptionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeAwsNetworkPerformanceMetricSubscriptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('subscriptionSet', SubscriptionList.stub('item', stub[:subscriptions])) unless stub[:subscriptions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeBundleTasks
      def self.build(params, context:)
        Params::DescribeBundleTasksOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeBundleTasksOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          bundle_tasks: BundleTaskList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeBundleTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('bundleInstanceTasksSet', BundleTaskList.stub('item', stub[:bundle_tasks])) unless stub[:bundle_tasks].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeByoipCidrs
      def self.build(params, context:)
        Params::DescribeByoipCidrsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeByoipCidrsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          byoip_cidrs: ByoipCidrSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeByoipCidrsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('byoipCidrSet', ByoipCidrSet.stub('item', stub[:byoip_cidrs])) unless stub[:byoip_cidrs].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeCapacityReservationFleets
      def self.build(params, context:)
        Params::DescribeCapacityReservationFleetsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeCapacityReservationFleetsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          capacity_reservation_fleets: CapacityReservationFleetSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCapacityReservationFleetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('capacityReservationFleetSet', CapacityReservationFleetSet.stub('item', stub[:capacity_reservation_fleets])) unless stub[:capacity_reservation_fleets].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeCapacityReservations
      def self.build(params, context:)
        Params::DescribeCapacityReservationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeCapacityReservationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          capacity_reservations: CapacityReservationSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCapacityReservationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('capacityReservationSet', CapacityReservationSet.stub('item', stub[:capacity_reservations])) unless stub[:capacity_reservations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeCarrierGateways
      def self.build(params, context:)
        Params::DescribeCarrierGatewaysOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeCarrierGatewaysOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          carrier_gateways: CarrierGatewaySet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCarrierGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('carrierGatewaySet', CarrierGatewaySet.stub('item', stub[:carrier_gateways])) unless stub[:carrier_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeClassicLinkInstances
      def self.build(params, context:)
        Params::DescribeClassicLinkInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeClassicLinkInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instances: ClassicLinkInstanceList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClassicLinkInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', ClassicLinkInstanceList.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeClientVpnAuthorizationRules
      def self.build(params, context:)
        Params::DescribeClientVpnAuthorizationRulesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeClientVpnAuthorizationRulesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          authorization_rules: AuthorizationRuleSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnAuthorizationRulesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('authorizationRule', AuthorizationRuleSet.stub('item', stub[:authorization_rules])) unless stub[:authorization_rules].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeClientVpnConnections
      def self.build(params, context:)
        Params::DescribeClientVpnConnectionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeClientVpnConnectionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          connections: ClientVpnConnectionSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('connections', ClientVpnConnectionSet.stub('item', stub[:connections])) unless stub[:connections].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeClientVpnEndpoints
      def self.build(params, context:)
        Params::DescribeClientVpnEndpointsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeClientVpnEndpointsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          client_vpn_endpoints: EndpointSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnEndpointsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientVpnEndpoint', EndpointSet.stub('item', stub[:client_vpn_endpoints])) unless stub[:client_vpn_endpoints].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeClientVpnRoutes
      def self.build(params, context:)
        Params::DescribeClientVpnRoutesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeClientVpnRoutesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          routes: ClientVpnRouteSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnRoutesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('routes', ClientVpnRouteSet.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeClientVpnTargetNetworks
      def self.build(params, context:)
        Params::DescribeClientVpnTargetNetworksOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeClientVpnTargetNetworksOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          client_vpn_target_networks: TargetNetworkSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeClientVpnTargetNetworksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientVpnTargetNetworks', TargetNetworkSet.stub('item', stub[:client_vpn_target_networks])) unless stub[:client_vpn_target_networks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeCoipPools
      def self.build(params, context:)
        Params::DescribeCoipPoolsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeCoipPoolsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          coip_pools: CoipPoolSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCoipPoolsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('coipPoolSet', CoipPoolSet.stub('item', stub[:coip_pools])) unless stub[:coip_pools].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeConversionTaskList
      def self.default(visited = [])
        return nil if visited.include?('DescribeConversionTaskList')
        visited = visited + ['DescribeConversionTaskList']
        [
          ConversionTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ConversionTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DescribeConversionTasks
      def self.build(params, context:)
        Params::DescribeConversionTasksOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeConversionTasksOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          conversion_tasks: DescribeConversionTaskList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeConversionTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('conversionTasks', DescribeConversionTaskList.stub('item', stub[:conversion_tasks])) unless stub[:conversion_tasks].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeCustomerGateways
      def self.build(params, context:)
        Params::DescribeCustomerGatewaysOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeCustomerGatewaysOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          customer_gateways: CustomerGatewayList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeCustomerGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('customerGatewaySet', CustomerGatewayList.stub('item', stub[:customer_gateways])) unless stub[:customer_gateways].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeDhcpOptions
      def self.build(params, context:)
        Params::DescribeDhcpOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeDhcpOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          dhcp_options: DhcpOptionsList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeDhcpOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('dhcpOptionsSet', DhcpOptionsList.stub('item', stub[:dhcp_options])) unless stub[:dhcp_options].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeEgressOnlyInternetGateways
      def self.build(params, context:)
        Params::DescribeEgressOnlyInternetGatewaysOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeEgressOnlyInternetGatewaysOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          egress_only_internet_gateways: EgressOnlyInternetGatewayList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeEgressOnlyInternetGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('egressOnlyInternetGatewaySet', EgressOnlyInternetGatewayList.stub('item', stub[:egress_only_internet_gateways])) unless stub[:egress_only_internet_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeElasticGpus
      def self.build(params, context:)
        Params::DescribeElasticGpusOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeElasticGpusOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          elastic_gpu_set: ElasticGpuSet.default(visited),
          max_results: 1,
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeElasticGpusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('elasticGpuSet', ElasticGpuSet.stub('item', stub[:elastic_gpu_set])) unless stub[:elastic_gpu_set].nil?
        xml << Hearth::XML::Node.new('maxResults', stub[:max_results].to_s) unless stub[:max_results].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeExportImageTasks
      def self.build(params, context:)
        Params::DescribeExportImageTasksOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeExportImageTasksOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          export_image_tasks: ExportImageTaskList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeExportImageTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('exportImageTaskSet', ExportImageTaskList.stub('item', stub[:export_image_tasks])) unless stub[:export_image_tasks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeExportTasks
      def self.build(params, context:)
        Params::DescribeExportTasksOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeExportTasksOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          export_tasks: ExportTaskList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeExportTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('exportTaskSet', ExportTaskList.stub('item', stub[:export_tasks])) unless stub[:export_tasks].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeFastLaunchImages
      def self.build(params, context:)
        Params::DescribeFastLaunchImagesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeFastLaunchImagesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          fast_launch_images: DescribeFastLaunchImagesSuccessSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFastLaunchImagesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fastLaunchImageSet', DescribeFastLaunchImagesSuccessSet.stub('item', stub[:fast_launch_images])) unless stub[:fast_launch_images].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeFastLaunchImagesSuccessItem
      def self.default(visited = [])
        return nil if visited.include?('DescribeFastLaunchImagesSuccessItem')
        visited = visited + ['DescribeFastLaunchImagesSuccessItem']
        {
          image_id: 'image_id',
          resource_type: 'resource_type',
          snapshot_configuration: FastLaunchSnapshotConfigurationResponse.default(visited),
          launch_template: FastLaunchLaunchTemplateSpecificationResponse.default(visited),
          max_parallel_launches: 1,
          owner_id: 'owner_id',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          state_transition_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << FastLaunchSnapshotConfigurationResponse.stub('snapshotConfiguration', stub[:snapshot_configuration]) unless stub[:snapshot_configuration].nil?
        xml << FastLaunchLaunchTemplateSpecificationResponse.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        xml << Hearth::XML::Node.new('maxParallelLaunches', stub[:max_parallel_launches].to_s) unless stub[:max_parallel_launches].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('stateTransitionTime', Hearth::TimeHelper.to_date_time(stub[:state_transition_time])) unless stub[:state_transition_time].nil?
        xml
      end
    end

    class DescribeFastLaunchImagesSuccessSet
      def self.default(visited = [])
        return nil if visited.include?('DescribeFastLaunchImagesSuccessSet')
        visited = visited + ['DescribeFastLaunchImagesSuccessSet']
        [
          DescribeFastLaunchImagesSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DescribeFastLaunchImagesSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DescribeFastSnapshotRestoreSuccessItem
      def self.default(visited = [])
        return nil if visited.include?('DescribeFastSnapshotRestoreSuccessItem')
        visited = visited + ['DescribeFastSnapshotRestoreSuccessItem']
        {
          snapshot_id: 'snapshot_id',
          availability_zone: 'availability_zone',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          owner_id: 'owner_id',
          owner_alias: 'owner_alias',
          enabling_time: Time.now,
          optimizing_time: Time.now,
          enabled_time: Time.now,
          disabling_time: Time.now,
          disabled_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('enablingTime', Hearth::TimeHelper.to_date_time(stub[:enabling_time])) unless stub[:enabling_time].nil?
        xml << Hearth::XML::Node.new('optimizingTime', Hearth::TimeHelper.to_date_time(stub[:optimizing_time])) unless stub[:optimizing_time].nil?
        xml << Hearth::XML::Node.new('enabledTime', Hearth::TimeHelper.to_date_time(stub[:enabled_time])) unless stub[:enabled_time].nil?
        xml << Hearth::XML::Node.new('disablingTime', Hearth::TimeHelper.to_date_time(stub[:disabling_time])) unless stub[:disabling_time].nil?
        xml << Hearth::XML::Node.new('disabledTime', Hearth::TimeHelper.to_date_time(stub[:disabled_time])) unless stub[:disabled_time].nil?
        xml
      end
    end

    class DescribeFastSnapshotRestoreSuccessSet
      def self.default(visited = [])
        return nil if visited.include?('DescribeFastSnapshotRestoreSuccessSet')
        visited = visited + ['DescribeFastSnapshotRestoreSuccessSet']
        [
          DescribeFastSnapshotRestoreSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DescribeFastSnapshotRestoreSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DescribeFastSnapshotRestores
      def self.build(params, context:)
        Params::DescribeFastSnapshotRestoresOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeFastSnapshotRestoresOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          fast_snapshot_restores: DescribeFastSnapshotRestoreSuccessSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFastSnapshotRestoresResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fastSnapshotRestoreSet', DescribeFastSnapshotRestoreSuccessSet.stub('item', stub[:fast_snapshot_restores])) unless stub[:fast_snapshot_restores].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeFleetError
      def self.default(visited = [])
        return nil if visited.include?('DescribeFleetError')
        visited = visited + ['DescribeFleetError']
        {
          launch_template_and_overrides: LaunchTemplateAndOverridesResponse.default(visited),
          lifecycle: 'lifecycle',
          error_code: 'error_code',
          error_message: 'error_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << LaunchTemplateAndOverridesResponse.stub('launchTemplateAndOverrides', stub[:launch_template_and_overrides]) unless stub[:launch_template_and_overrides].nil?
        xml << Hearth::XML::Node.new('lifecycle', stub[:lifecycle].to_s) unless stub[:lifecycle].nil?
        xml << Hearth::XML::Node.new('errorCode', stub[:error_code].to_s) unless stub[:error_code].nil?
        xml << Hearth::XML::Node.new('errorMessage', stub[:error_message].to_s) unless stub[:error_message].nil?
        xml
      end
    end

    class DescribeFleetHistory
      def self.build(params, context:)
        Params::DescribeFleetHistoryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeFleetHistoryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          history_records: HistoryRecordSet.default(visited),
          last_evaluated_time: Time.now,
          next_token: 'next_token',
          fleet_id: 'fleet_id',
          start_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFleetHistoryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('historyRecordSet', HistoryRecordSet.stub('item', stub[:history_records])) unless stub[:history_records].nil?
        xml << Hearth::XML::Node.new('lastEvaluatedTime', Hearth::TimeHelper.to_date_time(stub[:last_evaluated_time])) unless stub[:last_evaluated_time].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeFleetInstances
      def self.build(params, context:)
        Params::DescribeFleetInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeFleetInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          active_instances: ActiveInstanceSet.default(visited),
          next_token: 'next_token',
          fleet_id: 'fleet_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFleetInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('activeInstanceSet', ActiveInstanceSet.stub('item', stub[:active_instances])) unless stub[:active_instances].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeFleets
      def self.build(params, context:)
        Params::DescribeFleetsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeFleetsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          fleets: FleetSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFleetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('fleetSet', FleetSet.stub('item', stub[:fleets])) unless stub[:fleets].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeFleetsErrorSet
      def self.default(visited = [])
        return nil if visited.include?('DescribeFleetsErrorSet')
        visited = visited + ['DescribeFleetsErrorSet']
        [
          DescribeFleetError.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DescribeFleetError.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DescribeFleetsInstances
      def self.default(visited = [])
        return nil if visited.include?('DescribeFleetsInstances')
        visited = visited + ['DescribeFleetsInstances']
        {
          launch_template_and_overrides: LaunchTemplateAndOverridesResponse.default(visited),
          lifecycle: 'lifecycle',
          instance_ids: InstanceIdsSet.default(visited),
          instance_type: 'instance_type',
          platform: 'platform',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << LaunchTemplateAndOverridesResponse.stub('launchTemplateAndOverrides', stub[:launch_template_and_overrides]) unless stub[:launch_template_and_overrides].nil?
        xml << Hearth::XML::Node.new('lifecycle', stub[:lifecycle].to_s) unless stub[:lifecycle].nil?
        xml << Hearth::XML::Node.new('instanceIds', InstanceIdsSet.stub('item', stub[:instance_ids])) unless stub[:instance_ids].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml
      end
    end

    class DescribeFleetsInstancesSet
      def self.default(visited = [])
        return nil if visited.include?('DescribeFleetsInstancesSet')
        visited = visited + ['DescribeFleetsInstancesSet']
        [
          DescribeFleetsInstances.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DescribeFleetsInstances.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DescribeFlowLogs
      def self.build(params, context:)
        Params::DescribeFlowLogsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeFlowLogsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          flow_logs: FlowLogSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFlowLogsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('flowLogSet', FlowLogSet.stub('item', stub[:flow_logs])) unless stub[:flow_logs].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeFpgaImageAttribute
      def self.build(params, context:)
        Params::DescribeFpgaImageAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeFpgaImageAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          fpga_image_attribute: FpgaImageAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFpgaImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << FpgaImageAttribute.stub('fpgaImageAttribute', stub[:fpga_image_attribute]) unless stub[:fpga_image_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeFpgaImages
      def self.build(params, context:)
        Params::DescribeFpgaImagesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeFpgaImagesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          fpga_images: FpgaImageList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeFpgaImagesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('fpgaImageSet', FpgaImageList.stub('item', stub[:fpga_images])) unless stub[:fpga_images].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeHostReservationOfferings
      def self.build(params, context:)
        Params::DescribeHostReservationOfferingsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeHostReservationOfferingsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          offering_set: HostOfferingSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeHostReservationOfferingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('offeringSet', HostOfferingSet.stub('item', stub[:offering_set])) unless stub[:offering_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeHostReservations
      def self.build(params, context:)
        Params::DescribeHostReservationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeHostReservationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          host_reservation_set: HostReservationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeHostReservationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('hostReservationSet', HostReservationSet.stub('item', stub[:host_reservation_set])) unless stub[:host_reservation_set].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeHosts
      def self.build(params, context:)
        Params::DescribeHostsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeHostsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          hosts: HostList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeHostsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('hostSet', HostList.stub('item', stub[:hosts])) unless stub[:hosts].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeIamInstanceProfileAssociations
      def self.build(params, context:)
        Params::DescribeIamInstanceProfileAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeIamInstanceProfileAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          iam_instance_profile_associations: IamInstanceProfileAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIamInstanceProfileAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('iamInstanceProfileAssociationSet', IamInstanceProfileAssociationSet.stub('item', stub[:iam_instance_profile_associations])) unless stub[:iam_instance_profile_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeIdFormat
      def self.build(params, context:)
        Params::DescribeIdFormatOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeIdFormatOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          statuses: IdFormatList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('statusSet', IdFormatList.stub('item', stub[:statuses])) unless stub[:statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeIdentityIdFormat
      def self.build(params, context:)
        Params::DescribeIdentityIdFormatOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeIdentityIdFormatOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          statuses: IdFormatList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIdentityIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('statusSet', IdFormatList.stub('item', stub[:statuses])) unless stub[:statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeImageAttribute
      def self.build(params, context:)
        Params::DescribeImageAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeImageAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          block_device_mappings: BlockDeviceMappingList.default(visited),
          image_id: 'image_id',
          launch_permissions: LaunchPermissionList.default(visited),
          product_codes: ProductCodeList.default(visited),
          description: AttributeValue.default(visited),
          kernel_id: AttributeValue.default(visited),
          ramdisk_id: AttributeValue.default(visited),
          sriov_net_support: AttributeValue.default(visited),
          boot_mode: AttributeValue.default(visited),
          tpm_support: AttributeValue.default(visited),
          uefi_data: AttributeValue.default(visited),
          last_launched_time: AttributeValue.default(visited),
          imds_support: AttributeValue.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('blockDeviceMapping', BlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('launchPermission', LaunchPermissionList.stub('item', stub[:launch_permissions])) unless stub[:launch_permissions].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << AttributeValue.stub('description', stub[:description]) unless stub[:description].nil?
        xml << AttributeValue.stub('kernel', stub[:kernel_id]) unless stub[:kernel_id].nil?
        xml << AttributeValue.stub('ramdisk', stub[:ramdisk_id]) unless stub[:ramdisk_id].nil?
        xml << AttributeValue.stub('sriovNetSupport', stub[:sriov_net_support]) unless stub[:sriov_net_support].nil?
        xml << AttributeValue.stub('bootMode', stub[:boot_mode]) unless stub[:boot_mode].nil?
        xml << AttributeValue.stub('tpmSupport', stub[:tpm_support]) unless stub[:tpm_support].nil?
        xml << AttributeValue.stub('uefiData', stub[:uefi_data]) unless stub[:uefi_data].nil?
        xml << AttributeValue.stub('lastLaunchedTime', stub[:last_launched_time]) unless stub[:last_launched_time].nil?
        xml << AttributeValue.stub('imdsSupport', stub[:imds_support]) unless stub[:imds_support].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeImages
      def self.build(params, context:)
        Params::DescribeImagesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeImagesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          images: ImageList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeImagesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imagesSet', ImageList.stub('item', stub[:images])) unless stub[:images].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeImportImageTasks
      def self.build(params, context:)
        Params::DescribeImportImageTasksOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeImportImageTasksOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          import_image_tasks: ImportImageTaskList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeImportImageTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('importImageTaskSet', ImportImageTaskList.stub('item', stub[:import_image_tasks])) unless stub[:import_image_tasks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeImportSnapshotTasks
      def self.build(params, context:)
        Params::DescribeImportSnapshotTasksOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeImportSnapshotTasksOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          import_snapshot_tasks: ImportSnapshotTaskList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeImportSnapshotTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('importSnapshotTaskSet', ImportSnapshotTaskList.stub('item', stub[:import_snapshot_tasks])) unless stub[:import_snapshot_tasks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInstanceAttribute
      def self.build(params, context:)
        Params::DescribeInstanceAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInstanceAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          groups: GroupIdentifierList.default(visited),
          block_device_mappings: InstanceBlockDeviceMappingList.default(visited),
          disable_api_termination: AttributeBooleanValue.default(visited),
          ena_support: AttributeBooleanValue.default(visited),
          enclave_options: EnclaveOptions.default(visited),
          ebs_optimized: AttributeBooleanValue.default(visited),
          instance_id: 'instance_id',
          instance_initiated_shutdown_behavior: AttributeValue.default(visited),
          instance_type: AttributeValue.default(visited),
          kernel_id: AttributeValue.default(visited),
          product_codes: ProductCodeList.default(visited),
          ramdisk_id: AttributeValue.default(visited),
          root_device_name: AttributeValue.default(visited),
          source_dest_check: AttributeBooleanValue.default(visited),
          sriov_net_support: AttributeValue.default(visited),
          user_data: AttributeValue.default(visited),
          disable_api_stop: AttributeBooleanValue.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', InstanceBlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << AttributeBooleanValue.stub('disableApiTermination', stub[:disable_api_termination]) unless stub[:disable_api_termination].nil?
        xml << AttributeBooleanValue.stub('enaSupport', stub[:ena_support]) unless stub[:ena_support].nil?
        xml << EnclaveOptions.stub('enclaveOptions', stub[:enclave_options]) unless stub[:enclave_options].nil?
        xml << AttributeBooleanValue.stub('ebsOptimized', stub[:ebs_optimized]) unless stub[:ebs_optimized].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << AttributeValue.stub('instanceInitiatedShutdownBehavior', stub[:instance_initiated_shutdown_behavior]) unless stub[:instance_initiated_shutdown_behavior].nil?
        xml << AttributeValue.stub('instanceType', stub[:instance_type]) unless stub[:instance_type].nil?
        xml << AttributeValue.stub('kernel', stub[:kernel_id]) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << AttributeValue.stub('ramdisk', stub[:ramdisk_id]) unless stub[:ramdisk_id].nil?
        xml << AttributeValue.stub('rootDeviceName', stub[:root_device_name]) unless stub[:root_device_name].nil?
        xml << AttributeBooleanValue.stub('sourceDestCheck', stub[:source_dest_check]) unless stub[:source_dest_check].nil?
        xml << AttributeValue.stub('sriovNetSupport', stub[:sriov_net_support]) unless stub[:sriov_net_support].nil?
        xml << AttributeValue.stub('userData', stub[:user_data]) unless stub[:user_data].nil?
        xml << AttributeBooleanValue.stub('disableApiStop', stub[:disable_api_stop]) unless stub[:disable_api_stop].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInstanceConnectEndpoints
      def self.build(params, context:)
        Params::DescribeInstanceConnectEndpointsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInstanceConnectEndpointsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_connect_endpoints: InstanceConnectEndpointSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceConnectEndpointsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceConnectEndpointSet', InstanceConnectEndpointSet.stub('item', stub[:instance_connect_endpoints])) unless stub[:instance_connect_endpoints].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInstanceCreditSpecifications
      def self.build(params, context:)
        Params::DescribeInstanceCreditSpecificationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInstanceCreditSpecificationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_credit_specifications: InstanceCreditSpecificationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceCreditSpecificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceCreditSpecificationSet', InstanceCreditSpecificationList.stub('item', stub[:instance_credit_specifications])) unless stub[:instance_credit_specifications].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInstanceEventNotificationAttributes
      def self.build(params, context:)
        Params::DescribeInstanceEventNotificationAttributesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInstanceEventNotificationAttributesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_tag_attribute: InstanceTagNotificationAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceEventNotificationAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceTagNotificationAttribute.stub('instanceTagAttribute', stub[:instance_tag_attribute]) unless stub[:instance_tag_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInstanceEventWindows
      def self.build(params, context:)
        Params::DescribeInstanceEventWindowsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInstanceEventWindowsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_event_windows: InstanceEventWindowSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceEventWindowsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceEventWindowSet', InstanceEventWindowSet.stub('item', stub[:instance_event_windows])) unless stub[:instance_event_windows].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInstanceStatus
      def self.build(params, context:)
        Params::DescribeInstanceStatusOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInstanceStatusOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_statuses: InstanceStatusList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceStatusSet', InstanceStatusList.stub('item', stub[:instance_statuses])) unless stub[:instance_statuses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInstanceTypeOfferings
      def self.build(params, context:)
        Params::DescribeInstanceTypeOfferingsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInstanceTypeOfferingsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_type_offerings: InstanceTypeOfferingsList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceTypeOfferingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceTypeOfferingSet', InstanceTypeOfferingsList.stub('item', stub[:instance_type_offerings])) unless stub[:instance_type_offerings].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInstanceTypes
      def self.build(params, context:)
        Params::DescribeInstanceTypesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInstanceTypesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_types: InstanceTypeInfoList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstanceTypesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceTypeSet', InstanceTypeInfoList.stub('item', stub[:instance_types])) unless stub[:instance_types].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInstances
      def self.build(params, context:)
        Params::DescribeInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          reservations: ReservationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservationSet', ReservationList.stub('item', stub[:reservations])) unless stub[:reservations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeInternetGateways
      def self.build(params, context:)
        Params::DescribeInternetGatewaysOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeInternetGatewaysOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          internet_gateways: InternetGatewayList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeInternetGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('internetGatewaySet', InternetGatewayList.stub('item', stub[:internet_gateways])) unless stub[:internet_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeIpamPools
      def self.build(params, context:)
        Params::DescribeIpamPoolsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeIpamPoolsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          ipam_pools: IpamPoolSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpamPoolsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('ipamPoolSet', IpamPoolSet.stub('item', stub[:ipam_pools])) unless stub[:ipam_pools].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeIpamResourceDiscoveries
      def self.build(params, context:)
        Params::DescribeIpamResourceDiscoveriesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeIpamResourceDiscoveriesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_resource_discoveries: IpamResourceDiscoverySet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpamResourceDiscoveriesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipamResourceDiscoverySet', IpamResourceDiscoverySet.stub('item', stub[:ipam_resource_discoveries])) unless stub[:ipam_resource_discoveries].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeIpamResourceDiscoveryAssociations
      def self.build(params, context:)
        Params::DescribeIpamResourceDiscoveryAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeIpamResourceDiscoveryAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_resource_discovery_associations: IpamResourceDiscoveryAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpamResourceDiscoveryAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipamResourceDiscoveryAssociationSet', IpamResourceDiscoveryAssociationSet.stub('item', stub[:ipam_resource_discovery_associations])) unless stub[:ipam_resource_discovery_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeIpamScopes
      def self.build(params, context:)
        Params::DescribeIpamScopesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeIpamScopesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          ipam_scopes: IpamScopeSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpamScopesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('ipamScopeSet', IpamScopeSet.stub('item', stub[:ipam_scopes])) unless stub[:ipam_scopes].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeIpams
      def self.build(params, context:)
        Params::DescribeIpamsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeIpamsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          ipams: IpamSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpamsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('ipamSet', IpamSet.stub('item', stub[:ipams])) unless stub[:ipams].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeIpv6Pools
      def self.build(params, context:)
        Params::DescribeIpv6PoolsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeIpv6PoolsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipv6_pools: Ipv6PoolSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeIpv6PoolsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipv6PoolSet', Ipv6PoolSet.stub('item', stub[:ipv6_pools])) unless stub[:ipv6_pools].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeKeyPairs
      def self.build(params, context:)
        Params::DescribeKeyPairsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeKeyPairsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          key_pairs: KeyPairList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeKeyPairsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('keySet', KeyPairList.stub('item', stub[:key_pairs])) unless stub[:key_pairs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeLaunchTemplateVersions
      def self.build(params, context:)
        Params::DescribeLaunchTemplateVersionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeLaunchTemplateVersionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          launch_template_versions: LaunchTemplateVersionSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLaunchTemplateVersionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('launchTemplateVersionSet', LaunchTemplateVersionSet.stub('item', stub[:launch_template_versions])) unless stub[:launch_template_versions].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeLaunchTemplates
      def self.build(params, context:)
        Params::DescribeLaunchTemplatesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeLaunchTemplatesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          launch_templates: LaunchTemplateSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLaunchTemplatesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('launchTemplates', LaunchTemplateSet.stub('item', stub[:launch_templates])) unless stub[:launch_templates].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations
      def self.build(params, context:)
        Params::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_route_table_virtual_interface_group_associations: LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayRouteTableVirtualInterfaceGroupAssociationSet', LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.stub('item', stub[:local_gateway_route_table_virtual_interface_group_associations])) unless stub[:local_gateway_route_table_virtual_interface_group_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeLocalGatewayRouteTableVpcAssociations
      def self.build(params, context:)
        Params::DescribeLocalGatewayRouteTableVpcAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeLocalGatewayRouteTableVpcAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_route_table_vpc_associations: LocalGatewayRouteTableVpcAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayRouteTableVpcAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayRouteTableVpcAssociationSet', LocalGatewayRouteTableVpcAssociationSet.stub('item', stub[:local_gateway_route_table_vpc_associations])) unless stub[:local_gateway_route_table_vpc_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeLocalGatewayRouteTables
      def self.build(params, context:)
        Params::DescribeLocalGatewayRouteTablesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeLocalGatewayRouteTablesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_route_tables: LocalGatewayRouteTableSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayRouteTablesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayRouteTableSet', LocalGatewayRouteTableSet.stub('item', stub[:local_gateway_route_tables])) unless stub[:local_gateway_route_tables].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeLocalGatewayVirtualInterfaceGroups
      def self.build(params, context:)
        Params::DescribeLocalGatewayVirtualInterfaceGroupsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeLocalGatewayVirtualInterfaceGroupsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_virtual_interface_groups: LocalGatewayVirtualInterfaceGroupSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayVirtualInterfaceGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceGroupSet', LocalGatewayVirtualInterfaceGroupSet.stub('item', stub[:local_gateway_virtual_interface_groups])) unless stub[:local_gateway_virtual_interface_groups].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeLocalGatewayVirtualInterfaces
      def self.build(params, context:)
        Params::DescribeLocalGatewayVirtualInterfacesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeLocalGatewayVirtualInterfacesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateway_virtual_interfaces: LocalGatewayVirtualInterfaceSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewayVirtualInterfacesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceSet', LocalGatewayVirtualInterfaceSet.stub('item', stub[:local_gateway_virtual_interfaces])) unless stub[:local_gateway_virtual_interfaces].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeLocalGateways
      def self.build(params, context:)
        Params::DescribeLocalGatewaysOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeLocalGatewaysOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          local_gateways: LocalGatewaySet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeLocalGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('localGatewaySet', LocalGatewaySet.stub('item', stub[:local_gateways])) unless stub[:local_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeManagedPrefixLists
      def self.build(params, context:)
        Params::DescribeManagedPrefixListsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeManagedPrefixListsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          prefix_lists: ManagedPrefixListSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeManagedPrefixListsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('prefixListSet', ManagedPrefixListSet.stub('item', stub[:prefix_lists])) unless stub[:prefix_lists].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeMovingAddresses
      def self.build(params, context:)
        Params::DescribeMovingAddressesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeMovingAddressesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          moving_address_statuses: MovingAddressStatusSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeMovingAddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('movingAddressStatusSet', MovingAddressStatusSet.stub('item', stub[:moving_address_statuses])) unless stub[:moving_address_statuses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeNatGateways
      def self.build(params, context:)
        Params::DescribeNatGatewaysOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeNatGatewaysOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          nat_gateways: NatGatewayList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNatGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('natGatewaySet', NatGatewayList.stub('item', stub[:nat_gateways])) unless stub[:nat_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeNetworkAcls
      def self.build(params, context:)
        Params::DescribeNetworkAclsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeNetworkAclsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_acls: NetworkAclList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkAclsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkAclSet', NetworkAclList.stub('item', stub[:network_acls])) unless stub[:network_acls].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeNetworkInsightsAccessScopeAnalyses
      def self.build(params, context:)
        Params::DescribeNetworkInsightsAccessScopeAnalysesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeNetworkInsightsAccessScopeAnalysesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_access_scope_analyses: NetworkInsightsAccessScopeAnalysisList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInsightsAccessScopeAnalysesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisSet', NetworkInsightsAccessScopeAnalysisList.stub('item', stub[:network_insights_access_scope_analyses])) unless stub[:network_insights_access_scope_analyses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeNetworkInsightsAccessScopes
      def self.build(params, context:)
        Params::DescribeNetworkInsightsAccessScopesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeNetworkInsightsAccessScopesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_access_scopes: NetworkInsightsAccessScopeList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInsightsAccessScopesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeSet', NetworkInsightsAccessScopeList.stub('item', stub[:network_insights_access_scopes])) unless stub[:network_insights_access_scopes].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeNetworkInsightsAnalyses
      def self.build(params, context:)
        Params::DescribeNetworkInsightsAnalysesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeNetworkInsightsAnalysesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_analyses: NetworkInsightsAnalysisList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInsightsAnalysesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAnalysisSet', NetworkInsightsAnalysisList.stub('item', stub[:network_insights_analyses])) unless stub[:network_insights_analyses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeNetworkInsightsPaths
      def self.build(params, context:)
        Params::DescribeNetworkInsightsPathsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeNetworkInsightsPathsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_paths: NetworkInsightsPathList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInsightsPathsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsPathSet', NetworkInsightsPathList.stub('item', stub[:network_insights_paths])) unless stub[:network_insights_paths].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeNetworkInterfaceAttribute
      def self.build(params, context:)
        Params::DescribeNetworkInterfaceAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeNetworkInterfaceAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          attachment: NetworkInterfaceAttachment.default(visited),
          description: AttributeValue.default(visited),
          groups: GroupIdentifierList.default(visited),
          network_interface_id: 'network_interface_id',
          source_dest_check: AttributeBooleanValue.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInterfaceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInterfaceAttachment.stub('attachment', stub[:attachment]) unless stub[:attachment].nil?
        xml << AttributeValue.stub('description', stub[:description]) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << AttributeBooleanValue.stub('sourceDestCheck', stub[:source_dest_check]) unless stub[:source_dest_check].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeNetworkInterfacePermissions
      def self.build(params, context:)
        Params::DescribeNetworkInterfacePermissionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeNetworkInterfacePermissionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_interface_permissions: NetworkInterfacePermissionList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInterfacePermissionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInterfacePermissions', NetworkInterfacePermissionList.stub('item', stub[:network_interface_permissions])) unless stub[:network_interface_permissions].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeNetworkInterfaces
      def self.build(params, context:)
        Params::DescribeNetworkInterfacesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeNetworkInterfacesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_interfaces: NetworkInterfaceList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeNetworkInterfacesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInterfaceSet', NetworkInterfaceList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribePlacementGroups
      def self.build(params, context:)
        Params::DescribePlacementGroupsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribePlacementGroupsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          placement_groups: PlacementGroupList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribePlacementGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('placementGroupSet', PlacementGroupList.stub('item', stub[:placement_groups])) unless stub[:placement_groups].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribePrefixLists
      def self.build(params, context:)
        Params::DescribePrefixListsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribePrefixListsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          prefix_lists: PrefixListSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribePrefixListsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('prefixListSet', PrefixListSet.stub('item', stub[:prefix_lists])) unless stub[:prefix_lists].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribePrincipalIdFormat
      def self.build(params, context:)
        Params::DescribePrincipalIdFormatOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribePrincipalIdFormatOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          principals: PrincipalIdFormatList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribePrincipalIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('principalSet', PrincipalIdFormatList.stub('item', stub[:principals])) unless stub[:principals].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribePublicIpv4Pools
      def self.build(params, context:)
        Params::DescribePublicIpv4PoolsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribePublicIpv4PoolsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          public_ipv4_pools: PublicIpv4PoolSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribePublicIpv4PoolsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('publicIpv4PoolSet', PublicIpv4PoolSet.stub('item', stub[:public_ipv4_pools])) unless stub[:public_ipv4_pools].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeRegions
      def self.build(params, context:)
        Params::DescribeRegionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeRegionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          regions: RegionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeRegionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('regionInfo', RegionList.stub('item', stub[:regions])) unless stub[:regions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeReplaceRootVolumeTasks
      def self.build(params, context:)
        Params::DescribeReplaceRootVolumeTasksOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeReplaceRootVolumeTasksOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          replace_root_volume_tasks: ReplaceRootVolumeTasks.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReplaceRootVolumeTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('replaceRootVolumeTaskSet', ReplaceRootVolumeTasks.stub('item', stub[:replace_root_volume_tasks])) unless stub[:replace_root_volume_tasks].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeReservedInstances
      def self.build(params, context:)
        Params::DescribeReservedInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeReservedInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          reserved_instances: ReservedInstancesList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReservedInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesSet', ReservedInstancesList.stub('item', stub[:reserved_instances])) unless stub[:reserved_instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeReservedInstancesListings
      def self.build(params, context:)
        Params::DescribeReservedInstancesListingsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeReservedInstancesListingsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          reserved_instances_listings: ReservedInstancesListingList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReservedInstancesListingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesListingsSet', ReservedInstancesListingList.stub('item', stub[:reserved_instances_listings])) unless stub[:reserved_instances_listings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeReservedInstancesModifications
      def self.build(params, context:)
        Params::DescribeReservedInstancesModificationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeReservedInstancesModificationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          reserved_instances_modifications: ReservedInstancesModificationList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReservedInstancesModificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('reservedInstancesModificationsSet', ReservedInstancesModificationList.stub('item', stub[:reserved_instances_modifications])) unless stub[:reserved_instances_modifications].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeReservedInstancesOfferings
      def self.build(params, context:)
        Params::DescribeReservedInstancesOfferingsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeReservedInstancesOfferingsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          reserved_instances_offerings: ReservedInstancesOfferingList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeReservedInstancesOfferingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesOfferingsSet', ReservedInstancesOfferingList.stub('item', stub[:reserved_instances_offerings])) unless stub[:reserved_instances_offerings].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeRouteTables
      def self.build(params, context:)
        Params::DescribeRouteTablesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeRouteTablesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          route_tables: RouteTableList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeRouteTablesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('routeTableSet', RouteTableList.stub('item', stub[:route_tables])) unless stub[:route_tables].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeScheduledInstanceAvailability
      def self.build(params, context:)
        Params::DescribeScheduledInstanceAvailabilityOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeScheduledInstanceAvailabilityOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          scheduled_instance_availability_set: ScheduledInstanceAvailabilitySet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeScheduledInstanceAvailabilityResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('scheduledInstanceAvailabilitySet', ScheduledInstanceAvailabilitySet.stub('item', stub[:scheduled_instance_availability_set])) unless stub[:scheduled_instance_availability_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeScheduledInstances
      def self.build(params, context:)
        Params::DescribeScheduledInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeScheduledInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          scheduled_instance_set: ScheduledInstanceSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeScheduledInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('scheduledInstanceSet', ScheduledInstanceSet.stub('item', stub[:scheduled_instance_set])) unless stub[:scheduled_instance_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSecurityGroupReferences
      def self.build(params, context:)
        Params::DescribeSecurityGroupReferencesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSecurityGroupReferencesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          security_group_reference_set: SecurityGroupReferences.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSecurityGroupReferencesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('securityGroupReferenceSet', SecurityGroupReferences.stub('item', stub[:security_group_reference_set])) unless stub[:security_group_reference_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSecurityGroupRules
      def self.build(params, context:)
        Params::DescribeSecurityGroupRulesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSecurityGroupRulesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          security_group_rules: SecurityGroupRuleList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSecurityGroupRulesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('securityGroupRuleSet', SecurityGroupRuleList.stub('item', stub[:security_group_rules])) unless stub[:security_group_rules].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSecurityGroups
      def self.build(params, context:)
        Params::DescribeSecurityGroupsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSecurityGroupsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          security_groups: SecurityGroupList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSecurityGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('securityGroupInfo', SecurityGroupList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSnapshotAttribute
      def self.build(params, context:)
        Params::DescribeSnapshotAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSnapshotAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          create_volume_permissions: CreateVolumePermissionList.default(visited),
          product_codes: ProductCodeList.default(visited),
          snapshot_id: 'snapshot_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSnapshotAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('createVolumePermission', CreateVolumePermissionList.stub('item', stub[:create_volume_permissions])) unless stub[:create_volume_permissions].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSnapshotTierStatus
      def self.build(params, context:)
        Params::DescribeSnapshotTierStatusOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSnapshotTierStatusOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          snapshot_tier_statuses: SnapshotTierStatusSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSnapshotTierStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotTierStatusSet', SnapshotTierStatusSet.stub('item', stub[:snapshot_tier_statuses])) unless stub[:snapshot_tier_statuses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSnapshots
      def self.build(params, context:)
        Params::DescribeSnapshotsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSnapshotsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          snapshots: SnapshotList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSnapshotsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotSet', SnapshotList.stub('item', stub[:snapshots])) unless stub[:snapshots].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSpotDatafeedSubscription
      def self.build(params, context:)
        Params::DescribeSpotDatafeedSubscriptionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSpotDatafeedSubscriptionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          spot_datafeed_subscription: SpotDatafeedSubscription.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotDatafeedSubscriptionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SpotDatafeedSubscription.stub('spotDatafeedSubscription', stub[:spot_datafeed_subscription]) unless stub[:spot_datafeed_subscription].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSpotFleetInstances
      def self.build(params, context:)
        Params::DescribeSpotFleetInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSpotFleetInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          active_instances: ActiveInstanceSet.default(visited),
          next_token: 'next_token',
          spot_fleet_request_id: 'spot_fleet_request_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotFleetInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('activeInstanceSet', ActiveInstanceSet.stub('item', stub[:active_instances])) unless stub[:active_instances].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSpotFleetRequestHistory
      def self.build(params, context:)
        Params::DescribeSpotFleetRequestHistoryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSpotFleetRequestHistoryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          history_records: HistoryRecords.default(visited),
          last_evaluated_time: Time.now,
          next_token: 'next_token',
          spot_fleet_request_id: 'spot_fleet_request_id',
          start_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotFleetRequestHistoryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('historyRecordSet', HistoryRecords.stub('item', stub[:history_records])) unless stub[:history_records].nil?
        xml << Hearth::XML::Node.new('lastEvaluatedTime', Hearth::TimeHelper.to_date_time(stub[:last_evaluated_time])) unless stub[:last_evaluated_time].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSpotFleetRequests
      def self.build(params, context:)
        Params::DescribeSpotFleetRequestsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSpotFleetRequestsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          spot_fleet_request_configs: SpotFleetRequestConfigSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotFleetRequestsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestConfigSet', SpotFleetRequestConfigSet.stub('item', stub[:spot_fleet_request_configs])) unless stub[:spot_fleet_request_configs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSpotInstanceRequests
      def self.build(params, context:)
        Params::DescribeSpotInstanceRequestsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSpotInstanceRequestsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          spot_instance_requests: SpotInstanceRequestList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotInstanceRequestsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotInstanceRequestSet', SpotInstanceRequestList.stub('item', stub[:spot_instance_requests])) unless stub[:spot_instance_requests].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSpotPriceHistory
      def self.build(params, context:)
        Params::DescribeSpotPriceHistoryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSpotPriceHistoryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          spot_price_history: SpotPriceHistoryList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSpotPriceHistoryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('spotPriceHistorySet', SpotPriceHistoryList.stub('item', stub[:spot_price_history])) unless stub[:spot_price_history].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeStaleSecurityGroups
      def self.build(params, context:)
        Params::DescribeStaleSecurityGroupsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeStaleSecurityGroupsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          stale_security_group_set: StaleSecurityGroupSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeStaleSecurityGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('staleSecurityGroupSet', StaleSecurityGroupSet.stub('item', stub[:stale_security_group_set])) unless stub[:stale_security_group_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeStoreImageTasks
      def self.build(params, context:)
        Params::DescribeStoreImageTasksOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeStoreImageTasksOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          store_image_task_results: StoreImageTaskResultSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeStoreImageTasksResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('storeImageTaskResultSet', StoreImageTaskResultSet.stub('item', stub[:store_image_task_results])) unless stub[:store_image_task_results].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeSubnets
      def self.build(params, context:)
        Params::DescribeSubnetsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeSubnetsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          subnets: SubnetList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeSubnetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('subnetSet', SubnetList.stub('item', stub[:subnets])) unless stub[:subnets].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTags
      def self.build(params, context:)
        Params::DescribeTagsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTagsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          tags: TagDescriptionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTagsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('tagSet', TagDescriptionList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTrafficMirrorFilters
      def self.build(params, context:)
        Params::DescribeTrafficMirrorFiltersOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTrafficMirrorFiltersOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_filters: TrafficMirrorFilterSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTrafficMirrorFiltersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorFilterSet', TrafficMirrorFilterSet.stub('item', stub[:traffic_mirror_filters])) unless stub[:traffic_mirror_filters].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTrafficMirrorSessions
      def self.build(params, context:)
        Params::DescribeTrafficMirrorSessionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTrafficMirrorSessionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_sessions: TrafficMirrorSessionSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTrafficMirrorSessionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorSessionSet', TrafficMirrorSessionSet.stub('item', stub[:traffic_mirror_sessions])) unless stub[:traffic_mirror_sessions].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTrafficMirrorTargets
      def self.build(params, context:)
        Params::DescribeTrafficMirrorTargetsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTrafficMirrorTargetsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_targets: TrafficMirrorTargetSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTrafficMirrorTargetsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('trafficMirrorTargetSet', TrafficMirrorTargetSet.stub('item', stub[:traffic_mirror_targets])) unless stub[:traffic_mirror_targets].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGatewayAttachments
      def self.build(params, context:)
        Params::DescribeTransitGatewayAttachmentsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewayAttachmentsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_attachments: TransitGatewayAttachmentList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayAttachmentsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayAttachments', TransitGatewayAttachmentList.stub('item', stub[:transit_gateway_attachments])) unless stub[:transit_gateway_attachments].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGatewayConnectPeers
      def self.build(params, context:)
        Params::DescribeTransitGatewayConnectPeersOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewayConnectPeersOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_connect_peers: TransitGatewayConnectPeerList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayConnectPeersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayConnectPeerSet', TransitGatewayConnectPeerList.stub('item', stub[:transit_gateway_connect_peers])) unless stub[:transit_gateway_connect_peers].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGatewayConnects
      def self.build(params, context:)
        Params::DescribeTransitGatewayConnectsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewayConnectsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_connects: TransitGatewayConnectList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayConnectsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayConnectSet', TransitGatewayConnectList.stub('item', stub[:transit_gateway_connects])) unless stub[:transit_gateway_connects].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGatewayMulticastDomains
      def self.build(params, context:)
        Params::DescribeTransitGatewayMulticastDomainsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewayMulticastDomainsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_multicast_domains: TransitGatewayMulticastDomainList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayMulticastDomainsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomains', TransitGatewayMulticastDomainList.stub('item', stub[:transit_gateway_multicast_domains])) unless stub[:transit_gateway_multicast_domains].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGatewayPeeringAttachments
      def self.build(params, context:)
        Params::DescribeTransitGatewayPeeringAttachmentsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewayPeeringAttachmentsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_peering_attachments: TransitGatewayPeeringAttachmentList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayPeeringAttachmentsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayPeeringAttachments', TransitGatewayPeeringAttachmentList.stub('item', stub[:transit_gateway_peering_attachments])) unless stub[:transit_gateway_peering_attachments].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGatewayPolicyTables
      def self.build(params, context:)
        Params::DescribeTransitGatewayPolicyTablesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewayPolicyTablesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_policy_tables: TransitGatewayPolicyTableList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayPolicyTablesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayPolicyTables', TransitGatewayPolicyTableList.stub('item', stub[:transit_gateway_policy_tables])) unless stub[:transit_gateway_policy_tables].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGatewayRouteTableAnnouncements
      def self.build(params, context:)
        Params::DescribeTransitGatewayRouteTableAnnouncementsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewayRouteTableAnnouncementsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_route_table_announcements: TransitGatewayRouteTableAnnouncementList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayRouteTableAnnouncementsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayRouteTableAnnouncements', TransitGatewayRouteTableAnnouncementList.stub('item', stub[:transit_gateway_route_table_announcements])) unless stub[:transit_gateway_route_table_announcements].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGatewayRouteTables
      def self.build(params, context:)
        Params::DescribeTransitGatewayRouteTablesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewayRouteTablesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_route_tables: TransitGatewayRouteTableList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayRouteTablesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayRouteTables', TransitGatewayRouteTableList.stub('item', stub[:transit_gateway_route_tables])) unless stub[:transit_gateway_route_tables].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGatewayVpcAttachments
      def self.build(params, context:)
        Params::DescribeTransitGatewayVpcAttachmentsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewayVpcAttachmentsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_vpc_attachments: TransitGatewayVpcAttachmentList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewayVpcAttachmentsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayVpcAttachments', TransitGatewayVpcAttachmentList.stub('item', stub[:transit_gateway_vpc_attachments])) unless stub[:transit_gateway_vpc_attachments].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTransitGateways
      def self.build(params, context:)
        Params::DescribeTransitGatewaysOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTransitGatewaysOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateways: TransitGatewayList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTransitGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewaySet', TransitGatewayList.stub('item', stub[:transit_gateways])) unless stub[:transit_gateways].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeTrunkInterfaceAssociations
      def self.build(params, context:)
        Params::DescribeTrunkInterfaceAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeTrunkInterfaceAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          interface_associations: TrunkInterfaceAssociationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeTrunkInterfaceAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('interfaceAssociationSet', TrunkInterfaceAssociationList.stub('item', stub[:interface_associations])) unless stub[:interface_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVerifiedAccessEndpoints
      def self.build(params, context:)
        Params::DescribeVerifiedAccessEndpointsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVerifiedAccessEndpointsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_endpoints: VerifiedAccessEndpointList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVerifiedAccessEndpointsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('verifiedAccessEndpointSet', VerifiedAccessEndpointList.stub('item', stub[:verified_access_endpoints])) unless stub[:verified_access_endpoints].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVerifiedAccessGroups
      def self.build(params, context:)
        Params::DescribeVerifiedAccessGroupsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVerifiedAccessGroupsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_groups: VerifiedAccessGroupList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVerifiedAccessGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('verifiedAccessGroupSet', VerifiedAccessGroupList.stub('item', stub[:verified_access_groups])) unless stub[:verified_access_groups].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVerifiedAccessInstanceLoggingConfigurations
      def self.build(params, context:)
        Params::DescribeVerifiedAccessInstanceLoggingConfigurationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVerifiedAccessInstanceLoggingConfigurationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          logging_configurations: VerifiedAccessInstanceLoggingConfigurationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVerifiedAccessInstanceLoggingConfigurationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('loggingConfigurationSet', VerifiedAccessInstanceLoggingConfigurationList.stub('item', stub[:logging_configurations])) unless stub[:logging_configurations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVerifiedAccessInstances
      def self.build(params, context:)
        Params::DescribeVerifiedAccessInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVerifiedAccessInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_instances: VerifiedAccessInstanceList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVerifiedAccessInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('verifiedAccessInstanceSet', VerifiedAccessInstanceList.stub('item', stub[:verified_access_instances])) unless stub[:verified_access_instances].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVerifiedAccessTrustProviders
      def self.build(params, context:)
        Params::DescribeVerifiedAccessTrustProvidersOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVerifiedAccessTrustProvidersOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_trust_providers: VerifiedAccessTrustProviderList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVerifiedAccessTrustProvidersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('verifiedAccessTrustProviderSet', VerifiedAccessTrustProviderList.stub('item', stub[:verified_access_trust_providers])) unless stub[:verified_access_trust_providers].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVolumeAttribute
      def self.build(params, context:)
        Params::DescribeVolumeAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVolumeAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          auto_enable_io: AttributeBooleanValue.default(visited),
          product_codes: ProductCodeList.default(visited),
          volume_id: 'volume_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVolumeAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << AttributeBooleanValue.stub('autoEnableIO', stub[:auto_enable_io]) unless stub[:auto_enable_io].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVolumeStatus
      def self.build(params, context:)
        Params::DescribeVolumeStatusOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVolumeStatusOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          volume_statuses: VolumeStatusList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVolumeStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('volumeStatusSet', VolumeStatusList.stub('item', stub[:volume_statuses])) unless stub[:volume_statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVolumes
      def self.build(params, context:)
        Params::DescribeVolumesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVolumesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          volumes: VolumeList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVolumesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('volumeSet', VolumeList.stub('item', stub[:volumes])) unless stub[:volumes].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVolumesModifications
      def self.build(params, context:)
        Params::DescribeVolumesModificationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVolumesModificationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          volumes_modifications: VolumeModificationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVolumesModificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('volumeModificationSet', VolumeModificationList.stub('item', stub[:volumes_modifications])) unless stub[:volumes_modifications].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcAttribute
      def self.build(params, context:)
        Params::DescribeVpcAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc_id: 'vpc_id',
          enable_dns_hostnames: AttributeBooleanValue.default(visited),
          enable_dns_support: AttributeBooleanValue.default(visited),
          enable_network_address_usage_metrics: AttributeBooleanValue.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << AttributeBooleanValue.stub('enableDnsHostnames', stub[:enable_dns_hostnames]) unless stub[:enable_dns_hostnames].nil?
        xml << AttributeBooleanValue.stub('enableDnsSupport', stub[:enable_dns_support]) unless stub[:enable_dns_support].nil?
        xml << AttributeBooleanValue.stub('enableNetworkAddressUsageMetrics', stub[:enable_network_address_usage_metrics]) unless stub[:enable_network_address_usage_metrics].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcClassicLink
      def self.build(params, context:)
        Params::DescribeVpcClassicLinkOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcClassicLinkOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpcs: VpcClassicLinkList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcClassicLinkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcSet', VpcClassicLinkList.stub('item', stub[:vpcs])) unless stub[:vpcs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcClassicLinkDnsSupport
      def self.build(params, context:)
        Params::DescribeVpcClassicLinkDnsSupportOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcClassicLinkDnsSupportOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          vpcs: ClassicLinkDnsSupportList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcClassicLinkDnsSupportResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('vpcs', ClassicLinkDnsSupportList.stub('item', stub[:vpcs])) unless stub[:vpcs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcEndpointConnectionNotifications
      def self.build(params, context:)
        Params::DescribeVpcEndpointConnectionNotificationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcEndpointConnectionNotificationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          connection_notification_set: ConnectionNotificationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointConnectionNotificationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('connectionNotificationSet', ConnectionNotificationSet.stub('item', stub[:connection_notification_set])) unless stub[:connection_notification_set].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcEndpointConnections
      def self.build(params, context:)
        Params::DescribeVpcEndpointConnectionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcEndpointConnectionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc_endpoint_connections: VpcEndpointConnectionSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcEndpointConnectionSet', VpcEndpointConnectionSet.stub('item', stub[:vpc_endpoint_connections])) unless stub[:vpc_endpoint_connections].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcEndpointServiceConfigurations
      def self.build(params, context:)
        Params::DescribeVpcEndpointServiceConfigurationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcEndpointServiceConfigurationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          service_configurations: ServiceConfigurationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointServiceConfigurationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serviceConfigurationSet', ServiceConfigurationSet.stub('item', stub[:service_configurations])) unless stub[:service_configurations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcEndpointServicePermissions
      def self.build(params, context:)
        Params::DescribeVpcEndpointServicePermissionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcEndpointServicePermissionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          allowed_principals: AllowedPrincipalSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointServicePermissionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('allowedPrincipals', AllowedPrincipalSet.stub('item', stub[:allowed_principals])) unless stub[:allowed_principals].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcEndpointServices
      def self.build(params, context:)
        Params::DescribeVpcEndpointServicesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcEndpointServicesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          service_names: ValueStringList.default(visited),
          service_details: ServiceDetailSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointServicesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serviceNameSet', ValueStringList.stub('item', stub[:service_names])) unless stub[:service_names].nil?
        xml << Hearth::XML::Node.new('serviceDetailSet', ServiceDetailSet.stub('item', stub[:service_details])) unless stub[:service_details].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcEndpoints
      def self.build(params, context:)
        Params::DescribeVpcEndpointsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcEndpointsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc_endpoints: VpcEndpointSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcEndpointsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcEndpointSet', VpcEndpointSet.stub('item', stub[:vpc_endpoints])) unless stub[:vpc_endpoints].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcPeeringConnections
      def self.build(params, context:)
        Params::DescribeVpcPeeringConnectionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcPeeringConnectionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpc_peering_connections: VpcPeeringConnectionList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcPeeringConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcPeeringConnectionSet', VpcPeeringConnectionList.stub('item', stub[:vpc_peering_connections])) unless stub[:vpc_peering_connections].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpcs
      def self.build(params, context:)
        Params::DescribeVpcsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpcsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpcs: VpcList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpcsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpcSet', VpcList.stub('item', stub[:vpcs])) unless stub[:vpcs].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpnConnections
      def self.build(params, context:)
        Params::DescribeVpnConnectionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpnConnectionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_connections: VpnConnectionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpnConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpnConnectionSet', VpnConnectionList.stub('item', stub[:vpn_connections])) unless stub[:vpn_connections].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DescribeVpnGateways
      def self.build(params, context:)
        Params::DescribeVpnGatewaysOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DescribeVpnGatewaysOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_gateways: VpnGatewayList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DescribeVpnGatewaysResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpnGatewaySet', VpnGatewayList.stub('item', stub[:vpn_gateways])) unless stub[:vpn_gateways].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DestinationOptionsResponse
      def self.default(visited = [])
        return nil if visited.include?('DestinationOptionsResponse')
        visited = visited + ['DestinationOptionsResponse']
        {
          file_format: 'file_format',
          hive_compatible_partitions: false,
          per_hour_partition: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fileFormat', stub[:file_format].to_s) unless stub[:file_format].nil?
        xml << Hearth::XML::Node.new('hiveCompatiblePartitions', stub[:hive_compatible_partitions].to_s) unless stub[:hive_compatible_partitions].nil?
        xml << Hearth::XML::Node.new('perHourPartition', stub[:per_hour_partition].to_s) unless stub[:per_hour_partition].nil?
        xml
      end
    end

    class DetachClassicLinkVpc
      def self.build(params, context:)
        Params::DetachClassicLinkVpcOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DetachClassicLinkVpcOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachClassicLinkVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DetachInternetGateway
      def self.build(params, context:)
        Params::DetachInternetGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DetachInternetGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachInternetGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DetachNetworkInterface
      def self.build(params, context:)
        Params::DetachNetworkInterfaceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DetachNetworkInterfaceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachNetworkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DetachVerifiedAccessTrustProvider
      def self.build(params, context:)
        Params::DetachVerifiedAccessTrustProviderOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DetachVerifiedAccessTrustProviderOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_trust_provider: VerifiedAccessTrustProvider.default(visited),
          verified_access_instance: VerifiedAccessInstance.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachVerifiedAccessTrustProviderResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessTrustProvider.stub('verifiedAccessTrustProvider', stub[:verified_access_trust_provider]) unless stub[:verified_access_trust_provider].nil?
        xml << VerifiedAccessInstance.stub('verifiedAccessInstance', stub[:verified_access_instance]) unless stub[:verified_access_instance].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DetachVolume
      def self.build(params, context:)
        Params::DetachVolumeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DetachVolumeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          attach_time: Time.now,
          device: 'device',
          instance_id: 'instance_id',
          state: 'state',
          volume_id: 'volume_id',
          delete_on_termination: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('device', stub[:device].to_s) unless stub[:device].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DetachVpnGateway
      def self.build(params, context:)
        Params::DetachVpnGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DetachVpnGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DetachVpnGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DeviceOptions
      def self.default(visited = [])
        return nil if visited.include?('DeviceOptions')
        visited = visited + ['DeviceOptions']
        {
          tenant_id: 'tenant_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('tenantId', stub[:tenant_id].to_s) unless stub[:tenant_id].nil?
        xml
      end
    end

    class DhcpConfiguration
      def self.default(visited = [])
        return nil if visited.include?('DhcpConfiguration')
        visited = visited + ['DhcpConfiguration']
        {
          key: 'key',
          values: DhcpConfigurationValueList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('key', stub[:key].to_s) unless stub[:key].nil?
        xml << Hearth::XML::Node.new('valueSet', DhcpConfigurationValueList.stub('item', stub[:values])) unless stub[:values].nil?
        xml
      end
    end

    class DhcpConfigurationList
      def self.default(visited = [])
        return nil if visited.include?('DhcpConfigurationList')
        visited = visited + ['DhcpConfigurationList']
        [
          DhcpConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DhcpConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DhcpConfigurationValueList
      def self.default(visited = [])
        return nil if visited.include?('DhcpConfigurationValueList')
        visited = visited + ['DhcpConfigurationValueList']
        [
          AttributeValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << AttributeValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DhcpOptions
      def self.default(visited = [])
        return nil if visited.include?('DhcpOptions')
        visited = visited + ['DhcpOptions']
        {
          dhcp_configurations: DhcpConfigurationList.default(visited),
          dhcp_options_id: 'dhcp_options_id',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dhcpConfigurationSet', DhcpConfigurationList.stub('item', stub[:dhcp_configurations])) unless stub[:dhcp_configurations].nil?
        xml << Hearth::XML::Node.new('dhcpOptionsId', stub[:dhcp_options_id].to_s) unless stub[:dhcp_options_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class DhcpOptionsList
      def self.default(visited = [])
        return nil if visited.include?('DhcpOptionsList')
        visited = visited + ['DhcpOptionsList']
        [
          DhcpOptions.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DhcpOptions.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DirectoryServiceAuthentication
      def self.default(visited = [])
        return nil if visited.include?('DirectoryServiceAuthentication')
        visited = visited + ['DirectoryServiceAuthentication']
        {
          directory_id: 'directory_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('directoryId', stub[:directory_id].to_s) unless stub[:directory_id].nil?
        xml
      end
    end

    class DisableAddressTransfer
      def self.build(params, context:)
        Params::DisableAddressTransferOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableAddressTransferOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          address_transfer: AddressTransfer.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableAddressTransferResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << AddressTransfer.stub('addressTransfer', stub[:address_transfer]) unless stub[:address_transfer].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableAwsNetworkPerformanceMetricSubscription
      def self.build(params, context:)
        Params::DisableAwsNetworkPerformanceMetricSubscriptionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableAwsNetworkPerformanceMetricSubscriptionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          output: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableAwsNetworkPerformanceMetricSubscriptionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('output', stub[:output].to_s) unless stub[:output].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableEbsEncryptionByDefault
      def self.build(params, context:)
        Params::DisableEbsEncryptionByDefaultOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableEbsEncryptionByDefaultOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ebs_encryption_by_default: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableEbsEncryptionByDefaultResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ebsEncryptionByDefault', stub[:ebs_encryption_by_default].to_s) unless stub[:ebs_encryption_by_default].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableFastLaunch
      def self.build(params, context:)
        Params::DisableFastLaunchOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableFastLaunchOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          image_id: 'image_id',
          resource_type: 'resource_type',
          snapshot_configuration: FastLaunchSnapshotConfigurationResponse.default(visited),
          launch_template: FastLaunchLaunchTemplateSpecificationResponse.default(visited),
          max_parallel_launches: 1,
          owner_id: 'owner_id',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          state_transition_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableFastLaunchResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << FastLaunchSnapshotConfigurationResponse.stub('snapshotConfiguration', stub[:snapshot_configuration]) unless stub[:snapshot_configuration].nil?
        xml << FastLaunchLaunchTemplateSpecificationResponse.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        xml << Hearth::XML::Node.new('maxParallelLaunches', stub[:max_parallel_launches].to_s) unless stub[:max_parallel_launches].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('stateTransitionTime', Hearth::TimeHelper.to_date_time(stub[:state_transition_time])) unless stub[:state_transition_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableFastSnapshotRestoreErrorItem
      def self.default(visited = [])
        return nil if visited.include?('DisableFastSnapshotRestoreErrorItem')
        visited = visited + ['DisableFastSnapshotRestoreErrorItem']
        {
          snapshot_id: 'snapshot_id',
          fast_snapshot_restore_state_errors: DisableFastSnapshotRestoreStateErrorSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('fastSnapshotRestoreStateErrorSet', DisableFastSnapshotRestoreStateErrorSet.stub('item', stub[:fast_snapshot_restore_state_errors])) unless stub[:fast_snapshot_restore_state_errors].nil?
        xml
      end
    end

    class DisableFastSnapshotRestoreErrorSet
      def self.default(visited = [])
        return nil if visited.include?('DisableFastSnapshotRestoreErrorSet')
        visited = visited + ['DisableFastSnapshotRestoreErrorSet']
        [
          DisableFastSnapshotRestoreErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DisableFastSnapshotRestoreErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DisableFastSnapshotRestoreStateError
      def self.default(visited = [])
        return nil if visited.include?('DisableFastSnapshotRestoreStateError')
        visited = visited + ['DisableFastSnapshotRestoreStateError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class DisableFastSnapshotRestoreStateErrorItem
      def self.default(visited = [])
        return nil if visited.include?('DisableFastSnapshotRestoreStateErrorItem')
        visited = visited + ['DisableFastSnapshotRestoreStateErrorItem']
        {
          availability_zone: 'availability_zone',
          error: DisableFastSnapshotRestoreStateError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << DisableFastSnapshotRestoreStateError.stub('error', stub[:error]) unless stub[:error].nil?
        xml
      end
    end

    class DisableFastSnapshotRestoreStateErrorSet
      def self.default(visited = [])
        return nil if visited.include?('DisableFastSnapshotRestoreStateErrorSet')
        visited = visited + ['DisableFastSnapshotRestoreStateErrorSet']
        [
          DisableFastSnapshotRestoreStateErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DisableFastSnapshotRestoreStateErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DisableFastSnapshotRestoreSuccessItem
      def self.default(visited = [])
        return nil if visited.include?('DisableFastSnapshotRestoreSuccessItem')
        visited = visited + ['DisableFastSnapshotRestoreSuccessItem']
        {
          snapshot_id: 'snapshot_id',
          availability_zone: 'availability_zone',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          owner_id: 'owner_id',
          owner_alias: 'owner_alias',
          enabling_time: Time.now,
          optimizing_time: Time.now,
          enabled_time: Time.now,
          disabling_time: Time.now,
          disabled_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('enablingTime', Hearth::TimeHelper.to_date_time(stub[:enabling_time])) unless stub[:enabling_time].nil?
        xml << Hearth::XML::Node.new('optimizingTime', Hearth::TimeHelper.to_date_time(stub[:optimizing_time])) unless stub[:optimizing_time].nil?
        xml << Hearth::XML::Node.new('enabledTime', Hearth::TimeHelper.to_date_time(stub[:enabled_time])) unless stub[:enabled_time].nil?
        xml << Hearth::XML::Node.new('disablingTime', Hearth::TimeHelper.to_date_time(stub[:disabling_time])) unless stub[:disabling_time].nil?
        xml << Hearth::XML::Node.new('disabledTime', Hearth::TimeHelper.to_date_time(stub[:disabled_time])) unless stub[:disabled_time].nil?
        xml
      end
    end

    class DisableFastSnapshotRestoreSuccessSet
      def self.default(visited = [])
        return nil if visited.include?('DisableFastSnapshotRestoreSuccessSet')
        visited = visited + ['DisableFastSnapshotRestoreSuccessSet']
        [
          DisableFastSnapshotRestoreSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DisableFastSnapshotRestoreSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DisableFastSnapshotRestores
      def self.build(params, context:)
        Params::DisableFastSnapshotRestoresOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableFastSnapshotRestoresOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successful: DisableFastSnapshotRestoreSuccessSet.default(visited),
          unsuccessful: DisableFastSnapshotRestoreErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableFastSnapshotRestoresResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successful', DisableFastSnapshotRestoreSuccessSet.stub('item', stub[:successful])) unless stub[:successful].nil?
        xml << Hearth::XML::Node.new('unsuccessful', DisableFastSnapshotRestoreErrorSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableImageDeprecation
      def self.build(params, context:)
        Params::DisableImageDeprecationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableImageDeprecationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableImageDeprecationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableIpamOrganizationAdminAccount
      def self.build(params, context:)
        Params::DisableIpamOrganizationAdminAccountOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableIpamOrganizationAdminAccountOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          success: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableIpamOrganizationAdminAccountResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('success', stub[:success].to_s) unless stub[:success].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableSerialConsoleAccess
      def self.build(params, context:)
        Params::DisableSerialConsoleAccessOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableSerialConsoleAccessOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          serial_console_access_enabled: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableSerialConsoleAccessResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serialConsoleAccessEnabled', stub[:serial_console_access_enabled].to_s) unless stub[:serial_console_access_enabled].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableTransitGatewayRouteTablePropagation
      def self.build(params, context:)
        Params::DisableTransitGatewayRouteTablePropagationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableTransitGatewayRouteTablePropagationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          propagation: TransitGatewayPropagation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableTransitGatewayRouteTablePropagationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPropagation.stub('propagation', stub[:propagation]) unless stub[:propagation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableVgwRoutePropagation
      def self.build(params, context:)
        Params::DisableVgwRoutePropagationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableVgwRoutePropagationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableVgwRoutePropagationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableVpcClassicLink
      def self.build(params, context:)
        Params::DisableVpcClassicLinkOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableVpcClassicLinkOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableVpcClassicLinkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisableVpcClassicLinkDnsSupport
      def self.build(params, context:)
        Params::DisableVpcClassicLinkDnsSupportOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisableVpcClassicLinkDnsSupportOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisableVpcClassicLinkDnsSupportResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateAddress
      def self.build(params, context:)
        Params::DisassociateAddressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateAddressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateClientVpnTargetNetwork
      def self.build(params, context:)
        Params::DisassociateClientVpnTargetNetworkOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateClientVpnTargetNetworkOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          association_id: 'association_id',
          status: AssociationStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateClientVpnTargetNetworkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << AssociationStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateEnclaveCertificateIamRole
      def self.build(params, context:)
        Params::DisassociateEnclaveCertificateIamRoleOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateEnclaveCertificateIamRoleOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateEnclaveCertificateIamRoleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateIamInstanceProfile
      def self.build(params, context:)
        Params::DisassociateIamInstanceProfileOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateIamInstanceProfileOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          iam_instance_profile_association: IamInstanceProfileAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateIamInstanceProfileResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IamInstanceProfileAssociation.stub('iamInstanceProfileAssociation', stub[:iam_instance_profile_association]) unless stub[:iam_instance_profile_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateInstanceEventWindow
      def self.build(params, context:)
        Params::DisassociateInstanceEventWindowOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateInstanceEventWindowOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_event_window: InstanceEventWindow.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindow.stub('instanceEventWindow', stub[:instance_event_window]) unless stub[:instance_event_window].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateIpamResourceDiscovery
      def self.build(params, context:)
        Params::DisassociateIpamResourceDiscoveryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateIpamResourceDiscoveryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_resource_discovery_association: IpamResourceDiscoveryAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateIpamResourceDiscoveryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamResourceDiscoveryAssociation.stub('ipamResourceDiscoveryAssociation', stub[:ipam_resource_discovery_association]) unless stub[:ipam_resource_discovery_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateNatGatewayAddress
      def self.build(params, context:)
        Params::DisassociateNatGatewayAddressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateNatGatewayAddressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          nat_gateway_id: 'nat_gateway_id',
          nat_gateway_addresses: NatGatewayAddressList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateNatGatewayAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << Hearth::XML::Node.new('natGatewayAddressSet', NatGatewayAddressList.stub('item', stub[:nat_gateway_addresses])) unless stub[:nat_gateway_addresses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateRouteTable
      def self.build(params, context:)
        Params::DisassociateRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateSubnetCidrBlock
      def self.build(params, context:)
        Params::DisassociateSubnetCidrBlockOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateSubnetCidrBlockOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.default(visited),
          subnet_id: 'subnet_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateSubnetCidrBlockResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << SubnetIpv6CidrBlockAssociation.stub('ipv6CidrBlockAssociation', stub[:ipv6_cidr_block_association]) unless stub[:ipv6_cidr_block_association].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateTransitGatewayMulticastDomain
      def self.build(params, context:)
        Params::DisassociateTransitGatewayMulticastDomainOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateTransitGatewayMulticastDomainOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          associations: TransitGatewayMulticastDomainAssociations.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateTransitGatewayMulticastDomainResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomainAssociations.stub('associations', stub[:associations]) unless stub[:associations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateTransitGatewayPolicyTable
      def self.build(params, context:)
        Params::DisassociateTransitGatewayPolicyTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateTransitGatewayPolicyTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          association: TransitGatewayPolicyTableAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateTransitGatewayPolicyTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPolicyTableAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateTransitGatewayRouteTable
      def self.build(params, context:)
        Params::DisassociateTransitGatewayRouteTableOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateTransitGatewayRouteTableOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          association: TransitGatewayAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateTransitGatewayRouteTableResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateTrunkInterface
      def self.build(params, context:)
        Params::DisassociateTrunkInterfaceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateTrunkInterfaceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
          client_token: 'client_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateTrunkInterfaceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DisassociateVpcCidrBlock
      def self.build(params, context:)
        Params::DisassociateVpcCidrBlockOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::DisassociateVpcCidrBlockOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.default(visited),
          cidr_block_association: VpcCidrBlockAssociation.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('DisassociateVpcCidrBlockResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpcIpv6CidrBlockAssociation.stub('ipv6CidrBlockAssociation', stub[:ipv6_cidr_block_association]) unless stub[:ipv6_cidr_block_association].nil?
        xml << VpcCidrBlockAssociation.stub('cidrBlockAssociation', stub[:cidr_block_association]) unless stub[:cidr_block_association].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class DiskImageDescription
      def self.default(visited = [])
        return nil if visited.include?('DiskImageDescription')
        visited = visited + ['DiskImageDescription']
        {
          checksum: 'checksum',
          format: 'format',
          import_manifest_url: 'import_manifest_url',
          size: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('checksum', stub[:checksum].to_s) unless stub[:checksum].nil?
        xml << Hearth::XML::Node.new('format', stub[:format].to_s) unless stub[:format].nil?
        xml << Hearth::XML::Node.new('importManifestUrl', stub[:import_manifest_url].to_s) unless stub[:import_manifest_url].nil?
        xml << Hearth::XML::Node.new('size', stub[:size].to_s) unless stub[:size].nil?
        xml
      end
    end

    class DiskImageVolumeDescription
      def self.default(visited = [])
        return nil if visited.include?('DiskImageVolumeDescription')
        visited = visited + ['DiskImageVolumeDescription']
        {
          id: 'id',
          size: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('id', stub[:id].to_s) unless stub[:id].nil?
        xml << Hearth::XML::Node.new('size', stub[:size].to_s) unless stub[:size].nil?
        xml
      end
    end

    class DiskInfo
      def self.default(visited = [])
        return nil if visited.include?('DiskInfo')
        visited = visited + ['DiskInfo']
        {
          size_in_gb: 1,
          count: 1,
          type: 'type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sizeInGB', stub[:size_in_gb].to_s) unless stub[:size_in_gb].nil?
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml
      end
    end

    class DiskInfoList
      def self.default(visited = [])
        return nil if visited.include?('DiskInfoList')
        visited = visited + ['DiskInfoList']
        [
          DiskInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DiskInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DnsEntry
      def self.default(visited = [])
        return nil if visited.include?('DnsEntry')
        visited = visited + ['DnsEntry']
        {
          dns_name: 'dns_name',
          hosted_zone_id: 'hosted_zone_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dnsName', stub[:dns_name].to_s) unless stub[:dns_name].nil?
        xml << Hearth::XML::Node.new('hostedZoneId', stub[:hosted_zone_id].to_s) unless stub[:hosted_zone_id].nil?
        xml
      end
    end

    class DnsEntrySet
      def self.default(visited = [])
        return nil if visited.include?('DnsEntrySet')
        visited = visited + ['DnsEntrySet']
        [
          DnsEntry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << DnsEntry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class DnsOptions
      def self.default(visited = [])
        return nil if visited.include?('DnsOptions')
        visited = visited + ['DnsOptions']
        {
          dns_record_ip_type: 'dns_record_ip_type',
          private_dns_only_for_inbound_resolver_endpoint: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dnsRecordIpType', stub[:dns_record_ip_type].to_s) unless stub[:dns_record_ip_type].nil?
        xml << Hearth::XML::Node.new('privateDnsOnlyForInboundResolverEndpoint', stub[:private_dns_only_for_inbound_resolver_endpoint].to_s) unless stub[:private_dns_only_for_inbound_resolver_endpoint].nil?
        xml
      end
    end

    class EbsBlockDevice
      def self.default(visited = [])
        return nil if visited.include?('EbsBlockDevice')
        visited = visited + ['EbsBlockDevice']
        {
          delete_on_termination: false,
          iops: 1,
          snapshot_id: 'snapshot_id',
          volume_size: 1,
          volume_type: 'volume_type',
          kms_key_id: 'kms_key_id',
          throughput: 1,
          outpost_arn: 'outpost_arn',
          encrypted: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('iops', stub[:iops].to_s) unless stub[:iops].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('volumeType', stub[:volume_type].to_s) unless stub[:volume_type].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('throughput', stub[:throughput].to_s) unless stub[:throughput].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml
      end
    end

    class EbsInfo
      def self.default(visited = [])
        return nil if visited.include?('EbsInfo')
        visited = visited + ['EbsInfo']
        {
          ebs_optimized_support: 'ebs_optimized_support',
          encryption_support: 'encryption_support',
          ebs_optimized_info: EbsOptimizedInfo.default(visited),
          nvme_support: 'nvme_support',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ebsOptimizedSupport', stub[:ebs_optimized_support].to_s) unless stub[:ebs_optimized_support].nil?
        xml << Hearth::XML::Node.new('encryptionSupport', stub[:encryption_support].to_s) unless stub[:encryption_support].nil?
        xml << EbsOptimizedInfo.stub('ebsOptimizedInfo', stub[:ebs_optimized_info]) unless stub[:ebs_optimized_info].nil?
        xml << Hearth::XML::Node.new('nvmeSupport', stub[:nvme_support].to_s) unless stub[:nvme_support].nil?
        xml
      end
    end

    class EbsInstanceBlockDevice
      def self.default(visited = [])
        return nil if visited.include?('EbsInstanceBlockDevice')
        visited = visited + ['EbsInstanceBlockDevice']
        {
          attach_time: Time.now,
          delete_on_termination: false,
          status: 'status',
          volume_id: 'volume_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml
      end
    end

    class EbsOptimizedInfo
      def self.default(visited = [])
        return nil if visited.include?('EbsOptimizedInfo')
        visited = visited + ['EbsOptimizedInfo']
        {
          baseline_bandwidth_in_mbps: 1,
          baseline_throughput_in_m_bps: 1.0,
          baseline_iops: 1,
          maximum_bandwidth_in_mbps: 1,
          maximum_throughput_in_m_bps: 1.0,
          maximum_iops: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('baselineBandwidthInMbps', stub[:baseline_bandwidth_in_mbps].to_s) unless stub[:baseline_bandwidth_in_mbps].nil?
        xml << Hearth::XML::Node.new('baselineThroughputInMBps', Hearth::NumberHelper.serialize(stub[:baseline_throughput_in_m_bps]).to_s) unless stub[:baseline_throughput_in_m_bps].nil?
        xml << Hearth::XML::Node.new('baselineIops', stub[:baseline_iops].to_s) unless stub[:baseline_iops].nil?
        xml << Hearth::XML::Node.new('maximumBandwidthInMbps', stub[:maximum_bandwidth_in_mbps].to_s) unless stub[:maximum_bandwidth_in_mbps].nil?
        xml << Hearth::XML::Node.new('maximumThroughputInMBps', Hearth::NumberHelper.serialize(stub[:maximum_throughput_in_m_bps]).to_s) unless stub[:maximum_throughput_in_m_bps].nil?
        xml << Hearth::XML::Node.new('maximumIops', stub[:maximum_iops].to_s) unless stub[:maximum_iops].nil?
        xml
      end
    end

    class Ec2InstanceConnectEndpoint
      def self.default(visited = [])
        return nil if visited.include?('Ec2InstanceConnectEndpoint')
        visited = visited + ['Ec2InstanceConnectEndpoint']
        {
          owner_id: 'owner_id',
          instance_connect_endpoint_id: 'instance_connect_endpoint_id',
          instance_connect_endpoint_arn: 'instance_connect_endpoint_arn',
          state: 'state',
          state_message: 'state_message',
          dns_name: 'dns_name',
          fips_dns_name: 'fips_dns_name',
          network_interface_ids: NetworkInterfaceIdSet.default(visited),
          vpc_id: 'vpc_id',
          availability_zone: 'availability_zone',
          created_at: Time.now,
          subnet_id: 'subnet_id',
          preserve_client_ip: false,
          security_group_ids: SecurityGroupIdSet.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('instanceConnectEndpointId', stub[:instance_connect_endpoint_id].to_s) unless stub[:instance_connect_endpoint_id].nil?
        xml << Hearth::XML::Node.new('instanceConnectEndpointArn', stub[:instance_connect_endpoint_arn].to_s) unless stub[:instance_connect_endpoint_arn].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateMessage', stub[:state_message].to_s) unless stub[:state_message].nil?
        xml << Hearth::XML::Node.new('dnsName', stub[:dns_name].to_s) unless stub[:dns_name].nil?
        xml << Hearth::XML::Node.new('fipsDnsName', stub[:fips_dns_name].to_s) unless stub[:fips_dns_name].nil?
        xml << Hearth::XML::Node.new('networkInterfaceIdSet', NetworkInterfaceIdSet.stub('item', stub[:network_interface_ids])) unless stub[:network_interface_ids].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('createdAt', Hearth::TimeHelper.to_date_time(stub[:created_at])) unless stub[:created_at].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('preserveClientIp', stub[:preserve_client_ip].to_s) unless stub[:preserve_client_ip].nil?
        xml << Hearth::XML::Node.new('securityGroupIdSet', SecurityGroupIdSet.stub('item', stub[:security_group_ids])) unless stub[:security_group_ids].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class EfaInfo
      def self.default(visited = [])
        return nil if visited.include?('EfaInfo')
        visited = visited + ['EfaInfo']
        {
          maximum_efa_interfaces: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('maximumEfaInterfaces', stub[:maximum_efa_interfaces].to_s) unless stub[:maximum_efa_interfaces].nil?
        xml
      end
    end

    class EgressOnlyInternetGateway
      def self.default(visited = [])
        return nil if visited.include?('EgressOnlyInternetGateway')
        visited = visited + ['EgressOnlyInternetGateway']
        {
          attachments: InternetGatewayAttachmentList.default(visited),
          egress_only_internet_gateway_id: 'egress_only_internet_gateway_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachmentSet', InternetGatewayAttachmentList.stub('item', stub[:attachments])) unless stub[:attachments].nil?
        xml << Hearth::XML::Node.new('egressOnlyInternetGatewayId', stub[:egress_only_internet_gateway_id].to_s) unless stub[:egress_only_internet_gateway_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class EgressOnlyInternetGatewayList
      def self.default(visited = [])
        return nil if visited.include?('EgressOnlyInternetGatewayList')
        visited = visited + ['EgressOnlyInternetGatewayList']
        [
          EgressOnlyInternetGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << EgressOnlyInternetGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ElasticGpuAssociation
      def self.default(visited = [])
        return nil if visited.include?('ElasticGpuAssociation')
        visited = visited + ['ElasticGpuAssociation']
        {
          elastic_gpu_id: 'elastic_gpu_id',
          elastic_gpu_association_id: 'elastic_gpu_association_id',
          elastic_gpu_association_state: 'elastic_gpu_association_state',
          elastic_gpu_association_time: 'elastic_gpu_association_time',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('elasticGpuId', stub[:elastic_gpu_id].to_s) unless stub[:elastic_gpu_id].nil?
        xml << Hearth::XML::Node.new('elasticGpuAssociationId', stub[:elastic_gpu_association_id].to_s) unless stub[:elastic_gpu_association_id].nil?
        xml << Hearth::XML::Node.new('elasticGpuAssociationState', stub[:elastic_gpu_association_state].to_s) unless stub[:elastic_gpu_association_state].nil?
        xml << Hearth::XML::Node.new('elasticGpuAssociationTime', stub[:elastic_gpu_association_time].to_s) unless stub[:elastic_gpu_association_time].nil?
        xml
      end
    end

    class ElasticGpuAssociationList
      def self.default(visited = [])
        return nil if visited.include?('ElasticGpuAssociationList')
        visited = visited + ['ElasticGpuAssociationList']
        [
          ElasticGpuAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ElasticGpuAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ElasticGpuHealth
      def self.default(visited = [])
        return nil if visited.include?('ElasticGpuHealth')
        visited = visited + ['ElasticGpuHealth']
        {
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    class ElasticGpuSet
      def self.default(visited = [])
        return nil if visited.include?('ElasticGpuSet')
        visited = visited + ['ElasticGpuSet']
        [
          ElasticGpus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ElasticGpus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ElasticGpuSpecificationResponse
      def self.default(visited = [])
        return nil if visited.include?('ElasticGpuSpecificationResponse')
        visited = visited + ['ElasticGpuSpecificationResponse']
        {
          type: 'type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml
      end
    end

    class ElasticGpuSpecificationResponseList
      def self.default(visited = [])
        return nil if visited.include?('ElasticGpuSpecificationResponseList')
        visited = visited + ['ElasticGpuSpecificationResponseList']
        [
          ElasticGpuSpecificationResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ElasticGpuSpecificationResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ElasticGpus
      def self.default(visited = [])
        return nil if visited.include?('ElasticGpus')
        visited = visited + ['ElasticGpus']
        {
          elastic_gpu_id: 'elastic_gpu_id',
          availability_zone: 'availability_zone',
          elastic_gpu_type: 'elastic_gpu_type',
          elastic_gpu_health: ElasticGpuHealth.default(visited),
          elastic_gpu_state: 'elastic_gpu_state',
          instance_id: 'instance_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('elasticGpuId', stub[:elastic_gpu_id].to_s) unless stub[:elastic_gpu_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('elasticGpuType', stub[:elastic_gpu_type].to_s) unless stub[:elastic_gpu_type].nil?
        xml << ElasticGpuHealth.stub('elasticGpuHealth', stub[:elastic_gpu_health]) unless stub[:elastic_gpu_health].nil?
        xml << Hearth::XML::Node.new('elasticGpuState', stub[:elastic_gpu_state].to_s) unless stub[:elastic_gpu_state].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class ElasticInferenceAcceleratorAssociation
      def self.default(visited = [])
        return nil if visited.include?('ElasticInferenceAcceleratorAssociation')
        visited = visited + ['ElasticInferenceAcceleratorAssociation']
        {
          elastic_inference_accelerator_arn: 'elastic_inference_accelerator_arn',
          elastic_inference_accelerator_association_id: 'elastic_inference_accelerator_association_id',
          elastic_inference_accelerator_association_state: 'elastic_inference_accelerator_association_state',
          elastic_inference_accelerator_association_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorArn', stub[:elastic_inference_accelerator_arn].to_s) unless stub[:elastic_inference_accelerator_arn].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorAssociationId', stub[:elastic_inference_accelerator_association_id].to_s) unless stub[:elastic_inference_accelerator_association_id].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorAssociationState', stub[:elastic_inference_accelerator_association_state].to_s) unless stub[:elastic_inference_accelerator_association_state].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorAssociationTime', Hearth::TimeHelper.to_date_time(stub[:elastic_inference_accelerator_association_time])) unless stub[:elastic_inference_accelerator_association_time].nil?
        xml
      end
    end

    class ElasticInferenceAcceleratorAssociationList
      def self.default(visited = [])
        return nil if visited.include?('ElasticInferenceAcceleratorAssociationList')
        visited = visited + ['ElasticInferenceAcceleratorAssociationList']
        [
          ElasticInferenceAcceleratorAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ElasticInferenceAcceleratorAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class EnableAddressTransfer
      def self.build(params, context:)
        Params::EnableAddressTransferOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableAddressTransferOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          address_transfer: AddressTransfer.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableAddressTransferResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << AddressTransfer.stub('addressTransfer', stub[:address_transfer]) unless stub[:address_transfer].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableAwsNetworkPerformanceMetricSubscription
      def self.build(params, context:)
        Params::EnableAwsNetworkPerformanceMetricSubscriptionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableAwsNetworkPerformanceMetricSubscriptionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          output: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableAwsNetworkPerformanceMetricSubscriptionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('output', stub[:output].to_s) unless stub[:output].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableEbsEncryptionByDefault
      def self.build(params, context:)
        Params::EnableEbsEncryptionByDefaultOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableEbsEncryptionByDefaultOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ebs_encryption_by_default: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableEbsEncryptionByDefaultResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ebsEncryptionByDefault', stub[:ebs_encryption_by_default].to_s) unless stub[:ebs_encryption_by_default].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableFastLaunch
      def self.build(params, context:)
        Params::EnableFastLaunchOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableFastLaunchOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          image_id: 'image_id',
          resource_type: 'resource_type',
          snapshot_configuration: FastLaunchSnapshotConfigurationResponse.default(visited),
          launch_template: FastLaunchLaunchTemplateSpecificationResponse.default(visited),
          max_parallel_launches: 1,
          owner_id: 'owner_id',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          state_transition_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableFastLaunchResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << FastLaunchSnapshotConfigurationResponse.stub('snapshotConfiguration', stub[:snapshot_configuration]) unless stub[:snapshot_configuration].nil?
        xml << FastLaunchLaunchTemplateSpecificationResponse.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        xml << Hearth::XML::Node.new('maxParallelLaunches', stub[:max_parallel_launches].to_s) unless stub[:max_parallel_launches].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('stateTransitionTime', Hearth::TimeHelper.to_date_time(stub[:state_transition_time])) unless stub[:state_transition_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableFastSnapshotRestoreErrorItem
      def self.default(visited = [])
        return nil if visited.include?('EnableFastSnapshotRestoreErrorItem')
        visited = visited + ['EnableFastSnapshotRestoreErrorItem']
        {
          snapshot_id: 'snapshot_id',
          fast_snapshot_restore_state_errors: EnableFastSnapshotRestoreStateErrorSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('fastSnapshotRestoreStateErrorSet', EnableFastSnapshotRestoreStateErrorSet.stub('item', stub[:fast_snapshot_restore_state_errors])) unless stub[:fast_snapshot_restore_state_errors].nil?
        xml
      end
    end

    class EnableFastSnapshotRestoreErrorSet
      def self.default(visited = [])
        return nil if visited.include?('EnableFastSnapshotRestoreErrorSet')
        visited = visited + ['EnableFastSnapshotRestoreErrorSet']
        [
          EnableFastSnapshotRestoreErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << EnableFastSnapshotRestoreErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class EnableFastSnapshotRestoreStateError
      def self.default(visited = [])
        return nil if visited.include?('EnableFastSnapshotRestoreStateError')
        visited = visited + ['EnableFastSnapshotRestoreStateError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class EnableFastSnapshotRestoreStateErrorItem
      def self.default(visited = [])
        return nil if visited.include?('EnableFastSnapshotRestoreStateErrorItem')
        visited = visited + ['EnableFastSnapshotRestoreStateErrorItem']
        {
          availability_zone: 'availability_zone',
          error: EnableFastSnapshotRestoreStateError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << EnableFastSnapshotRestoreStateError.stub('error', stub[:error]) unless stub[:error].nil?
        xml
      end
    end

    class EnableFastSnapshotRestoreStateErrorSet
      def self.default(visited = [])
        return nil if visited.include?('EnableFastSnapshotRestoreStateErrorSet')
        visited = visited + ['EnableFastSnapshotRestoreStateErrorSet']
        [
          EnableFastSnapshotRestoreStateErrorItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << EnableFastSnapshotRestoreStateErrorItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class EnableFastSnapshotRestoreSuccessItem
      def self.default(visited = [])
        return nil if visited.include?('EnableFastSnapshotRestoreSuccessItem')
        visited = visited + ['EnableFastSnapshotRestoreSuccessItem']
        {
          snapshot_id: 'snapshot_id',
          availability_zone: 'availability_zone',
          state: 'state',
          state_transition_reason: 'state_transition_reason',
          owner_id: 'owner_id',
          owner_alias: 'owner_alias',
          enabling_time: Time.now,
          optimizing_time: Time.now,
          enabled_time: Time.now,
          disabling_time: Time.now,
          disabled_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateTransitionReason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('enablingTime', Hearth::TimeHelper.to_date_time(stub[:enabling_time])) unless stub[:enabling_time].nil?
        xml << Hearth::XML::Node.new('optimizingTime', Hearth::TimeHelper.to_date_time(stub[:optimizing_time])) unless stub[:optimizing_time].nil?
        xml << Hearth::XML::Node.new('enabledTime', Hearth::TimeHelper.to_date_time(stub[:enabled_time])) unless stub[:enabled_time].nil?
        xml << Hearth::XML::Node.new('disablingTime', Hearth::TimeHelper.to_date_time(stub[:disabling_time])) unless stub[:disabling_time].nil?
        xml << Hearth::XML::Node.new('disabledTime', Hearth::TimeHelper.to_date_time(stub[:disabled_time])) unless stub[:disabled_time].nil?
        xml
      end
    end

    class EnableFastSnapshotRestoreSuccessSet
      def self.default(visited = [])
        return nil if visited.include?('EnableFastSnapshotRestoreSuccessSet')
        visited = visited + ['EnableFastSnapshotRestoreSuccessSet']
        [
          EnableFastSnapshotRestoreSuccessItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << EnableFastSnapshotRestoreSuccessItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class EnableFastSnapshotRestores
      def self.build(params, context:)
        Params::EnableFastSnapshotRestoresOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableFastSnapshotRestoresOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successful: EnableFastSnapshotRestoreSuccessSet.default(visited),
          unsuccessful: EnableFastSnapshotRestoreErrorSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableFastSnapshotRestoresResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successful', EnableFastSnapshotRestoreSuccessSet.stub('item', stub[:successful])) unless stub[:successful].nil?
        xml << Hearth::XML::Node.new('unsuccessful', EnableFastSnapshotRestoreErrorSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableImageDeprecation
      def self.build(params, context:)
        Params::EnableImageDeprecationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableImageDeprecationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableImageDeprecationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableIpamOrganizationAdminAccount
      def self.build(params, context:)
        Params::EnableIpamOrganizationAdminAccountOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableIpamOrganizationAdminAccountOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          success: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableIpamOrganizationAdminAccountResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('success', stub[:success].to_s) unless stub[:success].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableReachabilityAnalyzerOrganizationSharing
      def self.build(params, context:)
        Params::EnableReachabilityAnalyzerOrganizationSharingOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableReachabilityAnalyzerOrganizationSharingOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableReachabilityAnalyzerOrganizationSharingResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('returnValue', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableSerialConsoleAccess
      def self.build(params, context:)
        Params::EnableSerialConsoleAccessOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableSerialConsoleAccessOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          serial_console_access_enabled: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableSerialConsoleAccessResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serialConsoleAccessEnabled', stub[:serial_console_access_enabled].to_s) unless stub[:serial_console_access_enabled].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableTransitGatewayRouteTablePropagation
      def self.build(params, context:)
        Params::EnableTransitGatewayRouteTablePropagationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableTransitGatewayRouteTablePropagationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          propagation: TransitGatewayPropagation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableTransitGatewayRouteTablePropagationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPropagation.stub('propagation', stub[:propagation]) unless stub[:propagation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableVgwRoutePropagation
      def self.build(params, context:)
        Params::EnableVgwRoutePropagationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableVgwRoutePropagationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableVgwRoutePropagationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableVolumeIO
      def self.build(params, context:)
        Params::EnableVolumeIOOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableVolumeIOOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableVolumeIOResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableVpcClassicLink
      def self.build(params, context:)
        Params::EnableVpcClassicLinkOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableVpcClassicLinkOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableVpcClassicLinkResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnableVpcClassicLinkDnsSupport
      def self.build(params, context:)
        Params::EnableVpcClassicLinkDnsSupportOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::EnableVpcClassicLinkDnsSupportOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('EnableVpcClassicLinkDnsSupportResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class EnclaveOptions
      def self.default(visited = [])
        return nil if visited.include?('EnclaveOptions')
        visited = visited + ['EnclaveOptions']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    class EndpointSet
      def self.default(visited = [])
        return nil if visited.include?('EndpointSet')
        visited = visited + ['EndpointSet']
        [
          ClientVpnEndpoint.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ClientVpnEndpoint.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ErrorSet
      def self.default(visited = [])
        return nil if visited.include?('ErrorSet')
        visited = visited + ['ErrorSet']
        [
          ValidationError.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ValidationError.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class EventInformation
      def self.default(visited = [])
        return nil if visited.include?('EventInformation')
        visited = visited + ['EventInformation']
        {
          event_description: 'event_description',
          event_sub_type: 'event_sub_type',
          instance_id: 'instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('eventDescription', stub[:event_description].to_s) unless stub[:event_description].nil?
        xml << Hearth::XML::Node.new('eventSubType', stub[:event_sub_type].to_s) unless stub[:event_sub_type].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml
      end
    end

    class ExcludedInstanceTypeSet
      def self.default(visited = [])
        return nil if visited.include?('ExcludedInstanceTypeSet')
        visited = visited + ['ExcludedInstanceTypeSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class Explanation
      def self.default(visited = [])
        return nil if visited.include?('Explanation')
        visited = visited + ['Explanation']
        {
          acl: AnalysisComponent.default(visited),
          acl_rule: AnalysisAclRule.default(visited),
          address: 'address',
          addresses: IpAddressList.default(visited),
          attached_to: AnalysisComponent.default(visited),
          availability_zones: ValueStringList.default(visited),
          cidrs: ValueStringList.default(visited),
          component: AnalysisComponent.default(visited),
          customer_gateway: AnalysisComponent.default(visited),
          destination: AnalysisComponent.default(visited),
          destination_vpc: AnalysisComponent.default(visited),
          direction: 'direction',
          explanation_code: 'explanation_code',
          ingress_route_table: AnalysisComponent.default(visited),
          internet_gateway: AnalysisComponent.default(visited),
          load_balancer_arn: 'load_balancer_arn',
          classic_load_balancer_listener: AnalysisLoadBalancerListener.default(visited),
          load_balancer_listener_port: 1,
          load_balancer_target: AnalysisLoadBalancerTarget.default(visited),
          load_balancer_target_group: AnalysisComponent.default(visited),
          load_balancer_target_groups: AnalysisComponentList.default(visited),
          load_balancer_target_port: 1,
          elastic_load_balancer_listener: AnalysisComponent.default(visited),
          missing_component: 'missing_component',
          nat_gateway: AnalysisComponent.default(visited),
          network_interface: AnalysisComponent.default(visited),
          packet_field: 'packet_field',
          vpc_peering_connection: AnalysisComponent.default(visited),
          port: 1,
          port_ranges: PortRangeList.default(visited),
          prefix_list: AnalysisComponent.default(visited),
          protocols: StringList.default(visited),
          route_table_route: AnalysisRouteTableRoute.default(visited),
          route_table: AnalysisComponent.default(visited),
          security_group: AnalysisComponent.default(visited),
          security_group_rule: AnalysisSecurityGroupRule.default(visited),
          security_groups: AnalysisComponentList.default(visited),
          source_vpc: AnalysisComponent.default(visited),
          state: 'state',
          subnet: AnalysisComponent.default(visited),
          subnet_route_table: AnalysisComponent.default(visited),
          vpc: AnalysisComponent.default(visited),
          vpc_endpoint: AnalysisComponent.default(visited),
          vpn_connection: AnalysisComponent.default(visited),
          vpn_gateway: AnalysisComponent.default(visited),
          transit_gateway: AnalysisComponent.default(visited),
          transit_gateway_route_table: AnalysisComponent.default(visited),
          transit_gateway_route_table_route: TransitGatewayRouteTableRoute.default(visited),
          transit_gateway_attachment: AnalysisComponent.default(visited),
          component_account: 'component_account',
          component_region: 'component_region',
          firewall_stateless_rule: FirewallStatelessRule.default(visited),
          firewall_stateful_rule: FirewallStatefulRule.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << AnalysisComponent.stub('acl', stub[:acl]) unless stub[:acl].nil?
        xml << AnalysisAclRule.stub('aclRule', stub[:acl_rule]) unless stub[:acl_rule].nil?
        xml << Hearth::XML::Node.new('address', stub[:address].to_s) unless stub[:address].nil?
        xml << Hearth::XML::Node.new('addressSet', IpAddressList.stub('item', stub[:addresses])) unless stub[:addresses].nil?
        xml << AnalysisComponent.stub('attachedTo', stub[:attached_to]) unless stub[:attached_to].nil?
        xml << Hearth::XML::Node.new('availabilityZoneSet', ValueStringList.stub('item', stub[:availability_zones])) unless stub[:availability_zones].nil?
        xml << Hearth::XML::Node.new('cidrSet', ValueStringList.stub('item', stub[:cidrs])) unless stub[:cidrs].nil?
        xml << AnalysisComponent.stub('component', stub[:component]) unless stub[:component].nil?
        xml << AnalysisComponent.stub('customerGateway', stub[:customer_gateway]) unless stub[:customer_gateway].nil?
        xml << AnalysisComponent.stub('destination', stub[:destination]) unless stub[:destination].nil?
        xml << AnalysisComponent.stub('destinationVpc', stub[:destination_vpc]) unless stub[:destination_vpc].nil?
        xml << Hearth::XML::Node.new('direction', stub[:direction].to_s) unless stub[:direction].nil?
        xml << Hearth::XML::Node.new('explanationCode', stub[:explanation_code].to_s) unless stub[:explanation_code].nil?
        xml << AnalysisComponent.stub('ingressRouteTable', stub[:ingress_route_table]) unless stub[:ingress_route_table].nil?
        xml << AnalysisComponent.stub('internetGateway', stub[:internet_gateway]) unless stub[:internet_gateway].nil?
        xml << Hearth::XML::Node.new('loadBalancerArn', stub[:load_balancer_arn].to_s) unless stub[:load_balancer_arn].nil?
        xml << AnalysisLoadBalancerListener.stub('classicLoadBalancerListener', stub[:classic_load_balancer_listener]) unless stub[:classic_load_balancer_listener].nil?
        xml << Hearth::XML::Node.new('loadBalancerListenerPort', stub[:load_balancer_listener_port].to_s) unless stub[:load_balancer_listener_port].nil?
        xml << AnalysisLoadBalancerTarget.stub('loadBalancerTarget', stub[:load_balancer_target]) unless stub[:load_balancer_target].nil?
        xml << AnalysisComponent.stub('loadBalancerTargetGroup', stub[:load_balancer_target_group]) unless stub[:load_balancer_target_group].nil?
        xml << Hearth::XML::Node.new('loadBalancerTargetGroupSet', AnalysisComponentList.stub('item', stub[:load_balancer_target_groups])) unless stub[:load_balancer_target_groups].nil?
        xml << Hearth::XML::Node.new('loadBalancerTargetPort', stub[:load_balancer_target_port].to_s) unless stub[:load_balancer_target_port].nil?
        xml << AnalysisComponent.stub('elasticLoadBalancerListener', stub[:elastic_load_balancer_listener]) unless stub[:elastic_load_balancer_listener].nil?
        xml << Hearth::XML::Node.new('missingComponent', stub[:missing_component].to_s) unless stub[:missing_component].nil?
        xml << AnalysisComponent.stub('natGateway', stub[:nat_gateway]) unless stub[:nat_gateway].nil?
        xml << AnalysisComponent.stub('networkInterface', stub[:network_interface]) unless stub[:network_interface].nil?
        xml << Hearth::XML::Node.new('packetField', stub[:packet_field].to_s) unless stub[:packet_field].nil?
        xml << AnalysisComponent.stub('vpcPeeringConnection', stub[:vpc_peering_connection]) unless stub[:vpc_peering_connection].nil?
        xml << Hearth::XML::Node.new('port', stub[:port].to_s) unless stub[:port].nil?
        xml << Hearth::XML::Node.new('portRangeSet', PortRangeList.stub('item', stub[:port_ranges])) unless stub[:port_ranges].nil?
        xml << AnalysisComponent.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        xml << Hearth::XML::Node.new('protocolSet', StringList.stub('item', stub[:protocols])) unless stub[:protocols].nil?
        xml << AnalysisRouteTableRoute.stub('routeTableRoute', stub[:route_table_route]) unless stub[:route_table_route].nil?
        xml << AnalysisComponent.stub('routeTable', stub[:route_table]) unless stub[:route_table].nil?
        xml << AnalysisComponent.stub('securityGroup', stub[:security_group]) unless stub[:security_group].nil?
        xml << AnalysisSecurityGroupRule.stub('securityGroupRule', stub[:security_group_rule]) unless stub[:security_group_rule].nil?
        xml << Hearth::XML::Node.new('securityGroupSet', AnalysisComponentList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << AnalysisComponent.stub('sourceVpc', stub[:source_vpc]) unless stub[:source_vpc].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << AnalysisComponent.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        xml << AnalysisComponent.stub('subnetRouteTable', stub[:subnet_route_table]) unless stub[:subnet_route_table].nil?
        xml << AnalysisComponent.stub('vpc', stub[:vpc]) unless stub[:vpc].nil?
        xml << AnalysisComponent.stub('vpcEndpoint', stub[:vpc_endpoint]) unless stub[:vpc_endpoint].nil?
        xml << AnalysisComponent.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        xml << AnalysisComponent.stub('vpnGateway', stub[:vpn_gateway]) unless stub[:vpn_gateway].nil?
        xml << AnalysisComponent.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        xml << AnalysisComponent.stub('transitGatewayRouteTable', stub[:transit_gateway_route_table]) unless stub[:transit_gateway_route_table].nil?
        xml << TransitGatewayRouteTableRoute.stub('transitGatewayRouteTableRoute', stub[:transit_gateway_route_table_route]) unless stub[:transit_gateway_route_table_route].nil?
        xml << AnalysisComponent.stub('transitGatewayAttachment', stub[:transit_gateway_attachment]) unless stub[:transit_gateway_attachment].nil?
        xml << Hearth::XML::Node.new('componentAccount', stub[:component_account].to_s) unless stub[:component_account].nil?
        xml << Hearth::XML::Node.new('componentRegion', stub[:component_region].to_s) unless stub[:component_region].nil?
        xml << FirewallStatelessRule.stub('firewallStatelessRule', stub[:firewall_stateless_rule]) unless stub[:firewall_stateless_rule].nil?
        xml << FirewallStatefulRule.stub('firewallStatefulRule', stub[:firewall_stateful_rule]) unless stub[:firewall_stateful_rule].nil?
        xml
      end
    end

    class ExplanationList
      def self.default(visited = [])
        return nil if visited.include?('ExplanationList')
        visited = visited + ['ExplanationList']
        [
          Explanation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Explanation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ExportClientVpnClientCertificateRevocationList
      def self.build(params, context:)
        Params::ExportClientVpnClientCertificateRevocationListOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ExportClientVpnClientCertificateRevocationListOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          certificate_revocation_list: 'certificate_revocation_list',
          status: ClientCertificateRevocationListStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ExportClientVpnClientCertificateRevocationListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('certificateRevocationList', stub[:certificate_revocation_list].to_s) unless stub[:certificate_revocation_list].nil?
        xml << ClientCertificateRevocationListStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ExportClientVpnClientConfiguration
      def self.build(params, context:)
        Params::ExportClientVpnClientConfigurationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ExportClientVpnClientConfigurationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          client_configuration: 'client_configuration',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ExportClientVpnClientConfigurationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientConfiguration', stub[:client_configuration].to_s) unless stub[:client_configuration].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ExportImage
      def self.build(params, context:)
        Params::ExportImageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ExportImageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          description: 'description',
          disk_image_format: 'disk_image_format',
          export_image_task_id: 'export_image_task_id',
          image_id: 'image_id',
          role_name: 'role_name',
          progress: 'progress',
          s3_export_location: ExportTaskS3Location.default(visited),
          status: 'status',
          status_message: 'status_message',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ExportImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('diskImageFormat', stub[:disk_image_format].to_s) unless stub[:disk_image_format].nil?
        xml << Hearth::XML::Node.new('exportImageTaskId', stub[:export_image_task_id].to_s) unless stub[:export_image_task_id].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('roleName', stub[:role_name].to_s) unless stub[:role_name].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << ExportTaskS3Location.stub('s3ExportLocation', stub[:s3_export_location]) unless stub[:s3_export_location].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ExportImageTask
      def self.default(visited = [])
        return nil if visited.include?('ExportImageTask')
        visited = visited + ['ExportImageTask']
        {
          description: 'description',
          export_image_task_id: 'export_image_task_id',
          image_id: 'image_id',
          progress: 'progress',
          s3_export_location: ExportTaskS3Location.default(visited),
          status: 'status',
          status_message: 'status_message',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('exportImageTaskId', stub[:export_image_task_id].to_s) unless stub[:export_image_task_id].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << ExportTaskS3Location.stub('s3ExportLocation', stub[:s3_export_location]) unless stub[:s3_export_location].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class ExportImageTaskList
      def self.default(visited = [])
        return nil if visited.include?('ExportImageTaskList')
        visited = visited + ['ExportImageTaskList']
        [
          ExportImageTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ExportImageTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ExportTask
      def self.default(visited = [])
        return nil if visited.include?('ExportTask')
        visited = visited + ['ExportTask']
        {
          description: 'description',
          export_task_id: 'export_task_id',
          export_to_s3_task: ExportToS3Task.default(visited),
          instance_export_details: InstanceExportDetails.default(visited),
          state: 'state',
          status_message: 'status_message',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('exportTaskId', stub[:export_task_id].to_s) unless stub[:export_task_id].nil?
        xml << ExportToS3Task.stub('exportToS3', stub[:export_to_s3_task]) unless stub[:export_to_s3_task].nil?
        xml << InstanceExportDetails.stub('instanceExport', stub[:instance_export_details]) unless stub[:instance_export_details].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class ExportTaskList
      def self.default(visited = [])
        return nil if visited.include?('ExportTaskList')
        visited = visited + ['ExportTaskList']
        [
          ExportTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ExportTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ExportTaskS3Location
      def self.default(visited = [])
        return nil if visited.include?('ExportTaskS3Location')
        visited = visited + ['ExportTaskS3Location']
        {
          s3_bucket: 's3_bucket',
          s3_prefix: 's3_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('s3Bucket', stub[:s3_bucket].to_s) unless stub[:s3_bucket].nil?
        xml << Hearth::XML::Node.new('s3Prefix', stub[:s3_prefix].to_s) unless stub[:s3_prefix].nil?
        xml
      end
    end

    class ExportToS3Task
      def self.default(visited = [])
        return nil if visited.include?('ExportToS3Task')
        visited = visited + ['ExportToS3Task']
        {
          container_format: 'container_format',
          disk_image_format: 'disk_image_format',
          s3_bucket: 's3_bucket',
          s3_key: 's3_key',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('containerFormat', stub[:container_format].to_s) unless stub[:container_format].nil?
        xml << Hearth::XML::Node.new('diskImageFormat', stub[:disk_image_format].to_s) unless stub[:disk_image_format].nil?
        xml << Hearth::XML::Node.new('s3Bucket', stub[:s3_bucket].to_s) unless stub[:s3_bucket].nil?
        xml << Hearth::XML::Node.new('s3Key', stub[:s3_key].to_s) unless stub[:s3_key].nil?
        xml
      end
    end

    class ExportTransitGatewayRoutes
      def self.build(params, context:)
        Params::ExportTransitGatewayRoutesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ExportTransitGatewayRoutesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          s3_location: 's3_location',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ExportTransitGatewayRoutesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('s3Location', stub[:s3_location].to_s) unless stub[:s3_location].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class FailedCapacityReservationFleetCancellationResult
      def self.default(visited = [])
        return nil if visited.include?('FailedCapacityReservationFleetCancellationResult')
        visited = visited + ['FailedCapacityReservationFleetCancellationResult']
        {
          capacity_reservation_fleet_id: 'capacity_reservation_fleet_id',
          cancel_capacity_reservation_fleet_error: CancelCapacityReservationFleetError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationFleetId', stub[:capacity_reservation_fleet_id].to_s) unless stub[:capacity_reservation_fleet_id].nil?
        xml << CancelCapacityReservationFleetError.stub('cancelCapacityReservationFleetError', stub[:cancel_capacity_reservation_fleet_error]) unless stub[:cancel_capacity_reservation_fleet_error].nil?
        xml
      end
    end

    class FailedCapacityReservationFleetCancellationResultSet
      def self.default(visited = [])
        return nil if visited.include?('FailedCapacityReservationFleetCancellationResultSet')
        visited = visited + ['FailedCapacityReservationFleetCancellationResultSet']
        [
          FailedCapacityReservationFleetCancellationResult.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FailedCapacityReservationFleetCancellationResult.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class FailedQueuedPurchaseDeletion
      def self.default(visited = [])
        return nil if visited.include?('FailedQueuedPurchaseDeletion')
        visited = visited + ['FailedQueuedPurchaseDeletion']
        {
          error: DeleteQueuedReservedInstancesError.default(visited),
          reserved_instances_id: 'reserved_instances_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << DeleteQueuedReservedInstancesError.stub('error', stub[:error]) unless stub[:error].nil?
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml
      end
    end

    class FailedQueuedPurchaseDeletionSet
      def self.default(visited = [])
        return nil if visited.include?('FailedQueuedPurchaseDeletionSet')
        visited = visited + ['FailedQueuedPurchaseDeletionSet']
        [
          FailedQueuedPurchaseDeletion.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FailedQueuedPurchaseDeletion.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class FastLaunchLaunchTemplateSpecificationResponse
      def self.default(visited = [])
        return nil if visited.include?('FastLaunchLaunchTemplateSpecificationResponse')
        visited = visited + ['FastLaunchLaunchTemplateSpecificationResponse']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version: 'version',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('version', stub[:version].to_s) unless stub[:version].nil?
        xml
      end
    end

    class FastLaunchSnapshotConfigurationResponse
      def self.default(visited = [])
        return nil if visited.include?('FastLaunchSnapshotConfigurationResponse')
        visited = visited + ['FastLaunchSnapshotConfigurationResponse']
        {
          target_resource_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('targetResourceCount', stub[:target_resource_count].to_s) unless stub[:target_resource_count].nil?
        xml
      end
    end

    class FederatedAuthentication
      def self.default(visited = [])
        return nil if visited.include?('FederatedAuthentication')
        visited = visited + ['FederatedAuthentication']
        {
          saml_provider_arn: 'saml_provider_arn',
          self_service_saml_provider_arn: 'self_service_saml_provider_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('samlProviderArn', stub[:saml_provider_arn].to_s) unless stub[:saml_provider_arn].nil?
        xml << Hearth::XML::Node.new('selfServiceSamlProviderArn', stub[:self_service_saml_provider_arn].to_s) unless stub[:self_service_saml_provider_arn].nil?
        xml
      end
    end

    class FilterPortRange
      def self.default(visited = [])
        return nil if visited.include?('FilterPortRange')
        visited = visited + ['FilterPortRange']
        {
          from_port: 1,
          to_port: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fromPort', stub[:from_port].to_s) unless stub[:from_port].nil?
        xml << Hearth::XML::Node.new('toPort', stub[:to_port].to_s) unless stub[:to_port].nil?
        xml
      end
    end

    class FirewallStatefulRule
      def self.default(visited = [])
        return nil if visited.include?('FirewallStatefulRule')
        visited = visited + ['FirewallStatefulRule']
        {
          rule_group_arn: 'rule_group_arn',
          sources: ValueStringList.default(visited),
          destinations: ValueStringList.default(visited),
          source_ports: PortRangeList.default(visited),
          destination_ports: PortRangeList.default(visited),
          protocol: 'protocol',
          rule_action: 'rule_action',
          direction: 'direction',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ruleGroupArn', stub[:rule_group_arn].to_s) unless stub[:rule_group_arn].nil?
        xml << Hearth::XML::Node.new('sourceSet', ValueStringList.stub('item', stub[:sources])) unless stub[:sources].nil?
        xml << Hearth::XML::Node.new('destinationSet', ValueStringList.stub('item', stub[:destinations])) unless stub[:destinations].nil?
        xml << Hearth::XML::Node.new('sourcePortSet', PortRangeList.stub('item', stub[:source_ports])) unless stub[:source_ports].nil?
        xml << Hearth::XML::Node.new('destinationPortSet', PortRangeList.stub('item', stub[:destination_ports])) unless stub[:destination_ports].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('ruleAction', stub[:rule_action].to_s) unless stub[:rule_action].nil?
        xml << Hearth::XML::Node.new('direction', stub[:direction].to_s) unless stub[:direction].nil?
        xml
      end
    end

    class FirewallStatelessRule
      def self.default(visited = [])
        return nil if visited.include?('FirewallStatelessRule')
        visited = visited + ['FirewallStatelessRule']
        {
          rule_group_arn: 'rule_group_arn',
          sources: ValueStringList.default(visited),
          destinations: ValueStringList.default(visited),
          source_ports: PortRangeList.default(visited),
          destination_ports: PortRangeList.default(visited),
          protocols: ProtocolIntList.default(visited),
          rule_action: 'rule_action',
          priority: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ruleGroupArn', stub[:rule_group_arn].to_s) unless stub[:rule_group_arn].nil?
        xml << Hearth::XML::Node.new('sourceSet', ValueStringList.stub('item', stub[:sources])) unless stub[:sources].nil?
        xml << Hearth::XML::Node.new('destinationSet', ValueStringList.stub('item', stub[:destinations])) unless stub[:destinations].nil?
        xml << Hearth::XML::Node.new('sourcePortSet', PortRangeList.stub('item', stub[:source_ports])) unless stub[:source_ports].nil?
        xml << Hearth::XML::Node.new('destinationPortSet', PortRangeList.stub('item', stub[:destination_ports])) unless stub[:destination_ports].nil?
        xml << Hearth::XML::Node.new('protocolSet', ProtocolIntList.stub('item', stub[:protocols])) unless stub[:protocols].nil?
        xml << Hearth::XML::Node.new('ruleAction', stub[:rule_action].to_s) unless stub[:rule_action].nil?
        xml << Hearth::XML::Node.new('priority', stub[:priority].to_s) unless stub[:priority].nil?
        xml
      end
    end

    class FleetCapacityReservation
      def self.default(visited = [])
        return nil if visited.include?('FleetCapacityReservation')
        visited = visited + ['FleetCapacityReservation']
        {
          capacity_reservation_id: 'capacity_reservation_id',
          availability_zone_id: 'availability_zone_id',
          instance_type: 'instance_type',
          instance_platform: 'instance_platform',
          availability_zone: 'availability_zone',
          total_instance_count: 1,
          fulfilled_capacity: 1.0,
          ebs_optimized: false,
          create_date: Time.now,
          weight: 1.0,
          priority: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('instancePlatform', stub[:instance_platform].to_s) unless stub[:instance_platform].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('totalInstanceCount', stub[:total_instance_count].to_s) unless stub[:total_instance_count].nil?
        xml << Hearth::XML::Node.new('fulfilledCapacity', Hearth::NumberHelper.serialize(stub[:fulfilled_capacity]).to_s) unless stub[:fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('weight', Hearth::NumberHelper.serialize(stub[:weight]).to_s) unless stub[:weight].nil?
        xml << Hearth::XML::Node.new('priority', stub[:priority].to_s) unless stub[:priority].nil?
        xml
      end
    end

    class FleetCapacityReservationSet
      def self.default(visited = [])
        return nil if visited.include?('FleetCapacityReservationSet')
        visited = visited + ['FleetCapacityReservationSet']
        [
          FleetCapacityReservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FleetCapacityReservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class FleetData
      def self.default(visited = [])
        return nil if visited.include?('FleetData')
        visited = visited + ['FleetData']
        {
          activity_status: 'activity_status',
          create_time: Time.now,
          fleet_id: 'fleet_id',
          fleet_state: 'fleet_state',
          client_token: 'client_token',
          excess_capacity_termination_policy: 'excess_capacity_termination_policy',
          fulfilled_capacity: 1.0,
          fulfilled_on_demand_capacity: 1.0,
          launch_template_configs: FleetLaunchTemplateConfigList.default(visited),
          target_capacity_specification: TargetCapacitySpecification.default(visited),
          terminate_instances_with_expiration: false,
          type: 'type',
          valid_from: Time.now,
          valid_until: Time.now,
          replace_unhealthy_instances: false,
          spot_options: SpotOptions.default(visited),
          on_demand_options: OnDemandOptions.default(visited),
          tags: TagList.default(visited),
          errors: DescribeFleetsErrorSet.default(visited),
          instances: DescribeFleetsInstancesSet.default(visited),
          context: 'context',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('activityStatus', stub[:activity_status].to_s) unless stub[:activity_status].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('fleetId', stub[:fleet_id].to_s) unless stub[:fleet_id].nil?
        xml << Hearth::XML::Node.new('fleetState', stub[:fleet_state].to_s) unless stub[:fleet_state].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('excessCapacityTerminationPolicy', stub[:excess_capacity_termination_policy].to_s) unless stub[:excess_capacity_termination_policy].nil?
        xml << Hearth::XML::Node.new('fulfilledCapacity', Hearth::NumberHelper.serialize(stub[:fulfilled_capacity]).to_s) unless stub[:fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('fulfilledOnDemandCapacity', Hearth::NumberHelper.serialize(stub[:fulfilled_on_demand_capacity]).to_s) unless stub[:fulfilled_on_demand_capacity].nil?
        xml << Hearth::XML::Node.new('launchTemplateConfigs', FleetLaunchTemplateConfigList.stub('item', stub[:launch_template_configs])) unless stub[:launch_template_configs].nil?
        xml << TargetCapacitySpecification.stub('targetCapacitySpecification', stub[:target_capacity_specification]) unless stub[:target_capacity_specification].nil?
        xml << Hearth::XML::Node.new('terminateInstancesWithExpiration', stub[:terminate_instances_with_expiration].to_s) unless stub[:terminate_instances_with_expiration].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('validFrom', Hearth::TimeHelper.to_date_time(stub[:valid_from])) unless stub[:valid_from].nil?
        xml << Hearth::XML::Node.new('validUntil', Hearth::TimeHelper.to_date_time(stub[:valid_until])) unless stub[:valid_until].nil?
        xml << Hearth::XML::Node.new('replaceUnhealthyInstances', stub[:replace_unhealthy_instances].to_s) unless stub[:replace_unhealthy_instances].nil?
        xml << SpotOptions.stub('spotOptions', stub[:spot_options]) unless stub[:spot_options].nil?
        xml << OnDemandOptions.stub('onDemandOptions', stub[:on_demand_options]) unless stub[:on_demand_options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('errorSet', DescribeFleetsErrorSet.stub('item', stub[:errors])) unless stub[:errors].nil?
        xml << Hearth::XML::Node.new('fleetInstanceSet', DescribeFleetsInstancesSet.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('context', stub[:context].to_s) unless stub[:context].nil?
        xml
      end
    end

    class FleetLaunchTemplateConfig
      def self.default(visited = [])
        return nil if visited.include?('FleetLaunchTemplateConfig')
        visited = visited + ['FleetLaunchTemplateConfig']
        {
          launch_template_specification: FleetLaunchTemplateSpecification.default(visited),
          overrides: FleetLaunchTemplateOverridesList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << FleetLaunchTemplateSpecification.stub('launchTemplateSpecification', stub[:launch_template_specification]) unless stub[:launch_template_specification].nil?
        xml << Hearth::XML::Node.new('overrides', FleetLaunchTemplateOverridesList.stub('item', stub[:overrides])) unless stub[:overrides].nil?
        xml
      end
    end

    class FleetLaunchTemplateConfigList
      def self.default(visited = [])
        return nil if visited.include?('FleetLaunchTemplateConfigList')
        visited = visited + ['FleetLaunchTemplateConfigList']
        [
          FleetLaunchTemplateConfig.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FleetLaunchTemplateConfig.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class FleetLaunchTemplateOverrides
      def self.default(visited = [])
        return nil if visited.include?('FleetLaunchTemplateOverrides')
        visited = visited + ['FleetLaunchTemplateOverrides']
        {
          instance_type: 'instance_type',
          max_price: 'max_price',
          subnet_id: 'subnet_id',
          availability_zone: 'availability_zone',
          weighted_capacity: 1.0,
          priority: 1.0,
          placement: PlacementResponse.default(visited),
          instance_requirements: InstanceRequirements.default(visited),
          image_id: 'image_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('maxPrice', stub[:max_price].to_s) unless stub[:max_price].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('weightedCapacity', Hearth::NumberHelper.serialize(stub[:weighted_capacity]).to_s) unless stub[:weighted_capacity].nil?
        xml << Hearth::XML::Node.new('priority', Hearth::NumberHelper.serialize(stub[:priority]).to_s) unless stub[:priority].nil?
        xml << PlacementResponse.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << InstanceRequirements.stub('instanceRequirements', stub[:instance_requirements]) unless stub[:instance_requirements].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml
      end
    end

    class FleetLaunchTemplateOverridesList
      def self.default(visited = [])
        return nil if visited.include?('FleetLaunchTemplateOverridesList')
        visited = visited + ['FleetLaunchTemplateOverridesList']
        [
          FleetLaunchTemplateOverrides.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FleetLaunchTemplateOverrides.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class FleetLaunchTemplateSpecification
      def self.default(visited = [])
        return nil if visited.include?('FleetLaunchTemplateSpecification')
        visited = visited + ['FleetLaunchTemplateSpecification']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version: 'version',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('version', stub[:version].to_s) unless stub[:version].nil?
        xml
      end
    end

    class FleetSet
      def self.default(visited = [])
        return nil if visited.include?('FleetSet')
        visited = visited + ['FleetSet']
        [
          FleetData.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FleetData.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class FleetSpotCapacityRebalance
      def self.default(visited = [])
        return nil if visited.include?('FleetSpotCapacityRebalance')
        visited = visited + ['FleetSpotCapacityRebalance']
        {
          replacement_strategy: 'replacement_strategy',
          termination_delay: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('replacementStrategy', stub[:replacement_strategy].to_s) unless stub[:replacement_strategy].nil?
        xml << Hearth::XML::Node.new('terminationDelay', stub[:termination_delay].to_s) unless stub[:termination_delay].nil?
        xml
      end
    end

    class FleetSpotMaintenanceStrategies
      def self.default(visited = [])
        return nil if visited.include?('FleetSpotMaintenanceStrategies')
        visited = visited + ['FleetSpotMaintenanceStrategies']
        {
          capacity_rebalance: FleetSpotCapacityRebalance.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << FleetSpotCapacityRebalance.stub('capacityRebalance', stub[:capacity_rebalance]) unless stub[:capacity_rebalance].nil?
        xml
      end
    end

    class FlowLog
      def self.default(visited = [])
        return nil if visited.include?('FlowLog')
        visited = visited + ['FlowLog']
        {
          creation_time: Time.now,
          deliver_logs_error_message: 'deliver_logs_error_message',
          deliver_logs_permission_arn: 'deliver_logs_permission_arn',
          deliver_cross_account_role: 'deliver_cross_account_role',
          deliver_logs_status: 'deliver_logs_status',
          flow_log_id: 'flow_log_id',
          flow_log_status: 'flow_log_status',
          log_group_name: 'log_group_name',
          resource_id: 'resource_id',
          traffic_type: 'traffic_type',
          log_destination_type: 'log_destination_type',
          log_destination: 'log_destination',
          log_format: 'log_format',
          tags: TagList.default(visited),
          max_aggregation_interval: 1,
          destination_options: DestinationOptionsResponse.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('deliverLogsErrorMessage', stub[:deliver_logs_error_message].to_s) unless stub[:deliver_logs_error_message].nil?
        xml << Hearth::XML::Node.new('deliverLogsPermissionArn', stub[:deliver_logs_permission_arn].to_s) unless stub[:deliver_logs_permission_arn].nil?
        xml << Hearth::XML::Node.new('deliverCrossAccountRole', stub[:deliver_cross_account_role].to_s) unless stub[:deliver_cross_account_role].nil?
        xml << Hearth::XML::Node.new('deliverLogsStatus', stub[:deliver_logs_status].to_s) unless stub[:deliver_logs_status].nil?
        xml << Hearth::XML::Node.new('flowLogId', stub[:flow_log_id].to_s) unless stub[:flow_log_id].nil?
        xml << Hearth::XML::Node.new('flowLogStatus', stub[:flow_log_status].to_s) unless stub[:flow_log_status].nil?
        xml << Hearth::XML::Node.new('logGroupName', stub[:log_group_name].to_s) unless stub[:log_group_name].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('trafficType', stub[:traffic_type].to_s) unless stub[:traffic_type].nil?
        xml << Hearth::XML::Node.new('logDestinationType', stub[:log_destination_type].to_s) unless stub[:log_destination_type].nil?
        xml << Hearth::XML::Node.new('logDestination', stub[:log_destination].to_s) unless stub[:log_destination].nil?
        xml << Hearth::XML::Node.new('logFormat', stub[:log_format].to_s) unless stub[:log_format].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('maxAggregationInterval', stub[:max_aggregation_interval].to_s) unless stub[:max_aggregation_interval].nil?
        xml << DestinationOptionsResponse.stub('destinationOptions', stub[:destination_options]) unless stub[:destination_options].nil?
        xml
      end
    end

    class FlowLogSet
      def self.default(visited = [])
        return nil if visited.include?('FlowLogSet')
        visited = visited + ['FlowLogSet']
        [
          FlowLog.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FlowLog.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class FpgaDeviceInfo
      def self.default(visited = [])
        return nil if visited.include?('FpgaDeviceInfo')
        visited = visited + ['FpgaDeviceInfo']
        {
          name: 'name',
          manufacturer: 'manufacturer',
          count: 1,
          memory_info: FpgaDeviceMemoryInfo.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('manufacturer', stub[:manufacturer].to_s) unless stub[:manufacturer].nil?
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << FpgaDeviceMemoryInfo.stub('memoryInfo', stub[:memory_info]) unless stub[:memory_info].nil?
        xml
      end
    end

    class FpgaDeviceInfoList
      def self.default(visited = [])
        return nil if visited.include?('FpgaDeviceInfoList')
        visited = visited + ['FpgaDeviceInfoList']
        [
          FpgaDeviceInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FpgaDeviceInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class FpgaDeviceMemoryInfo
      def self.default(visited = [])
        return nil if visited.include?('FpgaDeviceMemoryInfo')
        visited = visited + ['FpgaDeviceMemoryInfo']
        {
          size_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sizeInMiB', stub[:size_in_mi_b].to_s) unless stub[:size_in_mi_b].nil?
        xml
      end
    end

    class FpgaImage
      def self.default(visited = [])
        return nil if visited.include?('FpgaImage')
        visited = visited + ['FpgaImage']
        {
          fpga_image_id: 'fpga_image_id',
          fpga_image_global_id: 'fpga_image_global_id',
          name: 'name',
          description: 'description',
          shell_version: 'shell_version',
          pci_id: PciId.default(visited),
          state: FpgaImageState.default(visited),
          create_time: Time.now,
          update_time: Time.now,
          owner_id: 'owner_id',
          owner_alias: 'owner_alias',
          product_codes: ProductCodeList.default(visited),
          tags: TagList.default(visited),
          public: false,
          data_retention_support: false,
          instance_types: InstanceTypesList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fpgaImageId', stub[:fpga_image_id].to_s) unless stub[:fpga_image_id].nil?
        xml << Hearth::XML::Node.new('fpgaImageGlobalId', stub[:fpga_image_global_id].to_s) unless stub[:fpga_image_global_id].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('shellVersion', stub[:shell_version].to_s) unless stub[:shell_version].nil?
        xml << PciId.stub('pciId', stub[:pci_id]) unless stub[:pci_id].nil?
        xml << FpgaImageState.stub('state', stub[:state]) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('updateTime', Hearth::TimeHelper.to_date_time(stub[:update_time])) unless stub[:update_time].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('tags', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('public', stub[:public].to_s) unless stub[:public].nil?
        xml << Hearth::XML::Node.new('dataRetentionSupport', stub[:data_retention_support].to_s) unless stub[:data_retention_support].nil?
        xml << Hearth::XML::Node.new('instanceTypes', InstanceTypesList.stub('item', stub[:instance_types])) unless stub[:instance_types].nil?
        xml
      end
    end

    class FpgaImageAttribute
      def self.default(visited = [])
        return nil if visited.include?('FpgaImageAttribute')
        visited = visited + ['FpgaImageAttribute']
        {
          fpga_image_id: 'fpga_image_id',
          name: 'name',
          description: 'description',
          load_permissions: LoadPermissionList.default(visited),
          product_codes: ProductCodeList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fpgaImageId', stub[:fpga_image_id].to_s) unless stub[:fpga_image_id].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('loadPermissions', LoadPermissionList.stub('item', stub[:load_permissions])) unless stub[:load_permissions].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml
      end
    end

    class FpgaImageList
      def self.default(visited = [])
        return nil if visited.include?('FpgaImageList')
        visited = visited + ['FpgaImageList']
        [
          FpgaImage.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << FpgaImage.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class FpgaImageState
      def self.default(visited = [])
        return nil if visited.include?('FpgaImageState')
        visited = visited + ['FpgaImageState']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class FpgaInfo
      def self.default(visited = [])
        return nil if visited.include?('FpgaInfo')
        visited = visited + ['FpgaInfo']
        {
          fpgas: FpgaDeviceInfoList.default(visited),
          total_fpga_memory_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fpgas', FpgaDeviceInfoList.stub('item', stub[:fpgas])) unless stub[:fpgas].nil?
        xml << Hearth::XML::Node.new('totalFpgaMemoryInMiB', stub[:total_fpga_memory_in_mi_b].to_s) unless stub[:total_fpga_memory_in_mi_b].nil?
        xml
      end
    end

    class GetAssociatedEnclaveCertificateIamRoles
      def self.build(params, context:)
        Params::GetAssociatedEnclaveCertificateIamRolesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetAssociatedEnclaveCertificateIamRolesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          associated_roles: AssociatedRolesList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetAssociatedEnclaveCertificateIamRolesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associatedRoleSet', AssociatedRolesList.stub('item', stub[:associated_roles])) unless stub[:associated_roles].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetAssociatedIpv6PoolCidrs
      def self.build(params, context:)
        Params::GetAssociatedIpv6PoolCidrsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetAssociatedIpv6PoolCidrsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipv6_cidr_associations: Ipv6CidrAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetAssociatedIpv6PoolCidrsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipv6CidrAssociationSet', Ipv6CidrAssociationSet.stub('item', stub[:ipv6_cidr_associations])) unless stub[:ipv6_cidr_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetAwsNetworkPerformanceData
      def self.build(params, context:)
        Params::GetAwsNetworkPerformanceDataOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetAwsNetworkPerformanceDataOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          data_responses: DataResponses.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetAwsNetworkPerformanceDataResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('dataResponseSet', DataResponses.stub('item', stub[:data_responses])) unless stub[:data_responses].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetCapacityReservationUsage
      def self.build(params, context:)
        Params::GetCapacityReservationUsageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetCapacityReservationUsageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          capacity_reservation_id: 'capacity_reservation_id',
          instance_type: 'instance_type',
          total_instance_count: 1,
          available_instance_count: 1,
          state: 'state',
          instance_usages: InstanceUsageSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetCapacityReservationUsageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('totalInstanceCount', stub[:total_instance_count].to_s) unless stub[:total_instance_count].nil?
        xml << Hearth::XML::Node.new('availableInstanceCount', stub[:available_instance_count].to_s) unless stub[:available_instance_count].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('instanceUsageSet', InstanceUsageSet.stub('item', stub[:instance_usages])) unless stub[:instance_usages].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetCoipPoolUsage
      def self.build(params, context:)
        Params::GetCoipPoolUsageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetCoipPoolUsageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          coip_pool_id: 'coip_pool_id',
          coip_address_usages: CoipAddressUsageSet.default(visited),
          local_gateway_route_table_id: 'local_gateway_route_table_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetCoipPoolUsageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('coipPoolId', stub[:coip_pool_id].to_s) unless stub[:coip_pool_id].nil?
        xml << Hearth::XML::Node.new('coipAddressUsageSet', CoipAddressUsageSet.stub('item', stub[:coip_address_usages])) unless stub[:coip_address_usages].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetConsoleOutput
      def self.build(params, context:)
        Params::GetConsoleOutputOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetConsoleOutputOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_id: 'instance_id',
          output: 'output',
          timestamp: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetConsoleOutputResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('output', stub[:output].to_s) unless stub[:output].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetConsoleScreenshot
      def self.build(params, context:)
        Params::GetConsoleScreenshotOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetConsoleScreenshotOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          image_data: 'image_data',
          instance_id: 'instance_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetConsoleScreenshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageData', stub[:image_data].to_s) unless stub[:image_data].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetDefaultCreditSpecification
      def self.build(params, context:)
        Params::GetDefaultCreditSpecificationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetDefaultCreditSpecificationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_family_credit_specification: InstanceFamilyCreditSpecification.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetDefaultCreditSpecificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceFamilyCreditSpecification.stub('instanceFamilyCreditSpecification', stub[:instance_family_credit_specification]) unless stub[:instance_family_credit_specification].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetEbsDefaultKmsKeyId
      def self.build(params, context:)
        Params::GetEbsDefaultKmsKeyIdOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetEbsDefaultKmsKeyIdOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          kms_key_id: 'kms_key_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetEbsDefaultKmsKeyIdResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetEbsEncryptionByDefault
      def self.build(params, context:)
        Params::GetEbsEncryptionByDefaultOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetEbsEncryptionByDefaultOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ebs_encryption_by_default: false,
          sse_type: 'sse_type',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetEbsEncryptionByDefaultResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ebsEncryptionByDefault', stub[:ebs_encryption_by_default].to_s) unless stub[:ebs_encryption_by_default].nil?
        xml << Hearth::XML::Node.new('sseType', stub[:sse_type].to_s) unless stub[:sse_type].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetFlowLogsIntegrationTemplate
      def self.build(params, context:)
        Params::GetFlowLogsIntegrationTemplateOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetFlowLogsIntegrationTemplateOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          result: 'result',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetFlowLogsIntegrationTemplateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('result', stub[:result].to_s) unless stub[:result].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetGroupsForCapacityReservation
      def self.build(params, context:)
        Params::GetGroupsForCapacityReservationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetGroupsForCapacityReservationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          capacity_reservation_groups: CapacityReservationGroupSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetGroupsForCapacityReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('capacityReservationGroupSet', CapacityReservationGroupSet.stub('item', stub[:capacity_reservation_groups])) unless stub[:capacity_reservation_groups].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetHostReservationPurchasePreview
      def self.build(params, context:)
        Params::GetHostReservationPurchasePreviewOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetHostReservationPurchasePreviewOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          currency_code: 'currency_code',
          purchase: PurchaseSet.default(visited),
          total_hourly_price: 'total_hourly_price',
          total_upfront_price: 'total_upfront_price',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetHostReservationPurchasePreviewResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('purchase', PurchaseSet.stub('item', stub[:purchase])) unless stub[:purchase].nil?
        xml << Hearth::XML::Node.new('totalHourlyPrice', stub[:total_hourly_price].to_s) unless stub[:total_hourly_price].nil?
        xml << Hearth::XML::Node.new('totalUpfrontPrice', stub[:total_upfront_price].to_s) unless stub[:total_upfront_price].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetInstanceTypesFromInstanceRequirements
      def self.build(params, context:)
        Params::GetInstanceTypesFromInstanceRequirementsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetInstanceTypesFromInstanceRequirementsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_types: InstanceTypeInfoFromInstanceRequirementsSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetInstanceTypesFromInstanceRequirementsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceTypeSet', InstanceTypeInfoFromInstanceRequirementsSet.stub('item', stub[:instance_types])) unless stub[:instance_types].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetInstanceUefiData
      def self.build(params, context:)
        Params::GetInstanceUefiDataOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetInstanceUefiDataOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_id: 'instance_id',
          uefi_data: 'uefi_data',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetInstanceUefiDataResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('uefiData', stub[:uefi_data].to_s) unless stub[:uefi_data].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetIpamAddressHistory
      def self.build(params, context:)
        Params::GetIpamAddressHistoryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetIpamAddressHistoryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          history_records: IpamAddressHistoryRecordSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamAddressHistoryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('historyRecordSet', IpamAddressHistoryRecordSet.stub('item', stub[:history_records])) unless stub[:history_records].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetIpamDiscoveredAccounts
      def self.build(params, context:)
        Params::GetIpamDiscoveredAccountsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetIpamDiscoveredAccountsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_discovered_accounts: IpamDiscoveredAccountSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamDiscoveredAccountsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipamDiscoveredAccountSet', IpamDiscoveredAccountSet.stub('item', stub[:ipam_discovered_accounts])) unless stub[:ipam_discovered_accounts].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetIpamDiscoveredResourceCidrs
      def self.build(params, context:)
        Params::GetIpamDiscoveredResourceCidrsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetIpamDiscoveredResourceCidrsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_discovered_resource_cidrs: IpamDiscoveredResourceCidrSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamDiscoveredResourceCidrsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipamDiscoveredResourceCidrSet', IpamDiscoveredResourceCidrSet.stub('item', stub[:ipam_discovered_resource_cidrs])) unless stub[:ipam_discovered_resource_cidrs].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetIpamPoolAllocations
      def self.build(params, context:)
        Params::GetIpamPoolAllocationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetIpamPoolAllocationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_pool_allocations: IpamPoolAllocationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamPoolAllocationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipamPoolAllocationSet', IpamPoolAllocationSet.stub('item', stub[:ipam_pool_allocations])) unless stub[:ipam_pool_allocations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetIpamPoolCidrs
      def self.build(params, context:)
        Params::GetIpamPoolCidrsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetIpamPoolCidrsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_pool_cidrs: IpamPoolCidrSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamPoolCidrsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('ipamPoolCidrSet', IpamPoolCidrSet.stub('item', stub[:ipam_pool_cidrs])) unless stub[:ipam_pool_cidrs].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetIpamResourceCidrs
      def self.build(params, context:)
        Params::GetIpamResourceCidrsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetIpamResourceCidrsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          next_token: 'next_token',
          ipam_resource_cidrs: IpamResourceCidrSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetIpamResourceCidrsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        xml << Hearth::XML::Node.new('ipamResourceCidrSet', IpamResourceCidrSet.stub('item', stub[:ipam_resource_cidrs])) unless stub[:ipam_resource_cidrs].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetLaunchTemplateData
      def self.build(params, context:)
        Params::GetLaunchTemplateDataOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetLaunchTemplateDataOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          launch_template_data: ResponseLaunchTemplateData.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetLaunchTemplateDataResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ResponseLaunchTemplateData.stub('launchTemplateData', stub[:launch_template_data]) unless stub[:launch_template_data].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetManagedPrefixListAssociations
      def self.build(params, context:)
        Params::GetManagedPrefixListAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetManagedPrefixListAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          prefix_list_associations: PrefixListAssociationSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetManagedPrefixListAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('prefixListAssociationSet', PrefixListAssociationSet.stub('item', stub[:prefix_list_associations])) unless stub[:prefix_list_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetManagedPrefixListEntries
      def self.build(params, context:)
        Params::GetManagedPrefixListEntriesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetManagedPrefixListEntriesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          entries: PrefixListEntrySet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetManagedPrefixListEntriesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('entrySet', PrefixListEntrySet.stub('item', stub[:entries])) unless stub[:entries].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetNetworkInsightsAccessScopeAnalysisFindings
      def self.build(params, context:)
        Params::GetNetworkInsightsAccessScopeAnalysisFindingsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetNetworkInsightsAccessScopeAnalysisFindingsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_access_scope_analysis_id: 'network_insights_access_scope_analysis_id',
          analysis_status: 'analysis_status',
          analysis_findings: AccessScopeAnalysisFindingList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetNetworkInsightsAccessScopeAnalysisFindingsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisId', stub[:network_insights_access_scope_analysis_id].to_s) unless stub[:network_insights_access_scope_analysis_id].nil?
        xml << Hearth::XML::Node.new('analysisStatus', stub[:analysis_status].to_s) unless stub[:analysis_status].nil?
        xml << Hearth::XML::Node.new('analysisFindingSet', AccessScopeAnalysisFindingList.stub('item', stub[:analysis_findings])) unless stub[:analysis_findings].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetNetworkInsightsAccessScopeContent
      def self.build(params, context:)
        Params::GetNetworkInsightsAccessScopeContentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetNetworkInsightsAccessScopeContentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_access_scope_content: NetworkInsightsAccessScopeContent.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetNetworkInsightsAccessScopeContentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsAccessScopeContent.stub('networkInsightsAccessScopeContent', stub[:network_insights_access_scope_content]) unless stub[:network_insights_access_scope_content].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetPasswordData
      def self.build(params, context:)
        Params::GetPasswordDataOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetPasswordDataOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_id: 'instance_id',
          password_data: 'password_data',
          timestamp: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetPasswordDataResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('passwordData', stub[:password_data].to_s) unless stub[:password_data].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetReservedInstancesExchangeQuote
      def self.build(params, context:)
        Params::GetReservedInstancesExchangeQuoteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetReservedInstancesExchangeQuoteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          currency_code: 'currency_code',
          is_valid_exchange: false,
          output_reserved_instances_will_expire_at: Time.now,
          payment_due: 'payment_due',
          reserved_instance_value_rollup: ReservationValue.default(visited),
          reserved_instance_value_set: ReservedInstanceReservationValueSet.default(visited),
          target_configuration_value_rollup: ReservationValue.default(visited),
          target_configuration_value_set: TargetReservationValueSet.default(visited),
          validation_failure_reason: 'validation_failure_reason',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetReservedInstancesExchangeQuoteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('isValidExchange', stub[:is_valid_exchange].to_s) unless stub[:is_valid_exchange].nil?
        xml << Hearth::XML::Node.new('outputReservedInstancesWillExpireAt', Hearth::TimeHelper.to_date_time(stub[:output_reserved_instances_will_expire_at])) unless stub[:output_reserved_instances_will_expire_at].nil?
        xml << Hearth::XML::Node.new('paymentDue', stub[:payment_due].to_s) unless stub[:payment_due].nil?
        xml << ReservationValue.stub('reservedInstanceValueRollup', stub[:reserved_instance_value_rollup]) unless stub[:reserved_instance_value_rollup].nil?
        xml << Hearth::XML::Node.new('reservedInstanceValueSet', ReservedInstanceReservationValueSet.stub('item', stub[:reserved_instance_value_set])) unless stub[:reserved_instance_value_set].nil?
        xml << ReservationValue.stub('targetConfigurationValueRollup', stub[:target_configuration_value_rollup]) unless stub[:target_configuration_value_rollup].nil?
        xml << Hearth::XML::Node.new('targetConfigurationValueSet', TargetReservationValueSet.stub('item', stub[:target_configuration_value_set])) unless stub[:target_configuration_value_set].nil?
        xml << Hearth::XML::Node.new('validationFailureReason', stub[:validation_failure_reason].to_s) unless stub[:validation_failure_reason].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetSerialConsoleAccessStatus
      def self.build(params, context:)
        Params::GetSerialConsoleAccessStatusOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetSerialConsoleAccessStatusOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          serial_console_access_enabled: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetSerialConsoleAccessStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('serialConsoleAccessEnabled', stub[:serial_console_access_enabled].to_s) unless stub[:serial_console_access_enabled].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetSpotPlacementScores
      def self.build(params, context:)
        Params::GetSpotPlacementScoresOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetSpotPlacementScoresOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          spot_placement_scores: SpotPlacementScores.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetSpotPlacementScoresResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotPlacementScoreSet', SpotPlacementScores.stub('item', stub[:spot_placement_scores])) unless stub[:spot_placement_scores].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetSubnetCidrReservations
      def self.build(params, context:)
        Params::GetSubnetCidrReservationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetSubnetCidrReservationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          subnet_ipv4_cidr_reservations: SubnetCidrReservationList.default(visited),
          subnet_ipv6_cidr_reservations: SubnetCidrReservationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetSubnetCidrReservationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('subnetIpv4CidrReservationSet', SubnetCidrReservationList.stub('item', stub[:subnet_ipv4_cidr_reservations])) unless stub[:subnet_ipv4_cidr_reservations].nil?
        xml << Hearth::XML::Node.new('subnetIpv6CidrReservationSet', SubnetCidrReservationList.stub('item', stub[:subnet_ipv6_cidr_reservations])) unless stub[:subnet_ipv6_cidr_reservations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetTransitGatewayAttachmentPropagations
      def self.build(params, context:)
        Params::GetTransitGatewayAttachmentPropagationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetTransitGatewayAttachmentPropagationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_attachment_propagations: TransitGatewayAttachmentPropagationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayAttachmentPropagationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayAttachmentPropagations', TransitGatewayAttachmentPropagationList.stub('item', stub[:transit_gateway_attachment_propagations])) unless stub[:transit_gateway_attachment_propagations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetTransitGatewayMulticastDomainAssociations
      def self.build(params, context:)
        Params::GetTransitGatewayMulticastDomainAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetTransitGatewayMulticastDomainAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          multicast_domain_associations: TransitGatewayMulticastDomainAssociationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayMulticastDomainAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('multicastDomainAssociations', TransitGatewayMulticastDomainAssociationList.stub('item', stub[:multicast_domain_associations])) unless stub[:multicast_domain_associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetTransitGatewayPolicyTableAssociations
      def self.build(params, context:)
        Params::GetTransitGatewayPolicyTableAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetTransitGatewayPolicyTableAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          associations: TransitGatewayPolicyTableAssociationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayPolicyTableAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associations', TransitGatewayPolicyTableAssociationList.stub('item', stub[:associations])) unless stub[:associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetTransitGatewayPolicyTableEntries
      def self.build(params, context:)
        Params::GetTransitGatewayPolicyTableEntriesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetTransitGatewayPolicyTableEntriesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_policy_table_entries: TransitGatewayPolicyTableEntryList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayPolicyTableEntriesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayPolicyTableEntries', TransitGatewayPolicyTableEntryList.stub('item', stub[:transit_gateway_policy_table_entries])) unless stub[:transit_gateway_policy_table_entries].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetTransitGatewayPrefixListReferences
      def self.build(params, context:)
        Params::GetTransitGatewayPrefixListReferencesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetTransitGatewayPrefixListReferencesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_prefix_list_references: TransitGatewayPrefixListReferenceSet.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayPrefixListReferencesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayPrefixListReferenceSet', TransitGatewayPrefixListReferenceSet.stub('item', stub[:transit_gateway_prefix_list_references])) unless stub[:transit_gateway_prefix_list_references].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetTransitGatewayRouteTableAssociations
      def self.build(params, context:)
        Params::GetTransitGatewayRouteTableAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetTransitGatewayRouteTableAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          associations: TransitGatewayRouteTableAssociationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayRouteTableAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('associations', TransitGatewayRouteTableAssociationList.stub('item', stub[:associations])) unless stub[:associations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetTransitGatewayRouteTablePropagations
      def self.build(params, context:)
        Params::GetTransitGatewayRouteTablePropagationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetTransitGatewayRouteTablePropagationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_route_table_propagations: TransitGatewayRouteTablePropagationList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetTransitGatewayRouteTablePropagationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('transitGatewayRouteTablePropagations', TransitGatewayRouteTablePropagationList.stub('item', stub[:transit_gateway_route_table_propagations])) unless stub[:transit_gateway_route_table_propagations].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetVerifiedAccessEndpointPolicy
      def self.build(params, context:)
        Params::GetVerifiedAccessEndpointPolicyOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetVerifiedAccessEndpointPolicyOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          policy_enabled: false,
          policy_document: 'policy_document',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetVerifiedAccessEndpointPolicyResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('policyEnabled', stub[:policy_enabled].to_s) unless stub[:policy_enabled].nil?
        xml << Hearth::XML::Node.new('policyDocument', stub[:policy_document].to_s) unless stub[:policy_document].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetVerifiedAccessGroupPolicy
      def self.build(params, context:)
        Params::GetVerifiedAccessGroupPolicyOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetVerifiedAccessGroupPolicyOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          policy_enabled: false,
          policy_document: 'policy_document',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetVerifiedAccessGroupPolicyResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('policyEnabled', stub[:policy_enabled].to_s) unless stub[:policy_enabled].nil?
        xml << Hearth::XML::Node.new('policyDocument', stub[:policy_document].to_s) unless stub[:policy_document].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetVpnConnectionDeviceSampleConfiguration
      def self.build(params, context:)
        Params::GetVpnConnectionDeviceSampleConfigurationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetVpnConnectionDeviceSampleConfigurationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_connection_device_sample_configuration: 'vpn_connection_device_sample_configuration',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetVpnConnectionDeviceSampleConfigurationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpnConnectionDeviceSampleConfiguration', stub[:vpn_connection_device_sample_configuration].to_s) unless stub[:vpn_connection_device_sample_configuration].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetVpnConnectionDeviceTypes
      def self.build(params, context:)
        Params::GetVpnConnectionDeviceTypesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetVpnConnectionDeviceTypesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_connection_device_types: VpnConnectionDeviceTypeList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetVpnConnectionDeviceTypesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpnConnectionDeviceTypeSet', VpnConnectionDeviceTypeList.stub('item', stub[:vpn_connection_device_types])) unless stub[:vpn_connection_device_types].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GetVpnTunnelReplacementStatus
      def self.build(params, context:)
        Params::GetVpnTunnelReplacementStatusOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::GetVpnTunnelReplacementStatusOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_connection_id: 'vpn_connection_id',
          transit_gateway_id: 'transit_gateway_id',
          customer_gateway_id: 'customer_gateway_id',
          vpn_gateway_id: 'vpn_gateway_id',
          vpn_tunnel_outside_ip_address: 'vpn_tunnel_outside_ip_address',
          maintenance_details: MaintenanceDetails.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('GetVpnTunnelReplacementStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('vpnConnectionId', stub[:vpn_connection_id].to_s) unless stub[:vpn_connection_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('customerGatewayId', stub[:customer_gateway_id].to_s) unless stub[:customer_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpnGatewayId', stub[:vpn_gateway_id].to_s) unless stub[:vpn_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpnTunnelOutsideIpAddress', stub[:vpn_tunnel_outside_ip_address].to_s) unless stub[:vpn_tunnel_outside_ip_address].nil?
        xml << MaintenanceDetails.stub('maintenanceDetails', stub[:maintenance_details]) unless stub[:maintenance_details].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class GpuDeviceInfo
      def self.default(visited = [])
        return nil if visited.include?('GpuDeviceInfo')
        visited = visited + ['GpuDeviceInfo']
        {
          name: 'name',
          manufacturer: 'manufacturer',
          count: 1,
          memory_info: GpuDeviceMemoryInfo.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('manufacturer', stub[:manufacturer].to_s) unless stub[:manufacturer].nil?
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << GpuDeviceMemoryInfo.stub('memoryInfo', stub[:memory_info]) unless stub[:memory_info].nil?
        xml
      end
    end

    class GpuDeviceInfoList
      def self.default(visited = [])
        return nil if visited.include?('GpuDeviceInfoList')
        visited = visited + ['GpuDeviceInfoList']
        [
          GpuDeviceInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << GpuDeviceInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class GpuDeviceMemoryInfo
      def self.default(visited = [])
        return nil if visited.include?('GpuDeviceMemoryInfo')
        visited = visited + ['GpuDeviceMemoryInfo']
        {
          size_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sizeInMiB', stub[:size_in_mi_b].to_s) unless stub[:size_in_mi_b].nil?
        xml
      end
    end

    class GpuInfo
      def self.default(visited = [])
        return nil if visited.include?('GpuInfo')
        visited = visited + ['GpuInfo']
        {
          gpus: GpuDeviceInfoList.default(visited),
          total_gpu_memory_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('gpus', GpuDeviceInfoList.stub('item', stub[:gpus])) unless stub[:gpus].nil?
        xml << Hearth::XML::Node.new('totalGpuMemoryInMiB', stub[:total_gpu_memory_in_mi_b].to_s) unless stub[:total_gpu_memory_in_mi_b].nil?
        xml
      end
    end

    class GroupIdStringList
      def self.default(visited = [])
        return nil if visited.include?('GroupIdStringList')
        visited = visited + ['GroupIdStringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class GroupIdentifier
      def self.default(visited = [])
        return nil if visited.include?('GroupIdentifier')
        visited = visited + ['GroupIdentifier']
        {
          group_name: 'group_name',
          group_id: 'group_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml
      end
    end

    class GroupIdentifierList
      def self.default(visited = [])
        return nil if visited.include?('GroupIdentifierList')
        visited = visited + ['GroupIdentifierList']
        [
          GroupIdentifier.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << GroupIdentifier.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class GroupIdentifierSet
      def self.default(visited = [])
        return nil if visited.include?('GroupIdentifierSet')
        visited = visited + ['GroupIdentifierSet']
        [
          SecurityGroupIdentifier.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SecurityGroupIdentifier.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class HibernationOptions
      def self.default(visited = [])
        return nil if visited.include?('HibernationOptions')
        visited = visited + ['HibernationOptions']
        {
          configured: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('configured', stub[:configured].to_s) unless stub[:configured].nil?
        xml
      end
    end

    class HistoryRecord
      def self.default(visited = [])
        return nil if visited.include?('HistoryRecord')
        visited = visited + ['HistoryRecord']
        {
          event_information: EventInformation.default(visited),
          event_type: 'event_type',
          timestamp: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << EventInformation.stub('eventInformation', stub[:event_information]) unless stub[:event_information].nil?
        xml << Hearth::XML::Node.new('eventType', stub[:event_type].to_s) unless stub[:event_type].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        xml
      end
    end

    class HistoryRecordEntry
      def self.default(visited = [])
        return nil if visited.include?('HistoryRecordEntry')
        visited = visited + ['HistoryRecordEntry']
        {
          event_information: EventInformation.default(visited),
          event_type: 'event_type',
          timestamp: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << EventInformation.stub('eventInformation', stub[:event_information]) unless stub[:event_information].nil?
        xml << Hearth::XML::Node.new('eventType', stub[:event_type].to_s) unless stub[:event_type].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        xml
      end
    end

    class HistoryRecordSet
      def self.default(visited = [])
        return nil if visited.include?('HistoryRecordSet')
        visited = visited + ['HistoryRecordSet']
        [
          HistoryRecordEntry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HistoryRecordEntry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class HistoryRecords
      def self.default(visited = [])
        return nil if visited.include?('HistoryRecords')
        visited = visited + ['HistoryRecords']
        [
          HistoryRecord.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HistoryRecord.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Host
      def self.default(visited = [])
        return nil if visited.include?('Host')
        visited = visited + ['Host']
        {
          auto_placement: 'auto_placement',
          availability_zone: 'availability_zone',
          available_capacity: AvailableCapacity.default(visited),
          client_token: 'client_token',
          host_id: 'host_id',
          host_properties: HostProperties.default(visited),
          host_reservation_id: 'host_reservation_id',
          instances: HostInstanceList.default(visited),
          state: 'state',
          allocation_time: Time.now,
          release_time: Time.now,
          tags: TagList.default(visited),
          host_recovery: 'host_recovery',
          allows_multiple_instance_types: 'allows_multiple_instance_types',
          owner_id: 'owner_id',
          availability_zone_id: 'availability_zone_id',
          member_of_service_linked_resource_group: false,
          outpost_arn: 'outpost_arn',
          host_maintenance: 'host_maintenance',
          asset_id: 'asset_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('autoPlacement', stub[:auto_placement].to_s) unless stub[:auto_placement].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << AvailableCapacity.stub('availableCapacity', stub[:available_capacity]) unless stub[:available_capacity].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('hostId', stub[:host_id].to_s) unless stub[:host_id].nil?
        xml << HostProperties.stub('hostProperties', stub[:host_properties]) unless stub[:host_properties].nil?
        xml << Hearth::XML::Node.new('hostReservationId', stub[:host_reservation_id].to_s) unless stub[:host_reservation_id].nil?
        xml << Hearth::XML::Node.new('instances', HostInstanceList.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('allocationTime', Hearth::TimeHelper.to_date_time(stub[:allocation_time])) unless stub[:allocation_time].nil?
        xml << Hearth::XML::Node.new('releaseTime', Hearth::TimeHelper.to_date_time(stub[:release_time])) unless stub[:release_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('hostRecovery', stub[:host_recovery].to_s) unless stub[:host_recovery].nil?
        xml << Hearth::XML::Node.new('allowsMultipleInstanceTypes', stub[:allows_multiple_instance_types].to_s) unless stub[:allows_multiple_instance_types].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('memberOfServiceLinkedResourceGroup', stub[:member_of_service_linked_resource_group].to_s) unless stub[:member_of_service_linked_resource_group].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('hostMaintenance', stub[:host_maintenance].to_s) unless stub[:host_maintenance].nil?
        xml << Hearth::XML::Node.new('assetId', stub[:asset_id].to_s) unless stub[:asset_id].nil?
        xml
      end
    end

    class HostInstance
      def self.default(visited = [])
        return nil if visited.include?('HostInstance')
        visited = visited + ['HostInstance']
        {
          instance_id: 'instance_id',
          instance_type: 'instance_type',
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    class HostInstanceList
      def self.default(visited = [])
        return nil if visited.include?('HostInstanceList')
        visited = visited + ['HostInstanceList']
        [
          HostInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HostInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class HostList
      def self.default(visited = [])
        return nil if visited.include?('HostList')
        visited = visited + ['HostList']
        [
          Host.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Host.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class HostOffering
      def self.default(visited = [])
        return nil if visited.include?('HostOffering')
        visited = visited + ['HostOffering']
        {
          currency_code: 'currency_code',
          duration: 1,
          hourly_price: 'hourly_price',
          instance_family: 'instance_family',
          offering_id: 'offering_id',
          payment_option: 'payment_option',
          upfront_price: 'upfront_price',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('offeringId', stub[:offering_id].to_s) unless stub[:offering_id].nil?
        xml << Hearth::XML::Node.new('paymentOption', stub[:payment_option].to_s) unless stub[:payment_option].nil?
        xml << Hearth::XML::Node.new('upfrontPrice', stub[:upfront_price].to_s) unless stub[:upfront_price].nil?
        xml
      end
    end

    class HostOfferingSet
      def self.default(visited = [])
        return nil if visited.include?('HostOfferingSet')
        visited = visited + ['HostOfferingSet']
        [
          HostOffering.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HostOffering.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class HostProperties
      def self.default(visited = [])
        return nil if visited.include?('HostProperties')
        visited = visited + ['HostProperties']
        {
          cores: 1,
          instance_type: 'instance_type',
          instance_family: 'instance_family',
          sockets: 1,
          total_v_cpus: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cores', stub[:cores].to_s) unless stub[:cores].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('sockets', stub[:sockets].to_s) unless stub[:sockets].nil?
        xml << Hearth::XML::Node.new('totalVCpus', stub[:total_v_cpus].to_s) unless stub[:total_v_cpus].nil?
        xml
      end
    end

    class HostReservation
      def self.default(visited = [])
        return nil if visited.include?('HostReservation')
        visited = visited + ['HostReservation']
        {
          count: 1,
          currency_code: 'currency_code',
          duration: 1,
          end: Time.now,
          host_id_set: ResponseHostIdSet.default(visited),
          host_reservation_id: 'host_reservation_id',
          hourly_price: 'hourly_price',
          instance_family: 'instance_family',
          offering_id: 'offering_id',
          payment_option: 'payment_option',
          start: Time.now,
          state: 'state',
          upfront_price: 'upfront_price',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('end', Hearth::TimeHelper.to_date_time(stub[:end])) unless stub[:end].nil?
        xml << Hearth::XML::Node.new('hostIdSet', ResponseHostIdSet.stub('item', stub[:host_id_set])) unless stub[:host_id_set].nil?
        xml << Hearth::XML::Node.new('hostReservationId', stub[:host_reservation_id].to_s) unless stub[:host_reservation_id].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('offeringId', stub[:offering_id].to_s) unless stub[:offering_id].nil?
        xml << Hearth::XML::Node.new('paymentOption', stub[:payment_option].to_s) unless stub[:payment_option].nil?
        xml << Hearth::XML::Node.new('start', Hearth::TimeHelper.to_date_time(stub[:start])) unless stub[:start].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('upfrontPrice', stub[:upfront_price].to_s) unless stub[:upfront_price].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class HostReservationSet
      def self.default(visited = [])
        return nil if visited.include?('HostReservationSet')
        visited = visited + ['HostReservationSet']
        [
          HostReservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << HostReservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IKEVersionsList
      def self.default(visited = [])
        return nil if visited.include?('IKEVersionsList')
        visited = visited + ['IKEVersionsList']
        [
          IKEVersionsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IKEVersionsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IKEVersionsListValue
      def self.default(visited = [])
        return nil if visited.include?('IKEVersionsListValue')
        visited = visited + ['IKEVersionsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class IamInstanceProfile
      def self.default(visited = [])
        return nil if visited.include?('IamInstanceProfile')
        visited = visited + ['IamInstanceProfile']
        {
          arn: 'arn',
          id: 'id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('id', stub[:id].to_s) unless stub[:id].nil?
        xml
      end
    end

    class IamInstanceProfileAssociation
      def self.default(visited = [])
        return nil if visited.include?('IamInstanceProfileAssociation')
        visited = visited + ['IamInstanceProfileAssociation']
        {
          association_id: 'association_id',
          instance_id: 'instance_id',
          iam_instance_profile: IamInstanceProfile.default(visited),
          state: 'state',
          timestamp: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << IamInstanceProfile.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        xml
      end
    end

    class IamInstanceProfileAssociationSet
      def self.default(visited = [])
        return nil if visited.include?('IamInstanceProfileAssociationSet')
        visited = visited + ['IamInstanceProfileAssociationSet']
        [
          IamInstanceProfileAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IamInstanceProfileAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IamInstanceProfileSpecification
      def self.default(visited = [])
        return nil if visited.include?('IamInstanceProfileSpecification')
        visited = visited + ['IamInstanceProfileSpecification']
        {
          arn: 'arn',
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    class IcmpTypeCode
      def self.default(visited = [])
        return nil if visited.include?('IcmpTypeCode')
        visited = visited + ['IcmpTypeCode']
        {
          code: 1,
          type: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml
      end
    end

    class IdFormat
      def self.default(visited = [])
        return nil if visited.include?('IdFormat')
        visited = visited + ['IdFormat']
        {
          deadline: Time.now,
          resource: 'resource',
          use_long_ids: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deadline', Hearth::TimeHelper.to_date_time(stub[:deadline])) unless stub[:deadline].nil?
        xml << Hearth::XML::Node.new('resource', stub[:resource].to_s) unless stub[:resource].nil?
        xml << Hearth::XML::Node.new('useLongIds', stub[:use_long_ids].to_s) unless stub[:use_long_ids].nil?
        xml
      end
    end

    class IdFormatList
      def self.default(visited = [])
        return nil if visited.include?('IdFormatList')
        visited = visited + ['IdFormatList']
        [
          IdFormat.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IdFormat.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Image
      def self.default(visited = [])
        return nil if visited.include?('Image')
        visited = visited + ['Image']
        {
          architecture: 'architecture',
          creation_date: 'creation_date',
          image_id: 'image_id',
          image_location: 'image_location',
          image_type: 'image_type',
          public: false,
          kernel_id: 'kernel_id',
          owner_id: 'owner_id',
          platform: 'platform',
          platform_details: 'platform_details',
          usage_operation: 'usage_operation',
          product_codes: ProductCodeList.default(visited),
          ramdisk_id: 'ramdisk_id',
          state: 'state',
          block_device_mappings: BlockDeviceMappingList.default(visited),
          description: 'description',
          ena_support: false,
          hypervisor: 'hypervisor',
          image_owner_alias: 'image_owner_alias',
          name: 'name',
          root_device_name: 'root_device_name',
          root_device_type: 'root_device_type',
          sriov_net_support: 'sriov_net_support',
          state_reason: StateReason.default(visited),
          tags: TagList.default(visited),
          virtualization_type: 'virtualization_type',
          boot_mode: 'boot_mode',
          tpm_support: 'tpm_support',
          deprecation_time: 'deprecation_time',
          imds_support: 'imds_support',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('architecture', stub[:architecture].to_s) unless stub[:architecture].nil?
        xml << Hearth::XML::Node.new('creationDate', stub[:creation_date].to_s) unless stub[:creation_date].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('imageLocation', stub[:image_location].to_s) unless stub[:image_location].nil?
        xml << Hearth::XML::Node.new('imageType', stub[:image_type].to_s) unless stub[:image_type].nil?
        xml << Hearth::XML::Node.new('isPublic', stub[:public].to_s) unless stub[:public].nil?
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('imageOwnerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('platformDetails', stub[:platform_details].to_s) unless stub[:platform_details].nil?
        xml << Hearth::XML::Node.new('usageOperation', stub[:usage_operation].to_s) unless stub[:usage_operation].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('ramdiskId', stub[:ramdisk_id].to_s) unless stub[:ramdisk_id].nil?
        xml << Hearth::XML::Node.new('imageState', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', BlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('enaSupport', stub[:ena_support].to_s) unless stub[:ena_support].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << Hearth::XML::Node.new('imageOwnerAlias', stub[:image_owner_alias].to_s) unless stub[:image_owner_alias].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('rootDeviceName', stub[:root_device_name].to_s) unless stub[:root_device_name].nil?
        xml << Hearth::XML::Node.new('rootDeviceType', stub[:root_device_type].to_s) unless stub[:root_device_type].nil?
        xml << Hearth::XML::Node.new('sriovNetSupport', stub[:sriov_net_support].to_s) unless stub[:sriov_net_support].nil?
        xml << StateReason.stub('stateReason', stub[:state_reason]) unless stub[:state_reason].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('virtualizationType', stub[:virtualization_type].to_s) unless stub[:virtualization_type].nil?
        xml << Hearth::XML::Node.new('bootMode', stub[:boot_mode].to_s) unless stub[:boot_mode].nil?
        xml << Hearth::XML::Node.new('tpmSupport', stub[:tpm_support].to_s) unless stub[:tpm_support].nil?
        xml << Hearth::XML::Node.new('deprecationTime', stub[:deprecation_time].to_s) unless stub[:deprecation_time].nil?
        xml << Hearth::XML::Node.new('imdsSupport', stub[:imds_support].to_s) unless stub[:imds_support].nil?
        xml
      end
    end

    class ImageList
      def self.default(visited = [])
        return nil if visited.include?('ImageList')
        visited = visited + ['ImageList']
        [
          Image.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Image.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ImageRecycleBinInfo
      def self.default(visited = [])
        return nil if visited.include?('ImageRecycleBinInfo')
        visited = visited + ['ImageRecycleBinInfo']
        {
          image_id: 'image_id',
          name: 'name',
          description: 'description',
          recycle_bin_enter_time: Time.now,
          recycle_bin_exit_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('recycleBinEnterTime', Hearth::TimeHelper.to_date_time(stub[:recycle_bin_enter_time])) unless stub[:recycle_bin_enter_time].nil?
        xml << Hearth::XML::Node.new('recycleBinExitTime', Hearth::TimeHelper.to_date_time(stub[:recycle_bin_exit_time])) unless stub[:recycle_bin_exit_time].nil?
        xml
      end
    end

    class ImageRecycleBinInfoList
      def self.default(visited = [])
        return nil if visited.include?('ImageRecycleBinInfoList')
        visited = visited + ['ImageRecycleBinInfoList']
        [
          ImageRecycleBinInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImageRecycleBinInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ImportClientVpnClientCertificateRevocationList
      def self.build(params, context:)
        Params::ImportClientVpnClientCertificateRevocationListOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ImportClientVpnClientCertificateRevocationListOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportClientVpnClientCertificateRevocationListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ImportImage
      def self.build(params, context:)
        Params::ImportImageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ImportImageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          architecture: 'architecture',
          description: 'description',
          encrypted: false,
          hypervisor: 'hypervisor',
          image_id: 'image_id',
          import_task_id: 'import_task_id',
          kms_key_id: 'kms_key_id',
          license_type: 'license_type',
          platform: 'platform',
          progress: 'progress',
          snapshot_details: SnapshotDetailList.default(visited),
          status: 'status',
          status_message: 'status_message',
          license_specifications: ImportImageLicenseSpecificationListResponse.default(visited),
          tags: TagList.default(visited),
          usage_operation: 'usage_operation',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('architecture', stub[:architecture].to_s) unless stub[:architecture].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('licenseType', stub[:license_type].to_s) unless stub[:license_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotDetailSet', SnapshotDetailList.stub('item', stub[:snapshot_details])) unless stub[:snapshot_details].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('licenseSpecifications', ImportImageLicenseSpecificationListResponse.stub('item', stub[:license_specifications])) unless stub[:license_specifications].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('usageOperation', stub[:usage_operation].to_s) unless stub[:usage_operation].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ImportImageLicenseConfigurationResponse
      def self.default(visited = [])
        return nil if visited.include?('ImportImageLicenseConfigurationResponse')
        visited = visited + ['ImportImageLicenseConfigurationResponse']
        {
          license_configuration_arn: 'license_configuration_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('licenseConfigurationArn', stub[:license_configuration_arn].to_s) unless stub[:license_configuration_arn].nil?
        xml
      end
    end

    class ImportImageLicenseSpecificationListResponse
      def self.default(visited = [])
        return nil if visited.include?('ImportImageLicenseSpecificationListResponse')
        visited = visited + ['ImportImageLicenseSpecificationListResponse']
        [
          ImportImageLicenseConfigurationResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImportImageLicenseConfigurationResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ImportImageTask
      def self.default(visited = [])
        return nil if visited.include?('ImportImageTask')
        visited = visited + ['ImportImageTask']
        {
          architecture: 'architecture',
          description: 'description',
          encrypted: false,
          hypervisor: 'hypervisor',
          image_id: 'image_id',
          import_task_id: 'import_task_id',
          kms_key_id: 'kms_key_id',
          license_type: 'license_type',
          platform: 'platform',
          progress: 'progress',
          snapshot_details: SnapshotDetailList.default(visited),
          status: 'status',
          status_message: 'status_message',
          tags: TagList.default(visited),
          license_specifications: ImportImageLicenseSpecificationListResponse.default(visited),
          usage_operation: 'usage_operation',
          boot_mode: 'boot_mode',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('architecture', stub[:architecture].to_s) unless stub[:architecture].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('licenseType', stub[:license_type].to_s) unless stub[:license_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotDetailSet', SnapshotDetailList.stub('item', stub[:snapshot_details])) unless stub[:snapshot_details].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('licenseSpecifications', ImportImageLicenseSpecificationListResponse.stub('item', stub[:license_specifications])) unless stub[:license_specifications].nil?
        xml << Hearth::XML::Node.new('usageOperation', stub[:usage_operation].to_s) unless stub[:usage_operation].nil?
        xml << Hearth::XML::Node.new('bootMode', stub[:boot_mode].to_s) unless stub[:boot_mode].nil?
        xml
      end
    end

    class ImportImageTaskList
      def self.default(visited = [])
        return nil if visited.include?('ImportImageTaskList')
        visited = visited + ['ImportImageTaskList']
        [
          ImportImageTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImportImageTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ImportInstance
      def self.build(params, context:)
        Params::ImportInstanceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ImportInstanceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          conversion_task: ConversionTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportInstanceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ConversionTask.stub('conversionTask', stub[:conversion_task]) unless stub[:conversion_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ImportInstanceTaskDetails
      def self.default(visited = [])
        return nil if visited.include?('ImportInstanceTaskDetails')
        visited = visited + ['ImportInstanceTaskDetails']
        {
          description: 'description',
          instance_id: 'instance_id',
          platform: 'platform',
          volumes: ImportInstanceVolumeDetailSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('volumes', ImportInstanceVolumeDetailSet.stub('item', stub[:volumes])) unless stub[:volumes].nil?
        xml
      end
    end

    class ImportInstanceVolumeDetailItem
      def self.default(visited = [])
        return nil if visited.include?('ImportInstanceVolumeDetailItem')
        visited = visited + ['ImportInstanceVolumeDetailItem']
        {
          availability_zone: 'availability_zone',
          bytes_converted: 1,
          description: 'description',
          image: DiskImageDescription.default(visited),
          status: 'status',
          status_message: 'status_message',
          volume: DiskImageVolumeDescription.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('bytesConverted', stub[:bytes_converted].to_s) unless stub[:bytes_converted].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << DiskImageDescription.stub('image', stub[:image]) unless stub[:image].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << DiskImageVolumeDescription.stub('volume', stub[:volume]) unless stub[:volume].nil?
        xml
      end
    end

    class ImportInstanceVolumeDetailSet
      def self.default(visited = [])
        return nil if visited.include?('ImportInstanceVolumeDetailSet')
        visited = visited + ['ImportInstanceVolumeDetailSet']
        [
          ImportInstanceVolumeDetailItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImportInstanceVolumeDetailItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ImportKeyPair
      def self.build(params, context:)
        Params::ImportKeyPairOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ImportKeyPairOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          key_fingerprint: 'key_fingerprint',
          key_name: 'key_name',
          key_pair_id: 'key_pair_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportKeyPairResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('keyFingerprint', stub[:key_fingerprint].to_s) unless stub[:key_fingerprint].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('keyPairId', stub[:key_pair_id].to_s) unless stub[:key_pair_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ImportSnapshot
      def self.build(params, context:)
        Params::ImportSnapshotOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ImportSnapshotOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          description: 'description',
          import_task_id: 'import_task_id',
          snapshot_task_detail: SnapshotTaskDetail.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportSnapshotResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << SnapshotTaskDetail.stub('snapshotTaskDetail', stub[:snapshot_task_detail]) unless stub[:snapshot_task_detail].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ImportSnapshotTask
      def self.default(visited = [])
        return nil if visited.include?('ImportSnapshotTask')
        visited = visited + ['ImportSnapshotTask']
        {
          description: 'description',
          import_task_id: 'import_task_id',
          snapshot_task_detail: SnapshotTaskDetail.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('importTaskId', stub[:import_task_id].to_s) unless stub[:import_task_id].nil?
        xml << SnapshotTaskDetail.stub('snapshotTaskDetail', stub[:snapshot_task_detail]) unless stub[:snapshot_task_detail].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class ImportSnapshotTaskList
      def self.default(visited = [])
        return nil if visited.include?('ImportSnapshotTaskList')
        visited = visited + ['ImportSnapshotTaskList']
        [
          ImportSnapshotTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ImportSnapshotTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ImportVolume
      def self.build(params, context:)
        Params::ImportVolumeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ImportVolumeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          conversion_task: ConversionTask.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ImportVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ConversionTask.stub('conversionTask', stub[:conversion_task]) unless stub[:conversion_task].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ImportVolumeTaskDetails
      def self.default(visited = [])
        return nil if visited.include?('ImportVolumeTaskDetails')
        visited = visited + ['ImportVolumeTaskDetails']
        {
          availability_zone: 'availability_zone',
          bytes_converted: 1,
          description: 'description',
          image: DiskImageDescription.default(visited),
          volume: DiskImageVolumeDescription.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('bytesConverted', stub[:bytes_converted].to_s) unless stub[:bytes_converted].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << DiskImageDescription.stub('image', stub[:image]) unless stub[:image].nil?
        xml << DiskImageVolumeDescription.stub('volume', stub[:volume]) unless stub[:volume].nil?
        xml
      end
    end

    class InferenceAcceleratorInfo
      def self.default(visited = [])
        return nil if visited.include?('InferenceAcceleratorInfo')
        visited = visited + ['InferenceAcceleratorInfo']
        {
          accelerators: InferenceDeviceInfoList.default(visited),
          total_inference_memory_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('accelerators', InferenceDeviceInfoList.stub('member', stub[:accelerators])) unless stub[:accelerators].nil?
        xml << Hearth::XML::Node.new('totalInferenceMemoryInMiB', stub[:total_inference_memory_in_mi_b].to_s) unless stub[:total_inference_memory_in_mi_b].nil?
        xml
      end
    end

    class InferenceDeviceInfo
      def self.default(visited = [])
        return nil if visited.include?('InferenceDeviceInfo')
        visited = visited + ['InferenceDeviceInfo']
        {
          count: 1,
          name: 'name',
          manufacturer: 'manufacturer',
          memory_info: InferenceDeviceMemoryInfo.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('manufacturer', stub[:manufacturer].to_s) unless stub[:manufacturer].nil?
        xml << InferenceDeviceMemoryInfo.stub('memoryInfo', stub[:memory_info]) unless stub[:memory_info].nil?
        xml
      end
    end

    class InferenceDeviceInfoList
      def self.default(visited = [])
        return nil if visited.include?('InferenceDeviceInfoList')
        visited = visited + ['InferenceDeviceInfoList']
        [
          InferenceDeviceInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InferenceDeviceInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InferenceDeviceMemoryInfo
      def self.default(visited = [])
        return nil if visited.include?('InferenceDeviceMemoryInfo')
        visited = visited + ['InferenceDeviceMemoryInfo']
        {
          size_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sizeInMiB', stub[:size_in_mi_b].to_s) unless stub[:size_in_mi_b].nil?
        xml
      end
    end

    class InsideCidrBlocksStringList
      def self.default(visited = [])
        return nil if visited.include?('InsideCidrBlocksStringList')
        visited = visited + ['InsideCidrBlocksStringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class Instance
      def self.default(visited = [])
        return nil if visited.include?('Instance')
        visited = visited + ['Instance']
        {
          ami_launch_index: 1,
          image_id: 'image_id',
          instance_id: 'instance_id',
          instance_type: 'instance_type',
          kernel_id: 'kernel_id',
          key_name: 'key_name',
          launch_time: Time.now,
          monitoring: Monitoring.default(visited),
          placement: Placement.default(visited),
          platform: 'platform',
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
          product_codes: ProductCodeList.default(visited),
          public_dns_name: 'public_dns_name',
          public_ip_address: 'public_ip_address',
          ramdisk_id: 'ramdisk_id',
          state: InstanceState.default(visited),
          state_transition_reason: 'state_transition_reason',
          subnet_id: 'subnet_id',
          vpc_id: 'vpc_id',
          architecture: 'architecture',
          block_device_mappings: InstanceBlockDeviceMappingList.default(visited),
          client_token: 'client_token',
          ebs_optimized: false,
          ena_support: false,
          hypervisor: 'hypervisor',
          iam_instance_profile: IamInstanceProfile.default(visited),
          instance_lifecycle: 'instance_lifecycle',
          elastic_gpu_associations: ElasticGpuAssociationList.default(visited),
          elastic_inference_accelerator_associations: ElasticInferenceAcceleratorAssociationList.default(visited),
          network_interfaces: InstanceNetworkInterfaceList.default(visited),
          outpost_arn: 'outpost_arn',
          root_device_name: 'root_device_name',
          root_device_type: 'root_device_type',
          security_groups: GroupIdentifierList.default(visited),
          source_dest_check: false,
          spot_instance_request_id: 'spot_instance_request_id',
          sriov_net_support: 'sriov_net_support',
          state_reason: StateReason.default(visited),
          tags: TagList.default(visited),
          virtualization_type: 'virtualization_type',
          cpu_options: CpuOptions.default(visited),
          capacity_reservation_id: 'capacity_reservation_id',
          capacity_reservation_specification: CapacityReservationSpecificationResponse.default(visited),
          hibernation_options: HibernationOptions.default(visited),
          licenses: LicenseList.default(visited),
          metadata_options: InstanceMetadataOptionsResponse.default(visited),
          enclave_options: EnclaveOptions.default(visited),
          boot_mode: 'boot_mode',
          platform_details: 'platform_details',
          usage_operation: 'usage_operation',
          usage_operation_update_time: Time.now,
          private_dns_name_options: PrivateDnsNameOptionsResponse.default(visited),
          ipv6_address: 'ipv6_address',
          tpm_support: 'tpm_support',
          maintenance_options: InstanceMaintenanceOptions.default(visited),
          current_instance_boot_mode: 'current_instance_boot_mode',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('amiLaunchIndex', stub[:ami_launch_index].to_s) unless stub[:ami_launch_index].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('launchTime', Hearth::TimeHelper.to_date_time(stub[:launch_time])) unless stub[:launch_time].nil?
        xml << Monitoring.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml << Placement.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('productCodes', ProductCodeList.stub('item', stub[:product_codes])) unless stub[:product_codes].nil?
        xml << Hearth::XML::Node.new('dnsName', stub[:public_dns_name].to_s) unless stub[:public_dns_name].nil?
        xml << Hearth::XML::Node.new('ipAddress', stub[:public_ip_address].to_s) unless stub[:public_ip_address].nil?
        xml << Hearth::XML::Node.new('ramdiskId', stub[:ramdisk_id].to_s) unless stub[:ramdisk_id].nil?
        xml << InstanceState.stub('instanceState', stub[:state]) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('reason', stub[:state_transition_reason].to_s) unless stub[:state_transition_reason].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('architecture', stub[:architecture].to_s) unless stub[:architecture].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', InstanceBlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << Hearth::XML::Node.new('enaSupport', stub[:ena_support].to_s) unless stub[:ena_support].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << IamInstanceProfile.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('instanceLifecycle', stub[:instance_lifecycle].to_s) unless stub[:instance_lifecycle].nil?
        xml << Hearth::XML::Node.new('elasticGpuAssociationSet', ElasticGpuAssociationList.stub('item', stub[:elastic_gpu_associations])) unless stub[:elastic_gpu_associations].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorAssociationSet', ElasticInferenceAcceleratorAssociationList.stub('item', stub[:elastic_inference_accelerator_associations])) unless stub[:elastic_inference_accelerator_associations].nil?
        xml << Hearth::XML::Node.new('networkInterfaceSet', InstanceNetworkInterfaceList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('rootDeviceName', stub[:root_device_name].to_s) unless stub[:root_device_name].nil?
        xml << Hearth::XML::Node.new('rootDeviceType', stub[:root_device_type].to_s) unless stub[:root_device_type].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << Hearth::XML::Node.new('sourceDestCheck', stub[:source_dest_check].to_s) unless stub[:source_dest_check].nil?
        xml << Hearth::XML::Node.new('spotInstanceRequestId', stub[:spot_instance_request_id].to_s) unless stub[:spot_instance_request_id].nil?
        xml << Hearth::XML::Node.new('sriovNetSupport', stub[:sriov_net_support].to_s) unless stub[:sriov_net_support].nil?
        xml << StateReason.stub('stateReason', stub[:state_reason]) unless stub[:state_reason].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('virtualizationType', stub[:virtualization_type].to_s) unless stub[:virtualization_type].nil?
        xml << CpuOptions.stub('cpuOptions', stub[:cpu_options]) unless stub[:cpu_options].nil?
        xml << Hearth::XML::Node.new('capacityReservationId', stub[:capacity_reservation_id].to_s) unless stub[:capacity_reservation_id].nil?
        xml << CapacityReservationSpecificationResponse.stub('capacityReservationSpecification', stub[:capacity_reservation_specification]) unless stub[:capacity_reservation_specification].nil?
        xml << HibernationOptions.stub('hibernationOptions', stub[:hibernation_options]) unless stub[:hibernation_options].nil?
        xml << Hearth::XML::Node.new('licenseSet', LicenseList.stub('item', stub[:licenses])) unless stub[:licenses].nil?
        xml << InstanceMetadataOptionsResponse.stub('metadataOptions', stub[:metadata_options]) unless stub[:metadata_options].nil?
        xml << EnclaveOptions.stub('enclaveOptions', stub[:enclave_options]) unless stub[:enclave_options].nil?
        xml << Hearth::XML::Node.new('bootMode', stub[:boot_mode].to_s) unless stub[:boot_mode].nil?
        xml << Hearth::XML::Node.new('platformDetails', stub[:platform_details].to_s) unless stub[:platform_details].nil?
        xml << Hearth::XML::Node.new('usageOperation', stub[:usage_operation].to_s) unless stub[:usage_operation].nil?
        xml << Hearth::XML::Node.new('usageOperationUpdateTime', Hearth::TimeHelper.to_date_time(stub[:usage_operation_update_time])) unless stub[:usage_operation_update_time].nil?
        xml << PrivateDnsNameOptionsResponse.stub('privateDnsNameOptions', stub[:private_dns_name_options]) unless stub[:private_dns_name_options].nil?
        xml << Hearth::XML::Node.new('ipv6Address', stub[:ipv6_address].to_s) unless stub[:ipv6_address].nil?
        xml << Hearth::XML::Node.new('tpmSupport', stub[:tpm_support].to_s) unless stub[:tpm_support].nil?
        xml << InstanceMaintenanceOptions.stub('maintenanceOptions', stub[:maintenance_options]) unless stub[:maintenance_options].nil?
        xml << Hearth::XML::Node.new('currentInstanceBootMode', stub[:current_instance_boot_mode].to_s) unless stub[:current_instance_boot_mode].nil?
        xml
      end
    end

    class InstanceBlockDeviceMapping
      def self.default(visited = [])
        return nil if visited.include?('InstanceBlockDeviceMapping')
        visited = visited + ['InstanceBlockDeviceMapping']
        {
          device_name: 'device_name',
          ebs: EbsInstanceBlockDevice.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << EbsInstanceBlockDevice.stub('ebs', stub[:ebs]) unless stub[:ebs].nil?
        xml
      end
    end

    class InstanceBlockDeviceMappingList
      def self.default(visited = [])
        return nil if visited.include?('InstanceBlockDeviceMappingList')
        visited = visited + ['InstanceBlockDeviceMappingList']
        [
          InstanceBlockDeviceMapping.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceBlockDeviceMapping.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceCapacity
      def self.default(visited = [])
        return nil if visited.include?('InstanceCapacity')
        visited = visited + ['InstanceCapacity']
        {
          available_capacity: 1,
          instance_type: 'instance_type',
          total_capacity: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availableCapacity', stub[:available_capacity].to_s) unless stub[:available_capacity].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('totalCapacity', stub[:total_capacity].to_s) unless stub[:total_capacity].nil?
        xml
      end
    end

    class InstanceConnectEndpointSet
      def self.default(visited = [])
        return nil if visited.include?('InstanceConnectEndpointSet')
        visited = visited + ['InstanceConnectEndpointSet']
        [
          Ec2InstanceConnectEndpoint.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ec2InstanceConnectEndpoint.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceCount
      def self.default(visited = [])
        return nil if visited.include?('InstanceCount')
        visited = visited + ['InstanceCount']
        {
          instance_count: 1,
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class InstanceCountList
      def self.default(visited = [])
        return nil if visited.include?('InstanceCountList')
        visited = visited + ['InstanceCountList']
        [
          InstanceCount.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceCount.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceCreditSpecification
      def self.default(visited = [])
        return nil if visited.include?('InstanceCreditSpecification')
        visited = visited + ['InstanceCreditSpecification']
        {
          instance_id: 'instance_id',
          cpu_credits: 'cpu_credits',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('cpuCredits', stub[:cpu_credits].to_s) unless stub[:cpu_credits].nil?
        xml
      end
    end

    class InstanceCreditSpecificationList
      def self.default(visited = [])
        return nil if visited.include?('InstanceCreditSpecificationList')
        visited = visited + ['InstanceCreditSpecificationList']
        [
          InstanceCreditSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceCreditSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceEventWindow
      def self.default(visited = [])
        return nil if visited.include?('InstanceEventWindow')
        visited = visited + ['InstanceEventWindow']
        {
          instance_event_window_id: 'instance_event_window_id',
          time_ranges: InstanceEventWindowTimeRangeList.default(visited),
          name: 'name',
          cron_expression: 'cron_expression',
          association_target: InstanceEventWindowAssociationTarget.default(visited),
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceEventWindowId', stub[:instance_event_window_id].to_s) unless stub[:instance_event_window_id].nil?
        xml << Hearth::XML::Node.new('timeRangeSet', InstanceEventWindowTimeRangeList.stub('item', stub[:time_ranges])) unless stub[:time_ranges].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('cronExpression', stub[:cron_expression].to_s) unless stub[:cron_expression].nil?
        xml << InstanceEventWindowAssociationTarget.stub('associationTarget', stub[:association_target]) unless stub[:association_target].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class InstanceEventWindowAssociationTarget
      def self.default(visited = [])
        return nil if visited.include?('InstanceEventWindowAssociationTarget')
        visited = visited + ['InstanceEventWindowAssociationTarget']
        {
          instance_ids: InstanceIdList.default(visited),
          tags: TagList.default(visited),
          dedicated_host_ids: DedicatedHostIdList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceIdSet', InstanceIdList.stub('item', stub[:instance_ids])) unless stub[:instance_ids].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('dedicatedHostIdSet', DedicatedHostIdList.stub('item', stub[:dedicated_host_ids])) unless stub[:dedicated_host_ids].nil?
        xml
      end
    end

    class InstanceEventWindowSet
      def self.default(visited = [])
        return nil if visited.include?('InstanceEventWindowSet')
        visited = visited + ['InstanceEventWindowSet']
        [
          InstanceEventWindow.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceEventWindow.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceEventWindowStateChange
      def self.default(visited = [])
        return nil if visited.include?('InstanceEventWindowStateChange')
        visited = visited + ['InstanceEventWindowStateChange']
        {
          instance_event_window_id: 'instance_event_window_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceEventWindowId', stub[:instance_event_window_id].to_s) unless stub[:instance_event_window_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class InstanceEventWindowTimeRange
      def self.default(visited = [])
        return nil if visited.include?('InstanceEventWindowTimeRange')
        visited = visited + ['InstanceEventWindowTimeRange']
        {
          start_week_day: 'start_week_day',
          start_hour: 1,
          end_week_day: 'end_week_day',
          end_hour: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('startWeekDay', stub[:start_week_day].to_s) unless stub[:start_week_day].nil?
        xml << Hearth::XML::Node.new('startHour', stub[:start_hour].to_s) unless stub[:start_hour].nil?
        xml << Hearth::XML::Node.new('endWeekDay', stub[:end_week_day].to_s) unless stub[:end_week_day].nil?
        xml << Hearth::XML::Node.new('endHour', stub[:end_hour].to_s) unless stub[:end_hour].nil?
        xml
      end
    end

    class InstanceEventWindowTimeRangeList
      def self.default(visited = [])
        return nil if visited.include?('InstanceEventWindowTimeRangeList')
        visited = visited + ['InstanceEventWindowTimeRangeList']
        [
          InstanceEventWindowTimeRange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceEventWindowTimeRange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceExportDetails
      def self.default(visited = [])
        return nil if visited.include?('InstanceExportDetails')
        visited = visited + ['InstanceExportDetails']
        {
          instance_id: 'instance_id',
          target_environment: 'target_environment',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('targetEnvironment', stub[:target_environment].to_s) unless stub[:target_environment].nil?
        xml
      end
    end

    class InstanceFamilyCreditSpecification
      def self.default(visited = [])
        return nil if visited.include?('InstanceFamilyCreditSpecification')
        visited = visited + ['InstanceFamilyCreditSpecification']
        {
          instance_family: 'instance_family',
          cpu_credits: 'cpu_credits',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('cpuCredits', stub[:cpu_credits].to_s) unless stub[:cpu_credits].nil?
        xml
      end
    end

    class InstanceGenerationSet
      def self.default(visited = [])
        return nil if visited.include?('InstanceGenerationSet')
        visited = visited + ['InstanceGenerationSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class InstanceIdList
      def self.default(visited = [])
        return nil if visited.include?('InstanceIdList')
        visited = visited + ['InstanceIdList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class InstanceIdSet
      def self.default(visited = [])
        return nil if visited.include?('InstanceIdSet')
        visited = visited + ['InstanceIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class InstanceIdsSet
      def self.default(visited = [])
        return nil if visited.include?('InstanceIdsSet')
        visited = visited + ['InstanceIdsSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class InstanceIpv4Prefix
      def self.default(visited = [])
        return nil if visited.include?('InstanceIpv4Prefix')
        visited = visited + ['InstanceIpv4Prefix']
        {
          ipv4_prefix: 'ipv4_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv4Prefix', stub[:ipv4_prefix].to_s) unless stub[:ipv4_prefix].nil?
        xml
      end
    end

    class InstanceIpv4PrefixList
      def self.default(visited = [])
        return nil if visited.include?('InstanceIpv4PrefixList')
        visited = visited + ['InstanceIpv4PrefixList']
        [
          InstanceIpv4Prefix.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceIpv4Prefix.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceIpv6Address
      def self.default(visited = [])
        return nil if visited.include?('InstanceIpv6Address')
        visited = visited + ['InstanceIpv6Address']
        {
          ipv6_address: 'ipv6_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Address', stub[:ipv6_address].to_s) unless stub[:ipv6_address].nil?
        xml
      end
    end

    class InstanceIpv6AddressList
      def self.default(visited = [])
        return nil if visited.include?('InstanceIpv6AddressList')
        visited = visited + ['InstanceIpv6AddressList']
        [
          InstanceIpv6Address.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceIpv6Address.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceIpv6Prefix
      def self.default(visited = [])
        return nil if visited.include?('InstanceIpv6Prefix')
        visited = visited + ['InstanceIpv6Prefix']
        {
          ipv6_prefix: 'ipv6_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Prefix', stub[:ipv6_prefix].to_s) unless stub[:ipv6_prefix].nil?
        xml
      end
    end

    class InstanceIpv6PrefixList
      def self.default(visited = [])
        return nil if visited.include?('InstanceIpv6PrefixList')
        visited = visited + ['InstanceIpv6PrefixList']
        [
          InstanceIpv6Prefix.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceIpv6Prefix.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceList
      def self.default(visited = [])
        return nil if visited.include?('InstanceList')
        visited = visited + ['InstanceList']
        [
          Instance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Instance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceMaintenanceOptions
      def self.default(visited = [])
        return nil if visited.include?('InstanceMaintenanceOptions')
        visited = visited + ['InstanceMaintenanceOptions']
        {
          auto_recovery: 'auto_recovery',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('autoRecovery', stub[:auto_recovery].to_s) unless stub[:auto_recovery].nil?
        xml
      end
    end

    class InstanceMetadataOptionsResponse
      def self.default(visited = [])
        return nil if visited.include?('InstanceMetadataOptionsResponse')
        visited = visited + ['InstanceMetadataOptionsResponse']
        {
          state: 'state',
          http_tokens: 'http_tokens',
          http_put_response_hop_limit: 1,
          http_endpoint: 'http_endpoint',
          http_protocol_ipv6: 'http_protocol_ipv6',
          instance_metadata_tags: 'instance_metadata_tags',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('httpTokens', stub[:http_tokens].to_s) unless stub[:http_tokens].nil?
        xml << Hearth::XML::Node.new('httpPutResponseHopLimit', stub[:http_put_response_hop_limit].to_s) unless stub[:http_put_response_hop_limit].nil?
        xml << Hearth::XML::Node.new('httpEndpoint', stub[:http_endpoint].to_s) unless stub[:http_endpoint].nil?
        xml << Hearth::XML::Node.new('httpProtocolIpv6', stub[:http_protocol_ipv6].to_s) unless stub[:http_protocol_ipv6].nil?
        xml << Hearth::XML::Node.new('instanceMetadataTags', stub[:instance_metadata_tags].to_s) unless stub[:instance_metadata_tags].nil?
        xml
      end
    end

    class InstanceMonitoring
      def self.default(visited = [])
        return nil if visited.include?('InstanceMonitoring')
        visited = visited + ['InstanceMonitoring']
        {
          instance_id: 'instance_id',
          monitoring: Monitoring.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Monitoring.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml
      end
    end

    class InstanceMonitoringList
      def self.default(visited = [])
        return nil if visited.include?('InstanceMonitoringList')
        visited = visited + ['InstanceMonitoringList']
        [
          InstanceMonitoring.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceMonitoring.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceNetworkInterface
      def self.default(visited = [])
        return nil if visited.include?('InstanceNetworkInterface')
        visited = visited + ['InstanceNetworkInterface']
        {
          association: InstanceNetworkInterfaceAssociation.default(visited),
          attachment: InstanceNetworkInterfaceAttachment.default(visited),
          description: 'description',
          groups: GroupIdentifierList.default(visited),
          ipv6_addresses: InstanceIpv6AddressList.default(visited),
          mac_address: 'mac_address',
          network_interface_id: 'network_interface_id',
          owner_id: 'owner_id',
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
          private_ip_addresses: InstancePrivateIpAddressList.default(visited),
          source_dest_check: false,
          status: 'status',
          subnet_id: 'subnet_id',
          vpc_id: 'vpc_id',
          interface_type: 'interface_type',
          ipv4_prefixes: InstanceIpv4PrefixList.default(visited),
          ipv6_prefixes: InstanceIpv6PrefixList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << InstanceNetworkInterfaceAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << InstanceNetworkInterfaceAttachment.stub('attachment', stub[:attachment]) unless stub[:attachment].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesSet', InstanceIpv6AddressList.stub('item', stub[:ipv6_addresses])) unless stub[:ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('macAddress', stub[:mac_address].to_s) unless stub[:mac_address].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('privateIpAddressesSet', InstancePrivateIpAddressList.stub('item', stub[:private_ip_addresses])) unless stub[:private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('sourceDestCheck', stub[:source_dest_check].to_s) unless stub[:source_dest_check].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('interfaceType', stub[:interface_type].to_s) unless stub[:interface_type].nil?
        xml << Hearth::XML::Node.new('ipv4PrefixSet', InstanceIpv4PrefixList.stub('item', stub[:ipv4_prefixes])) unless stub[:ipv4_prefixes].nil?
        xml << Hearth::XML::Node.new('ipv6PrefixSet', InstanceIpv6PrefixList.stub('item', stub[:ipv6_prefixes])) unless stub[:ipv6_prefixes].nil?
        xml
      end
    end

    class InstanceNetworkInterfaceAssociation
      def self.default(visited = [])
        return nil if visited.include?('InstanceNetworkInterfaceAssociation')
        visited = visited + ['InstanceNetworkInterfaceAssociation']
        {
          carrier_ip: 'carrier_ip',
          customer_owned_ip: 'customer_owned_ip',
          ip_owner_id: 'ip_owner_id',
          public_dns_name: 'public_dns_name',
          public_ip: 'public_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('carrierIp', stub[:carrier_ip].to_s) unless stub[:carrier_ip].nil?
        xml << Hearth::XML::Node.new('customerOwnedIp', stub[:customer_owned_ip].to_s) unless stub[:customer_owned_ip].nil?
        xml << Hearth::XML::Node.new('ipOwnerId', stub[:ip_owner_id].to_s) unless stub[:ip_owner_id].nil?
        xml << Hearth::XML::Node.new('publicDnsName', stub[:public_dns_name].to_s) unless stub[:public_dns_name].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml
      end
    end

    class InstanceNetworkInterfaceAttachment
      def self.default(visited = [])
        return nil if visited.include?('InstanceNetworkInterfaceAttachment')
        visited = visited + ['InstanceNetworkInterfaceAttachment']
        {
          attach_time: Time.now,
          attachment_id: 'attachment_id',
          delete_on_termination: false,
          device_index: 1,
          status: 'status',
          network_card_index: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('attachmentId', stub[:attachment_id].to_s) unless stub[:attachment_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('deviceIndex', stub[:device_index].to_s) unless stub[:device_index].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml
      end
    end

    class InstanceNetworkInterfaceList
      def self.default(visited = [])
        return nil if visited.include?('InstanceNetworkInterfaceList')
        visited = visited + ['InstanceNetworkInterfaceList']
        [
          InstanceNetworkInterface.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceNetworkInterface.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceNetworkInterfaceSpecification
      def self.default(visited = [])
        return nil if visited.include?('InstanceNetworkInterfaceSpecification')
        visited = visited + ['InstanceNetworkInterfaceSpecification']
        {
          associate_public_ip_address: false,
          delete_on_termination: false,
          description: 'description',
          device_index: 1,
          groups: SecurityGroupIdStringList.default(visited),
          ipv6_address_count: 1,
          ipv6_addresses: InstanceIpv6AddressList.default(visited),
          network_interface_id: 'network_interface_id',
          private_ip_address: 'private_ip_address',
          private_ip_addresses: PrivateIpAddressSpecificationList.default(visited),
          secondary_private_ip_address_count: 1,
          subnet_id: 'subnet_id',
          associate_carrier_ip_address: false,
          interface_type: 'interface_type',
          network_card_index: 1,
          ipv4_prefixes: Ipv4PrefixList.default(visited),
          ipv4_prefix_count: 1,
          ipv6_prefixes: Ipv6PrefixList.default(visited),
          ipv6_prefix_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associatePublicIpAddress', stub[:associate_public_ip_address].to_s) unless stub[:associate_public_ip_address].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('deviceIndex', stub[:device_index].to_s) unless stub[:device_index].nil?
        xml << Hearth::XML::Node.new('SecurityGroupId', SecurityGroupIdStringList.stub('SecurityGroupId', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('ipv6AddressCount', stub[:ipv6_address_count].to_s) unless stub[:ipv6_address_count].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesSet', InstanceIpv6AddressList.stub('item', stub[:ipv6_addresses])) unless stub[:ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('privateIpAddressesSet', PrivateIpAddressSpecificationList.stub('item', stub[:private_ip_addresses])) unless stub[:private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('secondaryPrivateIpAddressCount', stub[:secondary_private_ip_address_count].to_s) unless stub[:secondary_private_ip_address_count].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('AssociateCarrierIpAddress', stub[:associate_carrier_ip_address].to_s) unless stub[:associate_carrier_ip_address].nil?
        xml << Hearth::XML::Node.new('InterfaceType', stub[:interface_type].to_s) unless stub[:interface_type].nil?
        xml << Hearth::XML::Node.new('NetworkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml << Hearth::XML::Node.new('Ipv4Prefix', Ipv4PrefixList.stub('item', stub[:ipv4_prefixes])) unless stub[:ipv4_prefixes].nil?
        xml << Hearth::XML::Node.new('Ipv4PrefixCount', stub[:ipv4_prefix_count].to_s) unless stub[:ipv4_prefix_count].nil?
        xml << Hearth::XML::Node.new('Ipv6Prefix', Ipv6PrefixList.stub('item', stub[:ipv6_prefixes])) unless stub[:ipv6_prefixes].nil?
        xml << Hearth::XML::Node.new('Ipv6PrefixCount', stub[:ipv6_prefix_count].to_s) unless stub[:ipv6_prefix_count].nil?
        xml
      end
    end

    class InstanceNetworkInterfaceSpecificationList
      def self.default(visited = [])
        return nil if visited.include?('InstanceNetworkInterfaceSpecificationList')
        visited = visited + ['InstanceNetworkInterfaceSpecificationList']
        [
          InstanceNetworkInterfaceSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceNetworkInterfaceSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstancePrivateIpAddress
      def self.default(visited = [])
        return nil if visited.include?('InstancePrivateIpAddress')
        visited = visited + ['InstancePrivateIpAddress']
        {
          association: InstanceNetworkInterfaceAssociation.default(visited),
          primary: false,
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << InstanceNetworkInterfaceAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << Hearth::XML::Node.new('primary', stub[:primary].to_s) unless stub[:primary].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml
      end
    end

    class InstancePrivateIpAddressList
      def self.default(visited = [])
        return nil if visited.include?('InstancePrivateIpAddressList')
        visited = visited + ['InstancePrivateIpAddressList']
        [
          InstancePrivateIpAddress.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstancePrivateIpAddress.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceRequirements
      def self.default(visited = [])
        return nil if visited.include?('InstanceRequirements')
        visited = visited + ['InstanceRequirements']
        {
          v_cpu_count: VCpuCountRange.default(visited),
          memory_mi_b: MemoryMiB.default(visited),
          cpu_manufacturers: CpuManufacturerSet.default(visited),
          memory_gi_b_per_v_cpu: MemoryGiBPerVCpu.default(visited),
          excluded_instance_types: ExcludedInstanceTypeSet.default(visited),
          instance_generations: InstanceGenerationSet.default(visited),
          spot_max_price_percentage_over_lowest_price: 1,
          on_demand_max_price_percentage_over_lowest_price: 1,
          bare_metal: 'bare_metal',
          burstable_performance: 'burstable_performance',
          require_hibernate_support: false,
          network_interface_count: NetworkInterfaceCount.default(visited),
          local_storage: 'local_storage',
          local_storage_types: LocalStorageTypeSet.default(visited),
          total_local_storage_gb: TotalLocalStorageGB.default(visited),
          baseline_ebs_bandwidth_mbps: BaselineEbsBandwidthMbps.default(visited),
          accelerator_types: AcceleratorTypeSet.default(visited),
          accelerator_count: AcceleratorCount.default(visited),
          accelerator_manufacturers: AcceleratorManufacturerSet.default(visited),
          accelerator_names: AcceleratorNameSet.default(visited),
          accelerator_total_memory_mi_b: AcceleratorTotalMemoryMiB.default(visited),
          network_bandwidth_gbps: NetworkBandwidthGbps.default(visited),
          allowed_instance_types: AllowedInstanceTypeSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << VCpuCountRange.stub('vCpuCount', stub[:v_cpu_count]) unless stub[:v_cpu_count].nil?
        xml << MemoryMiB.stub('memoryMiB', stub[:memory_mi_b]) unless stub[:memory_mi_b].nil?
        xml << Hearth::XML::Node.new('cpuManufacturerSet', CpuManufacturerSet.stub('item', stub[:cpu_manufacturers])) unless stub[:cpu_manufacturers].nil?
        xml << MemoryGiBPerVCpu.stub('memoryGiBPerVCpu', stub[:memory_gi_b_per_v_cpu]) unless stub[:memory_gi_b_per_v_cpu].nil?
        xml << Hearth::XML::Node.new('excludedInstanceTypeSet', ExcludedInstanceTypeSet.stub('item', stub[:excluded_instance_types])) unless stub[:excluded_instance_types].nil?
        xml << Hearth::XML::Node.new('instanceGenerationSet', InstanceGenerationSet.stub('item', stub[:instance_generations])) unless stub[:instance_generations].nil?
        xml << Hearth::XML::Node.new('spotMaxPricePercentageOverLowestPrice', stub[:spot_max_price_percentage_over_lowest_price].to_s) unless stub[:spot_max_price_percentage_over_lowest_price].nil?
        xml << Hearth::XML::Node.new('onDemandMaxPricePercentageOverLowestPrice', stub[:on_demand_max_price_percentage_over_lowest_price].to_s) unless stub[:on_demand_max_price_percentage_over_lowest_price].nil?
        xml << Hearth::XML::Node.new('bareMetal', stub[:bare_metal].to_s) unless stub[:bare_metal].nil?
        xml << Hearth::XML::Node.new('burstablePerformance', stub[:burstable_performance].to_s) unless stub[:burstable_performance].nil?
        xml << Hearth::XML::Node.new('requireHibernateSupport', stub[:require_hibernate_support].to_s) unless stub[:require_hibernate_support].nil?
        xml << NetworkInterfaceCount.stub('networkInterfaceCount', stub[:network_interface_count]) unless stub[:network_interface_count].nil?
        xml << Hearth::XML::Node.new('localStorage', stub[:local_storage].to_s) unless stub[:local_storage].nil?
        xml << Hearth::XML::Node.new('localStorageTypeSet', LocalStorageTypeSet.stub('item', stub[:local_storage_types])) unless stub[:local_storage_types].nil?
        xml << TotalLocalStorageGB.stub('totalLocalStorageGB', stub[:total_local_storage_gb]) unless stub[:total_local_storage_gb].nil?
        xml << BaselineEbsBandwidthMbps.stub('baselineEbsBandwidthMbps', stub[:baseline_ebs_bandwidth_mbps]) unless stub[:baseline_ebs_bandwidth_mbps].nil?
        xml << Hearth::XML::Node.new('acceleratorTypeSet', AcceleratorTypeSet.stub('item', stub[:accelerator_types])) unless stub[:accelerator_types].nil?
        xml << AcceleratorCount.stub('acceleratorCount', stub[:accelerator_count]) unless stub[:accelerator_count].nil?
        xml << Hearth::XML::Node.new('acceleratorManufacturerSet', AcceleratorManufacturerSet.stub('item', stub[:accelerator_manufacturers])) unless stub[:accelerator_manufacturers].nil?
        xml << Hearth::XML::Node.new('acceleratorNameSet', AcceleratorNameSet.stub('item', stub[:accelerator_names])) unless stub[:accelerator_names].nil?
        xml << AcceleratorTotalMemoryMiB.stub('acceleratorTotalMemoryMiB', stub[:accelerator_total_memory_mi_b]) unless stub[:accelerator_total_memory_mi_b].nil?
        xml << NetworkBandwidthGbps.stub('networkBandwidthGbps', stub[:network_bandwidth_gbps]) unless stub[:network_bandwidth_gbps].nil?
        xml << Hearth::XML::Node.new('allowedInstanceTypeSet', AllowedInstanceTypeSet.stub('item', stub[:allowed_instance_types])) unless stub[:allowed_instance_types].nil?
        xml
      end
    end

    class InstanceState
      def self.default(visited = [])
        return nil if visited.include?('InstanceState')
        visited = visited + ['InstanceState']
        {
          code: 1,
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    class InstanceStateChange
      def self.default(visited = [])
        return nil if visited.include?('InstanceStateChange')
        visited = visited + ['InstanceStateChange']
        {
          current_state: InstanceState.default(visited),
          instance_id: 'instance_id',
          previous_state: InstanceState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << InstanceState.stub('currentState', stub[:current_state]) unless stub[:current_state].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << InstanceState.stub('previousState', stub[:previous_state]) unless stub[:previous_state].nil?
        xml
      end
    end

    class InstanceStateChangeList
      def self.default(visited = [])
        return nil if visited.include?('InstanceStateChangeList')
        visited = visited + ['InstanceStateChangeList']
        [
          InstanceStateChange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceStateChange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceStatus
      def self.default(visited = [])
        return nil if visited.include?('InstanceStatus')
        visited = visited + ['InstanceStatus']
        {
          availability_zone: 'availability_zone',
          outpost_arn: 'outpost_arn',
          events: InstanceStatusEventList.default(visited),
          instance_id: 'instance_id',
          instance_state: InstanceState.default(visited),
          instance_status: InstanceStatusSummary.default(visited),
          system_status: InstanceStatusSummary.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('eventsSet', InstanceStatusEventList.stub('item', stub[:events])) unless stub[:events].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << InstanceState.stub('instanceState', stub[:instance_state]) unless stub[:instance_state].nil?
        xml << InstanceStatusSummary.stub('instanceStatus', stub[:instance_status]) unless stub[:instance_status].nil?
        xml << InstanceStatusSummary.stub('systemStatus', stub[:system_status]) unless stub[:system_status].nil?
        xml
      end
    end

    class InstanceStatusDetails
      def self.default(visited = [])
        return nil if visited.include?('InstanceStatusDetails')
        visited = visited + ['InstanceStatusDetails']
        {
          impaired_since: Time.now,
          name: 'name',
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('impairedSince', Hearth::TimeHelper.to_date_time(stub[:impaired_since])) unless stub[:impaired_since].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    class InstanceStatusDetailsList
      def self.default(visited = [])
        return nil if visited.include?('InstanceStatusDetailsList')
        visited = visited + ['InstanceStatusDetailsList']
        [
          InstanceStatusDetails.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceStatusDetails.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceStatusEvent
      def self.default(visited = [])
        return nil if visited.include?('InstanceStatusEvent')
        visited = visited + ['InstanceStatusEvent']
        {
          instance_event_id: 'instance_event_id',
          code: 'code',
          description: 'description',
          not_after: Time.now,
          not_before: Time.now,
          not_before_deadline: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceEventId', stub[:instance_event_id].to_s) unless stub[:instance_event_id].nil?
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('notAfter', Hearth::TimeHelper.to_date_time(stub[:not_after])) unless stub[:not_after].nil?
        xml << Hearth::XML::Node.new('notBefore', Hearth::TimeHelper.to_date_time(stub[:not_before])) unless stub[:not_before].nil?
        xml << Hearth::XML::Node.new('notBeforeDeadline', Hearth::TimeHelper.to_date_time(stub[:not_before_deadline])) unless stub[:not_before_deadline].nil?
        xml
      end
    end

    class InstanceStatusEventList
      def self.default(visited = [])
        return nil if visited.include?('InstanceStatusEventList')
        visited = visited + ['InstanceStatusEventList']
        [
          InstanceStatusEvent.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceStatusEvent.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceStatusList
      def self.default(visited = [])
        return nil if visited.include?('InstanceStatusList')
        visited = visited + ['InstanceStatusList']
        [
          InstanceStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceStatusSummary
      def self.default(visited = [])
        return nil if visited.include?('InstanceStatusSummary')
        visited = visited + ['InstanceStatusSummary']
        {
          details: InstanceStatusDetailsList.default(visited),
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('details', InstanceStatusDetailsList.stub('item', stub[:details])) unless stub[:details].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    class InstanceStorageInfo
      def self.default(visited = [])
        return nil if visited.include?('InstanceStorageInfo')
        visited = visited + ['InstanceStorageInfo']
        {
          total_size_in_gb: 1,
          disks: DiskInfoList.default(visited),
          nvme_support: 'nvme_support',
          encryption_support: 'encryption_support',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('totalSizeInGB', stub[:total_size_in_gb].to_s) unless stub[:total_size_in_gb].nil?
        xml << Hearth::XML::Node.new('disks', DiskInfoList.stub('item', stub[:disks])) unless stub[:disks].nil?
        xml << Hearth::XML::Node.new('nvmeSupport', stub[:nvme_support].to_s) unless stub[:nvme_support].nil?
        xml << Hearth::XML::Node.new('encryptionSupport', stub[:encryption_support].to_s) unless stub[:encryption_support].nil?
        xml
      end
    end

    class InstanceTagKeySet
      def self.default(visited = [])
        return nil if visited.include?('InstanceTagKeySet')
        visited = visited + ['InstanceTagKeySet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class InstanceTagNotificationAttribute
      def self.default(visited = [])
        return nil if visited.include?('InstanceTagNotificationAttribute')
        visited = visited + ['InstanceTagNotificationAttribute']
        {
          instance_tag_keys: InstanceTagKeySet.default(visited),
          include_all_tags_of_instance: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceTagKeySet', InstanceTagKeySet.stub('item', stub[:instance_tag_keys])) unless stub[:instance_tag_keys].nil?
        xml << Hearth::XML::Node.new('includeAllTagsOfInstance', stub[:include_all_tags_of_instance].to_s) unless stub[:include_all_tags_of_instance].nil?
        xml
      end
    end

    class InstanceTypeInfo
      def self.default(visited = [])
        return nil if visited.include?('InstanceTypeInfo')
        visited = visited + ['InstanceTypeInfo']
        {
          instance_type: 'instance_type',
          current_generation: false,
          free_tier_eligible: false,
          supported_usage_classes: UsageClassTypeList.default(visited),
          supported_root_device_types: RootDeviceTypeList.default(visited),
          supported_virtualization_types: VirtualizationTypeList.default(visited),
          bare_metal: false,
          hypervisor: 'hypervisor',
          processor_info: ProcessorInfo.default(visited),
          v_cpu_info: VCpuInfo.default(visited),
          memory_info: MemoryInfo.default(visited),
          instance_storage_supported: false,
          instance_storage_info: InstanceStorageInfo.default(visited),
          ebs_info: EbsInfo.default(visited),
          network_info: NetworkInfo.default(visited),
          gpu_info: GpuInfo.default(visited),
          fpga_info: FpgaInfo.default(visited),
          placement_group_info: PlacementGroupInfo.default(visited),
          inference_accelerator_info: InferenceAcceleratorInfo.default(visited),
          hibernation_supported: false,
          burstable_performance_supported: false,
          dedicated_hosts_supported: false,
          auto_recovery_supported: false,
          supported_boot_modes: BootModeTypeList.default(visited),
          nitro_enclaves_support: 'nitro_enclaves_support',
          nitro_tpm_support: 'nitro_tpm_support',
          nitro_tpm_info: NitroTpmInfo.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('currentGeneration', stub[:current_generation].to_s) unless stub[:current_generation].nil?
        xml << Hearth::XML::Node.new('freeTierEligible', stub[:free_tier_eligible].to_s) unless stub[:free_tier_eligible].nil?
        xml << Hearth::XML::Node.new('supportedUsageClasses', UsageClassTypeList.stub('item', stub[:supported_usage_classes])) unless stub[:supported_usage_classes].nil?
        xml << Hearth::XML::Node.new('supportedRootDeviceTypes', RootDeviceTypeList.stub('item', stub[:supported_root_device_types])) unless stub[:supported_root_device_types].nil?
        xml << Hearth::XML::Node.new('supportedVirtualizationTypes', VirtualizationTypeList.stub('item', stub[:supported_virtualization_types])) unless stub[:supported_virtualization_types].nil?
        xml << Hearth::XML::Node.new('bareMetal', stub[:bare_metal].to_s) unless stub[:bare_metal].nil?
        xml << Hearth::XML::Node.new('hypervisor', stub[:hypervisor].to_s) unless stub[:hypervisor].nil?
        xml << ProcessorInfo.stub('processorInfo', stub[:processor_info]) unless stub[:processor_info].nil?
        xml << VCpuInfo.stub('vCpuInfo', stub[:v_cpu_info]) unless stub[:v_cpu_info].nil?
        xml << MemoryInfo.stub('memoryInfo', stub[:memory_info]) unless stub[:memory_info].nil?
        xml << Hearth::XML::Node.new('instanceStorageSupported', stub[:instance_storage_supported].to_s) unless stub[:instance_storage_supported].nil?
        xml << InstanceStorageInfo.stub('instanceStorageInfo', stub[:instance_storage_info]) unless stub[:instance_storage_info].nil?
        xml << EbsInfo.stub('ebsInfo', stub[:ebs_info]) unless stub[:ebs_info].nil?
        xml << NetworkInfo.stub('networkInfo', stub[:network_info]) unless stub[:network_info].nil?
        xml << GpuInfo.stub('gpuInfo', stub[:gpu_info]) unless stub[:gpu_info].nil?
        xml << FpgaInfo.stub('fpgaInfo', stub[:fpga_info]) unless stub[:fpga_info].nil?
        xml << PlacementGroupInfo.stub('placementGroupInfo', stub[:placement_group_info]) unless stub[:placement_group_info].nil?
        xml << InferenceAcceleratorInfo.stub('inferenceAcceleratorInfo', stub[:inference_accelerator_info]) unless stub[:inference_accelerator_info].nil?
        xml << Hearth::XML::Node.new('hibernationSupported', stub[:hibernation_supported].to_s) unless stub[:hibernation_supported].nil?
        xml << Hearth::XML::Node.new('burstablePerformanceSupported', stub[:burstable_performance_supported].to_s) unless stub[:burstable_performance_supported].nil?
        xml << Hearth::XML::Node.new('dedicatedHostsSupported', stub[:dedicated_hosts_supported].to_s) unless stub[:dedicated_hosts_supported].nil?
        xml << Hearth::XML::Node.new('autoRecoverySupported', stub[:auto_recovery_supported].to_s) unless stub[:auto_recovery_supported].nil?
        xml << Hearth::XML::Node.new('supportedBootModes', BootModeTypeList.stub('item', stub[:supported_boot_modes])) unless stub[:supported_boot_modes].nil?
        xml << Hearth::XML::Node.new('nitroEnclavesSupport', stub[:nitro_enclaves_support].to_s) unless stub[:nitro_enclaves_support].nil?
        xml << Hearth::XML::Node.new('nitroTpmSupport', stub[:nitro_tpm_support].to_s) unless stub[:nitro_tpm_support].nil?
        xml << NitroTpmInfo.stub('nitroTpmInfo', stub[:nitro_tpm_info]) unless stub[:nitro_tpm_info].nil?
        xml
      end
    end

    class InstanceTypeInfoFromInstanceRequirements
      def self.default(visited = [])
        return nil if visited.include?('InstanceTypeInfoFromInstanceRequirements')
        visited = visited + ['InstanceTypeInfoFromInstanceRequirements']
        {
          instance_type: 'instance_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml
      end
    end

    class InstanceTypeInfoFromInstanceRequirementsSet
      def self.default(visited = [])
        return nil if visited.include?('InstanceTypeInfoFromInstanceRequirementsSet')
        visited = visited + ['InstanceTypeInfoFromInstanceRequirementsSet']
        [
          InstanceTypeInfoFromInstanceRequirements.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceTypeInfoFromInstanceRequirements.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceTypeInfoList
      def self.default(visited = [])
        return nil if visited.include?('InstanceTypeInfoList')
        visited = visited + ['InstanceTypeInfoList']
        [
          InstanceTypeInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceTypeInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceTypeOffering
      def self.default(visited = [])
        return nil if visited.include?('InstanceTypeOffering')
        visited = visited + ['InstanceTypeOffering']
        {
          instance_type: 'instance_type',
          location_type: 'location_type',
          location: 'location',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('locationType', stub[:location_type].to_s) unless stub[:location_type].nil?
        xml << Hearth::XML::Node.new('location', stub[:location].to_s) unless stub[:location].nil?
        xml
      end
    end

    class InstanceTypeOfferingsList
      def self.default(visited = [])
        return nil if visited.include?('InstanceTypeOfferingsList')
        visited = visited + ['InstanceTypeOfferingsList']
        [
          InstanceTypeOffering.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceTypeOffering.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InstanceTypesList
      def self.default(visited = [])
        return nil if visited.include?('InstanceTypesList')
        visited = visited + ['InstanceTypesList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class InstanceUsage
      def self.default(visited = [])
        return nil if visited.include?('InstanceUsage')
        visited = visited + ['InstanceUsage']
        {
          account_id: 'account_id',
          used_instance_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('accountId', stub[:account_id].to_s) unless stub[:account_id].nil?
        xml << Hearth::XML::Node.new('usedInstanceCount', stub[:used_instance_count].to_s) unless stub[:used_instance_count].nil?
        xml
      end
    end

    class InstanceUsageSet
      def self.default(visited = [])
        return nil if visited.include?('InstanceUsageSet')
        visited = visited + ['InstanceUsageSet']
        [
          InstanceUsage.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InstanceUsage.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InternetGateway
      def self.default(visited = [])
        return nil if visited.include?('InternetGateway')
        visited = visited + ['InternetGateway']
        {
          attachments: InternetGatewayAttachmentList.default(visited),
          internet_gateway_id: 'internet_gateway_id',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachmentSet', InternetGatewayAttachmentList.stub('item', stub[:attachments])) unless stub[:attachments].nil?
        xml << Hearth::XML::Node.new('internetGatewayId', stub[:internet_gateway_id].to_s) unless stub[:internet_gateway_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class InternetGatewayAttachment
      def self.default(visited = [])
        return nil if visited.include?('InternetGatewayAttachment')
        visited = visited + ['InternetGatewayAttachment']
        {
          state: 'state',
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    class InternetGatewayAttachmentList
      def self.default(visited = [])
        return nil if visited.include?('InternetGatewayAttachmentList')
        visited = visited + ['InternetGatewayAttachmentList']
        [
          InternetGatewayAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InternetGatewayAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class InternetGatewayList
      def self.default(visited = [])
        return nil if visited.include?('InternetGatewayList')
        visited = visited + ['InternetGatewayList']
        [
          InternetGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << InternetGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpAddressList
      def self.default(visited = [])
        return nil if visited.include?('IpAddressList')
        visited = visited + ['IpAddressList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class IpPermission
      def self.default(visited = [])
        return nil if visited.include?('IpPermission')
        visited = visited + ['IpPermission']
        {
          from_port: 1,
          ip_protocol: 'ip_protocol',
          ip_ranges: IpRangeList.default(visited),
          ipv6_ranges: Ipv6RangeList.default(visited),
          prefix_list_ids: PrefixListIdList.default(visited),
          to_port: 1,
          user_id_group_pairs: UserIdGroupPairList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fromPort', stub[:from_port].to_s) unless stub[:from_port].nil?
        xml << Hearth::XML::Node.new('ipProtocol', stub[:ip_protocol].to_s) unless stub[:ip_protocol].nil?
        xml << Hearth::XML::Node.new('ipRanges', IpRangeList.stub('item', stub[:ip_ranges])) unless stub[:ip_ranges].nil?
        xml << Hearth::XML::Node.new('ipv6Ranges', Ipv6RangeList.stub('item', stub[:ipv6_ranges])) unless stub[:ipv6_ranges].nil?
        xml << Hearth::XML::Node.new('prefixListIds', PrefixListIdList.stub('item', stub[:prefix_list_ids])) unless stub[:prefix_list_ids].nil?
        xml << Hearth::XML::Node.new('toPort', stub[:to_port].to_s) unless stub[:to_port].nil?
        xml << Hearth::XML::Node.new('groups', UserIdGroupPairList.stub('item', stub[:user_id_group_pairs])) unless stub[:user_id_group_pairs].nil?
        xml
      end
    end

    class IpPermissionList
      def self.default(visited = [])
        return nil if visited.include?('IpPermissionList')
        visited = visited + ['IpPermissionList']
        [
          IpPermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpPermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpPrefixList
      def self.default(visited = [])
        return nil if visited.include?('IpPrefixList')
        visited = visited + ['IpPrefixList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class IpRange
      def self.default(visited = [])
        return nil if visited.include?('IpRange')
        visited = visited + ['IpRange']
        {
          cidr_ip: 'cidr_ip',
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrIp', stub[:cidr_ip].to_s) unless stub[:cidr_ip].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    class IpRangeList
      def self.default(visited = [])
        return nil if visited.include?('IpRangeList')
        visited = visited + ['IpRangeList']
        [
          IpRange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpRange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpRanges
      def self.default(visited = [])
        return nil if visited.include?('IpRanges')
        visited = visited + ['IpRanges']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class Ipam
      def self.default(visited = [])
        return nil if visited.include?('Ipam')
        visited = visited + ['Ipam']
        {
          owner_id: 'owner_id',
          ipam_id: 'ipam_id',
          ipam_arn: 'ipam_arn',
          ipam_region: 'ipam_region',
          public_default_scope_id: 'public_default_scope_id',
          private_default_scope_id: 'private_default_scope_id',
          scope_count: 1,
          description: 'description',
          operating_regions: IpamOperatingRegionSet.default(visited),
          state: 'state',
          tags: TagList.default(visited),
          default_resource_discovery_id: 'default_resource_discovery_id',
          default_resource_discovery_association_id: 'default_resource_discovery_association_id',
          resource_discovery_association_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ipamId', stub[:ipam_id].to_s) unless stub[:ipam_id].nil?
        xml << Hearth::XML::Node.new('ipamArn', stub[:ipam_arn].to_s) unless stub[:ipam_arn].nil?
        xml << Hearth::XML::Node.new('ipamRegion', stub[:ipam_region].to_s) unless stub[:ipam_region].nil?
        xml << Hearth::XML::Node.new('publicDefaultScopeId', stub[:public_default_scope_id].to_s) unless stub[:public_default_scope_id].nil?
        xml << Hearth::XML::Node.new('privateDefaultScopeId', stub[:private_default_scope_id].to_s) unless stub[:private_default_scope_id].nil?
        xml << Hearth::XML::Node.new('scopeCount', stub[:scope_count].to_s) unless stub[:scope_count].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('operatingRegionSet', IpamOperatingRegionSet.stub('item', stub[:operating_regions])) unless stub[:operating_regions].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('defaultResourceDiscoveryId', stub[:default_resource_discovery_id].to_s) unless stub[:default_resource_discovery_id].nil?
        xml << Hearth::XML::Node.new('defaultResourceDiscoveryAssociationId', stub[:default_resource_discovery_association_id].to_s) unless stub[:default_resource_discovery_association_id].nil?
        xml << Hearth::XML::Node.new('resourceDiscoveryAssociationCount', stub[:resource_discovery_association_count].to_s) unless stub[:resource_discovery_association_count].nil?
        xml
      end
    end

    class IpamAddressHistoryRecord
      def self.default(visited = [])
        return nil if visited.include?('IpamAddressHistoryRecord')
        visited = visited + ['IpamAddressHistoryRecord']
        {
          resource_owner_id: 'resource_owner_id',
          resource_region: 'resource_region',
          resource_type: 'resource_type',
          resource_id: 'resource_id',
          resource_cidr: 'resource_cidr',
          resource_name: 'resource_name',
          resource_compliance_status: 'resource_compliance_status',
          resource_overlap_status: 'resource_overlap_status',
          vpc_id: 'vpc_id',
          sampled_start_time: Time.now,
          sampled_end_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('resourceRegion', stub[:resource_region].to_s) unless stub[:resource_region].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceCidr', stub[:resource_cidr].to_s) unless stub[:resource_cidr].nil?
        xml << Hearth::XML::Node.new('resourceName', stub[:resource_name].to_s) unless stub[:resource_name].nil?
        xml << Hearth::XML::Node.new('resourceComplianceStatus', stub[:resource_compliance_status].to_s) unless stub[:resource_compliance_status].nil?
        xml << Hearth::XML::Node.new('resourceOverlapStatus', stub[:resource_overlap_status].to_s) unless stub[:resource_overlap_status].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('sampledStartTime', Hearth::TimeHelper.to_date_time(stub[:sampled_start_time])) unless stub[:sampled_start_time].nil?
        xml << Hearth::XML::Node.new('sampledEndTime', Hearth::TimeHelper.to_date_time(stub[:sampled_end_time])) unless stub[:sampled_end_time].nil?
        xml
      end
    end

    class IpamAddressHistoryRecordSet
      def self.default(visited = [])
        return nil if visited.include?('IpamAddressHistoryRecordSet')
        visited = visited + ['IpamAddressHistoryRecordSet']
        [
          IpamAddressHistoryRecord.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamAddressHistoryRecord.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamDiscoveredAccount
      def self.default(visited = [])
        return nil if visited.include?('IpamDiscoveredAccount')
        visited = visited + ['IpamDiscoveredAccount']
        {
          account_id: 'account_id',
          discovery_region: 'discovery_region',
          failure_reason: IpamDiscoveryFailureReason.default(visited),
          last_attempted_discovery_time: Time.now,
          last_successful_discovery_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('accountId', stub[:account_id].to_s) unless stub[:account_id].nil?
        xml << Hearth::XML::Node.new('discoveryRegion', stub[:discovery_region].to_s) unless stub[:discovery_region].nil?
        xml << IpamDiscoveryFailureReason.stub('failureReason', stub[:failure_reason]) unless stub[:failure_reason].nil?
        xml << Hearth::XML::Node.new('lastAttemptedDiscoveryTime', Hearth::TimeHelper.to_date_time(stub[:last_attempted_discovery_time])) unless stub[:last_attempted_discovery_time].nil?
        xml << Hearth::XML::Node.new('lastSuccessfulDiscoveryTime', Hearth::TimeHelper.to_date_time(stub[:last_successful_discovery_time])) unless stub[:last_successful_discovery_time].nil?
        xml
      end
    end

    class IpamDiscoveredAccountSet
      def self.default(visited = [])
        return nil if visited.include?('IpamDiscoveredAccountSet')
        visited = visited + ['IpamDiscoveredAccountSet']
        [
          IpamDiscoveredAccount.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamDiscoveredAccount.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamDiscoveredResourceCidr
      def self.default(visited = [])
        return nil if visited.include?('IpamDiscoveredResourceCidr')
        visited = visited + ['IpamDiscoveredResourceCidr']
        {
          ipam_resource_discovery_id: 'ipam_resource_discovery_id',
          resource_region: 'resource_region',
          resource_id: 'resource_id',
          resource_owner_id: 'resource_owner_id',
          resource_cidr: 'resource_cidr',
          resource_type: 'resource_type',
          resource_tags: IpamResourceTagList.default(visited),
          ip_usage: 1.0,
          vpc_id: 'vpc_id',
          sample_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipamResourceDiscoveryId', stub[:ipam_resource_discovery_id].to_s) unless stub[:ipam_resource_discovery_id].nil?
        xml << Hearth::XML::Node.new('resourceRegion', stub[:resource_region].to_s) unless stub[:resource_region].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('resourceCidr', stub[:resource_cidr].to_s) unless stub[:resource_cidr].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceTagSet', IpamResourceTagList.stub('item', stub[:resource_tags])) unless stub[:resource_tags].nil?
        xml << Hearth::XML::Node.new('ipUsage', Hearth::NumberHelper.serialize(stub[:ip_usage]).to_s) unless stub[:ip_usage].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('sampleTime', Hearth::TimeHelper.to_date_time(stub[:sample_time])) unless stub[:sample_time].nil?
        xml
      end
    end

    class IpamDiscoveredResourceCidrSet
      def self.default(visited = [])
        return nil if visited.include?('IpamDiscoveredResourceCidrSet')
        visited = visited + ['IpamDiscoveredResourceCidrSet']
        [
          IpamDiscoveredResourceCidr.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamDiscoveredResourceCidr.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamDiscoveryFailureReason
      def self.default(visited = [])
        return nil if visited.include?('IpamDiscoveryFailureReason')
        visited = visited + ['IpamDiscoveryFailureReason']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class IpamOperatingRegion
      def self.default(visited = [])
        return nil if visited.include?('IpamOperatingRegion')
        visited = visited + ['IpamOperatingRegion']
        {
          region_name: 'region_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('regionName', stub[:region_name].to_s) unless stub[:region_name].nil?
        xml
      end
    end

    class IpamOperatingRegionSet
      def self.default(visited = [])
        return nil if visited.include?('IpamOperatingRegionSet')
        visited = visited + ['IpamOperatingRegionSet']
        [
          IpamOperatingRegion.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamOperatingRegion.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamPool
      def self.default(visited = [])
        return nil if visited.include?('IpamPool')
        visited = visited + ['IpamPool']
        {
          owner_id: 'owner_id',
          ipam_pool_id: 'ipam_pool_id',
          source_ipam_pool_id: 'source_ipam_pool_id',
          ipam_pool_arn: 'ipam_pool_arn',
          ipam_scope_arn: 'ipam_scope_arn',
          ipam_scope_type: 'ipam_scope_type',
          ipam_arn: 'ipam_arn',
          ipam_region: 'ipam_region',
          locale: 'locale',
          pool_depth: 1,
          state: 'state',
          state_message: 'state_message',
          description: 'description',
          auto_import: false,
          publicly_advertisable: false,
          address_family: 'address_family',
          allocation_min_netmask_length: 1,
          allocation_max_netmask_length: 1,
          allocation_default_netmask_length: 1,
          allocation_resource_tags: IpamResourceTagList.default(visited),
          tags: TagList.default(visited),
          aws_service: 'aws_service',
          public_ip_source: 'public_ip_source',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ipamPoolId', stub[:ipam_pool_id].to_s) unless stub[:ipam_pool_id].nil?
        xml << Hearth::XML::Node.new('sourceIpamPoolId', stub[:source_ipam_pool_id].to_s) unless stub[:source_ipam_pool_id].nil?
        xml << Hearth::XML::Node.new('ipamPoolArn', stub[:ipam_pool_arn].to_s) unless stub[:ipam_pool_arn].nil?
        xml << Hearth::XML::Node.new('ipamScopeArn', stub[:ipam_scope_arn].to_s) unless stub[:ipam_scope_arn].nil?
        xml << Hearth::XML::Node.new('ipamScopeType', stub[:ipam_scope_type].to_s) unless stub[:ipam_scope_type].nil?
        xml << Hearth::XML::Node.new('ipamArn', stub[:ipam_arn].to_s) unless stub[:ipam_arn].nil?
        xml << Hearth::XML::Node.new('ipamRegion', stub[:ipam_region].to_s) unless stub[:ipam_region].nil?
        xml << Hearth::XML::Node.new('locale', stub[:locale].to_s) unless stub[:locale].nil?
        xml << Hearth::XML::Node.new('poolDepth', stub[:pool_depth].to_s) unless stub[:pool_depth].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateMessage', stub[:state_message].to_s) unless stub[:state_message].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('autoImport', stub[:auto_import].to_s) unless stub[:auto_import].nil?
        xml << Hearth::XML::Node.new('publiclyAdvertisable', stub[:publicly_advertisable].to_s) unless stub[:publicly_advertisable].nil?
        xml << Hearth::XML::Node.new('addressFamily', stub[:address_family].to_s) unless stub[:address_family].nil?
        xml << Hearth::XML::Node.new('allocationMinNetmaskLength', stub[:allocation_min_netmask_length].to_s) unless stub[:allocation_min_netmask_length].nil?
        xml << Hearth::XML::Node.new('allocationMaxNetmaskLength', stub[:allocation_max_netmask_length].to_s) unless stub[:allocation_max_netmask_length].nil?
        xml << Hearth::XML::Node.new('allocationDefaultNetmaskLength', stub[:allocation_default_netmask_length].to_s) unless stub[:allocation_default_netmask_length].nil?
        xml << Hearth::XML::Node.new('allocationResourceTagSet', IpamResourceTagList.stub('item', stub[:allocation_resource_tags])) unless stub[:allocation_resource_tags].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('awsService', stub[:aws_service].to_s) unless stub[:aws_service].nil?
        xml << Hearth::XML::Node.new('publicIpSource', stub[:public_ip_source].to_s) unless stub[:public_ip_source].nil?
        xml
      end
    end

    class IpamPoolAllocation
      def self.default(visited = [])
        return nil if visited.include?('IpamPoolAllocation')
        visited = visited + ['IpamPoolAllocation']
        {
          cidr: 'cidr',
          ipam_pool_allocation_id: 'ipam_pool_allocation_id',
          description: 'description',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          resource_region: 'resource_region',
          resource_owner: 'resource_owner',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('ipamPoolAllocationId', stub[:ipam_pool_allocation_id].to_s) unless stub[:ipam_pool_allocation_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceRegion', stub[:resource_region].to_s) unless stub[:resource_region].nil?
        xml << Hearth::XML::Node.new('resourceOwner', stub[:resource_owner].to_s) unless stub[:resource_owner].nil?
        xml
      end
    end

    class IpamPoolAllocationSet
      def self.default(visited = [])
        return nil if visited.include?('IpamPoolAllocationSet')
        visited = visited + ['IpamPoolAllocationSet']
        [
          IpamPoolAllocation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamPoolAllocation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamPoolCidr
      def self.default(visited = [])
        return nil if visited.include?('IpamPoolCidr')
        visited = visited + ['IpamPoolCidr']
        {
          cidr: 'cidr',
          state: 'state',
          failure_reason: IpamPoolCidrFailureReason.default(visited),
          ipam_pool_cidr_id: 'ipam_pool_cidr_id',
          netmask_length: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << IpamPoolCidrFailureReason.stub('failureReason', stub[:failure_reason]) unless stub[:failure_reason].nil?
        xml << Hearth::XML::Node.new('ipamPoolCidrId', stub[:ipam_pool_cidr_id].to_s) unless stub[:ipam_pool_cidr_id].nil?
        xml << Hearth::XML::Node.new('netmaskLength', stub[:netmask_length].to_s) unless stub[:netmask_length].nil?
        xml
      end
    end

    class IpamPoolCidrFailureReason
      def self.default(visited = [])
        return nil if visited.include?('IpamPoolCidrFailureReason')
        visited = visited + ['IpamPoolCidrFailureReason']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class IpamPoolCidrSet
      def self.default(visited = [])
        return nil if visited.include?('IpamPoolCidrSet')
        visited = visited + ['IpamPoolCidrSet']
        [
          IpamPoolCidr.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamPoolCidr.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamPoolSet
      def self.default(visited = [])
        return nil if visited.include?('IpamPoolSet')
        visited = visited + ['IpamPoolSet']
        [
          IpamPool.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamPool.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamResourceCidr
      def self.default(visited = [])
        return nil if visited.include?('IpamResourceCidr')
        visited = visited + ['IpamResourceCidr']
        {
          ipam_id: 'ipam_id',
          ipam_scope_id: 'ipam_scope_id',
          ipam_pool_id: 'ipam_pool_id',
          resource_region: 'resource_region',
          resource_owner_id: 'resource_owner_id',
          resource_id: 'resource_id',
          resource_name: 'resource_name',
          resource_cidr: 'resource_cidr',
          resource_type: 'resource_type',
          resource_tags: IpamResourceTagList.default(visited),
          ip_usage: 1.0,
          compliance_status: 'compliance_status',
          management_state: 'management_state',
          overlap_status: 'overlap_status',
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipamId', stub[:ipam_id].to_s) unless stub[:ipam_id].nil?
        xml << Hearth::XML::Node.new('ipamScopeId', stub[:ipam_scope_id].to_s) unless stub[:ipam_scope_id].nil?
        xml << Hearth::XML::Node.new('ipamPoolId', stub[:ipam_pool_id].to_s) unless stub[:ipam_pool_id].nil?
        xml << Hearth::XML::Node.new('resourceRegion', stub[:resource_region].to_s) unless stub[:resource_region].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceName', stub[:resource_name].to_s) unless stub[:resource_name].nil?
        xml << Hearth::XML::Node.new('resourceCidr', stub[:resource_cidr].to_s) unless stub[:resource_cidr].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceTagSet', IpamResourceTagList.stub('item', stub[:resource_tags])) unless stub[:resource_tags].nil?
        xml << Hearth::XML::Node.new('ipUsage', Hearth::NumberHelper.serialize(stub[:ip_usage]).to_s) unless stub[:ip_usage].nil?
        xml << Hearth::XML::Node.new('complianceStatus', stub[:compliance_status].to_s) unless stub[:compliance_status].nil?
        xml << Hearth::XML::Node.new('managementState', stub[:management_state].to_s) unless stub[:management_state].nil?
        xml << Hearth::XML::Node.new('overlapStatus', stub[:overlap_status].to_s) unless stub[:overlap_status].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    class IpamResourceCidrSet
      def self.default(visited = [])
        return nil if visited.include?('IpamResourceCidrSet')
        visited = visited + ['IpamResourceCidrSet']
        [
          IpamResourceCidr.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamResourceCidr.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamResourceDiscovery
      def self.default(visited = [])
        return nil if visited.include?('IpamResourceDiscovery')
        visited = visited + ['IpamResourceDiscovery']
        {
          owner_id: 'owner_id',
          ipam_resource_discovery_id: 'ipam_resource_discovery_id',
          ipam_resource_discovery_arn: 'ipam_resource_discovery_arn',
          ipam_resource_discovery_region: 'ipam_resource_discovery_region',
          description: 'description',
          operating_regions: IpamOperatingRegionSet.default(visited),
          is_default: false,
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ipamResourceDiscoveryId', stub[:ipam_resource_discovery_id].to_s) unless stub[:ipam_resource_discovery_id].nil?
        xml << Hearth::XML::Node.new('ipamResourceDiscoveryArn', stub[:ipam_resource_discovery_arn].to_s) unless stub[:ipam_resource_discovery_arn].nil?
        xml << Hearth::XML::Node.new('ipamResourceDiscoveryRegion', stub[:ipam_resource_discovery_region].to_s) unless stub[:ipam_resource_discovery_region].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('operatingRegionSet', IpamOperatingRegionSet.stub('item', stub[:operating_regions])) unless stub[:operating_regions].nil?
        xml << Hearth::XML::Node.new('isDefault', stub[:is_default].to_s) unless stub[:is_default].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class IpamResourceDiscoveryAssociation
      def self.default(visited = [])
        return nil if visited.include?('IpamResourceDiscoveryAssociation')
        visited = visited + ['IpamResourceDiscoveryAssociation']
        {
          owner_id: 'owner_id',
          ipam_resource_discovery_association_id: 'ipam_resource_discovery_association_id',
          ipam_resource_discovery_association_arn: 'ipam_resource_discovery_association_arn',
          ipam_resource_discovery_id: 'ipam_resource_discovery_id',
          ipam_id: 'ipam_id',
          ipam_arn: 'ipam_arn',
          ipam_region: 'ipam_region',
          is_default: false,
          resource_discovery_status: 'resource_discovery_status',
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ipamResourceDiscoveryAssociationId', stub[:ipam_resource_discovery_association_id].to_s) unless stub[:ipam_resource_discovery_association_id].nil?
        xml << Hearth::XML::Node.new('ipamResourceDiscoveryAssociationArn', stub[:ipam_resource_discovery_association_arn].to_s) unless stub[:ipam_resource_discovery_association_arn].nil?
        xml << Hearth::XML::Node.new('ipamResourceDiscoveryId', stub[:ipam_resource_discovery_id].to_s) unless stub[:ipam_resource_discovery_id].nil?
        xml << Hearth::XML::Node.new('ipamId', stub[:ipam_id].to_s) unless stub[:ipam_id].nil?
        xml << Hearth::XML::Node.new('ipamArn', stub[:ipam_arn].to_s) unless stub[:ipam_arn].nil?
        xml << Hearth::XML::Node.new('ipamRegion', stub[:ipam_region].to_s) unless stub[:ipam_region].nil?
        xml << Hearth::XML::Node.new('isDefault', stub[:is_default].to_s) unless stub[:is_default].nil?
        xml << Hearth::XML::Node.new('resourceDiscoveryStatus', stub[:resource_discovery_status].to_s) unless stub[:resource_discovery_status].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class IpamResourceDiscoveryAssociationSet
      def self.default(visited = [])
        return nil if visited.include?('IpamResourceDiscoveryAssociationSet')
        visited = visited + ['IpamResourceDiscoveryAssociationSet']
        [
          IpamResourceDiscoveryAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamResourceDiscoveryAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamResourceDiscoverySet
      def self.default(visited = [])
        return nil if visited.include?('IpamResourceDiscoverySet')
        visited = visited + ['IpamResourceDiscoverySet']
        [
          IpamResourceDiscovery.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamResourceDiscovery.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamResourceTag
      def self.default(visited = [])
        return nil if visited.include?('IpamResourceTag')
        visited = visited + ['IpamResourceTag']
        {
          key: 'key',
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('key', stub[:key].to_s) unless stub[:key].nil?
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class IpamResourceTagList
      def self.default(visited = [])
        return nil if visited.include?('IpamResourceTagList')
        visited = visited + ['IpamResourceTagList']
        [
          IpamResourceTag.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamResourceTag.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamScope
      def self.default(visited = [])
        return nil if visited.include?('IpamScope')
        visited = visited + ['IpamScope']
        {
          owner_id: 'owner_id',
          ipam_scope_id: 'ipam_scope_id',
          ipam_scope_arn: 'ipam_scope_arn',
          ipam_arn: 'ipam_arn',
          ipam_region: 'ipam_region',
          ipam_scope_type: 'ipam_scope_type',
          is_default: false,
          description: 'description',
          pool_count: 1,
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('ipamScopeId', stub[:ipam_scope_id].to_s) unless stub[:ipam_scope_id].nil?
        xml << Hearth::XML::Node.new('ipamScopeArn', stub[:ipam_scope_arn].to_s) unless stub[:ipam_scope_arn].nil?
        xml << Hearth::XML::Node.new('ipamArn', stub[:ipam_arn].to_s) unless stub[:ipam_arn].nil?
        xml << Hearth::XML::Node.new('ipamRegion', stub[:ipam_region].to_s) unless stub[:ipam_region].nil?
        xml << Hearth::XML::Node.new('ipamScopeType', stub[:ipam_scope_type].to_s) unless stub[:ipam_scope_type].nil?
        xml << Hearth::XML::Node.new('isDefault', stub[:is_default].to_s) unless stub[:is_default].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('poolCount', stub[:pool_count].to_s) unless stub[:pool_count].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class IpamScopeSet
      def self.default(visited = [])
        return nil if visited.include?('IpamScopeSet')
        visited = visited + ['IpamScopeSet']
        [
          IpamScope.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << IpamScope.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class IpamSet
      def self.default(visited = [])
        return nil if visited.include?('IpamSet')
        visited = visited + ['IpamSet']
        [
          Ipam.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipam.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv4PrefixList
      def self.default(visited = [])
        return nil if visited.include?('Ipv4PrefixList')
        visited = visited + ['Ipv4PrefixList']
        [
          Ipv4PrefixSpecificationRequest.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv4PrefixSpecificationRequest.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv4PrefixListResponse
      def self.default(visited = [])
        return nil if visited.include?('Ipv4PrefixListResponse')
        visited = visited + ['Ipv4PrefixListResponse']
        [
          Ipv4PrefixSpecificationResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv4PrefixSpecificationResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv4PrefixSpecification
      def self.default(visited = [])
        return nil if visited.include?('Ipv4PrefixSpecification')
        visited = visited + ['Ipv4PrefixSpecification']
        {
          ipv4_prefix: 'ipv4_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv4Prefix', stub[:ipv4_prefix].to_s) unless stub[:ipv4_prefix].nil?
        xml
      end
    end

    class Ipv4PrefixSpecificationRequest
      def self.default(visited = [])
        return nil if visited.include?('Ipv4PrefixSpecificationRequest')
        visited = visited + ['Ipv4PrefixSpecificationRequest']
        {
          ipv4_prefix: 'ipv4_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('Ipv4Prefix', stub[:ipv4_prefix].to_s) unless stub[:ipv4_prefix].nil?
        xml
      end
    end

    class Ipv4PrefixSpecificationResponse
      def self.default(visited = [])
        return nil if visited.include?('Ipv4PrefixSpecificationResponse')
        visited = visited + ['Ipv4PrefixSpecificationResponse']
        {
          ipv4_prefix: 'ipv4_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv4Prefix', stub[:ipv4_prefix].to_s) unless stub[:ipv4_prefix].nil?
        xml
      end
    end

    class Ipv4PrefixesList
      def self.default(visited = [])
        return nil if visited.include?('Ipv4PrefixesList')
        visited = visited + ['Ipv4PrefixesList']
        [
          Ipv4PrefixSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv4PrefixSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv6AddressList
      def self.default(visited = [])
        return nil if visited.include?('Ipv6AddressList')
        visited = visited + ['Ipv6AddressList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class Ipv6CidrAssociation
      def self.default(visited = [])
        return nil if visited.include?('Ipv6CidrAssociation')
        visited = visited + ['Ipv6CidrAssociation']
        {
          ipv6_cidr: 'ipv6_cidr',
          associated_resource: 'associated_resource',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Cidr', stub[:ipv6_cidr].to_s) unless stub[:ipv6_cidr].nil?
        xml << Hearth::XML::Node.new('associatedResource', stub[:associated_resource].to_s) unless stub[:associated_resource].nil?
        xml
      end
    end

    class Ipv6CidrAssociationSet
      def self.default(visited = [])
        return nil if visited.include?('Ipv6CidrAssociationSet')
        visited = visited + ['Ipv6CidrAssociationSet']
        [
          Ipv6CidrAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6CidrAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv6CidrBlock
      def self.default(visited = [])
        return nil if visited.include?('Ipv6CidrBlock')
        visited = visited + ['Ipv6CidrBlock']
        {
          ipv6_cidr_block: 'ipv6_cidr_block',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6CidrBlock', stub[:ipv6_cidr_block].to_s) unless stub[:ipv6_cidr_block].nil?
        xml
      end
    end

    class Ipv6CidrBlockSet
      def self.default(visited = [])
        return nil if visited.include?('Ipv6CidrBlockSet')
        visited = visited + ['Ipv6CidrBlockSet']
        [
          Ipv6CidrBlock.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6CidrBlock.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv6Pool
      def self.default(visited = [])
        return nil if visited.include?('Ipv6Pool')
        visited = visited + ['Ipv6Pool']
        {
          pool_id: 'pool_id',
          description: 'description',
          pool_cidr_blocks: PoolCidrBlocksSet.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('poolCidrBlockSet', PoolCidrBlocksSet.stub('item', stub[:pool_cidr_blocks])) unless stub[:pool_cidr_blocks].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class Ipv6PoolSet
      def self.default(visited = [])
        return nil if visited.include?('Ipv6PoolSet')
        visited = visited + ['Ipv6PoolSet']
        [
          Ipv6Pool.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6Pool.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv6PrefixList
      def self.default(visited = [])
        return nil if visited.include?('Ipv6PrefixList')
        visited = visited + ['Ipv6PrefixList']
        [
          Ipv6PrefixSpecificationRequest.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6PrefixSpecificationRequest.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv6PrefixListResponse
      def self.default(visited = [])
        return nil if visited.include?('Ipv6PrefixListResponse')
        visited = visited + ['Ipv6PrefixListResponse']
        [
          Ipv6PrefixSpecificationResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6PrefixSpecificationResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv6PrefixSpecification
      def self.default(visited = [])
        return nil if visited.include?('Ipv6PrefixSpecification')
        visited = visited + ['Ipv6PrefixSpecification']
        {
          ipv6_prefix: 'ipv6_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Prefix', stub[:ipv6_prefix].to_s) unless stub[:ipv6_prefix].nil?
        xml
      end
    end

    class Ipv6PrefixSpecificationRequest
      def self.default(visited = [])
        return nil if visited.include?('Ipv6PrefixSpecificationRequest')
        visited = visited + ['Ipv6PrefixSpecificationRequest']
        {
          ipv6_prefix: 'ipv6_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('Ipv6Prefix', stub[:ipv6_prefix].to_s) unless stub[:ipv6_prefix].nil?
        xml
      end
    end

    class Ipv6PrefixSpecificationResponse
      def self.default(visited = [])
        return nil if visited.include?('Ipv6PrefixSpecificationResponse')
        visited = visited + ['Ipv6PrefixSpecificationResponse']
        {
          ipv6_prefix: 'ipv6_prefix',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Prefix', stub[:ipv6_prefix].to_s) unless stub[:ipv6_prefix].nil?
        xml
      end
    end

    class Ipv6PrefixesList
      def self.default(visited = [])
        return nil if visited.include?('Ipv6PrefixesList')
        visited = visited + ['Ipv6PrefixesList']
        [
          Ipv6PrefixSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6PrefixSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Ipv6Range
      def self.default(visited = [])
        return nil if visited.include?('Ipv6Range')
        visited = visited + ['Ipv6Range']
        {
          cidr_ipv6: 'cidr_ipv6',
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrIpv6', stub[:cidr_ipv6].to_s) unless stub[:cidr_ipv6].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    class Ipv6RangeList
      def self.default(visited = [])
        return nil if visited.include?('Ipv6RangeList')
        visited = visited + ['Ipv6RangeList']
        [
          Ipv6Range.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Ipv6Range.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class KeyPairInfo
      def self.default(visited = [])
        return nil if visited.include?('KeyPairInfo')
        visited = visited + ['KeyPairInfo']
        {
          key_pair_id: 'key_pair_id',
          key_fingerprint: 'key_fingerprint',
          key_name: 'key_name',
          key_type: 'key_type',
          tags: TagList.default(visited),
          public_key: 'public_key',
          create_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('keyPairId', stub[:key_pair_id].to_s) unless stub[:key_pair_id].nil?
        xml << Hearth::XML::Node.new('keyFingerprint', stub[:key_fingerprint].to_s) unless stub[:key_fingerprint].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('keyType', stub[:key_type].to_s) unless stub[:key_type].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('publicKey', stub[:public_key].to_s) unless stub[:public_key].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml
      end
    end

    class KeyPairList
      def self.default(visited = [])
        return nil if visited.include?('KeyPairList')
        visited = visited + ['KeyPairList']
        [
          KeyPairInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << KeyPairInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LastError
      def self.default(visited = [])
        return nil if visited.include?('LastError')
        visited = visited + ['LastError']
        {
          message: 'message',
          code: 'code',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml
      end
    end

    class LaunchPermission
      def self.default(visited = [])
        return nil if visited.include?('LaunchPermission')
        visited = visited + ['LaunchPermission']
        {
          group: 'group',
          user_id: 'user_id',
          organization_arn: 'organization_arn',
          organizational_unit_arn: 'organizational_unit_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('group', stub[:group].to_s) unless stub[:group].nil?
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml << Hearth::XML::Node.new('organizationArn', stub[:organization_arn].to_s) unless stub[:organization_arn].nil?
        xml << Hearth::XML::Node.new('organizationalUnitArn', stub[:organizational_unit_arn].to_s) unless stub[:organizational_unit_arn].nil?
        xml
      end
    end

    class LaunchPermissionList
      def self.default(visited = [])
        return nil if visited.include?('LaunchPermissionList')
        visited = visited + ['LaunchPermissionList']
        [
          LaunchPermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchPermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchSpecification
      def self.default(visited = [])
        return nil if visited.include?('LaunchSpecification')
        visited = visited + ['LaunchSpecification']
        {
          user_data: 'user_data',
          security_groups: GroupIdentifierList.default(visited),
          addressing_type: 'addressing_type',
          block_device_mappings: BlockDeviceMappingList.default(visited),
          ebs_optimized: false,
          iam_instance_profile: IamInstanceProfileSpecification.default(visited),
          image_id: 'image_id',
          instance_type: 'instance_type',
          kernel_id: 'kernel_id',
          key_name: 'key_name',
          network_interfaces: InstanceNetworkInterfaceSpecificationList.default(visited),
          placement: SpotPlacement.default(visited),
          ramdisk_id: 'ramdisk_id',
          subnet_id: 'subnet_id',
          monitoring: RunInstancesMonitoringEnabled.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('userData', stub[:user_data].to_s) unless stub[:user_data].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << Hearth::XML::Node.new('addressingType', stub[:addressing_type].to_s) unless stub[:addressing_type].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', BlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << IamInstanceProfileSpecification.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << Hearth::XML::Node.new('networkInterfaceSet', InstanceNetworkInterfaceSpecificationList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << SpotPlacement.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << Hearth::XML::Node.new('ramdiskId', stub[:ramdisk_id].to_s) unless stub[:ramdisk_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << RunInstancesMonitoringEnabled.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml
      end
    end

    class LaunchSpecsList
      def self.default(visited = [])
        return nil if visited.include?('LaunchSpecsList')
        visited = visited + ['LaunchSpecsList']
        [
          SpotFleetLaunchSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotFleetLaunchSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplate
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplate')
        visited = visited + ['LaunchTemplate']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          create_time: Time.now,
          created_by: 'created_by',
          default_version_number: 1,
          latest_version_number: 1,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('createdBy', stub[:created_by].to_s) unless stub[:created_by].nil?
        xml << Hearth::XML::Node.new('defaultVersionNumber', stub[:default_version_number].to_s) unless stub[:default_version_number].nil?
        xml << Hearth::XML::Node.new('latestVersionNumber', stub[:latest_version_number].to_s) unless stub[:latest_version_number].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class LaunchTemplateAndOverridesResponse
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateAndOverridesResponse')
        visited = visited + ['LaunchTemplateAndOverridesResponse']
        {
          launch_template_specification: FleetLaunchTemplateSpecification.default(visited),
          overrides: FleetLaunchTemplateOverrides.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << FleetLaunchTemplateSpecification.stub('launchTemplateSpecification', stub[:launch_template_specification]) unless stub[:launch_template_specification].nil?
        xml << FleetLaunchTemplateOverrides.stub('overrides', stub[:overrides]) unless stub[:overrides].nil?
        xml
      end
    end

    class LaunchTemplateBlockDeviceMapping
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateBlockDeviceMapping')
        visited = visited + ['LaunchTemplateBlockDeviceMapping']
        {
          device_name: 'device_name',
          virtual_name: 'virtual_name',
          ebs: LaunchTemplateEbsBlockDevice.default(visited),
          no_device: 'no_device',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << Hearth::XML::Node.new('virtualName', stub[:virtual_name].to_s) unless stub[:virtual_name].nil?
        xml << LaunchTemplateEbsBlockDevice.stub('ebs', stub[:ebs]) unless stub[:ebs].nil?
        xml << Hearth::XML::Node.new('noDevice', stub[:no_device].to_s) unless stub[:no_device].nil?
        xml
      end
    end

    class LaunchTemplateBlockDeviceMappingList
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateBlockDeviceMappingList')
        visited = visited + ['LaunchTemplateBlockDeviceMappingList']
        [
          LaunchTemplateBlockDeviceMapping.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateBlockDeviceMapping.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplateCapacityReservationSpecificationResponse
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateCapacityReservationSpecificationResponse')
        visited = visited + ['LaunchTemplateCapacityReservationSpecificationResponse']
        {
          capacity_reservation_preference: 'capacity_reservation_preference',
          capacity_reservation_target: CapacityReservationTargetResponse.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('capacityReservationPreference', stub[:capacity_reservation_preference].to_s) unless stub[:capacity_reservation_preference].nil?
        xml << CapacityReservationTargetResponse.stub('capacityReservationTarget', stub[:capacity_reservation_target]) unless stub[:capacity_reservation_target].nil?
        xml
      end
    end

    class LaunchTemplateConfig
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateConfig')
        visited = visited + ['LaunchTemplateConfig']
        {
          launch_template_specification: FleetLaunchTemplateSpecification.default(visited),
          overrides: LaunchTemplateOverridesList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << FleetLaunchTemplateSpecification.stub('launchTemplateSpecification', stub[:launch_template_specification]) unless stub[:launch_template_specification].nil?
        xml << Hearth::XML::Node.new('overrides', LaunchTemplateOverridesList.stub('item', stub[:overrides])) unless stub[:overrides].nil?
        xml
      end
    end

    class LaunchTemplateConfigList
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateConfigList')
        visited = visited + ['LaunchTemplateConfigList']
        [
          LaunchTemplateConfig.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateConfig.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplateCpuOptions
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateCpuOptions')
        visited = visited + ['LaunchTemplateCpuOptions']
        {
          core_count: 1,
          threads_per_core: 1,
          amd_sev_snp: 'amd_sev_snp',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('coreCount', stub[:core_count].to_s) unless stub[:core_count].nil?
        xml << Hearth::XML::Node.new('threadsPerCore', stub[:threads_per_core].to_s) unless stub[:threads_per_core].nil?
        xml << Hearth::XML::Node.new('amdSevSnp', stub[:amd_sev_snp].to_s) unless stub[:amd_sev_snp].nil?
        xml
      end
    end

    class LaunchTemplateEbsBlockDevice
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateEbsBlockDevice')
        visited = visited + ['LaunchTemplateEbsBlockDevice']
        {
          encrypted: false,
          delete_on_termination: false,
          iops: 1,
          kms_key_id: 'kms_key_id',
          snapshot_id: 'snapshot_id',
          volume_size: 1,
          volume_type: 'volume_type',
          throughput: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('iops', stub[:iops].to_s) unless stub[:iops].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('volumeType', stub[:volume_type].to_s) unless stub[:volume_type].nil?
        xml << Hearth::XML::Node.new('throughput', stub[:throughput].to_s) unless stub[:throughput].nil?
        xml
      end
    end

    class LaunchTemplateElasticInferenceAcceleratorResponse
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateElasticInferenceAcceleratorResponse')
        visited = visited + ['LaunchTemplateElasticInferenceAcceleratorResponse']
        {
          type: 'type',
          count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml
      end
    end

    class LaunchTemplateElasticInferenceAcceleratorResponseList
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateElasticInferenceAcceleratorResponseList')
        visited = visited + ['LaunchTemplateElasticInferenceAcceleratorResponseList']
        [
          LaunchTemplateElasticInferenceAcceleratorResponse.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateElasticInferenceAcceleratorResponse.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplateEnclaveOptions
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateEnclaveOptions')
        visited = visited + ['LaunchTemplateEnclaveOptions']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    class LaunchTemplateHibernationOptions
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateHibernationOptions')
        visited = visited + ['LaunchTemplateHibernationOptions']
        {
          configured: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('configured', stub[:configured].to_s) unless stub[:configured].nil?
        xml
      end
    end

    class LaunchTemplateIamInstanceProfileSpecification
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateIamInstanceProfileSpecification')
        visited = visited + ['LaunchTemplateIamInstanceProfileSpecification']
        {
          arn: 'arn',
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    class LaunchTemplateInstanceMaintenanceOptions
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateInstanceMaintenanceOptions')
        visited = visited + ['LaunchTemplateInstanceMaintenanceOptions']
        {
          auto_recovery: 'auto_recovery',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('autoRecovery', stub[:auto_recovery].to_s) unless stub[:auto_recovery].nil?
        xml
      end
    end

    class LaunchTemplateInstanceMarketOptions
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateInstanceMarketOptions')
        visited = visited + ['LaunchTemplateInstanceMarketOptions']
        {
          market_type: 'market_type',
          spot_options: LaunchTemplateSpotMarketOptions.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('marketType', stub[:market_type].to_s) unless stub[:market_type].nil?
        xml << LaunchTemplateSpotMarketOptions.stub('spotOptions', stub[:spot_options]) unless stub[:spot_options].nil?
        xml
      end
    end

    class LaunchTemplateInstanceMetadataOptions
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateInstanceMetadataOptions')
        visited = visited + ['LaunchTemplateInstanceMetadataOptions']
        {
          state: 'state',
          http_tokens: 'http_tokens',
          http_put_response_hop_limit: 1,
          http_endpoint: 'http_endpoint',
          http_protocol_ipv6: 'http_protocol_ipv6',
          instance_metadata_tags: 'instance_metadata_tags',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('httpTokens', stub[:http_tokens].to_s) unless stub[:http_tokens].nil?
        xml << Hearth::XML::Node.new('httpPutResponseHopLimit', stub[:http_put_response_hop_limit].to_s) unless stub[:http_put_response_hop_limit].nil?
        xml << Hearth::XML::Node.new('httpEndpoint', stub[:http_endpoint].to_s) unless stub[:http_endpoint].nil?
        xml << Hearth::XML::Node.new('httpProtocolIpv6', stub[:http_protocol_ipv6].to_s) unless stub[:http_protocol_ipv6].nil?
        xml << Hearth::XML::Node.new('instanceMetadataTags', stub[:instance_metadata_tags].to_s) unless stub[:instance_metadata_tags].nil?
        xml
      end
    end

    class LaunchTemplateInstanceNetworkInterfaceSpecification
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateInstanceNetworkInterfaceSpecification')
        visited = visited + ['LaunchTemplateInstanceNetworkInterfaceSpecification']
        {
          associate_carrier_ip_address: false,
          associate_public_ip_address: false,
          delete_on_termination: false,
          description: 'description',
          device_index: 1,
          groups: GroupIdStringList.default(visited),
          interface_type: 'interface_type',
          ipv6_address_count: 1,
          ipv6_addresses: InstanceIpv6AddressList.default(visited),
          network_interface_id: 'network_interface_id',
          private_ip_address: 'private_ip_address',
          private_ip_addresses: PrivateIpAddressSpecificationList.default(visited),
          secondary_private_ip_address_count: 1,
          subnet_id: 'subnet_id',
          network_card_index: 1,
          ipv4_prefixes: Ipv4PrefixListResponse.default(visited),
          ipv4_prefix_count: 1,
          ipv6_prefixes: Ipv6PrefixListResponse.default(visited),
          ipv6_prefix_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associateCarrierIpAddress', stub[:associate_carrier_ip_address].to_s) unless stub[:associate_carrier_ip_address].nil?
        xml << Hearth::XML::Node.new('associatePublicIpAddress', stub[:associate_public_ip_address].to_s) unless stub[:associate_public_ip_address].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('deviceIndex', stub[:device_index].to_s) unless stub[:device_index].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdStringList.stub('groupId', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('interfaceType', stub[:interface_type].to_s) unless stub[:interface_type].nil?
        xml << Hearth::XML::Node.new('ipv6AddressCount', stub[:ipv6_address_count].to_s) unless stub[:ipv6_address_count].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesSet', InstanceIpv6AddressList.stub('item', stub[:ipv6_addresses])) unless stub[:ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('privateIpAddressesSet', PrivateIpAddressSpecificationList.stub('item', stub[:private_ip_addresses])) unless stub[:private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('secondaryPrivateIpAddressCount', stub[:secondary_private_ip_address_count].to_s) unless stub[:secondary_private_ip_address_count].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml << Hearth::XML::Node.new('ipv4PrefixSet', Ipv4PrefixListResponse.stub('item', stub[:ipv4_prefixes])) unless stub[:ipv4_prefixes].nil?
        xml << Hearth::XML::Node.new('ipv4PrefixCount', stub[:ipv4_prefix_count].to_s) unless stub[:ipv4_prefix_count].nil?
        xml << Hearth::XML::Node.new('ipv6PrefixSet', Ipv6PrefixListResponse.stub('item', stub[:ipv6_prefixes])) unless stub[:ipv6_prefixes].nil?
        xml << Hearth::XML::Node.new('ipv6PrefixCount', stub[:ipv6_prefix_count].to_s) unless stub[:ipv6_prefix_count].nil?
        xml
      end
    end

    class LaunchTemplateInstanceNetworkInterfaceSpecificationList
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateInstanceNetworkInterfaceSpecificationList')
        visited = visited + ['LaunchTemplateInstanceNetworkInterfaceSpecificationList']
        [
          LaunchTemplateInstanceNetworkInterfaceSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateInstanceNetworkInterfaceSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplateLicenseConfiguration
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateLicenseConfiguration')
        visited = visited + ['LaunchTemplateLicenseConfiguration']
        {
          license_configuration_arn: 'license_configuration_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('licenseConfigurationArn', stub[:license_configuration_arn].to_s) unless stub[:license_configuration_arn].nil?
        xml
      end
    end

    class LaunchTemplateLicenseList
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateLicenseList')
        visited = visited + ['LaunchTemplateLicenseList']
        [
          LaunchTemplateLicenseConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateLicenseConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplateOverrides
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateOverrides')
        visited = visited + ['LaunchTemplateOverrides']
        {
          instance_type: 'instance_type',
          spot_price: 'spot_price',
          subnet_id: 'subnet_id',
          availability_zone: 'availability_zone',
          weighted_capacity: 1.0,
          priority: 1.0,
          instance_requirements: InstanceRequirements.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('weightedCapacity', Hearth::NumberHelper.serialize(stub[:weighted_capacity]).to_s) unless stub[:weighted_capacity].nil?
        xml << Hearth::XML::Node.new('priority', Hearth::NumberHelper.serialize(stub[:priority]).to_s) unless stub[:priority].nil?
        xml << InstanceRequirements.stub('instanceRequirements', stub[:instance_requirements]) unless stub[:instance_requirements].nil?
        xml
      end
    end

    class LaunchTemplateOverridesList
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateOverridesList')
        visited = visited + ['LaunchTemplateOverridesList']
        [
          LaunchTemplateOverrides.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateOverrides.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplatePlacement
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplatePlacement')
        visited = visited + ['LaunchTemplatePlacement']
        {
          availability_zone: 'availability_zone',
          affinity: 'affinity',
          group_name: 'group_name',
          host_id: 'host_id',
          tenancy: 'tenancy',
          spread_domain: 'spread_domain',
          host_resource_group_arn: 'host_resource_group_arn',
          partition_number: 1,
          group_id: 'group_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('affinity', stub[:affinity].to_s) unless stub[:affinity].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('hostId', stub[:host_id].to_s) unless stub[:host_id].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('spreadDomain', stub[:spread_domain].to_s) unless stub[:spread_domain].nil?
        xml << Hearth::XML::Node.new('hostResourceGroupArn', stub[:host_resource_group_arn].to_s) unless stub[:host_resource_group_arn].nil?
        xml << Hearth::XML::Node.new('partitionNumber', stub[:partition_number].to_s) unless stub[:partition_number].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml
      end
    end

    class LaunchTemplatePrivateDnsNameOptions
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplatePrivateDnsNameOptions')
        visited = visited + ['LaunchTemplatePrivateDnsNameOptions']
        {
          hostname_type: 'hostname_type',
          enable_resource_name_dns_a_record: false,
          enable_resource_name_dns_aaaa_record: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('hostnameType', stub[:hostname_type].to_s) unless stub[:hostname_type].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsARecord', stub[:enable_resource_name_dns_a_record].to_s) unless stub[:enable_resource_name_dns_a_record].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsAAAARecord', stub[:enable_resource_name_dns_aaaa_record].to_s) unless stub[:enable_resource_name_dns_aaaa_record].nil?
        xml
      end
    end

    class LaunchTemplateSet
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateSet')
        visited = visited + ['LaunchTemplateSet']
        [
          LaunchTemplate.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplate.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplateSpotMarketOptions
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateSpotMarketOptions')
        visited = visited + ['LaunchTemplateSpotMarketOptions']
        {
          max_price: 'max_price',
          spot_instance_type: 'spot_instance_type',
          block_duration_minutes: 1,
          valid_until: Time.now,
          instance_interruption_behavior: 'instance_interruption_behavior',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('maxPrice', stub[:max_price].to_s) unless stub[:max_price].nil?
        xml << Hearth::XML::Node.new('spotInstanceType', stub[:spot_instance_type].to_s) unless stub[:spot_instance_type].nil?
        xml << Hearth::XML::Node.new('blockDurationMinutes', stub[:block_duration_minutes].to_s) unless stub[:block_duration_minutes].nil?
        xml << Hearth::XML::Node.new('validUntil', Hearth::TimeHelper.to_date_time(stub[:valid_until])) unless stub[:valid_until].nil?
        xml << Hearth::XML::Node.new('instanceInterruptionBehavior', stub[:instance_interruption_behavior].to_s) unless stub[:instance_interruption_behavior].nil?
        xml
      end
    end

    class LaunchTemplateTagSpecification
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateTagSpecification')
        visited = visited + ['LaunchTemplateTagSpecification']
        {
          resource_type: 'resource_type',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class LaunchTemplateTagSpecificationList
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateTagSpecificationList')
        visited = visited + ['LaunchTemplateTagSpecificationList']
        [
          LaunchTemplateTagSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateTagSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplateVersion
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateVersion')
        visited = visited + ['LaunchTemplateVersion']
        {
          launch_template_id: 'launch_template_id',
          launch_template_name: 'launch_template_name',
          version_number: 1,
          version_description: 'version_description',
          create_time: Time.now,
          created_by: 'created_by',
          default_version: false,
          launch_template_data: ResponseLaunchTemplateData.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('launchTemplateId', stub[:launch_template_id].to_s) unless stub[:launch_template_id].nil?
        xml << Hearth::XML::Node.new('launchTemplateName', stub[:launch_template_name].to_s) unless stub[:launch_template_name].nil?
        xml << Hearth::XML::Node.new('versionNumber', stub[:version_number].to_s) unless stub[:version_number].nil?
        xml << Hearth::XML::Node.new('versionDescription', stub[:version_description].to_s) unless stub[:version_description].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('createdBy', stub[:created_by].to_s) unless stub[:created_by].nil?
        xml << Hearth::XML::Node.new('defaultVersion', stub[:default_version].to_s) unless stub[:default_version].nil?
        xml << ResponseLaunchTemplateData.stub('launchTemplateData', stub[:launch_template_data]) unless stub[:launch_template_data].nil?
        xml
      end
    end

    class LaunchTemplateVersionSet
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplateVersionSet')
        visited = visited + ['LaunchTemplateVersionSet']
        [
          LaunchTemplateVersion.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LaunchTemplateVersion.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LaunchTemplatesMonitoring
      def self.default(visited = [])
        return nil if visited.include?('LaunchTemplatesMonitoring')
        visited = visited + ['LaunchTemplatesMonitoring']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    class LicenseConfiguration
      def self.default(visited = [])
        return nil if visited.include?('LicenseConfiguration')
        visited = visited + ['LicenseConfiguration']
        {
          license_configuration_arn: 'license_configuration_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('licenseConfigurationArn', stub[:license_configuration_arn].to_s) unless stub[:license_configuration_arn].nil?
        xml
      end
    end

    class LicenseList
      def self.default(visited = [])
        return nil if visited.include?('LicenseList')
        visited = visited + ['LicenseList']
        [
          LicenseConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LicenseConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ListImagesInRecycleBin
      def self.build(params, context:)
        Params::ListImagesInRecycleBinOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ListImagesInRecycleBinOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          images: ImageRecycleBinInfoList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ListImagesInRecycleBinResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageSet', ImageRecycleBinInfoList.stub('item', stub[:images])) unless stub[:images].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ListSnapshotsInRecycleBin
      def self.build(params, context:)
        Params::ListSnapshotsInRecycleBinOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ListSnapshotsInRecycleBinOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          snapshots: SnapshotRecycleBinInfoList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ListSnapshotsInRecycleBinResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotSet', SnapshotRecycleBinInfoList.stub('item', stub[:snapshots])) unless stub[:snapshots].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class LoadBalancersConfig
      def self.default(visited = [])
        return nil if visited.include?('LoadBalancersConfig')
        visited = visited + ['LoadBalancersConfig']
        {
          classic_load_balancers_config: ClassicLoadBalancersConfig.default(visited),
          target_groups_config: TargetGroupsConfig.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << ClassicLoadBalancersConfig.stub('classicLoadBalancersConfig', stub[:classic_load_balancers_config]) unless stub[:classic_load_balancers_config].nil?
        xml << TargetGroupsConfig.stub('targetGroupsConfig', stub[:target_groups_config]) unless stub[:target_groups_config].nil?
        xml
      end
    end

    class LoadPermission
      def self.default(visited = [])
        return nil if visited.include?('LoadPermission')
        visited = visited + ['LoadPermission']
        {
          user_id: 'user_id',
          group: 'group',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml << Hearth::XML::Node.new('group', stub[:group].to_s) unless stub[:group].nil?
        xml
      end
    end

    class LoadPermissionList
      def self.default(visited = [])
        return nil if visited.include?('LoadPermissionList')
        visited = visited + ['LoadPermissionList']
        [
          LoadPermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LoadPermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LocalGateway
      def self.default(visited = [])
        return nil if visited.include?('LocalGateway')
        visited = visited + ['LocalGateway']
        {
          local_gateway_id: 'local_gateway_id',
          outpost_arn: 'outpost_arn',
          owner_id: 'owner_id',
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class LocalGatewayRoute
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayRoute')
        visited = visited + ['LocalGatewayRoute']
        {
          destination_cidr_block: 'destination_cidr_block',
          local_gateway_virtual_interface_group_id: 'local_gateway_virtual_interface_group_id',
          type: 'type',
          state: 'state',
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          local_gateway_route_table_arn: 'local_gateway_route_table_arn',
          owner_id: 'owner_id',
          subnet_id: 'subnet_id',
          coip_pool_id: 'coip_pool_id',
          network_interface_id: 'network_interface_id',
          destination_prefix_list_id: 'destination_prefix_list_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceGroupId', stub[:local_gateway_virtual_interface_group_id].to_s) unless stub[:local_gateway_virtual_interface_group_id].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableArn', stub[:local_gateway_route_table_arn].to_s) unless stub[:local_gateway_route_table_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('coipPoolId', stub[:coip_pool_id].to_s) unless stub[:coip_pool_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('destinationPrefixListId', stub[:destination_prefix_list_id].to_s) unless stub[:destination_prefix_list_id].nil?
        xml
      end
    end

    class LocalGatewayRouteList
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayRouteList')
        visited = visited + ['LocalGatewayRouteList']
        [
          LocalGatewayRoute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayRoute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LocalGatewayRouteTable
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayRouteTable')
        visited = visited + ['LocalGatewayRouteTable']
        {
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          local_gateway_route_table_arn: 'local_gateway_route_table_arn',
          local_gateway_id: 'local_gateway_id',
          outpost_arn: 'outpost_arn',
          owner_id: 'owner_id',
          state: 'state',
          tags: TagList.default(visited),
          mode: 'mode',
          state_reason: StateReason.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableArn', stub[:local_gateway_route_table_arn].to_s) unless stub[:local_gateway_route_table_arn].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('mode', stub[:mode].to_s) unless stub[:mode].nil?
        xml << StateReason.stub('stateReason', stub[:state_reason]) unless stub[:state_reason].nil?
        xml
      end
    end

    class LocalGatewayRouteTableSet
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayRouteTableSet')
        visited = visited + ['LocalGatewayRouteTableSet']
        [
          LocalGatewayRouteTable.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayRouteTable.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LocalGatewayRouteTableVirtualInterfaceGroupAssociation
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayRouteTableVirtualInterfaceGroupAssociation')
        visited = visited + ['LocalGatewayRouteTableVirtualInterfaceGroupAssociation']
        {
          local_gateway_route_table_virtual_interface_group_association_id: 'local_gateway_route_table_virtual_interface_group_association_id',
          local_gateway_virtual_interface_group_id: 'local_gateway_virtual_interface_group_id',
          local_gateway_id: 'local_gateway_id',
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          local_gateway_route_table_arn: 'local_gateway_route_table_arn',
          owner_id: 'owner_id',
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayRouteTableVirtualInterfaceGroupAssociationId', stub[:local_gateway_route_table_virtual_interface_group_association_id].to_s) unless stub[:local_gateway_route_table_virtual_interface_group_association_id].nil?
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceGroupId', stub[:local_gateway_virtual_interface_group_id].to_s) unless stub[:local_gateway_virtual_interface_group_id].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableArn', stub[:local_gateway_route_table_arn].to_s) unless stub[:local_gateway_route_table_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet')
        visited = visited + ['LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet']
        [
          LocalGatewayRouteTableVirtualInterfaceGroupAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayRouteTableVirtualInterfaceGroupAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LocalGatewayRouteTableVpcAssociation
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayRouteTableVpcAssociation')
        visited = visited + ['LocalGatewayRouteTableVpcAssociation']
        {
          local_gateway_route_table_vpc_association_id: 'local_gateway_route_table_vpc_association_id',
          local_gateway_route_table_id: 'local_gateway_route_table_id',
          local_gateway_route_table_arn: 'local_gateway_route_table_arn',
          local_gateway_id: 'local_gateway_id',
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
          state: 'state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayRouteTableVpcAssociationId', stub[:local_gateway_route_table_vpc_association_id].to_s) unless stub[:local_gateway_route_table_vpc_association_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableId', stub[:local_gateway_route_table_id].to_s) unless stub[:local_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('localGatewayRouteTableArn', stub[:local_gateway_route_table_arn].to_s) unless stub[:local_gateway_route_table_arn].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class LocalGatewayRouteTableVpcAssociationSet
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayRouteTableVpcAssociationSet')
        visited = visited + ['LocalGatewayRouteTableVpcAssociationSet']
        [
          LocalGatewayRouteTableVpcAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayRouteTableVpcAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LocalGatewaySet
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewaySet')
        visited = visited + ['LocalGatewaySet']
        [
          LocalGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LocalGatewayVirtualInterface
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayVirtualInterface')
        visited = visited + ['LocalGatewayVirtualInterface']
        {
          local_gateway_virtual_interface_id: 'local_gateway_virtual_interface_id',
          local_gateway_id: 'local_gateway_id',
          vlan: 1,
          local_address: 'local_address',
          peer_address: 'peer_address',
          local_bgp_asn: 1,
          peer_bgp_asn: 1,
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceId', stub[:local_gateway_virtual_interface_id].to_s) unless stub[:local_gateway_virtual_interface_id].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('vlan', stub[:vlan].to_s) unless stub[:vlan].nil?
        xml << Hearth::XML::Node.new('localAddress', stub[:local_address].to_s) unless stub[:local_address].nil?
        xml << Hearth::XML::Node.new('peerAddress', stub[:peer_address].to_s) unless stub[:peer_address].nil?
        xml << Hearth::XML::Node.new('localBgpAsn', stub[:local_bgp_asn].to_s) unless stub[:local_bgp_asn].nil?
        xml << Hearth::XML::Node.new('peerBgpAsn', stub[:peer_bgp_asn].to_s) unless stub[:peer_bgp_asn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class LocalGatewayVirtualInterfaceGroup
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayVirtualInterfaceGroup')
        visited = visited + ['LocalGatewayVirtualInterfaceGroup']
        {
          local_gateway_virtual_interface_group_id: 'local_gateway_virtual_interface_group_id',
          local_gateway_virtual_interface_ids: LocalGatewayVirtualInterfaceIdSet.default(visited),
          local_gateway_id: 'local_gateway_id',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceGroupId', stub[:local_gateway_virtual_interface_group_id].to_s) unless stub[:local_gateway_virtual_interface_group_id].nil?
        xml << Hearth::XML::Node.new('localGatewayVirtualInterfaceIdSet', LocalGatewayVirtualInterfaceIdSet.stub('item', stub[:local_gateway_virtual_interface_ids])) unless stub[:local_gateway_virtual_interface_ids].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class LocalGatewayVirtualInterfaceGroupSet
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayVirtualInterfaceGroupSet')
        visited = visited + ['LocalGatewayVirtualInterfaceGroupSet']
        [
          LocalGatewayVirtualInterfaceGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayVirtualInterfaceGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LocalGatewayVirtualInterfaceIdSet
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayVirtualInterfaceIdSet')
        visited = visited + ['LocalGatewayVirtualInterfaceIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class LocalGatewayVirtualInterfaceSet
      def self.default(visited = [])
        return nil if visited.include?('LocalGatewayVirtualInterfaceSet')
        visited = visited + ['LocalGatewayVirtualInterfaceSet']
        [
          LocalGatewayVirtualInterface.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << LocalGatewayVirtualInterface.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class LocalStorageTypeSet
      def self.default(visited = [])
        return nil if visited.include?('LocalStorageTypeSet')
        visited = visited + ['LocalStorageTypeSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class MaintenanceDetails
      def self.default(visited = [])
        return nil if visited.include?('MaintenanceDetails')
        visited = visited + ['MaintenanceDetails']
        {
          pending_maintenance: 'pending_maintenance',
          maintenance_auto_applied_after: Time.now,
          last_maintenance_applied: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('pendingMaintenance', stub[:pending_maintenance].to_s) unless stub[:pending_maintenance].nil?
        xml << Hearth::XML::Node.new('maintenanceAutoAppliedAfter', Hearth::TimeHelper.to_date_time(stub[:maintenance_auto_applied_after])) unless stub[:maintenance_auto_applied_after].nil?
        xml << Hearth::XML::Node.new('lastMaintenanceApplied', Hearth::TimeHelper.to_date_time(stub[:last_maintenance_applied])) unless stub[:last_maintenance_applied].nil?
        xml
      end
    end

    class ManagedPrefixList
      def self.default(visited = [])
        return nil if visited.include?('ManagedPrefixList')
        visited = visited + ['ManagedPrefixList']
        {
          prefix_list_id: 'prefix_list_id',
          address_family: 'address_family',
          state: 'state',
          state_message: 'state_message',
          prefix_list_arn: 'prefix_list_arn',
          prefix_list_name: 'prefix_list_name',
          max_entries: 1,
          version: 1,
          tags: TagList.default(visited),
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('addressFamily', stub[:address_family].to_s) unless stub[:address_family].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('stateMessage', stub[:state_message].to_s) unless stub[:state_message].nil?
        xml << Hearth::XML::Node.new('prefixListArn', stub[:prefix_list_arn].to_s) unless stub[:prefix_list_arn].nil?
        xml << Hearth::XML::Node.new('prefixListName', stub[:prefix_list_name].to_s) unless stub[:prefix_list_name].nil?
        xml << Hearth::XML::Node.new('maxEntries', stub[:max_entries].to_s) unless stub[:max_entries].nil?
        xml << Hearth::XML::Node.new('version', stub[:version].to_s) unless stub[:version].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    class ManagedPrefixListSet
      def self.default(visited = [])
        return nil if visited.include?('ManagedPrefixListSet')
        visited = visited + ['ManagedPrefixListSet']
        [
          ManagedPrefixList.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ManagedPrefixList.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class MemoryGiBPerVCpu
      def self.default(visited = [])
        return nil if visited.include?('MemoryGiBPerVCpu')
        visited = visited + ['MemoryGiBPerVCpu']
        {
          min: 1.0,
          max: 1.0,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', Hearth::NumberHelper.serialize(stub[:min]).to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', Hearth::NumberHelper.serialize(stub[:max]).to_s) unless stub[:max].nil?
        xml
      end
    end

    class MemoryInfo
      def self.default(visited = [])
        return nil if visited.include?('MemoryInfo')
        visited = visited + ['MemoryInfo']
        {
          size_in_mi_b: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sizeInMiB', stub[:size_in_mi_b].to_s) unless stub[:size_in_mi_b].nil?
        xml
      end
    end

    class MemoryMiB
      def self.default(visited = [])
        return nil if visited.include?('MemoryMiB')
        visited = visited + ['MemoryMiB']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    class MetricPoint
      def self.default(visited = [])
        return nil if visited.include?('MetricPoint')
        visited = visited + ['MetricPoint']
        {
          start_date: Time.now,
          end_date: Time.now,
          value: 1.0,
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('startDate', Hearth::TimeHelper.to_date_time(stub[:start_date])) unless stub[:start_date].nil?
        xml << Hearth::XML::Node.new('endDate', Hearth::TimeHelper.to_date_time(stub[:end_date])) unless stub[:end_date].nil?
        xml << Hearth::XML::Node.new('value', Hearth::NumberHelper.serialize(stub[:value]).to_s) unless stub[:value].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    class MetricPoints
      def self.default(visited = [])
        return nil if visited.include?('MetricPoints')
        visited = visited + ['MetricPoints']
        [
          MetricPoint.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << MetricPoint.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ModifyAddressAttribute
      def self.build(params, context:)
        Params::ModifyAddressAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyAddressAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          address: AddressAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyAddressAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << AddressAttribute.stub('address', stub[:address]) unless stub[:address].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyAvailabilityZoneGroup
      def self.build(params, context:)
        Params::ModifyAvailabilityZoneGroupOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyAvailabilityZoneGroupOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyAvailabilityZoneGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyCapacityReservation
      def self.build(params, context:)
        Params::ModifyCapacityReservationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyCapacityReservationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyCapacityReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyCapacityReservationFleet
      def self.build(params, context:)
        Params::ModifyCapacityReservationFleetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyCapacityReservationFleetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyCapacityReservationFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyClientVpnEndpoint
      def self.build(params, context:)
        Params::ModifyClientVpnEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyClientVpnEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyClientVpnEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyDefaultCreditSpecification
      def self.build(params, context:)
        Params::ModifyDefaultCreditSpecificationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyDefaultCreditSpecificationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_family_credit_specification: InstanceFamilyCreditSpecification.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyDefaultCreditSpecificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceFamilyCreditSpecification.stub('instanceFamilyCreditSpecification', stub[:instance_family_credit_specification]) unless stub[:instance_family_credit_specification].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyEbsDefaultKmsKeyId
      def self.build(params, context:)
        Params::ModifyEbsDefaultKmsKeyIdOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyEbsDefaultKmsKeyIdOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          kms_key_id: 'kms_key_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyEbsDefaultKmsKeyIdResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyFleet
      def self.build(params, context:)
        Params::ModifyFleetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyFleetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyFpgaImageAttribute
      def self.build(params, context:)
        Params::ModifyFpgaImageAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyFpgaImageAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          fpga_image_attribute: FpgaImageAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyFpgaImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << FpgaImageAttribute.stub('fpgaImageAttribute', stub[:fpga_image_attribute]) unless stub[:fpga_image_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyHosts
      def self.build(params, context:)
        Params::ModifyHostsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyHostsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successful: ResponseHostIdList.default(visited),
          unsuccessful: UnsuccessfulItemList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyHostsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successful', ResponseHostIdList.stub('item', stub[:successful])) unless stub[:successful].nil?
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemList.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyIdFormat
      def self.build(params, context:)
        Params::ModifyIdFormatOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyIdFormatOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyIdentityIdFormat
      def self.build(params, context:)
        Params::ModifyIdentityIdFormatOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyIdentityIdFormatOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIdentityIdFormatResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyImageAttribute
      def self.build(params, context:)
        Params::ModifyImageAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyImageAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyInstanceAttribute
      def self.build(params, context:)
        Params::ModifyInstanceAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyInstanceAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyInstanceCapacityReservationAttributes
      def self.build(params, context:)
        Params::ModifyInstanceCapacityReservationAttributesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyInstanceCapacityReservationAttributesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceCapacityReservationAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyInstanceCreditSpecification
      def self.build(params, context:)
        Params::ModifyInstanceCreditSpecificationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyInstanceCreditSpecificationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successful_instance_credit_specifications: SuccessfulInstanceCreditSpecificationSet.default(visited),
          unsuccessful_instance_credit_specifications: UnsuccessfulInstanceCreditSpecificationSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceCreditSpecificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successfulInstanceCreditSpecificationSet', SuccessfulInstanceCreditSpecificationSet.stub('item', stub[:successful_instance_credit_specifications])) unless stub[:successful_instance_credit_specifications].nil?
        xml << Hearth::XML::Node.new('unsuccessfulInstanceCreditSpecificationSet', UnsuccessfulInstanceCreditSpecificationSet.stub('item', stub[:unsuccessful_instance_credit_specifications])) unless stub[:unsuccessful_instance_credit_specifications].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyInstanceEventStartTime
      def self.build(params, context:)
        Params::ModifyInstanceEventStartTimeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyInstanceEventStartTimeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          event: InstanceStatusEvent.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceEventStartTimeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceStatusEvent.stub('event', stub[:event]) unless stub[:event].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyInstanceEventWindow
      def self.build(params, context:)
        Params::ModifyInstanceEventWindowOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyInstanceEventWindowOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_event_window: InstanceEventWindow.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceEventWindowResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceEventWindow.stub('instanceEventWindow', stub[:instance_event_window]) unless stub[:instance_event_window].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyInstanceMaintenanceOptions
      def self.build(params, context:)
        Params::ModifyInstanceMaintenanceOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyInstanceMaintenanceOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_id: 'instance_id',
          auto_recovery: 'auto_recovery',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceMaintenanceOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('autoRecovery', stub[:auto_recovery].to_s) unless stub[:auto_recovery].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyInstanceMetadataOptions
      def self.build(params, context:)
        Params::ModifyInstanceMetadataOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyInstanceMetadataOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_id: 'instance_id',
          instance_metadata_options: InstanceMetadataOptionsResponse.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstanceMetadataOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << InstanceMetadataOptionsResponse.stub('instanceMetadataOptions', stub[:instance_metadata_options]) unless stub[:instance_metadata_options].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyInstancePlacement
      def self.build(params, context:)
        Params::ModifyInstancePlacementOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyInstancePlacementOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyInstancePlacementResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyIpam
      def self.build(params, context:)
        Params::ModifyIpamOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyIpamOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam: Ipam.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIpamResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Ipam.stub('ipam', stub[:ipam]) unless stub[:ipam].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyIpamPool
      def self.build(params, context:)
        Params::ModifyIpamPoolOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyIpamPoolOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_pool: IpamPool.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIpamPoolResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPool.stub('ipamPool', stub[:ipam_pool]) unless stub[:ipam_pool].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyIpamResourceCidr
      def self.build(params, context:)
        Params::ModifyIpamResourceCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyIpamResourceCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_resource_cidr: IpamResourceCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIpamResourceCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamResourceCidr.stub('ipamResourceCidr', stub[:ipam_resource_cidr]) unless stub[:ipam_resource_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyIpamResourceDiscovery
      def self.build(params, context:)
        Params::ModifyIpamResourceDiscoveryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyIpamResourceDiscoveryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_resource_discovery: IpamResourceDiscovery.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIpamResourceDiscoveryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamResourceDiscovery.stub('ipamResourceDiscovery', stub[:ipam_resource_discovery]) unless stub[:ipam_resource_discovery].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyIpamScope
      def self.build(params, context:)
        Params::ModifyIpamScopeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyIpamScopeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_scope: IpamScope.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyIpamScopeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamScope.stub('ipamScope', stub[:ipam_scope]) unless stub[:ipam_scope].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyLaunchTemplate
      def self.build(params, context:)
        Params::ModifyLaunchTemplateOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyLaunchTemplateOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          launch_template: LaunchTemplate.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyLaunchTemplateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LaunchTemplate.stub('launchTemplate', stub[:launch_template]) unless stub[:launch_template].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyLocalGatewayRoute
      def self.build(params, context:)
        Params::ModifyLocalGatewayRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyLocalGatewayRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          route: LocalGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyLocalGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << LocalGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyManagedPrefixList
      def self.build(params, context:)
        Params::ModifyManagedPrefixListOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyManagedPrefixListOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          prefix_list: ManagedPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyManagedPrefixListResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ManagedPrefixList.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyNetworkInterfaceAttribute
      def self.build(params, context:)
        Params::ModifyNetworkInterfaceAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyNetworkInterfaceAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyNetworkInterfaceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyPrivateDnsNameOptions
      def self.build(params, context:)
        Params::ModifyPrivateDnsNameOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyPrivateDnsNameOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyPrivateDnsNameOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyReservedInstances
      def self.build(params, context:)
        Params::ModifyReservedInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyReservedInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          reserved_instances_modification_id: 'reserved_instances_modification_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyReservedInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesModificationId', stub[:reserved_instances_modification_id].to_s) unless stub[:reserved_instances_modification_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifySecurityGroupRules
      def self.build(params, context:)
        Params::ModifySecurityGroupRulesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifySecurityGroupRulesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySecurityGroupRulesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifySnapshotAttribute
      def self.build(params, context:)
        Params::ModifySnapshotAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifySnapshotAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySnapshotAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifySnapshotTier
      def self.build(params, context:)
        Params::ModifySnapshotTierOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifySnapshotTierOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          snapshot_id: 'snapshot_id',
          tiering_start_time: Time.now,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySnapshotTierResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('tieringStartTime', Hearth::TimeHelper.to_date_time(stub[:tiering_start_time])) unless stub[:tiering_start_time].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifySpotFleetRequest
      def self.build(params, context:)
        Params::ModifySpotFleetRequestOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifySpotFleetRequestOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySpotFleetRequestResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifySubnetAttribute
      def self.build(params, context:)
        Params::ModifySubnetAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifySubnetAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifySubnetAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyTrafficMirrorFilterNetworkServices
      def self.build(params, context:)
        Params::ModifyTrafficMirrorFilterNetworkServicesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyTrafficMirrorFilterNetworkServicesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_filter: TrafficMirrorFilter.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTrafficMirrorFilterNetworkServicesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorFilter.stub('trafficMirrorFilter', stub[:traffic_mirror_filter]) unless stub[:traffic_mirror_filter].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyTrafficMirrorFilterRule
      def self.build(params, context:)
        Params::ModifyTrafficMirrorFilterRuleOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyTrafficMirrorFilterRuleOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_filter_rule: TrafficMirrorFilterRule.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTrafficMirrorFilterRuleResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorFilterRule.stub('trafficMirrorFilterRule', stub[:traffic_mirror_filter_rule]) unless stub[:traffic_mirror_filter_rule].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyTrafficMirrorSession
      def self.build(params, context:)
        Params::ModifyTrafficMirrorSessionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyTrafficMirrorSessionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          traffic_mirror_session: TrafficMirrorSession.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTrafficMirrorSessionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TrafficMirrorSession.stub('trafficMirrorSession', stub[:traffic_mirror_session]) unless stub[:traffic_mirror_session].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyTransitGateway
      def self.build(params, context:)
        Params::ModifyTransitGatewayOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyTransitGatewayOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway: TransitGateway.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTransitGatewayResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGateway.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyTransitGatewayPrefixListReference
      def self.build(params, context:)
        Params::ModifyTransitGatewayPrefixListReferenceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyTransitGatewayPrefixListReferenceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_prefix_list_reference: TransitGatewayPrefixListReference.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTransitGatewayPrefixListReferenceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPrefixListReference.stub('transitGatewayPrefixListReference', stub[:transit_gateway_prefix_list_reference]) unless stub[:transit_gateway_prefix_list_reference].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyTransitGatewayVpcAttachment
      def self.build(params, context:)
        Params::ModifyTransitGatewayVpcAttachmentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyTransitGatewayVpcAttachmentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVerifiedAccessEndpoint
      def self.build(params, context:)
        Params::ModifyVerifiedAccessEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVerifiedAccessEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_endpoint: VerifiedAccessEndpoint.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVerifiedAccessEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessEndpoint.stub('verifiedAccessEndpoint', stub[:verified_access_endpoint]) unless stub[:verified_access_endpoint].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVerifiedAccessEndpointPolicy
      def self.build(params, context:)
        Params::ModifyVerifiedAccessEndpointPolicyOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVerifiedAccessEndpointPolicyOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          policy_enabled: false,
          policy_document: 'policy_document',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVerifiedAccessEndpointPolicyResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('policyEnabled', stub[:policy_enabled].to_s) unless stub[:policy_enabled].nil?
        xml << Hearth::XML::Node.new('policyDocument', stub[:policy_document].to_s) unless stub[:policy_document].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVerifiedAccessGroup
      def self.build(params, context:)
        Params::ModifyVerifiedAccessGroupOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVerifiedAccessGroupOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_group: VerifiedAccessGroup.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVerifiedAccessGroupResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessGroup.stub('verifiedAccessGroup', stub[:verified_access_group]) unless stub[:verified_access_group].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVerifiedAccessGroupPolicy
      def self.build(params, context:)
        Params::ModifyVerifiedAccessGroupPolicyOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVerifiedAccessGroupPolicyOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          policy_enabled: false,
          policy_document: 'policy_document',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVerifiedAccessGroupPolicyResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('policyEnabled', stub[:policy_enabled].to_s) unless stub[:policy_enabled].nil?
        xml << Hearth::XML::Node.new('policyDocument', stub[:policy_document].to_s) unless stub[:policy_document].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVerifiedAccessInstance
      def self.build(params, context:)
        Params::ModifyVerifiedAccessInstanceOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVerifiedAccessInstanceOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_instance: VerifiedAccessInstance.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVerifiedAccessInstanceResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessInstance.stub('verifiedAccessInstance', stub[:verified_access_instance]) unless stub[:verified_access_instance].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVerifiedAccessInstanceLoggingConfiguration
      def self.build(params, context:)
        Params::ModifyVerifiedAccessInstanceLoggingConfigurationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVerifiedAccessInstanceLoggingConfigurationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          logging_configuration: VerifiedAccessInstanceLoggingConfiguration.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVerifiedAccessInstanceLoggingConfigurationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessInstanceLoggingConfiguration.stub('loggingConfiguration', stub[:logging_configuration]) unless stub[:logging_configuration].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVerifiedAccessTrustProvider
      def self.build(params, context:)
        Params::ModifyVerifiedAccessTrustProviderOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVerifiedAccessTrustProviderOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          verified_access_trust_provider: VerifiedAccessTrustProvider.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVerifiedAccessTrustProviderResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VerifiedAccessTrustProvider.stub('verifiedAccessTrustProvider', stub[:verified_access_trust_provider]) unless stub[:verified_access_trust_provider].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVolume
      def self.build(params, context:)
        Params::ModifyVolumeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVolumeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          volume_modification: VolumeModification.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVolumeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VolumeModification.stub('volumeModification', stub[:volume_modification]) unless stub[:volume_modification].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVolumeAttribute
      def self.build(params, context:)
        Params::ModifyVolumeAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVolumeAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVolumeAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpcAttribute
      def self.build(params, context:)
        Params::ModifyVpcAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpcAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpcEndpoint
      def self.build(params, context:)
        Params::ModifyVpcEndpointOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpcEndpointOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpcEndpointConnectionNotification
      def self.build(params, context:)
        Params::ModifyVpcEndpointConnectionNotificationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpcEndpointConnectionNotificationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointConnectionNotificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpcEndpointServiceConfiguration
      def self.build(params, context:)
        Params::ModifyVpcEndpointServiceConfigurationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpcEndpointServiceConfigurationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointServiceConfigurationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpcEndpointServicePayerResponsibility
      def self.build(params, context:)
        Params::ModifyVpcEndpointServicePayerResponsibilityOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpcEndpointServicePayerResponsibilityOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointServicePayerResponsibilityResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpcEndpointServicePermissions
      def self.build(params, context:)
        Params::ModifyVpcEndpointServicePermissionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpcEndpointServicePermissionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          added_principals: AddedPrincipalSet.default(visited),
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcEndpointServicePermissionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('addedPrincipalSet', AddedPrincipalSet.stub('item', stub[:added_principals])) unless stub[:added_principals].nil?
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpcPeeringConnectionOptions
      def self.build(params, context:)
        Params::ModifyVpcPeeringConnectionOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpcPeeringConnectionOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          accepter_peering_connection_options: PeeringConnectionOptions.default(visited),
          requester_peering_connection_options: PeeringConnectionOptions.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcPeeringConnectionOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << PeeringConnectionOptions.stub('accepterPeeringConnectionOptions', stub[:accepter_peering_connection_options]) unless stub[:accepter_peering_connection_options].nil?
        xml << PeeringConnectionOptions.stub('requesterPeeringConnectionOptions', stub[:requester_peering_connection_options]) unless stub[:requester_peering_connection_options].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpcTenancy
      def self.build(params, context:)
        Params::ModifyVpcTenancyOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpcTenancyOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpcTenancyResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpnConnection
      def self.build(params, context:)
        Params::ModifyVpnConnectionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpnConnectionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpnConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpnConnectionOptions
      def self.build(params, context:)
        Params::ModifyVpnConnectionOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpnConnectionOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpnConnectionOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpnTunnelCertificate
      def self.build(params, context:)
        Params::ModifyVpnTunnelCertificateOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpnTunnelCertificateOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpnTunnelCertificateResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ModifyVpnTunnelOptions
      def self.build(params, context:)
        Params::ModifyVpnTunnelOptionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ModifyVpnTunnelOptionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          vpn_connection: VpnConnection.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ModifyVpnTunnelOptionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << VpnConnection.stub('vpnConnection', stub[:vpn_connection]) unless stub[:vpn_connection].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class MonitorInstances
      def self.build(params, context:)
        Params::MonitorInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::MonitorInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_monitorings: InstanceMonitoringList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('MonitorInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceMonitoringList.stub('item', stub[:instance_monitorings])) unless stub[:instance_monitorings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class Monitoring
      def self.default(visited = [])
        return nil if visited.include?('Monitoring')
        visited = visited + ['Monitoring']
        {
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class MoveAddressToVpc
      def self.build(params, context:)
        Params::MoveAddressToVpcOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::MoveAddressToVpcOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          allocation_id: 'allocation_id',
          status: 'status',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('MoveAddressToVpcResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class MoveByoipCidrToIpam
      def self.build(params, context:)
        Params::MoveByoipCidrToIpamOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::MoveByoipCidrToIpamOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('MoveByoipCidrToIpamResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class MovingAddressStatus
      def self.default(visited = [])
        return nil if visited.include?('MovingAddressStatus')
        visited = visited + ['MovingAddressStatus']
        {
          move_status: 'move_status',
          public_ip: 'public_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('moveStatus', stub[:move_status].to_s) unless stub[:move_status].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml
      end
    end

    class MovingAddressStatusSet
      def self.default(visited = [])
        return nil if visited.include?('MovingAddressStatusSet')
        visited = visited + ['MovingAddressStatusSet']
        [
          MovingAddressStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << MovingAddressStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NatGateway
      def self.default(visited = [])
        return nil if visited.include?('NatGateway')
        visited = visited + ['NatGateway']
        {
          create_time: Time.now,
          delete_time: Time.now,
          failure_code: 'failure_code',
          failure_message: 'failure_message',
          nat_gateway_addresses: NatGatewayAddressList.default(visited),
          nat_gateway_id: 'nat_gateway_id',
          provisioned_bandwidth: ProvisionedBandwidth.default(visited),
          state: 'state',
          subnet_id: 'subnet_id',
          vpc_id: 'vpc_id',
          tags: TagList.default(visited),
          connectivity_type: 'connectivity_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('deleteTime', Hearth::TimeHelper.to_date_time(stub[:delete_time])) unless stub[:delete_time].nil?
        xml << Hearth::XML::Node.new('failureCode', stub[:failure_code].to_s) unless stub[:failure_code].nil?
        xml << Hearth::XML::Node.new('failureMessage', stub[:failure_message].to_s) unless stub[:failure_message].nil?
        xml << Hearth::XML::Node.new('natGatewayAddressSet', NatGatewayAddressList.stub('item', stub[:nat_gateway_addresses])) unless stub[:nat_gateway_addresses].nil?
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << ProvisionedBandwidth.stub('provisionedBandwidth', stub[:provisioned_bandwidth]) unless stub[:provisioned_bandwidth].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('connectivityType', stub[:connectivity_type].to_s) unless stub[:connectivity_type].nil?
        xml
      end
    end

    class NatGatewayAddress
      def self.default(visited = [])
        return nil if visited.include?('NatGatewayAddress')
        visited = visited + ['NatGatewayAddress']
        {
          allocation_id: 'allocation_id',
          network_interface_id: 'network_interface_id',
          private_ip: 'private_ip',
          public_ip: 'public_ip',
          association_id: 'association_id',
          is_primary: false,
          failure_message: 'failure_message',
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('privateIp', stub[:private_ip].to_s) unless stub[:private_ip].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('isPrimary', stub[:is_primary].to_s) unless stub[:is_primary].nil?
        xml << Hearth::XML::Node.new('failureMessage', stub[:failure_message].to_s) unless stub[:failure_message].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    class NatGatewayAddressList
      def self.default(visited = [])
        return nil if visited.include?('NatGatewayAddressList')
        visited = visited + ['NatGatewayAddressList']
        [
          NatGatewayAddress.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NatGatewayAddress.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NatGatewayList
      def self.default(visited = [])
        return nil if visited.include?('NatGatewayList')
        visited = visited + ['NatGatewayList']
        [
          NatGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NatGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkAcl
      def self.default(visited = [])
        return nil if visited.include?('NetworkAcl')
        visited = visited + ['NetworkAcl']
        {
          associations: NetworkAclAssociationList.default(visited),
          entries: NetworkAclEntryList.default(visited),
          is_default: false,
          network_acl_id: 'network_acl_id',
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationSet', NetworkAclAssociationList.stub('item', stub[:associations])) unless stub[:associations].nil?
        xml << Hearth::XML::Node.new('entrySet', NetworkAclEntryList.stub('item', stub[:entries])) unless stub[:entries].nil?
        xml << Hearth::XML::Node.new('default', stub[:is_default].to_s) unless stub[:is_default].nil?
        xml << Hearth::XML::Node.new('networkAclId', stub[:network_acl_id].to_s) unless stub[:network_acl_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    class NetworkAclAssociation
      def self.default(visited = [])
        return nil if visited.include?('NetworkAclAssociation')
        visited = visited + ['NetworkAclAssociation']
        {
          network_acl_association_id: 'network_acl_association_id',
          network_acl_id: 'network_acl_id',
          subnet_id: 'subnet_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkAclAssociationId', stub[:network_acl_association_id].to_s) unless stub[:network_acl_association_id].nil?
        xml << Hearth::XML::Node.new('networkAclId', stub[:network_acl_id].to_s) unless stub[:network_acl_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml
      end
    end

    class NetworkAclAssociationList
      def self.default(visited = [])
        return nil if visited.include?('NetworkAclAssociationList')
        visited = visited + ['NetworkAclAssociationList']
        [
          NetworkAclAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkAclAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkAclEntry
      def self.default(visited = [])
        return nil if visited.include?('NetworkAclEntry')
        visited = visited + ['NetworkAclEntry']
        {
          cidr_block: 'cidr_block',
          egress: false,
          icmp_type_code: IcmpTypeCode.default(visited),
          ipv6_cidr_block: 'ipv6_cidr_block',
          port_range: PortRange.default(visited),
          protocol: 'protocol',
          rule_action: 'rule_action',
          rule_number: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << Hearth::XML::Node.new('egress', stub[:egress].to_s) unless stub[:egress].nil?
        xml << IcmpTypeCode.stub('icmpTypeCode', stub[:icmp_type_code]) unless stub[:icmp_type_code].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlock', stub[:ipv6_cidr_block].to_s) unless stub[:ipv6_cidr_block].nil?
        xml << PortRange.stub('portRange', stub[:port_range]) unless stub[:port_range].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('ruleAction', stub[:rule_action].to_s) unless stub[:rule_action].nil?
        xml << Hearth::XML::Node.new('ruleNumber', stub[:rule_number].to_s) unless stub[:rule_number].nil?
        xml
      end
    end

    class NetworkAclEntryList
      def self.default(visited = [])
        return nil if visited.include?('NetworkAclEntryList')
        visited = visited + ['NetworkAclEntryList']
        [
          NetworkAclEntry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkAclEntry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkAclList
      def self.default(visited = [])
        return nil if visited.include?('NetworkAclList')
        visited = visited + ['NetworkAclList']
        [
          NetworkAcl.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkAcl.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkBandwidthGbps
      def self.default(visited = [])
        return nil if visited.include?('NetworkBandwidthGbps')
        visited = visited + ['NetworkBandwidthGbps']
        {
          min: 1.0,
          max: 1.0,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', Hearth::NumberHelper.serialize(stub[:min]).to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', Hearth::NumberHelper.serialize(stub[:max]).to_s) unless stub[:max].nil?
        xml
      end
    end

    class NetworkCardInfo
      def self.default(visited = [])
        return nil if visited.include?('NetworkCardInfo')
        visited = visited + ['NetworkCardInfo']
        {
          network_card_index: 1,
          network_performance: 'network_performance',
          maximum_network_interfaces: 1,
          baseline_bandwidth_in_gbps: 1.0,
          peak_bandwidth_in_gbps: 1.0,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml << Hearth::XML::Node.new('networkPerformance', stub[:network_performance].to_s) unless stub[:network_performance].nil?
        xml << Hearth::XML::Node.new('maximumNetworkInterfaces', stub[:maximum_network_interfaces].to_s) unless stub[:maximum_network_interfaces].nil?
        xml << Hearth::XML::Node.new('baselineBandwidthInGbps', Hearth::NumberHelper.serialize(stub[:baseline_bandwidth_in_gbps]).to_s) unless stub[:baseline_bandwidth_in_gbps].nil?
        xml << Hearth::XML::Node.new('peakBandwidthInGbps', Hearth::NumberHelper.serialize(stub[:peak_bandwidth_in_gbps]).to_s) unless stub[:peak_bandwidth_in_gbps].nil?
        xml
      end
    end

    class NetworkCardInfoList
      def self.default(visited = [])
        return nil if visited.include?('NetworkCardInfoList')
        visited = visited + ['NetworkCardInfoList']
        [
          NetworkCardInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkCardInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkInfo
      def self.default(visited = [])
        return nil if visited.include?('NetworkInfo')
        visited = visited + ['NetworkInfo']
        {
          network_performance: 'network_performance',
          maximum_network_interfaces: 1,
          maximum_network_cards: 1,
          default_network_card_index: 1,
          network_cards: NetworkCardInfoList.default(visited),
          ipv4_addresses_per_interface: 1,
          ipv6_addresses_per_interface: 1,
          ipv6_supported: false,
          ena_support: 'ena_support',
          efa_supported: false,
          efa_info: EfaInfo.default(visited),
          encryption_in_transit_supported: false,
          ena_srd_supported: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkPerformance', stub[:network_performance].to_s) unless stub[:network_performance].nil?
        xml << Hearth::XML::Node.new('maximumNetworkInterfaces', stub[:maximum_network_interfaces].to_s) unless stub[:maximum_network_interfaces].nil?
        xml << Hearth::XML::Node.new('maximumNetworkCards', stub[:maximum_network_cards].to_s) unless stub[:maximum_network_cards].nil?
        xml << Hearth::XML::Node.new('defaultNetworkCardIndex', stub[:default_network_card_index].to_s) unless stub[:default_network_card_index].nil?
        xml << Hearth::XML::Node.new('networkCards', NetworkCardInfoList.stub('item', stub[:network_cards])) unless stub[:network_cards].nil?
        xml << Hearth::XML::Node.new('ipv4AddressesPerInterface', stub[:ipv4_addresses_per_interface].to_s) unless stub[:ipv4_addresses_per_interface].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesPerInterface', stub[:ipv6_addresses_per_interface].to_s) unless stub[:ipv6_addresses_per_interface].nil?
        xml << Hearth::XML::Node.new('ipv6Supported', stub[:ipv6_supported].to_s) unless stub[:ipv6_supported].nil?
        xml << Hearth::XML::Node.new('enaSupport', stub[:ena_support].to_s) unless stub[:ena_support].nil?
        xml << Hearth::XML::Node.new('efaSupported', stub[:efa_supported].to_s) unless stub[:efa_supported].nil?
        xml << EfaInfo.stub('efaInfo', stub[:efa_info]) unless stub[:efa_info].nil?
        xml << Hearth::XML::Node.new('encryptionInTransitSupported', stub[:encryption_in_transit_supported].to_s) unless stub[:encryption_in_transit_supported].nil?
        xml << Hearth::XML::Node.new('enaSrdSupported', stub[:ena_srd_supported].to_s) unless stub[:ena_srd_supported].nil?
        xml
      end
    end

    class NetworkInsightsAccessScope
      def self.default(visited = [])
        return nil if visited.include?('NetworkInsightsAccessScope')
        visited = visited + ['NetworkInsightsAccessScope']
        {
          network_insights_access_scope_id: 'network_insights_access_scope_id',
          network_insights_access_scope_arn: 'network_insights_access_scope_arn',
          created_date: Time.now,
          updated_date: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeArn', stub[:network_insights_access_scope_arn].to_s) unless stub[:network_insights_access_scope_arn].nil?
        xml << Hearth::XML::Node.new('createdDate', Hearth::TimeHelper.to_date_time(stub[:created_date])) unless stub[:created_date].nil?
        xml << Hearth::XML::Node.new('updatedDate', Hearth::TimeHelper.to_date_time(stub[:updated_date])) unless stub[:updated_date].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class NetworkInsightsAccessScopeAnalysis
      def self.default(visited = [])
        return nil if visited.include?('NetworkInsightsAccessScopeAnalysis')
        visited = visited + ['NetworkInsightsAccessScopeAnalysis']
        {
          network_insights_access_scope_analysis_id: 'network_insights_access_scope_analysis_id',
          network_insights_access_scope_analysis_arn: 'network_insights_access_scope_analysis_arn',
          network_insights_access_scope_id: 'network_insights_access_scope_id',
          status: 'status',
          status_message: 'status_message',
          warning_message: 'warning_message',
          start_date: Time.now,
          end_date: Time.now,
          findings_found: 'findings_found',
          analyzed_eni_count: 1,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisId', stub[:network_insights_access_scope_analysis_id].to_s) unless stub[:network_insights_access_scope_analysis_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeAnalysisArn', stub[:network_insights_access_scope_analysis_arn].to_s) unless stub[:network_insights_access_scope_analysis_arn].nil?
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('warningMessage', stub[:warning_message].to_s) unless stub[:warning_message].nil?
        xml << Hearth::XML::Node.new('startDate', Hearth::TimeHelper.to_date_time(stub[:start_date])) unless stub[:start_date].nil?
        xml << Hearth::XML::Node.new('endDate', Hearth::TimeHelper.to_date_time(stub[:end_date])) unless stub[:end_date].nil?
        xml << Hearth::XML::Node.new('findingsFound', stub[:findings_found].to_s) unless stub[:findings_found].nil?
        xml << Hearth::XML::Node.new('analyzedEniCount', stub[:analyzed_eni_count].to_s) unless stub[:analyzed_eni_count].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class NetworkInsightsAccessScopeAnalysisList
      def self.default(visited = [])
        return nil if visited.include?('NetworkInsightsAccessScopeAnalysisList')
        visited = visited + ['NetworkInsightsAccessScopeAnalysisList']
        [
          NetworkInsightsAccessScopeAnalysis.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInsightsAccessScopeAnalysis.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkInsightsAccessScopeContent
      def self.default(visited = [])
        return nil if visited.include?('NetworkInsightsAccessScopeContent')
        visited = visited + ['NetworkInsightsAccessScopeContent']
        {
          network_insights_access_scope_id: 'network_insights_access_scope_id',
          match_paths: AccessScopePathList.default(visited),
          exclude_paths: AccessScopePathList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAccessScopeId', stub[:network_insights_access_scope_id].to_s) unless stub[:network_insights_access_scope_id].nil?
        xml << Hearth::XML::Node.new('matchPathSet', AccessScopePathList.stub('item', stub[:match_paths])) unless stub[:match_paths].nil?
        xml << Hearth::XML::Node.new('excludePathSet', AccessScopePathList.stub('item', stub[:exclude_paths])) unless stub[:exclude_paths].nil?
        xml
      end
    end

    class NetworkInsightsAccessScopeList
      def self.default(visited = [])
        return nil if visited.include?('NetworkInsightsAccessScopeList')
        visited = visited + ['NetworkInsightsAccessScopeList']
        [
          NetworkInsightsAccessScope.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInsightsAccessScope.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkInsightsAnalysis
      def self.default(visited = [])
        return nil if visited.include?('NetworkInsightsAnalysis')
        visited = visited + ['NetworkInsightsAnalysis']
        {
          network_insights_analysis_id: 'network_insights_analysis_id',
          network_insights_analysis_arn: 'network_insights_analysis_arn',
          network_insights_path_id: 'network_insights_path_id',
          additional_accounts: ValueStringList.default(visited),
          filter_in_arns: ArnList.default(visited),
          start_date: Time.now,
          status: 'status',
          status_message: 'status_message',
          warning_message: 'warning_message',
          network_path_found: false,
          forward_path_components: PathComponentList.default(visited),
          return_path_components: PathComponentList.default(visited),
          explanations: ExplanationList.default(visited),
          alternate_path_hints: AlternatePathHintList.default(visited),
          suggested_accounts: ValueStringList.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsAnalysisId', stub[:network_insights_analysis_id].to_s) unless stub[:network_insights_analysis_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsAnalysisArn', stub[:network_insights_analysis_arn].to_s) unless stub[:network_insights_analysis_arn].nil?
        xml << Hearth::XML::Node.new('networkInsightsPathId', stub[:network_insights_path_id].to_s) unless stub[:network_insights_path_id].nil?
        xml << Hearth::XML::Node.new('additionalAccountSet', ValueStringList.stub('item', stub[:additional_accounts])) unless stub[:additional_accounts].nil?
        xml << Hearth::XML::Node.new('filterInArnSet', ArnList.stub('item', stub[:filter_in_arns])) unless stub[:filter_in_arns].nil?
        xml << Hearth::XML::Node.new('startDate', Hearth::TimeHelper.to_date_time(stub[:start_date])) unless stub[:start_date].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('warningMessage', stub[:warning_message].to_s) unless stub[:warning_message].nil?
        xml << Hearth::XML::Node.new('networkPathFound', stub[:network_path_found].to_s) unless stub[:network_path_found].nil?
        xml << Hearth::XML::Node.new('forwardPathComponentSet', PathComponentList.stub('item', stub[:forward_path_components])) unless stub[:forward_path_components].nil?
        xml << Hearth::XML::Node.new('returnPathComponentSet', PathComponentList.stub('item', stub[:return_path_components])) unless stub[:return_path_components].nil?
        xml << Hearth::XML::Node.new('explanationSet', ExplanationList.stub('item', stub[:explanations])) unless stub[:explanations].nil?
        xml << Hearth::XML::Node.new('alternatePathHintSet', AlternatePathHintList.stub('item', stub[:alternate_path_hints])) unless stub[:alternate_path_hints].nil?
        xml << Hearth::XML::Node.new('suggestedAccountSet', ValueStringList.stub('item', stub[:suggested_accounts])) unless stub[:suggested_accounts].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class NetworkInsightsAnalysisList
      def self.default(visited = [])
        return nil if visited.include?('NetworkInsightsAnalysisList')
        visited = visited + ['NetworkInsightsAnalysisList']
        [
          NetworkInsightsAnalysis.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInsightsAnalysis.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkInsightsPath
      def self.default(visited = [])
        return nil if visited.include?('NetworkInsightsPath')
        visited = visited + ['NetworkInsightsPath']
        {
          network_insights_path_id: 'network_insights_path_id',
          network_insights_path_arn: 'network_insights_path_arn',
          created_date: Time.now,
          source: 'source',
          destination: 'destination',
          source_arn: 'source_arn',
          destination_arn: 'destination_arn',
          source_ip: 'source_ip',
          destination_ip: 'destination_ip',
          protocol: 'protocol',
          destination_port: 1,
          tags: TagList.default(visited),
          filter_at_source: PathFilter.default(visited),
          filter_at_destination: PathFilter.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInsightsPathId', stub[:network_insights_path_id].to_s) unless stub[:network_insights_path_id].nil?
        xml << Hearth::XML::Node.new('networkInsightsPathArn', stub[:network_insights_path_arn].to_s) unless stub[:network_insights_path_arn].nil?
        xml << Hearth::XML::Node.new('createdDate', Hearth::TimeHelper.to_date_time(stub[:created_date])) unless stub[:created_date].nil?
        xml << Hearth::XML::Node.new('source', stub[:source].to_s) unless stub[:source].nil?
        xml << Hearth::XML::Node.new('destination', stub[:destination].to_s) unless stub[:destination].nil?
        xml << Hearth::XML::Node.new('sourceArn', stub[:source_arn].to_s) unless stub[:source_arn].nil?
        xml << Hearth::XML::Node.new('destinationArn', stub[:destination_arn].to_s) unless stub[:destination_arn].nil?
        xml << Hearth::XML::Node.new('sourceIp', stub[:source_ip].to_s) unless stub[:source_ip].nil?
        xml << Hearth::XML::Node.new('destinationIp', stub[:destination_ip].to_s) unless stub[:destination_ip].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('destinationPort', stub[:destination_port].to_s) unless stub[:destination_port].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << PathFilter.stub('filterAtSource', stub[:filter_at_source]) unless stub[:filter_at_source].nil?
        xml << PathFilter.stub('filterAtDestination', stub[:filter_at_destination]) unless stub[:filter_at_destination].nil?
        xml
      end
    end

    class NetworkInsightsPathList
      def self.default(visited = [])
        return nil if visited.include?('NetworkInsightsPathList')
        visited = visited + ['NetworkInsightsPathList']
        [
          NetworkInsightsPath.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInsightsPath.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkInterface
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterface')
        visited = visited + ['NetworkInterface']
        {
          association: NetworkInterfaceAssociation.default(visited),
          attachment: NetworkInterfaceAttachment.default(visited),
          availability_zone: 'availability_zone',
          description: 'description',
          groups: GroupIdentifierList.default(visited),
          interface_type: 'interface_type',
          ipv6_addresses: NetworkInterfaceIpv6AddressesList.default(visited),
          mac_address: 'mac_address',
          network_interface_id: 'network_interface_id',
          outpost_arn: 'outpost_arn',
          owner_id: 'owner_id',
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
          private_ip_addresses: NetworkInterfacePrivateIpAddressList.default(visited),
          ipv4_prefixes: Ipv4PrefixesList.default(visited),
          ipv6_prefixes: Ipv6PrefixesList.default(visited),
          requester_id: 'requester_id',
          requester_managed: false,
          source_dest_check: false,
          status: 'status',
          subnet_id: 'subnet_id',
          tag_set: TagList.default(visited),
          vpc_id: 'vpc_id',
          deny_all_igw_traffic: false,
          ipv6_native: false,
          ipv6_address: 'ipv6_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << NetworkInterfaceAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << NetworkInterfaceAttachment.stub('attachment', stub[:attachment]) unless stub[:attachment].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('interfaceType', stub[:interface_type].to_s) unless stub[:interface_type].nil?
        xml << Hearth::XML::Node.new('ipv6AddressesSet', NetworkInterfaceIpv6AddressesList.stub('item', stub[:ipv6_addresses])) unless stub[:ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('macAddress', stub[:mac_address].to_s) unless stub[:mac_address].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml << Hearth::XML::Node.new('privateIpAddressesSet', NetworkInterfacePrivateIpAddressList.stub('item', stub[:private_ip_addresses])) unless stub[:private_ip_addresses].nil?
        xml << Hearth::XML::Node.new('ipv4PrefixSet', Ipv4PrefixesList.stub('item', stub[:ipv4_prefixes])) unless stub[:ipv4_prefixes].nil?
        xml << Hearth::XML::Node.new('ipv6PrefixSet', Ipv6PrefixesList.stub('item', stub[:ipv6_prefixes])) unless stub[:ipv6_prefixes].nil?
        xml << Hearth::XML::Node.new('requesterId', stub[:requester_id].to_s) unless stub[:requester_id].nil?
        xml << Hearth::XML::Node.new('requesterManaged', stub[:requester_managed].to_s) unless stub[:requester_managed].nil?
        xml << Hearth::XML::Node.new('sourceDestCheck', stub[:source_dest_check].to_s) unless stub[:source_dest_check].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tag_set])) unless stub[:tag_set].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('denyAllIgwTraffic', stub[:deny_all_igw_traffic].to_s) unless stub[:deny_all_igw_traffic].nil?
        xml << Hearth::XML::Node.new('ipv6Native', stub[:ipv6_native].to_s) unless stub[:ipv6_native].nil?
        xml << Hearth::XML::Node.new('ipv6Address', stub[:ipv6_address].to_s) unless stub[:ipv6_address].nil?
        xml
      end
    end

    class NetworkInterfaceAssociation
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfaceAssociation')
        visited = visited + ['NetworkInterfaceAssociation']
        {
          allocation_id: 'allocation_id',
          association_id: 'association_id',
          ip_owner_id: 'ip_owner_id',
          public_dns_name: 'public_dns_name',
          public_ip: 'public_ip',
          customer_owned_ip: 'customer_owned_ip',
          carrier_ip: 'carrier_ip',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationId', stub[:allocation_id].to_s) unless stub[:allocation_id].nil?
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('ipOwnerId', stub[:ip_owner_id].to_s) unless stub[:ip_owner_id].nil?
        xml << Hearth::XML::Node.new('publicDnsName', stub[:public_dns_name].to_s) unless stub[:public_dns_name].nil?
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('customerOwnedIp', stub[:customer_owned_ip].to_s) unless stub[:customer_owned_ip].nil?
        xml << Hearth::XML::Node.new('carrierIp', stub[:carrier_ip].to_s) unless stub[:carrier_ip].nil?
        xml
      end
    end

    class NetworkInterfaceAttachment
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfaceAttachment')
        visited = visited + ['NetworkInterfaceAttachment']
        {
          attach_time: Time.now,
          attachment_id: 'attachment_id',
          delete_on_termination: false,
          device_index: 1,
          network_card_index: 1,
          instance_id: 'instance_id',
          instance_owner_id: 'instance_owner_id',
          status: 'status',
          ena_srd_specification: AttachmentEnaSrdSpecification.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('attachmentId', stub[:attachment_id].to_s) unless stub[:attachment_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml << Hearth::XML::Node.new('deviceIndex', stub[:device_index].to_s) unless stub[:device_index].nil?
        xml << Hearth::XML::Node.new('networkCardIndex', stub[:network_card_index].to_s) unless stub[:network_card_index].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceOwnerId', stub[:instance_owner_id].to_s) unless stub[:instance_owner_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << AttachmentEnaSrdSpecification.stub('enaSrdSpecification', stub[:ena_srd_specification]) unless stub[:ena_srd_specification].nil?
        xml
      end
    end

    class NetworkInterfaceCount
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfaceCount')
        visited = visited + ['NetworkInterfaceCount']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    class NetworkInterfaceIdSet
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfaceIdSet')
        visited = visited + ['NetworkInterfaceIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class NetworkInterfaceIpv6Address
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfaceIpv6Address')
        visited = visited + ['NetworkInterfaceIpv6Address']
        {
          ipv6_address: 'ipv6_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ipv6Address', stub[:ipv6_address].to_s) unless stub[:ipv6_address].nil?
        xml
      end
    end

    class NetworkInterfaceIpv6AddressesList
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfaceIpv6AddressesList')
        visited = visited + ['NetworkInterfaceIpv6AddressesList']
        [
          NetworkInterfaceIpv6Address.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInterfaceIpv6Address.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkInterfaceList
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfaceList')
        visited = visited + ['NetworkInterfaceList']
        [
          NetworkInterface.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInterface.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkInterfacePermission
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfacePermission')
        visited = visited + ['NetworkInterfacePermission']
        {
          network_interface_permission_id: 'network_interface_permission_id',
          network_interface_id: 'network_interface_id',
          aws_account_id: 'aws_account_id',
          aws_service: 'aws_service',
          permission: 'permission',
          permission_state: NetworkInterfacePermissionState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInterfacePermissionId', stub[:network_interface_permission_id].to_s) unless stub[:network_interface_permission_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('awsAccountId', stub[:aws_account_id].to_s) unless stub[:aws_account_id].nil?
        xml << Hearth::XML::Node.new('awsService', stub[:aws_service].to_s) unless stub[:aws_service].nil?
        xml << Hearth::XML::Node.new('permission', stub[:permission].to_s) unless stub[:permission].nil?
        xml << NetworkInterfacePermissionState.stub('permissionState', stub[:permission_state]) unless stub[:permission_state].nil?
        xml
      end
    end

    class NetworkInterfacePermissionList
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfacePermissionList')
        visited = visited + ['NetworkInterfacePermissionList']
        [
          NetworkInterfacePermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInterfacePermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NetworkInterfacePermissionState
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfacePermissionState')
        visited = visited + ['NetworkInterfacePermissionState']
        {
          state: 'state',
          status_message: 'status_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml
      end
    end

    class NetworkInterfacePrivateIpAddress
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfacePrivateIpAddress')
        visited = visited + ['NetworkInterfacePrivateIpAddress']
        {
          association: NetworkInterfaceAssociation.default(visited),
          primary: false,
          private_dns_name: 'private_dns_name',
          private_ip_address: 'private_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << NetworkInterfaceAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << Hearth::XML::Node.new('primary', stub[:primary].to_s) unless stub[:primary].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml
      end
    end

    class NetworkInterfacePrivateIpAddressList
      def self.default(visited = [])
        return nil if visited.include?('NetworkInterfacePrivateIpAddressList')
        visited = visited + ['NetworkInterfacePrivateIpAddressList']
        [
          NetworkInterfacePrivateIpAddress.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << NetworkInterfacePrivateIpAddress.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class NitroTpmInfo
      def self.default(visited = [])
        return nil if visited.include?('NitroTpmInfo')
        visited = visited + ['NitroTpmInfo']
        {
          supported_versions: NitroTpmSupportedVersionsList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('supportedVersions', NitroTpmSupportedVersionsList.stub('item', stub[:supported_versions])) unless stub[:supported_versions].nil?
        xml
      end
    end

    class NitroTpmSupportedVersionsList
      def self.default(visited = [])
        return nil if visited.include?('NitroTpmSupportedVersionsList')
        visited = visited + ['NitroTpmSupportedVersionsList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class OccurrenceDaySet
      def self.default(visited = [])
        return nil if visited.include?('OccurrenceDaySet')
        visited = visited + ['OccurrenceDaySet']
        [
          1
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class OidcOptions
      def self.default(visited = [])
        return nil if visited.include?('OidcOptions')
        visited = visited + ['OidcOptions']
        {
          issuer: 'issuer',
          authorization_endpoint: 'authorization_endpoint',
          token_endpoint: 'token_endpoint',
          user_info_endpoint: 'user_info_endpoint',
          client_id: 'client_id',
          client_secret: 'client_secret',
          scope: 'scope',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('issuer', stub[:issuer].to_s) unless stub[:issuer].nil?
        xml << Hearth::XML::Node.new('authorizationEndpoint', stub[:authorization_endpoint].to_s) unless stub[:authorization_endpoint].nil?
        xml << Hearth::XML::Node.new('tokenEndpoint', stub[:token_endpoint].to_s) unless stub[:token_endpoint].nil?
        xml << Hearth::XML::Node.new('userInfoEndpoint', stub[:user_info_endpoint].to_s) unless stub[:user_info_endpoint].nil?
        xml << Hearth::XML::Node.new('clientId', stub[:client_id].to_s) unless stub[:client_id].nil?
        xml << Hearth::XML::Node.new('clientSecret', stub[:client_secret].to_s) unless stub[:client_secret].nil?
        xml << Hearth::XML::Node.new('scope', stub[:scope].to_s) unless stub[:scope].nil?
        xml
      end
    end

    class OnDemandOptions
      def self.default(visited = [])
        return nil if visited.include?('OnDemandOptions')
        visited = visited + ['OnDemandOptions']
        {
          allocation_strategy: 'allocation_strategy',
          capacity_reservation_options: CapacityReservationOptions.default(visited),
          single_instance_type: false,
          single_availability_zone: false,
          min_target_capacity: 1,
          max_total_price: 'max_total_price',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << CapacityReservationOptions.stub('capacityReservationOptions', stub[:capacity_reservation_options]) unless stub[:capacity_reservation_options].nil?
        xml << Hearth::XML::Node.new('singleInstanceType', stub[:single_instance_type].to_s) unless stub[:single_instance_type].nil?
        xml << Hearth::XML::Node.new('singleAvailabilityZone', stub[:single_availability_zone].to_s) unless stub[:single_availability_zone].nil?
        xml << Hearth::XML::Node.new('minTargetCapacity', stub[:min_target_capacity].to_s) unless stub[:min_target_capacity].nil?
        xml << Hearth::XML::Node.new('maxTotalPrice', stub[:max_total_price].to_s) unless stub[:max_total_price].nil?
        xml
      end
    end

    class PacketHeaderStatement
      def self.default(visited = [])
        return nil if visited.include?('PacketHeaderStatement')
        visited = visited + ['PacketHeaderStatement']
        {
          source_addresses: ValueStringList.default(visited),
          destination_addresses: ValueStringList.default(visited),
          source_ports: ValueStringList.default(visited),
          destination_ports: ValueStringList.default(visited),
          source_prefix_lists: ValueStringList.default(visited),
          destination_prefix_lists: ValueStringList.default(visited),
          protocols: ProtocolList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sourceAddressSet', ValueStringList.stub('item', stub[:source_addresses])) unless stub[:source_addresses].nil?
        xml << Hearth::XML::Node.new('destinationAddressSet', ValueStringList.stub('item', stub[:destination_addresses])) unless stub[:destination_addresses].nil?
        xml << Hearth::XML::Node.new('sourcePortSet', ValueStringList.stub('item', stub[:source_ports])) unless stub[:source_ports].nil?
        xml << Hearth::XML::Node.new('destinationPortSet', ValueStringList.stub('item', stub[:destination_ports])) unless stub[:destination_ports].nil?
        xml << Hearth::XML::Node.new('sourcePrefixListSet', ValueStringList.stub('item', stub[:source_prefix_lists])) unless stub[:source_prefix_lists].nil?
        xml << Hearth::XML::Node.new('destinationPrefixListSet', ValueStringList.stub('item', stub[:destination_prefix_lists])) unless stub[:destination_prefix_lists].nil?
        xml << Hearth::XML::Node.new('protocolSet', ProtocolList.stub('item', stub[:protocols])) unless stub[:protocols].nil?
        xml
      end
    end

    class PathComponent
      def self.default(visited = [])
        return nil if visited.include?('PathComponent')
        visited = visited + ['PathComponent']
        {
          sequence_number: 1,
          acl_rule: AnalysisAclRule.default(visited),
          attached_to: AnalysisComponent.default(visited),
          component: AnalysisComponent.default(visited),
          destination_vpc: AnalysisComponent.default(visited),
          outbound_header: AnalysisPacketHeader.default(visited),
          inbound_header: AnalysisPacketHeader.default(visited),
          route_table_route: AnalysisRouteTableRoute.default(visited),
          security_group_rule: AnalysisSecurityGroupRule.default(visited),
          source_vpc: AnalysisComponent.default(visited),
          subnet: AnalysisComponent.default(visited),
          vpc: AnalysisComponent.default(visited),
          additional_details: AdditionalDetailList.default(visited),
          transit_gateway: AnalysisComponent.default(visited),
          transit_gateway_route_table_route: TransitGatewayRouteTableRoute.default(visited),
          explanations: ExplanationList.default(visited),
          elastic_load_balancer_listener: AnalysisComponent.default(visited),
          firewall_stateless_rule: FirewallStatelessRule.default(visited),
          firewall_stateful_rule: FirewallStatefulRule.default(visited),
          service_name: 'service_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sequenceNumber', stub[:sequence_number].to_s) unless stub[:sequence_number].nil?
        xml << AnalysisAclRule.stub('aclRule', stub[:acl_rule]) unless stub[:acl_rule].nil?
        xml << AnalysisComponent.stub('attachedTo', stub[:attached_to]) unless stub[:attached_to].nil?
        xml << AnalysisComponent.stub('component', stub[:component]) unless stub[:component].nil?
        xml << AnalysisComponent.stub('destinationVpc', stub[:destination_vpc]) unless stub[:destination_vpc].nil?
        xml << AnalysisPacketHeader.stub('outboundHeader', stub[:outbound_header]) unless stub[:outbound_header].nil?
        xml << AnalysisPacketHeader.stub('inboundHeader', stub[:inbound_header]) unless stub[:inbound_header].nil?
        xml << AnalysisRouteTableRoute.stub('routeTableRoute', stub[:route_table_route]) unless stub[:route_table_route].nil?
        xml << AnalysisSecurityGroupRule.stub('securityGroupRule', stub[:security_group_rule]) unless stub[:security_group_rule].nil?
        xml << AnalysisComponent.stub('sourceVpc', stub[:source_vpc]) unless stub[:source_vpc].nil?
        xml << AnalysisComponent.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        xml << AnalysisComponent.stub('vpc', stub[:vpc]) unless stub[:vpc].nil?
        xml << Hearth::XML::Node.new('additionalDetailSet', AdditionalDetailList.stub('item', stub[:additional_details])) unless stub[:additional_details].nil?
        xml << AnalysisComponent.stub('transitGateway', stub[:transit_gateway]) unless stub[:transit_gateway].nil?
        xml << TransitGatewayRouteTableRoute.stub('transitGatewayRouteTableRoute', stub[:transit_gateway_route_table_route]) unless stub[:transit_gateway_route_table_route].nil?
        xml << Hearth::XML::Node.new('explanationSet', ExplanationList.stub('item', stub[:explanations])) unless stub[:explanations].nil?
        xml << AnalysisComponent.stub('elasticLoadBalancerListener', stub[:elastic_load_balancer_listener]) unless stub[:elastic_load_balancer_listener].nil?
        xml << FirewallStatelessRule.stub('firewallStatelessRule', stub[:firewall_stateless_rule]) unless stub[:firewall_stateless_rule].nil?
        xml << FirewallStatefulRule.stub('firewallStatefulRule', stub[:firewall_stateful_rule]) unless stub[:firewall_stateful_rule].nil?
        xml << Hearth::XML::Node.new('serviceName', stub[:service_name].to_s) unless stub[:service_name].nil?
        xml
      end
    end

    class PathComponentList
      def self.default(visited = [])
        return nil if visited.include?('PathComponentList')
        visited = visited + ['PathComponentList']
        [
          PathComponent.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PathComponent.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PathFilter
      def self.default(visited = [])
        return nil if visited.include?('PathFilter')
        visited = visited + ['PathFilter']
        {
          source_address: 'source_address',
          source_port_range: FilterPortRange.default(visited),
          destination_address: 'destination_address',
          destination_port_range: FilterPortRange.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sourceAddress', stub[:source_address].to_s) unless stub[:source_address].nil?
        xml << FilterPortRange.stub('sourcePortRange', stub[:source_port_range]) unless stub[:source_port_range].nil?
        xml << Hearth::XML::Node.new('destinationAddress', stub[:destination_address].to_s) unless stub[:destination_address].nil?
        xml << FilterPortRange.stub('destinationPortRange', stub[:destination_port_range]) unless stub[:destination_port_range].nil?
        xml
      end
    end

    class PathStatement
      def self.default(visited = [])
        return nil if visited.include?('PathStatement')
        visited = visited + ['PathStatement']
        {
          packet_header_statement: PacketHeaderStatement.default(visited),
          resource_statement: ResourceStatement.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << PacketHeaderStatement.stub('packetHeaderStatement', stub[:packet_header_statement]) unless stub[:packet_header_statement].nil?
        xml << ResourceStatement.stub('resourceStatement', stub[:resource_statement]) unless stub[:resource_statement].nil?
        xml
      end
    end

    class PciId
      def self.default(visited = [])
        return nil if visited.include?('PciId')
        visited = visited + ['PciId']
        {
          device_id: 'device_id',
          vendor_id: 'vendor_id',
          subsystem_id: 'subsystem_id',
          subsystem_vendor_id: 'subsystem_vendor_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('DeviceId', stub[:device_id].to_s) unless stub[:device_id].nil?
        xml << Hearth::XML::Node.new('VendorId', stub[:vendor_id].to_s) unless stub[:vendor_id].nil?
        xml << Hearth::XML::Node.new('SubsystemId', stub[:subsystem_id].to_s) unless stub[:subsystem_id].nil?
        xml << Hearth::XML::Node.new('SubsystemVendorId', stub[:subsystem_vendor_id].to_s) unless stub[:subsystem_vendor_id].nil?
        xml
      end
    end

    class PeeringAttachmentStatus
      def self.default(visited = [])
        return nil if visited.include?('PeeringAttachmentStatus')
        visited = visited + ['PeeringAttachmentStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class PeeringConnectionOptions
      def self.default(visited = [])
        return nil if visited.include?('PeeringConnectionOptions')
        visited = visited + ['PeeringConnectionOptions']
        {
          allow_dns_resolution_from_remote_vpc: false,
          allow_egress_from_local_classic_link_to_remote_vpc: false,
          allow_egress_from_local_vpc_to_remote_classic_link: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allowDnsResolutionFromRemoteVpc', stub[:allow_dns_resolution_from_remote_vpc].to_s) unless stub[:allow_dns_resolution_from_remote_vpc].nil?
        xml << Hearth::XML::Node.new('allowEgressFromLocalClassicLinkToRemoteVpc', stub[:allow_egress_from_local_classic_link_to_remote_vpc].to_s) unless stub[:allow_egress_from_local_classic_link_to_remote_vpc].nil?
        xml << Hearth::XML::Node.new('allowEgressFromLocalVpcToRemoteClassicLink', stub[:allow_egress_from_local_vpc_to_remote_classic_link].to_s) unless stub[:allow_egress_from_local_vpc_to_remote_classic_link].nil?
        xml
      end
    end

    class PeeringTgwInfo
      def self.default(visited = [])
        return nil if visited.include?('PeeringTgwInfo')
        visited = visited + ['PeeringTgwInfo']
        {
          transit_gateway_id: 'transit_gateway_id',
          core_network_id: 'core_network_id',
          owner_id: 'owner_id',
          region: 'region',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('coreNetworkId', stub[:core_network_id].to_s) unless stub[:core_network_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('region', stub[:region].to_s) unless stub[:region].nil?
        xml
      end
    end

    class Phase1DHGroupNumbersList
      def self.default(visited = [])
        return nil if visited.include?('Phase1DHGroupNumbersList')
        visited = visited + ['Phase1DHGroupNumbersList']
        [
          Phase1DHGroupNumbersListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase1DHGroupNumbersListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Phase1DHGroupNumbersListValue
      def self.default(visited = [])
        return nil if visited.include?('Phase1DHGroupNumbersListValue')
        visited = visited + ['Phase1DHGroupNumbersListValue']
        {
          value: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class Phase1EncryptionAlgorithmsList
      def self.default(visited = [])
        return nil if visited.include?('Phase1EncryptionAlgorithmsList')
        visited = visited + ['Phase1EncryptionAlgorithmsList']
        [
          Phase1EncryptionAlgorithmsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase1EncryptionAlgorithmsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Phase1EncryptionAlgorithmsListValue
      def self.default(visited = [])
        return nil if visited.include?('Phase1EncryptionAlgorithmsListValue')
        visited = visited + ['Phase1EncryptionAlgorithmsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class Phase1IntegrityAlgorithmsList
      def self.default(visited = [])
        return nil if visited.include?('Phase1IntegrityAlgorithmsList')
        visited = visited + ['Phase1IntegrityAlgorithmsList']
        [
          Phase1IntegrityAlgorithmsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase1IntegrityAlgorithmsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Phase1IntegrityAlgorithmsListValue
      def self.default(visited = [])
        return nil if visited.include?('Phase1IntegrityAlgorithmsListValue')
        visited = visited + ['Phase1IntegrityAlgorithmsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class Phase2DHGroupNumbersList
      def self.default(visited = [])
        return nil if visited.include?('Phase2DHGroupNumbersList')
        visited = visited + ['Phase2DHGroupNumbersList']
        [
          Phase2DHGroupNumbersListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase2DHGroupNumbersListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Phase2DHGroupNumbersListValue
      def self.default(visited = [])
        return nil if visited.include?('Phase2DHGroupNumbersListValue')
        visited = visited + ['Phase2DHGroupNumbersListValue']
        {
          value: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class Phase2EncryptionAlgorithmsList
      def self.default(visited = [])
        return nil if visited.include?('Phase2EncryptionAlgorithmsList')
        visited = visited + ['Phase2EncryptionAlgorithmsList']
        [
          Phase2EncryptionAlgorithmsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase2EncryptionAlgorithmsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Phase2EncryptionAlgorithmsListValue
      def self.default(visited = [])
        return nil if visited.include?('Phase2EncryptionAlgorithmsListValue')
        visited = visited + ['Phase2EncryptionAlgorithmsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class Phase2IntegrityAlgorithmsList
      def self.default(visited = [])
        return nil if visited.include?('Phase2IntegrityAlgorithmsList')
        visited = visited + ['Phase2IntegrityAlgorithmsList']
        [
          Phase2IntegrityAlgorithmsListValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Phase2IntegrityAlgorithmsListValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Phase2IntegrityAlgorithmsListValue
      def self.default(visited = [])
        return nil if visited.include?('Phase2IntegrityAlgorithmsListValue')
        visited = visited + ['Phase2IntegrityAlgorithmsListValue']
        {
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class Placement
      def self.default(visited = [])
        return nil if visited.include?('Placement')
        visited = visited + ['Placement']
        {
          availability_zone: 'availability_zone',
          affinity: 'affinity',
          group_name: 'group_name',
          partition_number: 1,
          host_id: 'host_id',
          tenancy: 'tenancy',
          spread_domain: 'spread_domain',
          host_resource_group_arn: 'host_resource_group_arn',
          group_id: 'group_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('affinity', stub[:affinity].to_s) unless stub[:affinity].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('partitionNumber', stub[:partition_number].to_s) unless stub[:partition_number].nil?
        xml << Hearth::XML::Node.new('hostId', stub[:host_id].to_s) unless stub[:host_id].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml << Hearth::XML::Node.new('spreadDomain', stub[:spread_domain].to_s) unless stub[:spread_domain].nil?
        xml << Hearth::XML::Node.new('hostResourceGroupArn', stub[:host_resource_group_arn].to_s) unless stub[:host_resource_group_arn].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml
      end
    end

    class PlacementGroup
      def self.default(visited = [])
        return nil if visited.include?('PlacementGroup')
        visited = visited + ['PlacementGroup']
        {
          group_name: 'group_name',
          state: 'state',
          strategy: 'strategy',
          partition_count: 1,
          group_id: 'group_id',
          tags: TagList.default(visited),
          group_arn: 'group_arn',
          spread_level: 'spread_level',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('strategy', stub[:strategy].to_s) unless stub[:strategy].nil?
        xml << Hearth::XML::Node.new('partitionCount', stub[:partition_count].to_s) unless stub[:partition_count].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('groupArn', stub[:group_arn].to_s) unless stub[:group_arn].nil?
        xml << Hearth::XML::Node.new('spreadLevel', stub[:spread_level].to_s) unless stub[:spread_level].nil?
        xml
      end
    end

    class PlacementGroupInfo
      def self.default(visited = [])
        return nil if visited.include?('PlacementGroupInfo')
        visited = visited + ['PlacementGroupInfo']
        {
          supported_strategies: PlacementGroupStrategyList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('supportedStrategies', PlacementGroupStrategyList.stub('item', stub[:supported_strategies])) unless stub[:supported_strategies].nil?
        xml
      end
    end

    class PlacementGroupList
      def self.default(visited = [])
        return nil if visited.include?('PlacementGroupList')
        visited = visited + ['PlacementGroupList']
        [
          PlacementGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PlacementGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PlacementGroupStrategyList
      def self.default(visited = [])
        return nil if visited.include?('PlacementGroupStrategyList')
        visited = visited + ['PlacementGroupStrategyList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class PlacementResponse
      def self.default(visited = [])
        return nil if visited.include?('PlacementResponse')
        visited = visited + ['PlacementResponse']
        {
          group_name: 'group_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml
      end
    end

    class PoolCidrBlock
      def self.default(visited = [])
        return nil if visited.include?('PoolCidrBlock')
        visited = visited + ['PoolCidrBlock']
        {
          cidr: 'cidr',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('poolCidrBlock', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml
      end
    end

    class PoolCidrBlocksSet
      def self.default(visited = [])
        return nil if visited.include?('PoolCidrBlocksSet')
        visited = visited + ['PoolCidrBlocksSet']
        [
          PoolCidrBlock.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PoolCidrBlock.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PortRange
      def self.default(visited = [])
        return nil if visited.include?('PortRange')
        visited = visited + ['PortRange']
        {
          from: 1,
          to: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('from', stub[:from].to_s) unless stub[:from].nil?
        xml << Hearth::XML::Node.new('to', stub[:to].to_s) unless stub[:to].nil?
        xml
      end
    end

    class PortRangeList
      def self.default(visited = [])
        return nil if visited.include?('PortRangeList')
        visited = visited + ['PortRangeList']
        [
          PortRange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PortRange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PrefixList
      def self.default(visited = [])
        return nil if visited.include?('PrefixList')
        visited = visited + ['PrefixList']
        {
          cidrs: ValueStringList.default(visited),
          prefix_list_id: 'prefix_list_id',
          prefix_list_name: 'prefix_list_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrSet', ValueStringList.stub('item', stub[:cidrs])) unless stub[:cidrs].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('prefixListName', stub[:prefix_list_name].to_s) unless stub[:prefix_list_name].nil?
        xml
      end
    end

    class PrefixListAssociation
      def self.default(visited = [])
        return nil if visited.include?('PrefixListAssociation')
        visited = visited + ['PrefixListAssociation']
        {
          resource_id: 'resource_id',
          resource_owner: 'resource_owner',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceOwner', stub[:resource_owner].to_s) unless stub[:resource_owner].nil?
        xml
      end
    end

    class PrefixListAssociationSet
      def self.default(visited = [])
        return nil if visited.include?('PrefixListAssociationSet')
        visited = visited + ['PrefixListAssociationSet']
        [
          PrefixListAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrefixListAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PrefixListEntry
      def self.default(visited = [])
        return nil if visited.include?('PrefixListEntry')
        visited = visited + ['PrefixListEntry']
        {
          cidr: 'cidr',
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    class PrefixListEntrySet
      def self.default(visited = [])
        return nil if visited.include?('PrefixListEntrySet')
        visited = visited + ['PrefixListEntrySet']
        [
          PrefixListEntry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrefixListEntry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PrefixListId
      def self.default(visited = [])
        return nil if visited.include?('PrefixListId')
        visited = visited + ['PrefixListId']
        {
          description: 'description',
          prefix_list_id: 'prefix_list_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml
      end
    end

    class PrefixListIdList
      def self.default(visited = [])
        return nil if visited.include?('PrefixListIdList')
        visited = visited + ['PrefixListIdList']
        [
          PrefixListId.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrefixListId.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PrefixListIdSet
      def self.default(visited = [])
        return nil if visited.include?('PrefixListIdSet')
        visited = visited + ['PrefixListIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class PrefixListSet
      def self.default(visited = [])
        return nil if visited.include?('PrefixListSet')
        visited = visited + ['PrefixListSet']
        [
          PrefixList.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrefixList.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PriceSchedule
      def self.default(visited = [])
        return nil if visited.include?('PriceSchedule')
        visited = visited + ['PriceSchedule']
        {
          active: false,
          currency_code: 'currency_code',
          price: 1.0,
          term: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('active', stub[:active].to_s) unless stub[:active].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('price', Hearth::NumberHelper.serialize(stub[:price]).to_s) unless stub[:price].nil?
        xml << Hearth::XML::Node.new('term', stub[:term].to_s) unless stub[:term].nil?
        xml
      end
    end

    class PriceScheduleList
      def self.default(visited = [])
        return nil if visited.include?('PriceScheduleList')
        visited = visited + ['PriceScheduleList']
        [
          PriceSchedule.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PriceSchedule.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PricingDetail
      def self.default(visited = [])
        return nil if visited.include?('PricingDetail')
        visited = visited + ['PricingDetail']
        {
          count: 1,
          price: 1.0,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('count', stub[:count].to_s) unless stub[:count].nil?
        xml << Hearth::XML::Node.new('price', Hearth::NumberHelper.serialize(stub[:price]).to_s) unless stub[:price].nil?
        xml
      end
    end

    class PricingDetailsList
      def self.default(visited = [])
        return nil if visited.include?('PricingDetailsList')
        visited = visited + ['PricingDetailsList']
        [
          PricingDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PricingDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PrincipalIdFormat
      def self.default(visited = [])
        return nil if visited.include?('PrincipalIdFormat')
        visited = visited + ['PrincipalIdFormat']
        {
          arn: 'arn',
          statuses: IdFormatList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml << Hearth::XML::Node.new('statusSet', IdFormatList.stub('item', stub[:statuses])) unless stub[:statuses].nil?
        xml
      end
    end

    class PrincipalIdFormatList
      def self.default(visited = [])
        return nil if visited.include?('PrincipalIdFormatList')
        visited = visited + ['PrincipalIdFormatList']
        [
          PrincipalIdFormat.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrincipalIdFormat.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PrivateDnsDetails
      def self.default(visited = [])
        return nil if visited.include?('PrivateDnsDetails')
        visited = visited + ['PrivateDnsDetails']
        {
          private_dns_name: 'private_dns_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml
      end
    end

    class PrivateDnsDetailsSet
      def self.default(visited = [])
        return nil if visited.include?('PrivateDnsDetailsSet')
        visited = visited + ['PrivateDnsDetailsSet']
        [
          PrivateDnsDetails.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrivateDnsDetails.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PrivateDnsNameConfiguration
      def self.default(visited = [])
        return nil if visited.include?('PrivateDnsNameConfiguration')
        visited = visited + ['PrivateDnsNameConfiguration']
        {
          state: 'state',
          type: 'type',
          value: 'value',
          name: 'name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml
      end
    end

    class PrivateDnsNameOptionsOnLaunch
      def self.default(visited = [])
        return nil if visited.include?('PrivateDnsNameOptionsOnLaunch')
        visited = visited + ['PrivateDnsNameOptionsOnLaunch']
        {
          hostname_type: 'hostname_type',
          enable_resource_name_dns_a_record: false,
          enable_resource_name_dns_aaaa_record: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('hostnameType', stub[:hostname_type].to_s) unless stub[:hostname_type].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsARecord', stub[:enable_resource_name_dns_a_record].to_s) unless stub[:enable_resource_name_dns_a_record].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsAAAARecord', stub[:enable_resource_name_dns_aaaa_record].to_s) unless stub[:enable_resource_name_dns_aaaa_record].nil?
        xml
      end
    end

    class PrivateDnsNameOptionsResponse
      def self.default(visited = [])
        return nil if visited.include?('PrivateDnsNameOptionsResponse')
        visited = visited + ['PrivateDnsNameOptionsResponse']
        {
          hostname_type: 'hostname_type',
          enable_resource_name_dns_a_record: false,
          enable_resource_name_dns_aaaa_record: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('hostnameType', stub[:hostname_type].to_s) unless stub[:hostname_type].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsARecord', stub[:enable_resource_name_dns_a_record].to_s) unless stub[:enable_resource_name_dns_a_record].nil?
        xml << Hearth::XML::Node.new('enableResourceNameDnsAAAARecord', stub[:enable_resource_name_dns_aaaa_record].to_s) unless stub[:enable_resource_name_dns_aaaa_record].nil?
        xml
      end
    end

    class PrivateIpAddressSpecification
      def self.default(visited = [])
        return nil if visited.include?('PrivateIpAddressSpecification')
        visited = visited + ['PrivateIpAddressSpecification']
        {
          primary: false,
          private_ip_address: 'private_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('primary', stub[:primary].to_s) unless stub[:primary].nil?
        xml << Hearth::XML::Node.new('privateIpAddress', stub[:private_ip_address].to_s) unless stub[:private_ip_address].nil?
        xml
      end
    end

    class PrivateIpAddressSpecificationList
      def self.default(visited = [])
        return nil if visited.include?('PrivateIpAddressSpecificationList')
        visited = visited + ['PrivateIpAddressSpecificationList']
        [
          PrivateIpAddressSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PrivateIpAddressSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ProcessorInfo
      def self.default(visited = [])
        return nil if visited.include?('ProcessorInfo')
        visited = visited + ['ProcessorInfo']
        {
          supported_architectures: ArchitectureTypeList.default(visited),
          sustained_clock_speed_in_ghz: 1.0,
          supported_features: SupportedAdditionalProcessorFeatureList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('supportedArchitectures', ArchitectureTypeList.stub('item', stub[:supported_architectures])) unless stub[:supported_architectures].nil?
        xml << Hearth::XML::Node.new('sustainedClockSpeedInGhz', Hearth::NumberHelper.serialize(stub[:sustained_clock_speed_in_ghz]).to_s) unless stub[:sustained_clock_speed_in_ghz].nil?
        xml << Hearth::XML::Node.new('supportedFeatures', SupportedAdditionalProcessorFeatureList.stub('item', stub[:supported_features])) unless stub[:supported_features].nil?
        xml
      end
    end

    class ProductCode
      def self.default(visited = [])
        return nil if visited.include?('ProductCode')
        visited = visited + ['ProductCode']
        {
          product_code_id: 'product_code_id',
          product_code_type: 'product_code_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('productCode', stub[:product_code_id].to_s) unless stub[:product_code_id].nil?
        xml << Hearth::XML::Node.new('type', stub[:product_code_type].to_s) unless stub[:product_code_type].nil?
        xml
      end
    end

    class ProductCodeList
      def self.default(visited = [])
        return nil if visited.include?('ProductCodeList')
        visited = visited + ['ProductCodeList']
        [
          ProductCode.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ProductCode.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PropagatingVgw
      def self.default(visited = [])
        return nil if visited.include?('PropagatingVgw')
        visited = visited + ['PropagatingVgw']
        {
          gateway_id: 'gateway_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('gatewayId', stub[:gateway_id].to_s) unless stub[:gateway_id].nil?
        xml
      end
    end

    class PropagatingVgwList
      def self.default(visited = [])
        return nil if visited.include?('PropagatingVgwList')
        visited = visited + ['PropagatingVgwList']
        [
          PropagatingVgw.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PropagatingVgw.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ProtocolIntList
      def self.default(visited = [])
        return nil if visited.include?('ProtocolIntList')
        visited = visited + ['ProtocolIntList']
        [
          1
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class ProtocolList
      def self.default(visited = [])
        return nil if visited.include?('ProtocolList')
        visited = visited + ['ProtocolList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class ProvisionByoipCidr
      def self.build(params, context:)
        Params::ProvisionByoipCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ProvisionByoipCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ProvisionByoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ProvisionIpamPoolCidr
      def self.build(params, context:)
        Params::ProvisionIpamPoolCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ProvisionIpamPoolCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          ipam_pool_cidr: IpamPoolCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ProvisionIpamPoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IpamPoolCidr.stub('ipamPoolCidr', stub[:ipam_pool_cidr]) unless stub[:ipam_pool_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ProvisionPublicIpv4PoolCidr
      def self.build(params, context:)
        Params::ProvisionPublicIpv4PoolCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ProvisionPublicIpv4PoolCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          pool_id: 'pool_id',
          pool_address_range: PublicIpv4PoolRange.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ProvisionPublicIpv4PoolCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << PublicIpv4PoolRange.stub('poolAddressRange', stub[:pool_address_range]) unless stub[:pool_address_range].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ProvisionedBandwidth
      def self.default(visited = [])
        return nil if visited.include?('ProvisionedBandwidth')
        visited = visited + ['ProvisionedBandwidth']
        {
          provision_time: Time.now,
          provisioned: 'provisioned',
          request_time: Time.now,
          requested: 'requested',
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('provisionTime', Hearth::TimeHelper.to_date_time(stub[:provision_time])) unless stub[:provision_time].nil?
        xml << Hearth::XML::Node.new('provisioned', stub[:provisioned].to_s) unless stub[:provisioned].nil?
        xml << Hearth::XML::Node.new('requestTime', Hearth::TimeHelper.to_date_time(stub[:request_time])) unless stub[:request_time].nil?
        xml << Hearth::XML::Node.new('requested', stub[:requested].to_s) unless stub[:requested].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    class PtrUpdateStatus
      def self.default(visited = [])
        return nil if visited.include?('PtrUpdateStatus')
        visited = visited + ['PtrUpdateStatus']
        {
          value: 'value',
          status: 'status',
          reason: 'reason',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('reason', stub[:reason].to_s) unless stub[:reason].nil?
        xml
      end
    end

    class PublicIpv4Pool
      def self.default(visited = [])
        return nil if visited.include?('PublicIpv4Pool')
        visited = visited + ['PublicIpv4Pool']
        {
          pool_id: 'pool_id',
          description: 'description',
          pool_address_ranges: PublicIpv4PoolRangeSet.default(visited),
          total_address_count: 1,
          total_available_address_count: 1,
          network_border_group: 'network_border_group',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('poolId', stub[:pool_id].to_s) unless stub[:pool_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('poolAddressRangeSet', PublicIpv4PoolRangeSet.stub('item', stub[:pool_address_ranges])) unless stub[:pool_address_ranges].nil?
        xml << Hearth::XML::Node.new('totalAddressCount', stub[:total_address_count].to_s) unless stub[:total_address_count].nil?
        xml << Hearth::XML::Node.new('totalAvailableAddressCount', stub[:total_available_address_count].to_s) unless stub[:total_available_address_count].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class PublicIpv4PoolRange
      def self.default(visited = [])
        return nil if visited.include?('PublicIpv4PoolRange')
        visited = visited + ['PublicIpv4PoolRange']
        {
          first_address: 'first_address',
          last_address: 'last_address',
          address_count: 1,
          available_address_count: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('firstAddress', stub[:first_address].to_s) unless stub[:first_address].nil?
        xml << Hearth::XML::Node.new('lastAddress', stub[:last_address].to_s) unless stub[:last_address].nil?
        xml << Hearth::XML::Node.new('addressCount', stub[:address_count].to_s) unless stub[:address_count].nil?
        xml << Hearth::XML::Node.new('availableAddressCount', stub[:available_address_count].to_s) unless stub[:available_address_count].nil?
        xml
      end
    end

    class PublicIpv4PoolRangeSet
      def self.default(visited = [])
        return nil if visited.include?('PublicIpv4PoolRangeSet')
        visited = visited + ['PublicIpv4PoolRangeSet']
        [
          PublicIpv4PoolRange.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PublicIpv4PoolRange.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PublicIpv4PoolSet
      def self.default(visited = [])
        return nil if visited.include?('PublicIpv4PoolSet')
        visited = visited + ['PublicIpv4PoolSet']
        [
          PublicIpv4Pool.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << PublicIpv4Pool.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Purchase
      def self.default(visited = [])
        return nil if visited.include?('Purchase')
        visited = visited + ['Purchase']
        {
          currency_code: 'currency_code',
          duration: 1,
          host_id_set: ResponseHostIdSet.default(visited),
          host_reservation_id: 'host_reservation_id',
          hourly_price: 'hourly_price',
          instance_family: 'instance_family',
          payment_option: 'payment_option',
          upfront_price: 'upfront_price',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('hostIdSet', ResponseHostIdSet.stub('item', stub[:host_id_set])) unless stub[:host_id_set].nil?
        xml << Hearth::XML::Node.new('hostReservationId', stub[:host_reservation_id].to_s) unless stub[:host_reservation_id].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceFamily', stub[:instance_family].to_s) unless stub[:instance_family].nil?
        xml << Hearth::XML::Node.new('paymentOption', stub[:payment_option].to_s) unless stub[:payment_option].nil?
        xml << Hearth::XML::Node.new('upfrontPrice', stub[:upfront_price].to_s) unless stub[:upfront_price].nil?
        xml
      end
    end

    class PurchaseHostReservation
      def self.build(params, context:)
        Params::PurchaseHostReservationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::PurchaseHostReservationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          client_token: 'client_token',
          currency_code: 'currency_code',
          purchase: PurchaseSet.default(visited),
          total_hourly_price: 'total_hourly_price',
          total_upfront_price: 'total_upfront_price',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('PurchaseHostReservationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('purchase', PurchaseSet.stub('item', stub[:purchase])) unless stub[:purchase].nil?
        xml << Hearth::XML::Node.new('totalHourlyPrice', stub[:total_hourly_price].to_s) unless stub[:total_hourly_price].nil?
        xml << Hearth::XML::Node.new('totalUpfrontPrice', stub[:total_upfront_price].to_s) unless stub[:total_upfront_price].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class PurchaseReservedInstancesOffering
      def self.build(params, context:)
        Params::PurchaseReservedInstancesOfferingOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::PurchaseReservedInstancesOfferingOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          reserved_instances_id: 'reserved_instances_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('PurchaseReservedInstancesOfferingResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class PurchaseScheduledInstances
      def self.build(params, context:)
        Params::PurchaseScheduledInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::PurchaseScheduledInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          scheduled_instance_set: PurchasedScheduledInstanceSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('PurchaseScheduledInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('scheduledInstanceSet', PurchasedScheduledInstanceSet.stub('item', stub[:scheduled_instance_set])) unless stub[:scheduled_instance_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class PurchaseSet
      def self.default(visited = [])
        return nil if visited.include?('PurchaseSet')
        visited = visited + ['PurchaseSet']
        [
          Purchase.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Purchase.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class PurchasedScheduledInstanceSet
      def self.default(visited = [])
        return nil if visited.include?('PurchasedScheduledInstanceSet')
        visited = visited + ['PurchasedScheduledInstanceSet']
        [
          ScheduledInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ScheduledInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class RebootInstances
      def self.build(params, context:)
        Params::RebootInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RebootInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RebootInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RecurringCharge
      def self.default(visited = [])
        return nil if visited.include?('RecurringCharge')
        visited = visited + ['RecurringCharge']
        {
          amount: 1.0,
          frequency: 'frequency',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('amount', Hearth::NumberHelper.serialize(stub[:amount]).to_s) unless stub[:amount].nil?
        xml << Hearth::XML::Node.new('frequency', stub[:frequency].to_s) unless stub[:frequency].nil?
        xml
      end
    end

    class RecurringChargesList
      def self.default(visited = [])
        return nil if visited.include?('RecurringChargesList')
        visited = visited + ['RecurringChargesList']
        [
          RecurringCharge.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << RecurringCharge.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ReferencedSecurityGroup
      def self.default(visited = [])
        return nil if visited.include?('ReferencedSecurityGroup')
        visited = visited + ['ReferencedSecurityGroup']
        {
          group_id: 'group_id',
          peering_status: 'peering_status',
          user_id: 'user_id',
          vpc_id: 'vpc_id',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('peeringStatus', stub[:peering_status].to_s) unless stub[:peering_status].nil?
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml
      end
    end

    class Region
      def self.default(visited = [])
        return nil if visited.include?('Region')
        visited = visited + ['Region']
        {
          endpoint: 'endpoint',
          region_name: 'region_name',
          opt_in_status: 'opt_in_status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('regionEndpoint', stub[:endpoint].to_s) unless stub[:endpoint].nil?
        xml << Hearth::XML::Node.new('regionName', stub[:region_name].to_s) unless stub[:region_name].nil?
        xml << Hearth::XML::Node.new('optInStatus', stub[:opt_in_status].to_s) unless stub[:opt_in_status].nil?
        xml
      end
    end

    class RegionList
      def self.default(visited = [])
        return nil if visited.include?('RegionList')
        visited = visited + ['RegionList']
        [
          Region.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Region.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class RegisterImage
      def self.build(params, context:)
        Params::RegisterImageOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RegisterImageOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          image_id: 'image_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RegisterImageResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RegisterInstanceEventNotificationAttributes
      def self.build(params, context:)
        Params::RegisterInstanceEventNotificationAttributesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RegisterInstanceEventNotificationAttributesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_tag_attribute: InstanceTagNotificationAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RegisterInstanceEventNotificationAttributesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << InstanceTagNotificationAttribute.stub('instanceTagAttribute', stub[:instance_tag_attribute]) unless stub[:instance_tag_attribute].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RegisterTransitGatewayMulticastGroupMembers
      def self.build(params, context:)
        Params::RegisterTransitGatewayMulticastGroupMembersOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RegisterTransitGatewayMulticastGroupMembersOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          registered_multicast_group_members: TransitGatewayMulticastRegisteredGroupMembers.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RegisterTransitGatewayMulticastGroupMembersResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastRegisteredGroupMembers.stub('registeredMulticastGroupMembers', stub[:registered_multicast_group_members]) unless stub[:registered_multicast_group_members].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RegisterTransitGatewayMulticastGroupSources
      def self.build(params, context:)
        Params::RegisterTransitGatewayMulticastGroupSourcesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RegisterTransitGatewayMulticastGroupSourcesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          registered_multicast_group_sources: TransitGatewayMulticastRegisteredGroupSources.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RegisterTransitGatewayMulticastGroupSourcesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastRegisteredGroupSources.stub('registeredMulticastGroupSources', stub[:registered_multicast_group_sources]) unless stub[:registered_multicast_group_sources].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RejectTransitGatewayMulticastDomainAssociations
      def self.build(params, context:)
        Params::RejectTransitGatewayMulticastDomainAssociationsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RejectTransitGatewayMulticastDomainAssociationsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          associations: TransitGatewayMulticastDomainAssociations.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectTransitGatewayMulticastDomainAssociationsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayMulticastDomainAssociations.stub('associations', stub[:associations]) unless stub[:associations].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RejectTransitGatewayPeeringAttachment
      def self.build(params, context:)
        Params::RejectTransitGatewayPeeringAttachmentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RejectTransitGatewayPeeringAttachmentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_peering_attachment: TransitGatewayPeeringAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectTransitGatewayPeeringAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayPeeringAttachment.stub('transitGatewayPeeringAttachment', stub[:transit_gateway_peering_attachment]) unless stub[:transit_gateway_peering_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RejectTransitGatewayVpcAttachment
      def self.build(params, context:)
        Params::RejectTransitGatewayVpcAttachmentOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RejectTransitGatewayVpcAttachmentOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectTransitGatewayVpcAttachmentResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayVpcAttachment.stub('transitGatewayVpcAttachment', stub[:transit_gateway_vpc_attachment]) unless stub[:transit_gateway_vpc_attachment].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RejectVpcEndpointConnections
      def self.build(params, context:)
        Params::RejectVpcEndpointConnectionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RejectVpcEndpointConnectionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          unsuccessful: UnsuccessfulItemSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectVpcEndpointConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemSet.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RejectVpcPeeringConnection
      def self.build(params, context:)
        Params::RejectVpcPeeringConnectionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RejectVpcPeeringConnectionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RejectVpcPeeringConnectionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReleaseAddress
      def self.build(params, context:)
        Params::ReleaseAddressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReleaseAddressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReleaseAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReleaseHosts
      def self.build(params, context:)
        Params::ReleaseHostsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReleaseHostsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          successful: ResponseHostIdList.default(visited),
          unsuccessful: UnsuccessfulItemList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReleaseHostsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('successful', ResponseHostIdList.stub('item', stub[:successful])) unless stub[:successful].nil?
        xml << Hearth::XML::Node.new('unsuccessful', UnsuccessfulItemList.stub('item', stub[:unsuccessful])) unless stub[:unsuccessful].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReleaseIpamPoolAllocation
      def self.build(params, context:)
        Params::ReleaseIpamPoolAllocationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReleaseIpamPoolAllocationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          success: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReleaseIpamPoolAllocationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('success', stub[:success].to_s) unless stub[:success].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReplaceIamInstanceProfileAssociation
      def self.build(params, context:)
        Params::ReplaceIamInstanceProfileAssociationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReplaceIamInstanceProfileAssociationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          iam_instance_profile_association: IamInstanceProfileAssociation.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceIamInstanceProfileAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << IamInstanceProfileAssociation.stub('iamInstanceProfileAssociation', stub[:iam_instance_profile_association]) unless stub[:iam_instance_profile_association].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReplaceNetworkAclAssociation
      def self.build(params, context:)
        Params::ReplaceNetworkAclAssociationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReplaceNetworkAclAssociationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          new_association_id: 'new_association_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceNetworkAclAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('newAssociationId', stub[:new_association_id].to_s) unless stub[:new_association_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReplaceNetworkAclEntry
      def self.build(params, context:)
        Params::ReplaceNetworkAclEntryOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReplaceNetworkAclEntryOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceNetworkAclEntryResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReplaceRootVolumeTask
      def self.default(visited = [])
        return nil if visited.include?('ReplaceRootVolumeTask')
        visited = visited + ['ReplaceRootVolumeTask']
        {
          replace_root_volume_task_id: 'replace_root_volume_task_id',
          instance_id: 'instance_id',
          task_state: 'task_state',
          start_time: 'start_time',
          complete_time: 'complete_time',
          tags: TagList.default(visited),
          image_id: 'image_id',
          snapshot_id: 'snapshot_id',
          delete_replaced_root_volume: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('replaceRootVolumeTaskId', stub[:replace_root_volume_task_id].to_s) unless stub[:replace_root_volume_task_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('taskState', stub[:task_state].to_s) unless stub[:task_state].nil?
        xml << Hearth::XML::Node.new('startTime', stub[:start_time].to_s) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('completeTime', stub[:complete_time].to_s) unless stub[:complete_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('deleteReplacedRootVolume', stub[:delete_replaced_root_volume].to_s) unless stub[:delete_replaced_root_volume].nil?
        xml
      end
    end

    class ReplaceRootVolumeTasks
      def self.default(visited = [])
        return nil if visited.include?('ReplaceRootVolumeTasks')
        visited = visited + ['ReplaceRootVolumeTasks']
        [
          ReplaceRootVolumeTask.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReplaceRootVolumeTask.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ReplaceRoute
      def self.build(params, context:)
        Params::ReplaceRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReplaceRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReplaceRouteTableAssociation
      def self.build(params, context:)
        Params::ReplaceRouteTableAssociationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReplaceRouteTableAssociationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          new_association_id: 'new_association_id',
          association_state: RouteTableAssociationState.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceRouteTableAssociationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('newAssociationId', stub[:new_association_id].to_s) unless stub[:new_association_id].nil?
        xml << RouteTableAssociationState.stub('associationState', stub[:association_state]) unless stub[:association_state].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReplaceTransitGatewayRoute
      def self.build(params, context:)
        Params::ReplaceTransitGatewayRouteOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReplaceTransitGatewayRouteOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          route: TransitGatewayRoute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceTransitGatewayRouteResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << TransitGatewayRoute.stub('route', stub[:route]) unless stub[:route].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReplaceVpnTunnel
      def self.build(params, context:)
        Params::ReplaceVpnTunnelOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReplaceVpnTunnelOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReplaceVpnTunnelResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ReportInstanceStatus
      def self.build(params, context:)
        Params::ReportInstanceStatusOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ReportInstanceStatusOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ReportInstanceStatusResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RequestSpotFleet
      def self.build(params, context:)
        Params::RequestSpotFleetOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RequestSpotFleetOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          spot_fleet_request_id: 'spot_fleet_request_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RequestSpotFleetResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RequestSpotInstances
      def self.build(params, context:)
        Params::RequestSpotInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RequestSpotInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          spot_instance_requests: SpotInstanceRequestList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RequestSpotInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('spotInstanceRequestSet', SpotInstanceRequestList.stub('item', stub[:spot_instance_requests])) unless stub[:spot_instance_requests].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class Reservation
      def self.default(visited = [])
        return nil if visited.include?('Reservation')
        visited = visited + ['Reservation']
        {
          groups: GroupIdentifierList.default(visited),
          instances: InstanceList.default(visited),
          owner_id: 'owner_id',
          requester_id: 'requester_id',
          reservation_id: 'reservation_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('instancesSet', InstanceList.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('requesterId', stub[:requester_id].to_s) unless stub[:requester_id].nil?
        xml << Hearth::XML::Node.new('reservationId', stub[:reservation_id].to_s) unless stub[:reservation_id].nil?
        xml
      end
    end

    class ReservationList
      def self.default(visited = [])
        return nil if visited.include?('ReservationList')
        visited = visited + ['ReservationList']
        [
          Reservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Reservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ReservationValue
      def self.default(visited = [])
        return nil if visited.include?('ReservationValue')
        visited = visited + ['ReservationValue']
        {
          hourly_price: 'hourly_price',
          remaining_total_value: 'remaining_total_value',
          remaining_upfront_value: 'remaining_upfront_value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('remainingTotalValue', stub[:remaining_total_value].to_s) unless stub[:remaining_total_value].nil?
        xml << Hearth::XML::Node.new('remainingUpfrontValue', stub[:remaining_upfront_value].to_s) unless stub[:remaining_upfront_value].nil?
        xml
      end
    end

    class ReservedInstanceReservationValue
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstanceReservationValue')
        visited = visited + ['ReservedInstanceReservationValue']
        {
          reservation_value: ReservationValue.default(visited),
          reserved_instance_id: 'reserved_instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << ReservationValue.stub('reservationValue', stub[:reservation_value]) unless stub[:reservation_value].nil?
        xml << Hearth::XML::Node.new('reservedInstanceId', stub[:reserved_instance_id].to_s) unless stub[:reserved_instance_id].nil?
        xml
      end
    end

    class ReservedInstanceReservationValueSet
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstanceReservationValueSet')
        visited = visited + ['ReservedInstanceReservationValueSet']
        [
          ReservedInstanceReservationValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstanceReservationValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ReservedInstances
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstances')
        visited = visited + ['ReservedInstances']
        {
          availability_zone: 'availability_zone',
          duration: 1,
          end: Time.now,
          fixed_price: 1.0,
          instance_count: 1,
          instance_type: 'instance_type',
          product_description: 'product_description',
          reserved_instances_id: 'reserved_instances_id',
          start: Time.now,
          state: 'state',
          usage_price: 1.0,
          currency_code: 'currency_code',
          instance_tenancy: 'instance_tenancy',
          offering_class: 'offering_class',
          offering_type: 'offering_type',
          recurring_charges: RecurringChargesList.default(visited),
          scope: 'scope',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('end', Hearth::TimeHelper.to_date_time(stub[:end])) unless stub[:end].nil?
        xml << Hearth::XML::Node.new('fixedPrice', Hearth::NumberHelper.serialize(stub[:fixed_price]).to_s) unless stub[:fixed_price].nil?
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('productDescription', stub[:product_description].to_s) unless stub[:product_description].nil?
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml << Hearth::XML::Node.new('start', Hearth::TimeHelper.to_date_time(stub[:start])) unless stub[:start].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('usagePrice', Hearth::NumberHelper.serialize(stub[:usage_price]).to_s) unless stub[:usage_price].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('instanceTenancy', stub[:instance_tenancy].to_s) unless stub[:instance_tenancy].nil?
        xml << Hearth::XML::Node.new('offeringClass', stub[:offering_class].to_s) unless stub[:offering_class].nil?
        xml << Hearth::XML::Node.new('offeringType', stub[:offering_type].to_s) unless stub[:offering_type].nil?
        xml << Hearth::XML::Node.new('recurringCharges', RecurringChargesList.stub('item', stub[:recurring_charges])) unless stub[:recurring_charges].nil?
        xml << Hearth::XML::Node.new('scope', stub[:scope].to_s) unless stub[:scope].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class ReservedInstancesConfiguration
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesConfiguration')
        visited = visited + ['ReservedInstancesConfiguration']
        {
          availability_zone: 'availability_zone',
          instance_count: 1,
          instance_type: 'instance_type',
          platform: 'platform',
          scope: 'scope',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('scope', stub[:scope].to_s) unless stub[:scope].nil?
        xml
      end
    end

    class ReservedInstancesId
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesId')
        visited = visited + ['ReservedInstancesId']
        {
          reserved_instances_id: 'reserved_instances_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml
      end
    end

    class ReservedInstancesList
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesList')
        visited = visited + ['ReservedInstancesList']
        [
          ReservedInstances.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstances.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ReservedInstancesListing
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesListing')
        visited = visited + ['ReservedInstancesListing']
        {
          client_token: 'client_token',
          create_date: Time.now,
          instance_counts: InstanceCountList.default(visited),
          price_schedules: PriceScheduleList.default(visited),
          reserved_instances_id: 'reserved_instances_id',
          reserved_instances_listing_id: 'reserved_instances_listing_id',
          status: 'status',
          status_message: 'status_message',
          tags: TagList.default(visited),
          update_date: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('instanceCounts', InstanceCountList.stub('item', stub[:instance_counts])) unless stub[:instance_counts].nil?
        xml << Hearth::XML::Node.new('priceSchedules', PriceScheduleList.stub('item', stub[:price_schedules])) unless stub[:price_schedules].nil?
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml << Hearth::XML::Node.new('reservedInstancesListingId', stub[:reserved_instances_listing_id].to_s) unless stub[:reserved_instances_listing_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('updateDate', Hearth::TimeHelper.to_date_time(stub[:update_date])) unless stub[:update_date].nil?
        xml
      end
    end

    class ReservedInstancesListingList
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesListingList')
        visited = visited + ['ReservedInstancesListingList']
        [
          ReservedInstancesListing.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesListing.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ReservedInstancesModification
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesModification')
        visited = visited + ['ReservedInstancesModification']
        {
          client_token: 'client_token',
          create_date: Time.now,
          effective_date: Time.now,
          modification_results: ReservedInstancesModificationResultList.default(visited),
          reserved_instances_ids: ReservedIntancesIds.default(visited),
          reserved_instances_modification_id: 'reserved_instances_modification_id',
          status: 'status',
          status_message: 'status_message',
          update_date: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('effectiveDate', Hearth::TimeHelper.to_date_time(stub[:effective_date])) unless stub[:effective_date].nil?
        xml << Hearth::XML::Node.new('modificationResultSet', ReservedInstancesModificationResultList.stub('item', stub[:modification_results])) unless stub[:modification_results].nil?
        xml << Hearth::XML::Node.new('reservedInstancesSet', ReservedIntancesIds.stub('item', stub[:reserved_instances_ids])) unless stub[:reserved_instances_ids].nil?
        xml << Hearth::XML::Node.new('reservedInstancesModificationId', stub[:reserved_instances_modification_id].to_s) unless stub[:reserved_instances_modification_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('updateDate', Hearth::TimeHelper.to_date_time(stub[:update_date])) unless stub[:update_date].nil?
        xml
      end
    end

    class ReservedInstancesModificationList
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesModificationList')
        visited = visited + ['ReservedInstancesModificationList']
        [
          ReservedInstancesModification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesModification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ReservedInstancesModificationResult
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesModificationResult')
        visited = visited + ['ReservedInstancesModificationResult']
        {
          reserved_instances_id: 'reserved_instances_id',
          target_configuration: ReservedInstancesConfiguration.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml << ReservedInstancesConfiguration.stub('targetConfiguration', stub[:target_configuration]) unless stub[:target_configuration].nil?
        xml
      end
    end

    class ReservedInstancesModificationResultList
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesModificationResultList')
        visited = visited + ['ReservedInstancesModificationResultList']
        [
          ReservedInstancesModificationResult.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesModificationResult.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ReservedInstancesOffering
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesOffering')
        visited = visited + ['ReservedInstancesOffering']
        {
          availability_zone: 'availability_zone',
          duration: 1,
          fixed_price: 1.0,
          instance_type: 'instance_type',
          product_description: 'product_description',
          reserved_instances_offering_id: 'reserved_instances_offering_id',
          usage_price: 1.0,
          currency_code: 'currency_code',
          instance_tenancy: 'instance_tenancy',
          marketplace: false,
          offering_class: 'offering_class',
          offering_type: 'offering_type',
          pricing_details: PricingDetailsList.default(visited),
          recurring_charges: RecurringChargesList.default(visited),
          scope: 'scope',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('duration', stub[:duration].to_s) unless stub[:duration].nil?
        xml << Hearth::XML::Node.new('fixedPrice', Hearth::NumberHelper.serialize(stub[:fixed_price]).to_s) unless stub[:fixed_price].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('productDescription', stub[:product_description].to_s) unless stub[:product_description].nil?
        xml << Hearth::XML::Node.new('reservedInstancesOfferingId', stub[:reserved_instances_offering_id].to_s) unless stub[:reserved_instances_offering_id].nil?
        xml << Hearth::XML::Node.new('usagePrice', Hearth::NumberHelper.serialize(stub[:usage_price]).to_s) unless stub[:usage_price].nil?
        xml << Hearth::XML::Node.new('currencyCode', stub[:currency_code].to_s) unless stub[:currency_code].nil?
        xml << Hearth::XML::Node.new('instanceTenancy', stub[:instance_tenancy].to_s) unless stub[:instance_tenancy].nil?
        xml << Hearth::XML::Node.new('marketplace', stub[:marketplace].to_s) unless stub[:marketplace].nil?
        xml << Hearth::XML::Node.new('offeringClass', stub[:offering_class].to_s) unless stub[:offering_class].nil?
        xml << Hearth::XML::Node.new('offeringType', stub[:offering_type].to_s) unless stub[:offering_type].nil?
        xml << Hearth::XML::Node.new('pricingDetailsSet', PricingDetailsList.stub('item', stub[:pricing_details])) unless stub[:pricing_details].nil?
        xml << Hearth::XML::Node.new('recurringCharges', RecurringChargesList.stub('item', stub[:recurring_charges])) unless stub[:recurring_charges].nil?
        xml << Hearth::XML::Node.new('scope', stub[:scope].to_s) unless stub[:scope].nil?
        xml
      end
    end

    class ReservedInstancesOfferingList
      def self.default(visited = [])
        return nil if visited.include?('ReservedInstancesOfferingList')
        visited = visited + ['ReservedInstancesOfferingList']
        [
          ReservedInstancesOffering.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesOffering.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ReservedIntancesIds
      def self.default(visited = [])
        return nil if visited.include?('ReservedIntancesIds')
        visited = visited + ['ReservedIntancesIds']
        [
          ReservedInstancesId.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ReservedInstancesId.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ResetAddressAttribute
      def self.build(params, context:)
        Params::ResetAddressAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ResetAddressAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          address: AddressAttribute.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetAddressAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << AddressAttribute.stub('address', stub[:address]) unless stub[:address].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ResetEbsDefaultKmsKeyId
      def self.build(params, context:)
        Params::ResetEbsDefaultKmsKeyIdOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ResetEbsDefaultKmsKeyIdOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          kms_key_id: 'kms_key_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetEbsDefaultKmsKeyIdResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ResetFpgaImageAttribute
      def self.build(params, context:)
        Params::ResetFpgaImageAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ResetFpgaImageAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetFpgaImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ResetImageAttribute
      def self.build(params, context:)
        Params::ResetImageAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ResetImageAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetImageAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ResetInstanceAttribute
      def self.build(params, context:)
        Params::ResetInstanceAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ResetInstanceAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetInstanceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ResetNetworkInterfaceAttribute
      def self.build(params, context:)
        Params::ResetNetworkInterfaceAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ResetNetworkInterfaceAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetNetworkInterfaceAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ResetSnapshotAttribute
      def self.build(params, context:)
        Params::ResetSnapshotAttributeOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::ResetSnapshotAttributeOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('ResetSnapshotAttributeResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ResourceStatement
      def self.default(visited = [])
        return nil if visited.include?('ResourceStatement')
        visited = visited + ['ResourceStatement']
        {
          resources: ValueStringList.default(visited),
          resource_types: ValueStringList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceSet', ValueStringList.stub('item', stub[:resources])) unless stub[:resources].nil?
        xml << Hearth::XML::Node.new('resourceTypeSet', ValueStringList.stub('item', stub[:resource_types])) unless stub[:resource_types].nil?
        xml
      end
    end

    class ResponseError
      def self.default(visited = [])
        return nil if visited.include?('ResponseError')
        visited = visited + ['ResponseError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class ResponseHostIdList
      def self.default(visited = [])
        return nil if visited.include?('ResponseHostIdList')
        visited = visited + ['ResponseHostIdList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class ResponseHostIdSet
      def self.default(visited = [])
        return nil if visited.include?('ResponseHostIdSet')
        visited = visited + ['ResponseHostIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class ResponseLaunchTemplateData
      def self.default(visited = [])
        return nil if visited.include?('ResponseLaunchTemplateData')
        visited = visited + ['ResponseLaunchTemplateData']
        {
          kernel_id: 'kernel_id',
          ebs_optimized: false,
          iam_instance_profile: LaunchTemplateIamInstanceProfileSpecification.default(visited),
          block_device_mappings: LaunchTemplateBlockDeviceMappingList.default(visited),
          network_interfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationList.default(visited),
          image_id: 'image_id',
          instance_type: 'instance_type',
          key_name: 'key_name',
          monitoring: LaunchTemplatesMonitoring.default(visited),
          placement: LaunchTemplatePlacement.default(visited),
          ram_disk_id: 'ram_disk_id',
          disable_api_termination: false,
          instance_initiated_shutdown_behavior: 'instance_initiated_shutdown_behavior',
          user_data: 'user_data',
          tag_specifications: LaunchTemplateTagSpecificationList.default(visited),
          elastic_gpu_specifications: ElasticGpuSpecificationResponseList.default(visited),
          elastic_inference_accelerators: LaunchTemplateElasticInferenceAcceleratorResponseList.default(visited),
          security_group_ids: ValueStringList.default(visited),
          security_groups: ValueStringList.default(visited),
          instance_market_options: LaunchTemplateInstanceMarketOptions.default(visited),
          credit_specification: CreditSpecification.default(visited),
          cpu_options: LaunchTemplateCpuOptions.default(visited),
          capacity_reservation_specification: LaunchTemplateCapacityReservationSpecificationResponse.default(visited),
          license_specifications: LaunchTemplateLicenseList.default(visited),
          hibernation_options: LaunchTemplateHibernationOptions.default(visited),
          metadata_options: LaunchTemplateInstanceMetadataOptions.default(visited),
          enclave_options: LaunchTemplateEnclaveOptions.default(visited),
          instance_requirements: InstanceRequirements.default(visited),
          private_dns_name_options: LaunchTemplatePrivateDnsNameOptions.default(visited),
          maintenance_options: LaunchTemplateInstanceMaintenanceOptions.default(visited),
          disable_api_stop: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << LaunchTemplateIamInstanceProfileSpecification.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('blockDeviceMappingSet', LaunchTemplateBlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('networkInterfaceSet', LaunchTemplateInstanceNetworkInterfaceSpecificationList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << LaunchTemplatesMonitoring.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml << LaunchTemplatePlacement.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << Hearth::XML::Node.new('ramDiskId', stub[:ram_disk_id].to_s) unless stub[:ram_disk_id].nil?
        xml << Hearth::XML::Node.new('disableApiTermination', stub[:disable_api_termination].to_s) unless stub[:disable_api_termination].nil?
        xml << Hearth::XML::Node.new('instanceInitiatedShutdownBehavior', stub[:instance_initiated_shutdown_behavior].to_s) unless stub[:instance_initiated_shutdown_behavior].nil?
        xml << Hearth::XML::Node.new('userData', stub[:user_data].to_s) unless stub[:user_data].nil?
        xml << Hearth::XML::Node.new('tagSpecificationSet', LaunchTemplateTagSpecificationList.stub('item', stub[:tag_specifications])) unless stub[:tag_specifications].nil?
        xml << Hearth::XML::Node.new('elasticGpuSpecificationSet', ElasticGpuSpecificationResponseList.stub('item', stub[:elastic_gpu_specifications])) unless stub[:elastic_gpu_specifications].nil?
        xml << Hearth::XML::Node.new('elasticInferenceAcceleratorSet', LaunchTemplateElasticInferenceAcceleratorResponseList.stub('item', stub[:elastic_inference_accelerators])) unless stub[:elastic_inference_accelerators].nil?
        xml << Hearth::XML::Node.new('securityGroupIdSet', ValueStringList.stub('item', stub[:security_group_ids])) unless stub[:security_group_ids].nil?
        xml << Hearth::XML::Node.new('securityGroupSet', ValueStringList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << LaunchTemplateInstanceMarketOptions.stub('instanceMarketOptions', stub[:instance_market_options]) unless stub[:instance_market_options].nil?
        xml << CreditSpecification.stub('creditSpecification', stub[:credit_specification]) unless stub[:credit_specification].nil?
        xml << LaunchTemplateCpuOptions.stub('cpuOptions', stub[:cpu_options]) unless stub[:cpu_options].nil?
        xml << LaunchTemplateCapacityReservationSpecificationResponse.stub('capacityReservationSpecification', stub[:capacity_reservation_specification]) unless stub[:capacity_reservation_specification].nil?
        xml << Hearth::XML::Node.new('licenseSet', LaunchTemplateLicenseList.stub('item', stub[:license_specifications])) unless stub[:license_specifications].nil?
        xml << LaunchTemplateHibernationOptions.stub('hibernationOptions', stub[:hibernation_options]) unless stub[:hibernation_options].nil?
        xml << LaunchTemplateInstanceMetadataOptions.stub('metadataOptions', stub[:metadata_options]) unless stub[:metadata_options].nil?
        xml << LaunchTemplateEnclaveOptions.stub('enclaveOptions', stub[:enclave_options]) unless stub[:enclave_options].nil?
        xml << InstanceRequirements.stub('instanceRequirements', stub[:instance_requirements]) unless stub[:instance_requirements].nil?
        xml << LaunchTemplatePrivateDnsNameOptions.stub('privateDnsNameOptions', stub[:private_dns_name_options]) unless stub[:private_dns_name_options].nil?
        xml << LaunchTemplateInstanceMaintenanceOptions.stub('maintenanceOptions', stub[:maintenance_options]) unless stub[:maintenance_options].nil?
        xml << Hearth::XML::Node.new('disableApiStop', stub[:disable_api_stop].to_s) unless stub[:disable_api_stop].nil?
        xml
      end
    end

    class RestoreAddressToClassic
      def self.build(params, context:)
        Params::RestoreAddressToClassicOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RestoreAddressToClassicOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          public_ip: 'public_ip',
          status: 'status',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreAddressToClassicResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('publicIp', stub[:public_ip].to_s) unless stub[:public_ip].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RestoreImageFromRecycleBin
      def self.build(params, context:)
        Params::RestoreImageFromRecycleBinOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RestoreImageFromRecycleBinOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreImageFromRecycleBinResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RestoreManagedPrefixListVersion
      def self.build(params, context:)
        Params::RestoreManagedPrefixListVersionOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RestoreManagedPrefixListVersionOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          prefix_list: ManagedPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreManagedPrefixListVersionResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ManagedPrefixList.stub('prefixList', stub[:prefix_list]) unless stub[:prefix_list].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RestoreSnapshotFromRecycleBin
      def self.build(params, context:)
        Params::RestoreSnapshotFromRecycleBinOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RestoreSnapshotFromRecycleBinOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          snapshot_id: 'snapshot_id',
          outpost_arn: 'outpost_arn',
          description: 'description',
          encrypted: false,
          owner_id: 'owner_id',
          progress: 'progress',
          start_time: Time.now,
          state: 'state',
          volume_id: 'volume_id',
          volume_size: 1,
          sse_type: 'sse_type',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreSnapshotFromRecycleBinResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('sseType', stub[:sse_type].to_s) unless stub[:sse_type].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RestoreSnapshotTier
      def self.build(params, context:)
        Params::RestoreSnapshotTierOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RestoreSnapshotTierOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          snapshot_id: 'snapshot_id',
          restore_start_time: Time.now,
          restore_duration: 1,
          is_permanent_restore: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RestoreSnapshotTierResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('restoreStartTime', Hearth::TimeHelper.to_date_time(stub[:restore_start_time])) unless stub[:restore_start_time].nil?
        xml << Hearth::XML::Node.new('restoreDuration', stub[:restore_duration].to_s) unless stub[:restore_duration].nil?
        xml << Hearth::XML::Node.new('isPermanentRestore', stub[:is_permanent_restore].to_s) unless stub[:is_permanent_restore].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RevokeClientVpnIngress
      def self.build(params, context:)
        Params::RevokeClientVpnIngressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RevokeClientVpnIngressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          status: ClientVpnAuthorizationRuleStatus.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RevokeClientVpnIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ClientVpnAuthorizationRuleStatus.stub('status', stub[:status]) unless stub[:status].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RevokeSecurityGroupEgress
      def self.build(params, context:)
        Params::RevokeSecurityGroupEgressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RevokeSecurityGroupEgressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
          unknown_ip_permissions: IpPermissionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RevokeSecurityGroupEgressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('unknownIpPermissionSet', IpPermissionList.stub('item', stub[:unknown_ip_permissions])) unless stub[:unknown_ip_permissions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RevokeSecurityGroupIngress
      def self.build(params, context:)
        Params::RevokeSecurityGroupIngressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RevokeSecurityGroupIngressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
          unknown_ip_permissions: IpPermissionList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RevokeSecurityGroupIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        xml << Hearth::XML::Node.new('unknownIpPermissionSet', IpPermissionList.stub('item', stub[:unknown_ip_permissions])) unless stub[:unknown_ip_permissions].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RootDeviceTypeList
      def self.default(visited = [])
        return nil if visited.include?('RootDeviceTypeList')
        visited = visited + ['RootDeviceTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class Route
      def self.default(visited = [])
        return nil if visited.include?('Route')
        visited = visited + ['Route']
        {
          destination_cidr_block: 'destination_cidr_block',
          destination_ipv6_cidr_block: 'destination_ipv6_cidr_block',
          destination_prefix_list_id: 'destination_prefix_list_id',
          egress_only_internet_gateway_id: 'egress_only_internet_gateway_id',
          gateway_id: 'gateway_id',
          instance_id: 'instance_id',
          instance_owner_id: 'instance_owner_id',
          nat_gateway_id: 'nat_gateway_id',
          transit_gateway_id: 'transit_gateway_id',
          local_gateway_id: 'local_gateway_id',
          carrier_gateway_id: 'carrier_gateway_id',
          network_interface_id: 'network_interface_id',
          origin: 'origin',
          state: 'state',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
          core_network_arn: 'core_network_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('destinationIpv6CidrBlock', stub[:destination_ipv6_cidr_block].to_s) unless stub[:destination_ipv6_cidr_block].nil?
        xml << Hearth::XML::Node.new('destinationPrefixListId', stub[:destination_prefix_list_id].to_s) unless stub[:destination_prefix_list_id].nil?
        xml << Hearth::XML::Node.new('egressOnlyInternetGatewayId', stub[:egress_only_internet_gateway_id].to_s) unless stub[:egress_only_internet_gateway_id].nil?
        xml << Hearth::XML::Node.new('gatewayId', stub[:gateway_id].to_s) unless stub[:gateway_id].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('instanceOwnerId', stub[:instance_owner_id].to_s) unless stub[:instance_owner_id].nil?
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('localGatewayId', stub[:local_gateway_id].to_s) unless stub[:local_gateway_id].nil?
        xml << Hearth::XML::Node.new('carrierGatewayId', stub[:carrier_gateway_id].to_s) unless stub[:carrier_gateway_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('origin', stub[:origin].to_s) unless stub[:origin].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml << Hearth::XML::Node.new('coreNetworkArn', stub[:core_network_arn].to_s) unless stub[:core_network_arn].nil?
        xml
      end
    end

    class RouteList
      def self.default(visited = [])
        return nil if visited.include?('RouteList')
        visited = visited + ['RouteList']
        [
          Route.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Route.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class RouteTable
      def self.default(visited = [])
        return nil if visited.include?('RouteTable')
        visited = visited + ['RouteTable']
        {
          associations: RouteTableAssociationList.default(visited),
          propagating_vgws: PropagatingVgwList.default(visited),
          route_table_id: 'route_table_id',
          routes: RouteList.default(visited),
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationSet', RouteTableAssociationList.stub('item', stub[:associations])) unless stub[:associations].nil?
        xml << Hearth::XML::Node.new('propagatingVgwSet', PropagatingVgwList.stub('item', stub[:propagating_vgws])) unless stub[:propagating_vgws].nil?
        xml << Hearth::XML::Node.new('routeTableId', stub[:route_table_id].to_s) unless stub[:route_table_id].nil?
        xml << Hearth::XML::Node.new('routeSet', RouteList.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml
      end
    end

    class RouteTableAssociation
      def self.default(visited = [])
        return nil if visited.include?('RouteTableAssociation')
        visited = visited + ['RouteTableAssociation']
        {
          main: false,
          route_table_association_id: 'route_table_association_id',
          route_table_id: 'route_table_id',
          subnet_id: 'subnet_id',
          gateway_id: 'gateway_id',
          association_state: RouteTableAssociationState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('main', stub[:main].to_s) unless stub[:main].nil?
        xml << Hearth::XML::Node.new('routeTableAssociationId', stub[:route_table_association_id].to_s) unless stub[:route_table_association_id].nil?
        xml << Hearth::XML::Node.new('routeTableId', stub[:route_table_id].to_s) unless stub[:route_table_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('gatewayId', stub[:gateway_id].to_s) unless stub[:gateway_id].nil?
        xml << RouteTableAssociationState.stub('associationState', stub[:association_state]) unless stub[:association_state].nil?
        xml
      end
    end

    class RouteTableAssociationList
      def self.default(visited = [])
        return nil if visited.include?('RouteTableAssociationList')
        visited = visited + ['RouteTableAssociationList']
        [
          RouteTableAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << RouteTableAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class RouteTableAssociationState
      def self.default(visited = [])
        return nil if visited.include?('RouteTableAssociationState')
        visited = visited + ['RouteTableAssociationState']
        {
          state: 'state',
          status_message: 'status_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml
      end
    end

    class RouteTableList
      def self.default(visited = [])
        return nil if visited.include?('RouteTableList')
        visited = visited + ['RouteTableList']
        [
          RouteTable.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << RouteTable.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class RuleGroupRuleOptionsPair
      def self.default(visited = [])
        return nil if visited.include?('RuleGroupRuleOptionsPair')
        visited = visited + ['RuleGroupRuleOptionsPair']
        {
          rule_group_arn: 'rule_group_arn',
          rule_options: RuleOptionList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ruleGroupArn', stub[:rule_group_arn].to_s) unless stub[:rule_group_arn].nil?
        xml << Hearth::XML::Node.new('ruleOptionSet', RuleOptionList.stub('item', stub[:rule_options])) unless stub[:rule_options].nil?
        xml
      end
    end

    class RuleGroupRuleOptionsPairList
      def self.default(visited = [])
        return nil if visited.include?('RuleGroupRuleOptionsPairList')
        visited = visited + ['RuleGroupRuleOptionsPairList']
        [
          RuleGroupRuleOptionsPair.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << RuleGroupRuleOptionsPair.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class RuleGroupTypePair
      def self.default(visited = [])
        return nil if visited.include?('RuleGroupTypePair')
        visited = visited + ['RuleGroupTypePair']
        {
          rule_group_arn: 'rule_group_arn',
          rule_group_type: 'rule_group_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ruleGroupArn', stub[:rule_group_arn].to_s) unless stub[:rule_group_arn].nil?
        xml << Hearth::XML::Node.new('ruleGroupType', stub[:rule_group_type].to_s) unless stub[:rule_group_type].nil?
        xml
      end
    end

    class RuleGroupTypePairList
      def self.default(visited = [])
        return nil if visited.include?('RuleGroupTypePairList')
        visited = visited + ['RuleGroupTypePairList']
        [
          RuleGroupTypePair.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << RuleGroupTypePair.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class RuleOption
      def self.default(visited = [])
        return nil if visited.include?('RuleOption')
        visited = visited + ['RuleOption']
        {
          keyword: 'keyword',
          settings: StringList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('keyword', stub[:keyword].to_s) unless stub[:keyword].nil?
        xml << Hearth::XML::Node.new('settingSet', StringList.stub('item', stub[:settings])) unless stub[:settings].nil?
        xml
      end
    end

    class RuleOptionList
      def self.default(visited = [])
        return nil if visited.include?('RuleOptionList')
        visited = visited + ['RuleOptionList']
        [
          RuleOption.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << RuleOption.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class RunInstances
      def self.build(params, context:)
        Params::RunInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RunInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          groups: GroupIdentifierList.default(visited),
          instances: InstanceList.default(visited),
          owner_id: 'owner_id',
          requester_id: 'requester_id',
          reservation_id: 'reservation_id',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RunInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('instancesSet', InstanceList.stub('item', stub[:instances])) unless stub[:instances].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('requesterId', stub[:requester_id].to_s) unless stub[:requester_id].nil?
        xml << Hearth::XML::Node.new('reservationId', stub[:reservation_id].to_s) unless stub[:reservation_id].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class RunInstancesMonitoringEnabled
      def self.default(visited = [])
        return nil if visited.include?('RunInstancesMonitoringEnabled')
        visited = visited + ['RunInstancesMonitoringEnabled']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    class RunScheduledInstances
      def self.build(params, context:)
        Params::RunScheduledInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::RunScheduledInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_id_set: InstanceIdSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('RunScheduledInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instanceIdSet', InstanceIdSet.stub('item', stub[:instance_id_set])) unless stub[:instance_id_set].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class S3Storage
      def self.default(visited = [])
        return nil if visited.include?('S3Storage')
        visited = visited + ['S3Storage']
        {
          aws_access_key_id: 'aws_access_key_id',
          bucket: 'bucket',
          prefix: 'prefix',
          upload_policy: 'upload_policy',
          upload_policy_signature: 'upload_policy_signature',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('AWSAccessKeyId', stub[:aws_access_key_id].to_s) unless stub[:aws_access_key_id].nil?
        xml << Hearth::XML::Node.new('bucket', stub[:bucket].to_s) unless stub[:bucket].nil?
        xml << Hearth::XML::Node.new('prefix', stub[:prefix].to_s) unless stub[:prefix].nil?
        xml << Hearth::XML::Node.new('uploadPolicy', ::Base64::encode64(stub[:upload_policy]).strip) unless stub[:upload_policy].nil?
        xml << Hearth::XML::Node.new('uploadPolicySignature', stub[:upload_policy_signature].to_s) unless stub[:upload_policy_signature].nil?
        xml
      end
    end

    class ScheduledInstance
      def self.default(visited = [])
        return nil if visited.include?('ScheduledInstance')
        visited = visited + ['ScheduledInstance']
        {
          availability_zone: 'availability_zone',
          create_date: Time.now,
          hourly_price: 'hourly_price',
          instance_count: 1,
          instance_type: 'instance_type',
          network_platform: 'network_platform',
          next_slot_start_time: Time.now,
          platform: 'platform',
          previous_slot_end_time: Time.now,
          recurrence: ScheduledInstanceRecurrence.default(visited),
          scheduled_instance_id: 'scheduled_instance_id',
          slot_duration_in_hours: 1,
          term_end_date: Time.now,
          term_start_date: Time.now,
          total_scheduled_instance_hours: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('createDate', Hearth::TimeHelper.to_date_time(stub[:create_date])) unless stub[:create_date].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('networkPlatform', stub[:network_platform].to_s) unless stub[:network_platform].nil?
        xml << Hearth::XML::Node.new('nextSlotStartTime', Hearth::TimeHelper.to_date_time(stub[:next_slot_start_time])) unless stub[:next_slot_start_time].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('previousSlotEndTime', Hearth::TimeHelper.to_date_time(stub[:previous_slot_end_time])) unless stub[:previous_slot_end_time].nil?
        xml << ScheduledInstanceRecurrence.stub('recurrence', stub[:recurrence]) unless stub[:recurrence].nil?
        xml << Hearth::XML::Node.new('scheduledInstanceId', stub[:scheduled_instance_id].to_s) unless stub[:scheduled_instance_id].nil?
        xml << Hearth::XML::Node.new('slotDurationInHours', stub[:slot_duration_in_hours].to_s) unless stub[:slot_duration_in_hours].nil?
        xml << Hearth::XML::Node.new('termEndDate', Hearth::TimeHelper.to_date_time(stub[:term_end_date])) unless stub[:term_end_date].nil?
        xml << Hearth::XML::Node.new('termStartDate', Hearth::TimeHelper.to_date_time(stub[:term_start_date])) unless stub[:term_start_date].nil?
        xml << Hearth::XML::Node.new('totalScheduledInstanceHours', stub[:total_scheduled_instance_hours].to_s) unless stub[:total_scheduled_instance_hours].nil?
        xml
      end
    end

    class ScheduledInstanceAvailability
      def self.default(visited = [])
        return nil if visited.include?('ScheduledInstanceAvailability')
        visited = visited + ['ScheduledInstanceAvailability']
        {
          availability_zone: 'availability_zone',
          available_instance_count: 1,
          first_slot_start_time: Time.now,
          hourly_price: 'hourly_price',
          instance_type: 'instance_type',
          max_term_duration_in_days: 1,
          min_term_duration_in_days: 1,
          network_platform: 'network_platform',
          platform: 'platform',
          purchase_token: 'purchase_token',
          recurrence: ScheduledInstanceRecurrence.default(visited),
          slot_duration_in_hours: 1,
          total_scheduled_instance_hours: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('availableInstanceCount', stub[:available_instance_count].to_s) unless stub[:available_instance_count].nil?
        xml << Hearth::XML::Node.new('firstSlotStartTime', Hearth::TimeHelper.to_date_time(stub[:first_slot_start_time])) unless stub[:first_slot_start_time].nil?
        xml << Hearth::XML::Node.new('hourlyPrice', stub[:hourly_price].to_s) unless stub[:hourly_price].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('maxTermDurationInDays', stub[:max_term_duration_in_days].to_s) unless stub[:max_term_duration_in_days].nil?
        xml << Hearth::XML::Node.new('minTermDurationInDays', stub[:min_term_duration_in_days].to_s) unless stub[:min_term_duration_in_days].nil?
        xml << Hearth::XML::Node.new('networkPlatform', stub[:network_platform].to_s) unless stub[:network_platform].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('purchaseToken', stub[:purchase_token].to_s) unless stub[:purchase_token].nil?
        xml << ScheduledInstanceRecurrence.stub('recurrence', stub[:recurrence]) unless stub[:recurrence].nil?
        xml << Hearth::XML::Node.new('slotDurationInHours', stub[:slot_duration_in_hours].to_s) unless stub[:slot_duration_in_hours].nil?
        xml << Hearth::XML::Node.new('totalScheduledInstanceHours', stub[:total_scheduled_instance_hours].to_s) unless stub[:total_scheduled_instance_hours].nil?
        xml
      end
    end

    class ScheduledInstanceAvailabilitySet
      def self.default(visited = [])
        return nil if visited.include?('ScheduledInstanceAvailabilitySet')
        visited = visited + ['ScheduledInstanceAvailabilitySet']
        [
          ScheduledInstanceAvailability.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ScheduledInstanceAvailability.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ScheduledInstanceRecurrence
      def self.default(visited = [])
        return nil if visited.include?('ScheduledInstanceRecurrence')
        visited = visited + ['ScheduledInstanceRecurrence']
        {
          frequency: 'frequency',
          interval: 1,
          occurrence_day_set: OccurrenceDaySet.default(visited),
          occurrence_relative_to_end: false,
          occurrence_unit: 'occurrence_unit',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('frequency', stub[:frequency].to_s) unless stub[:frequency].nil?
        xml << Hearth::XML::Node.new('interval', stub[:interval].to_s) unless stub[:interval].nil?
        xml << Hearth::XML::Node.new('occurrenceDaySet', OccurrenceDaySet.stub('item', stub[:occurrence_day_set])) unless stub[:occurrence_day_set].nil?
        xml << Hearth::XML::Node.new('occurrenceRelativeToEnd', stub[:occurrence_relative_to_end].to_s) unless stub[:occurrence_relative_to_end].nil?
        xml << Hearth::XML::Node.new('occurrenceUnit', stub[:occurrence_unit].to_s) unless stub[:occurrence_unit].nil?
        xml
      end
    end

    class ScheduledInstanceSet
      def self.default(visited = [])
        return nil if visited.include?('ScheduledInstanceSet')
        visited = visited + ['ScheduledInstanceSet']
        [
          ScheduledInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ScheduledInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SearchLocalGatewayRoutes
      def self.build(params, context:)
        Params::SearchLocalGatewayRoutesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::SearchLocalGatewayRoutesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          routes: LocalGatewayRouteList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('SearchLocalGatewayRoutesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('routeSet', LocalGatewayRouteList.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class SearchTransitGatewayMulticastGroups
      def self.build(params, context:)
        Params::SearchTransitGatewayMulticastGroupsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::SearchTransitGatewayMulticastGroupsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          multicast_groups: TransitGatewayMulticastGroupList.default(visited),
          next_token: 'next_token',
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('SearchTransitGatewayMulticastGroupsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('multicastGroups', TransitGatewayMulticastGroupList.stub('item', stub[:multicast_groups])) unless stub[:multicast_groups].nil?
        xml << Hearth::XML::Node.new('nextToken', stub[:next_token].to_s) unless stub[:next_token].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class SearchTransitGatewayRoutes
      def self.build(params, context:)
        Params::SearchTransitGatewayRoutesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::SearchTransitGatewayRoutesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          routes: TransitGatewayRouteList.default(visited),
          additional_routes_available: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('SearchTransitGatewayRoutesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('routeSet', TransitGatewayRouteList.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('additionalRoutesAvailable', stub[:additional_routes_available].to_s) unless stub[:additional_routes_available].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class SecurityGroup
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroup')
        visited = visited + ['SecurityGroup']
        {
          description: 'description',
          group_name: 'group_name',
          ip_permissions: IpPermissionList.default(visited),
          owner_id: 'owner_id',
          group_id: 'group_id',
          ip_permissions_egress: IpPermissionList.default(visited),
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupDescription', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('ipPermissions', IpPermissionList.stub('item', stub[:ip_permissions])) unless stub[:ip_permissions].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('ipPermissionsEgress', IpPermissionList.stub('item', stub[:ip_permissions_egress])) unless stub[:ip_permissions_egress].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    class SecurityGroupIdList
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroupIdList')
        visited = visited + ['SecurityGroupIdList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class SecurityGroupIdSet
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroupIdSet')
        visited = visited + ['SecurityGroupIdSet']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class SecurityGroupIdStringList
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroupIdStringList')
        visited = visited + ['SecurityGroupIdStringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class SecurityGroupIdentifier
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroupIdentifier')
        visited = visited + ['SecurityGroupIdentifier']
        {
          group_id: 'group_id',
          group_name: 'group_name',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml
      end
    end

    class SecurityGroupList
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroupList')
        visited = visited + ['SecurityGroupList']
        [
          SecurityGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SecurityGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SecurityGroupReference
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroupReference')
        visited = visited + ['SecurityGroupReference']
        {
          group_id: 'group_id',
          referencing_vpc_id: 'referencing_vpc_id',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('referencingVpcId', stub[:referencing_vpc_id].to_s) unless stub[:referencing_vpc_id].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml
      end
    end

    class SecurityGroupReferences
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroupReferences')
        visited = visited + ['SecurityGroupReferences']
        [
          SecurityGroupReference.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SecurityGroupReference.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SecurityGroupRule
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroupRule')
        visited = visited + ['SecurityGroupRule']
        {
          security_group_rule_id: 'security_group_rule_id',
          group_id: 'group_id',
          group_owner_id: 'group_owner_id',
          is_egress: false,
          ip_protocol: 'ip_protocol',
          from_port: 1,
          to_port: 1,
          cidr_ipv4: 'cidr_ipv4',
          cidr_ipv6: 'cidr_ipv6',
          prefix_list_id: 'prefix_list_id',
          referenced_group_info: ReferencedSecurityGroup.default(visited),
          description: 'description',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('securityGroupRuleId', stub[:security_group_rule_id].to_s) unless stub[:security_group_rule_id].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('groupOwnerId', stub[:group_owner_id].to_s) unless stub[:group_owner_id].nil?
        xml << Hearth::XML::Node.new('isEgress', stub[:is_egress].to_s) unless stub[:is_egress].nil?
        xml << Hearth::XML::Node.new('ipProtocol', stub[:ip_protocol].to_s) unless stub[:ip_protocol].nil?
        xml << Hearth::XML::Node.new('fromPort', stub[:from_port].to_s) unless stub[:from_port].nil?
        xml << Hearth::XML::Node.new('toPort', stub[:to_port].to_s) unless stub[:to_port].nil?
        xml << Hearth::XML::Node.new('cidrIpv4', stub[:cidr_ipv4].to_s) unless stub[:cidr_ipv4].nil?
        xml << Hearth::XML::Node.new('cidrIpv6', stub[:cidr_ipv6].to_s) unless stub[:cidr_ipv6].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << ReferencedSecurityGroup.stub('referencedGroupInfo', stub[:referenced_group_info]) unless stub[:referenced_group_info].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class SecurityGroupRuleList
      def self.default(visited = [])
        return nil if visited.include?('SecurityGroupRuleList')
        visited = visited + ['SecurityGroupRuleList']
        [
          SecurityGroupRule.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SecurityGroupRule.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SendDiagnosticInterrupt
      def self.build(params, context:)
        Params::SendDiagnosticInterruptOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::SendDiagnosticInterruptOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('SendDiagnosticInterruptResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ServiceConfiguration
      def self.default(visited = [])
        return nil if visited.include?('ServiceConfiguration')
        visited = visited + ['ServiceConfiguration']
        {
          service_type: ServiceTypeDetailSet.default(visited),
          service_id: 'service_id',
          service_name: 'service_name',
          service_state: 'service_state',
          availability_zones: ValueStringList.default(visited),
          acceptance_required: false,
          manages_vpc_endpoints: false,
          network_load_balancer_arns: ValueStringList.default(visited),
          gateway_load_balancer_arns: ValueStringList.default(visited),
          supported_ip_address_types: SupportedIpAddressTypes.default(visited),
          base_endpoint_dns_names: ValueStringList.default(visited),
          private_dns_name: 'private_dns_name',
          private_dns_name_configuration: PrivateDnsNameConfiguration.default(visited),
          payer_responsibility: 'payer_responsibility',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('serviceType', ServiceTypeDetailSet.stub('item', stub[:service_type])) unless stub[:service_type].nil?
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml << Hearth::XML::Node.new('serviceName', stub[:service_name].to_s) unless stub[:service_name].nil?
        xml << Hearth::XML::Node.new('serviceState', stub[:service_state].to_s) unless stub[:service_state].nil?
        xml << Hearth::XML::Node.new('availabilityZoneSet', ValueStringList.stub('item', stub[:availability_zones])) unless stub[:availability_zones].nil?
        xml << Hearth::XML::Node.new('acceptanceRequired', stub[:acceptance_required].to_s) unless stub[:acceptance_required].nil?
        xml << Hearth::XML::Node.new('managesVpcEndpoints', stub[:manages_vpc_endpoints].to_s) unless stub[:manages_vpc_endpoints].nil?
        xml << Hearth::XML::Node.new('networkLoadBalancerArnSet', ValueStringList.stub('item', stub[:network_load_balancer_arns])) unless stub[:network_load_balancer_arns].nil?
        xml << Hearth::XML::Node.new('gatewayLoadBalancerArnSet', ValueStringList.stub('item', stub[:gateway_load_balancer_arns])) unless stub[:gateway_load_balancer_arns].nil?
        xml << Hearth::XML::Node.new('supportedIpAddressTypeSet', SupportedIpAddressTypes.stub('item', stub[:supported_ip_address_types])) unless stub[:supported_ip_address_types].nil?
        xml << Hearth::XML::Node.new('baseEndpointDnsNameSet', ValueStringList.stub('item', stub[:base_endpoint_dns_names])) unless stub[:base_endpoint_dns_names].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << PrivateDnsNameConfiguration.stub('privateDnsNameConfiguration', stub[:private_dns_name_configuration]) unless stub[:private_dns_name_configuration].nil?
        xml << Hearth::XML::Node.new('payerResponsibility', stub[:payer_responsibility].to_s) unless stub[:payer_responsibility].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class ServiceConfigurationSet
      def self.default(visited = [])
        return nil if visited.include?('ServiceConfigurationSet')
        visited = visited + ['ServiceConfigurationSet']
        [
          ServiceConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ServiceConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ServiceDetail
      def self.default(visited = [])
        return nil if visited.include?('ServiceDetail')
        visited = visited + ['ServiceDetail']
        {
          service_name: 'service_name',
          service_id: 'service_id',
          service_type: ServiceTypeDetailSet.default(visited),
          availability_zones: ValueStringList.default(visited),
          owner: 'owner',
          base_endpoint_dns_names: ValueStringList.default(visited),
          private_dns_name: 'private_dns_name',
          private_dns_names: PrivateDnsDetailsSet.default(visited),
          vpc_endpoint_policy_supported: false,
          acceptance_required: false,
          manages_vpc_endpoints: false,
          payer_responsibility: 'payer_responsibility',
          tags: TagList.default(visited),
          private_dns_name_verification_state: 'private_dns_name_verification_state',
          supported_ip_address_types: SupportedIpAddressTypes.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('serviceName', stub[:service_name].to_s) unless stub[:service_name].nil?
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml << Hearth::XML::Node.new('serviceType', ServiceTypeDetailSet.stub('item', stub[:service_type])) unless stub[:service_type].nil?
        xml << Hearth::XML::Node.new('availabilityZoneSet', ValueStringList.stub('item', stub[:availability_zones])) unless stub[:availability_zones].nil?
        xml << Hearth::XML::Node.new('owner', stub[:owner].to_s) unless stub[:owner].nil?
        xml << Hearth::XML::Node.new('baseEndpointDnsNameSet', ValueStringList.stub('item', stub[:base_endpoint_dns_names])) unless stub[:base_endpoint_dns_names].nil?
        xml << Hearth::XML::Node.new('privateDnsName', stub[:private_dns_name].to_s) unless stub[:private_dns_name].nil?
        xml << Hearth::XML::Node.new('privateDnsNameSet', PrivateDnsDetailsSet.stub('item', stub[:private_dns_names])) unless stub[:private_dns_names].nil?
        xml << Hearth::XML::Node.new('vpcEndpointPolicySupported', stub[:vpc_endpoint_policy_supported].to_s) unless stub[:vpc_endpoint_policy_supported].nil?
        xml << Hearth::XML::Node.new('acceptanceRequired', stub[:acceptance_required].to_s) unless stub[:acceptance_required].nil?
        xml << Hearth::XML::Node.new('managesVpcEndpoints', stub[:manages_vpc_endpoints].to_s) unless stub[:manages_vpc_endpoints].nil?
        xml << Hearth::XML::Node.new('payerResponsibility', stub[:payer_responsibility].to_s) unless stub[:payer_responsibility].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('privateDnsNameVerificationState', stub[:private_dns_name_verification_state].to_s) unless stub[:private_dns_name_verification_state].nil?
        xml << Hearth::XML::Node.new('supportedIpAddressTypeSet', SupportedIpAddressTypes.stub('item', stub[:supported_ip_address_types])) unless stub[:supported_ip_address_types].nil?
        xml
      end
    end

    class ServiceDetailSet
      def self.default(visited = [])
        return nil if visited.include?('ServiceDetailSet')
        visited = visited + ['ServiceDetailSet']
        [
          ServiceDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ServiceDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class ServiceTypeDetail
      def self.default(visited = [])
        return nil if visited.include?('ServiceTypeDetail')
        visited = visited + ['ServiceTypeDetail']
        {
          service_type: 'service_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('serviceType', stub[:service_type].to_s) unless stub[:service_type].nil?
        xml
      end
    end

    class ServiceTypeDetailSet
      def self.default(visited = [])
        return nil if visited.include?('ServiceTypeDetailSet')
        visited = visited + ['ServiceTypeDetailSet']
        [
          ServiceTypeDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ServiceTypeDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Snapshot
      def self.default(visited = [])
        return nil if visited.include?('Snapshot')
        visited = visited + ['Snapshot']
        {
          data_encryption_key_id: 'data_encryption_key_id',
          description: 'description',
          encrypted: false,
          kms_key_id: 'kms_key_id',
          owner_id: 'owner_id',
          progress: 'progress',
          snapshot_id: 'snapshot_id',
          start_time: Time.now,
          state: 'state',
          state_message: 'state_message',
          volume_id: 'volume_id',
          volume_size: 1,
          owner_alias: 'owner_alias',
          outpost_arn: 'outpost_arn',
          tags: TagList.default(visited),
          storage_tier: 'storage_tier',
          restore_expiry_time: Time.now,
          sse_type: 'sse_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dataEncryptionKeyId', stub[:data_encryption_key_id].to_s) unless stub[:data_encryption_key_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:state_message].to_s) unless stub[:state_message].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('ownerAlias', stub[:owner_alias].to_s) unless stub[:owner_alias].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('storageTier', stub[:storage_tier].to_s) unless stub[:storage_tier].nil?
        xml << Hearth::XML::Node.new('restoreExpiryTime', Hearth::TimeHelper.to_date_time(stub[:restore_expiry_time])) unless stub[:restore_expiry_time].nil?
        xml << Hearth::XML::Node.new('sseType', stub[:sse_type].to_s) unless stub[:sse_type].nil?
        xml
      end
    end

    class SnapshotDetail
      def self.default(visited = [])
        return nil if visited.include?('SnapshotDetail')
        visited = visited + ['SnapshotDetail']
        {
          description: 'description',
          device_name: 'device_name',
          disk_image_size: 1.0,
          format: 'format',
          progress: 'progress',
          snapshot_id: 'snapshot_id',
          status: 'status',
          status_message: 'status_message',
          url: 'url',
          user_bucket: UserBucketDetails.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('deviceName', stub[:device_name].to_s) unless stub[:device_name].nil?
        xml << Hearth::XML::Node.new('diskImageSize', Hearth::NumberHelper.serialize(stub[:disk_image_size]).to_s) unless stub[:disk_image_size].nil?
        xml << Hearth::XML::Node.new('format', stub[:format].to_s) unless stub[:format].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('url', stub[:url].to_s) unless stub[:url].nil?
        xml << UserBucketDetails.stub('userBucket', stub[:user_bucket]) unless stub[:user_bucket].nil?
        xml
      end
    end

    class SnapshotDetailList
      def self.default(visited = [])
        return nil if visited.include?('SnapshotDetailList')
        visited = visited + ['SnapshotDetailList']
        [
          SnapshotDetail.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SnapshotDetail.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SnapshotInfo
      def self.default(visited = [])
        return nil if visited.include?('SnapshotInfo')
        visited = visited + ['SnapshotInfo']
        {
          description: 'description',
          tags: TagList.default(visited),
          encrypted: false,
          volume_id: 'volume_id',
          state: 'state',
          volume_size: 1,
          start_time: Time.now,
          progress: 'progress',
          owner_id: 'owner_id',
          snapshot_id: 'snapshot_id',
          outpost_arn: 'outpost_arn',
          sse_type: 'sse_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeSize', stub[:volume_size].to_s) unless stub[:volume_size].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('sseType', stub[:sse_type].to_s) unless stub[:sse_type].nil?
        xml
      end
    end

    class SnapshotList
      def self.default(visited = [])
        return nil if visited.include?('SnapshotList')
        visited = visited + ['SnapshotList']
        [
          Snapshot.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Snapshot.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SnapshotRecycleBinInfo
      def self.default(visited = [])
        return nil if visited.include?('SnapshotRecycleBinInfo')
        visited = visited + ['SnapshotRecycleBinInfo']
        {
          snapshot_id: 'snapshot_id',
          recycle_bin_enter_time: Time.now,
          recycle_bin_exit_time: Time.now,
          description: 'description',
          volume_id: 'volume_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('recycleBinEnterTime', Hearth::TimeHelper.to_date_time(stub[:recycle_bin_enter_time])) unless stub[:recycle_bin_enter_time].nil?
        xml << Hearth::XML::Node.new('recycleBinExitTime', Hearth::TimeHelper.to_date_time(stub[:recycle_bin_exit_time])) unless stub[:recycle_bin_exit_time].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml
      end
    end

    class SnapshotRecycleBinInfoList
      def self.default(visited = [])
        return nil if visited.include?('SnapshotRecycleBinInfoList')
        visited = visited + ['SnapshotRecycleBinInfoList']
        [
          SnapshotRecycleBinInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SnapshotRecycleBinInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SnapshotSet
      def self.default(visited = [])
        return nil if visited.include?('SnapshotSet')
        visited = visited + ['SnapshotSet']
        [
          SnapshotInfo.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SnapshotInfo.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SnapshotTaskDetail
      def self.default(visited = [])
        return nil if visited.include?('SnapshotTaskDetail')
        visited = visited + ['SnapshotTaskDetail']
        {
          description: 'description',
          disk_image_size: 1.0,
          encrypted: false,
          format: 'format',
          kms_key_id: 'kms_key_id',
          progress: 'progress',
          snapshot_id: 'snapshot_id',
          status: 'status',
          status_message: 'status_message',
          url: 'url',
          user_bucket: UserBucketDetails.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('diskImageSize', Hearth::NumberHelper.serialize(stub[:disk_image_size]).to_s) unless stub[:disk_image_size].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('format', stub[:format].to_s) unless stub[:format].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('url', stub[:url].to_s) unless stub[:url].nil?
        xml << UserBucketDetails.stub('userBucket', stub[:user_bucket]) unless stub[:user_bucket].nil?
        xml
      end
    end

    class SnapshotTierStatus
      def self.default(visited = [])
        return nil if visited.include?('SnapshotTierStatus')
        visited = visited + ['SnapshotTierStatus']
        {
          snapshot_id: 'snapshot_id',
          volume_id: 'volume_id',
          status: 'status',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
          storage_tier: 'storage_tier',
          last_tiering_start_time: Time.now,
          last_tiering_progress: 1,
          last_tiering_operation_status: 'last_tiering_operation_status',
          last_tiering_operation_status_detail: 'last_tiering_operation_status_detail',
          archival_complete_time: Time.now,
          restore_expiry_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('storageTier', stub[:storage_tier].to_s) unless stub[:storage_tier].nil?
        xml << Hearth::XML::Node.new('lastTieringStartTime', Hearth::TimeHelper.to_date_time(stub[:last_tiering_start_time])) unless stub[:last_tiering_start_time].nil?
        xml << Hearth::XML::Node.new('lastTieringProgress', stub[:last_tiering_progress].to_s) unless stub[:last_tiering_progress].nil?
        xml << Hearth::XML::Node.new('lastTieringOperationStatus', stub[:last_tiering_operation_status].to_s) unless stub[:last_tiering_operation_status].nil?
        xml << Hearth::XML::Node.new('lastTieringOperationStatusDetail', stub[:last_tiering_operation_status_detail].to_s) unless stub[:last_tiering_operation_status_detail].nil?
        xml << Hearth::XML::Node.new('archivalCompleteTime', Hearth::TimeHelper.to_date_time(stub[:archival_complete_time])) unless stub[:archival_complete_time].nil?
        xml << Hearth::XML::Node.new('restoreExpiryTime', Hearth::TimeHelper.to_date_time(stub[:restore_expiry_time])) unless stub[:restore_expiry_time].nil?
        xml
      end
    end

    class SpotCapacityRebalance
      def self.default(visited = [])
        return nil if visited.include?('SpotCapacityRebalance')
        visited = visited + ['SpotCapacityRebalance']
        {
          replacement_strategy: 'replacement_strategy',
          termination_delay: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('replacementStrategy', stub[:replacement_strategy].to_s) unless stub[:replacement_strategy].nil?
        xml << Hearth::XML::Node.new('terminationDelay', stub[:termination_delay].to_s) unless stub[:termination_delay].nil?
        xml
      end
    end

    class SpotDatafeedSubscription
      def self.default(visited = [])
        return nil if visited.include?('SpotDatafeedSubscription')
        visited = visited + ['SpotDatafeedSubscription']
        {
          bucket: 'bucket',
          fault: SpotInstanceStateFault.default(visited),
          owner_id: 'owner_id',
          prefix: 'prefix',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('bucket', stub[:bucket].to_s) unless stub[:bucket].nil?
        xml << SpotInstanceStateFault.stub('fault', stub[:fault]) unless stub[:fault].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('prefix', stub[:prefix].to_s) unless stub[:prefix].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class SpotFleetLaunchSpecification
      def self.default(visited = [])
        return nil if visited.include?('SpotFleetLaunchSpecification')
        visited = visited + ['SpotFleetLaunchSpecification']
        {
          security_groups: GroupIdentifierList.default(visited),
          addressing_type: 'addressing_type',
          block_device_mappings: BlockDeviceMappingList.default(visited),
          ebs_optimized: false,
          iam_instance_profile: IamInstanceProfileSpecification.default(visited),
          image_id: 'image_id',
          instance_type: 'instance_type',
          kernel_id: 'kernel_id',
          key_name: 'key_name',
          monitoring: SpotFleetMonitoring.default(visited),
          network_interfaces: InstanceNetworkInterfaceSpecificationList.default(visited),
          placement: SpotPlacement.default(visited),
          ramdisk_id: 'ramdisk_id',
          spot_price: 'spot_price',
          subnet_id: 'subnet_id',
          user_data: 'user_data',
          weighted_capacity: 1.0,
          tag_specifications: SpotFleetTagSpecificationList.default(visited),
          instance_requirements: InstanceRequirements.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml << Hearth::XML::Node.new('addressingType', stub[:addressing_type].to_s) unless stub[:addressing_type].nil?
        xml << Hearth::XML::Node.new('blockDeviceMapping', BlockDeviceMappingList.stub('item', stub[:block_device_mappings])) unless stub[:block_device_mappings].nil?
        xml << Hearth::XML::Node.new('ebsOptimized', stub[:ebs_optimized].to_s) unless stub[:ebs_optimized].nil?
        xml << IamInstanceProfileSpecification.stub('iamInstanceProfile', stub[:iam_instance_profile]) unless stub[:iam_instance_profile].nil?
        xml << Hearth::XML::Node.new('imageId', stub[:image_id].to_s) unless stub[:image_id].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('kernelId', stub[:kernel_id].to_s) unless stub[:kernel_id].nil?
        xml << Hearth::XML::Node.new('keyName', stub[:key_name].to_s) unless stub[:key_name].nil?
        xml << SpotFleetMonitoring.stub('monitoring', stub[:monitoring]) unless stub[:monitoring].nil?
        xml << Hearth::XML::Node.new('networkInterfaceSet', InstanceNetworkInterfaceSpecificationList.stub('item', stub[:network_interfaces])) unless stub[:network_interfaces].nil?
        xml << SpotPlacement.stub('placement', stub[:placement]) unless stub[:placement].nil?
        xml << Hearth::XML::Node.new('ramdiskId', stub[:ramdisk_id].to_s) unless stub[:ramdisk_id].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('userData', stub[:user_data].to_s) unless stub[:user_data].nil?
        xml << Hearth::XML::Node.new('weightedCapacity', Hearth::NumberHelper.serialize(stub[:weighted_capacity]).to_s) unless stub[:weighted_capacity].nil?
        xml << Hearth::XML::Node.new('tagSpecificationSet', SpotFleetTagSpecificationList.stub('item', stub[:tag_specifications])) unless stub[:tag_specifications].nil?
        xml << InstanceRequirements.stub('instanceRequirements', stub[:instance_requirements]) unless stub[:instance_requirements].nil?
        xml
      end
    end

    class SpotFleetMonitoring
      def self.default(visited = [])
        return nil if visited.include?('SpotFleetMonitoring')
        visited = visited + ['SpotFleetMonitoring']
        {
          enabled: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml
      end
    end

    class SpotFleetRequestConfig
      def self.default(visited = [])
        return nil if visited.include?('SpotFleetRequestConfig')
        visited = visited + ['SpotFleetRequestConfig']
        {
          activity_status: 'activity_status',
          create_time: Time.now,
          spot_fleet_request_config: SpotFleetRequestConfigData.default(visited),
          spot_fleet_request_id: 'spot_fleet_request_id',
          spot_fleet_request_state: 'spot_fleet_request_state',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('activityStatus', stub[:activity_status].to_s) unless stub[:activity_status].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << SpotFleetRequestConfigData.stub('spotFleetRequestConfig', stub[:spot_fleet_request_config]) unless stub[:spot_fleet_request_config].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestId', stub[:spot_fleet_request_id].to_s) unless stub[:spot_fleet_request_id].nil?
        xml << Hearth::XML::Node.new('spotFleetRequestState', stub[:spot_fleet_request_state].to_s) unless stub[:spot_fleet_request_state].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class SpotFleetRequestConfigData
      def self.default(visited = [])
        return nil if visited.include?('SpotFleetRequestConfigData')
        visited = visited + ['SpotFleetRequestConfigData']
        {
          allocation_strategy: 'allocation_strategy',
          on_demand_allocation_strategy: 'on_demand_allocation_strategy',
          spot_maintenance_strategies: SpotMaintenanceStrategies.default(visited),
          client_token: 'client_token',
          excess_capacity_termination_policy: 'excess_capacity_termination_policy',
          fulfilled_capacity: 1.0,
          on_demand_fulfilled_capacity: 1.0,
          iam_fleet_role: 'iam_fleet_role',
          launch_specifications: LaunchSpecsList.default(visited),
          launch_template_configs: LaunchTemplateConfigList.default(visited),
          spot_price: 'spot_price',
          target_capacity: 1,
          on_demand_target_capacity: 1,
          on_demand_max_total_price: 'on_demand_max_total_price',
          spot_max_total_price: 'spot_max_total_price',
          terminate_instances_with_expiration: false,
          type: 'type',
          valid_from: Time.now,
          valid_until: Time.now,
          replace_unhealthy_instances: false,
          instance_interruption_behavior: 'instance_interruption_behavior',
          load_balancers_config: LoadBalancersConfig.default(visited),
          instance_pools_to_use_count: 1,
          context: 'context',
          target_capacity_unit_type: 'target_capacity_unit_type',
          tag_specifications: TagSpecificationList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << Hearth::XML::Node.new('onDemandAllocationStrategy', stub[:on_demand_allocation_strategy].to_s) unless stub[:on_demand_allocation_strategy].nil?
        xml << SpotMaintenanceStrategies.stub('spotMaintenanceStrategies', stub[:spot_maintenance_strategies]) unless stub[:spot_maintenance_strategies].nil?
        xml << Hearth::XML::Node.new('clientToken', stub[:client_token].to_s) unless stub[:client_token].nil?
        xml << Hearth::XML::Node.new('excessCapacityTerminationPolicy', stub[:excess_capacity_termination_policy].to_s) unless stub[:excess_capacity_termination_policy].nil?
        xml << Hearth::XML::Node.new('fulfilledCapacity', Hearth::NumberHelper.serialize(stub[:fulfilled_capacity]).to_s) unless stub[:fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('onDemandFulfilledCapacity', Hearth::NumberHelper.serialize(stub[:on_demand_fulfilled_capacity]).to_s) unless stub[:on_demand_fulfilled_capacity].nil?
        xml << Hearth::XML::Node.new('iamFleetRole', stub[:iam_fleet_role].to_s) unless stub[:iam_fleet_role].nil?
        xml << Hearth::XML::Node.new('launchSpecifications', LaunchSpecsList.stub('item', stub[:launch_specifications])) unless stub[:launch_specifications].nil?
        xml << Hearth::XML::Node.new('launchTemplateConfigs', LaunchTemplateConfigList.stub('item', stub[:launch_template_configs])) unless stub[:launch_template_configs].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('targetCapacity', stub[:target_capacity].to_s) unless stub[:target_capacity].nil?
        xml << Hearth::XML::Node.new('onDemandTargetCapacity', stub[:on_demand_target_capacity].to_s) unless stub[:on_demand_target_capacity].nil?
        xml << Hearth::XML::Node.new('onDemandMaxTotalPrice', stub[:on_demand_max_total_price].to_s) unless stub[:on_demand_max_total_price].nil?
        xml << Hearth::XML::Node.new('spotMaxTotalPrice', stub[:spot_max_total_price].to_s) unless stub[:spot_max_total_price].nil?
        xml << Hearth::XML::Node.new('terminateInstancesWithExpiration', stub[:terminate_instances_with_expiration].to_s) unless stub[:terminate_instances_with_expiration].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('validFrom', Hearth::TimeHelper.to_date_time(stub[:valid_from])) unless stub[:valid_from].nil?
        xml << Hearth::XML::Node.new('validUntil', Hearth::TimeHelper.to_date_time(stub[:valid_until])) unless stub[:valid_until].nil?
        xml << Hearth::XML::Node.new('replaceUnhealthyInstances', stub[:replace_unhealthy_instances].to_s) unless stub[:replace_unhealthy_instances].nil?
        xml << Hearth::XML::Node.new('instanceInterruptionBehavior', stub[:instance_interruption_behavior].to_s) unless stub[:instance_interruption_behavior].nil?
        xml << LoadBalancersConfig.stub('loadBalancersConfig', stub[:load_balancers_config]) unless stub[:load_balancers_config].nil?
        xml << Hearth::XML::Node.new('instancePoolsToUseCount', stub[:instance_pools_to_use_count].to_s) unless stub[:instance_pools_to_use_count].nil?
        xml << Hearth::XML::Node.new('context', stub[:context].to_s) unless stub[:context].nil?
        xml << Hearth::XML::Node.new('targetCapacityUnitType', stub[:target_capacity_unit_type].to_s) unless stub[:target_capacity_unit_type].nil?
        xml << Hearth::XML::Node.new('TagSpecification', TagSpecificationList.stub('item', stub[:tag_specifications])) unless stub[:tag_specifications].nil?
        xml
      end
    end

    class SpotFleetRequestConfigSet
      def self.default(visited = [])
        return nil if visited.include?('SpotFleetRequestConfigSet')
        visited = visited + ['SpotFleetRequestConfigSet']
        [
          SpotFleetRequestConfig.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotFleetRequestConfig.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SpotFleetTagSpecification
      def self.default(visited = [])
        return nil if visited.include?('SpotFleetTagSpecification')
        visited = visited + ['SpotFleetTagSpecification']
        {
          resource_type: 'resource_type',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('tag', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class SpotFleetTagSpecificationList
      def self.default(visited = [])
        return nil if visited.include?('SpotFleetTagSpecificationList')
        visited = visited + ['SpotFleetTagSpecificationList']
        [
          SpotFleetTagSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotFleetTagSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SpotInstanceRequest
      def self.default(visited = [])
        return nil if visited.include?('SpotInstanceRequest')
        visited = visited + ['SpotInstanceRequest']
        {
          actual_block_hourly_price: 'actual_block_hourly_price',
          availability_zone_group: 'availability_zone_group',
          block_duration_minutes: 1,
          create_time: Time.now,
          fault: SpotInstanceStateFault.default(visited),
          instance_id: 'instance_id',
          launch_group: 'launch_group',
          launch_specification: LaunchSpecification.default(visited),
          launched_availability_zone: 'launched_availability_zone',
          product_description: 'product_description',
          spot_instance_request_id: 'spot_instance_request_id',
          spot_price: 'spot_price',
          state: 'state',
          status: SpotInstanceStatus.default(visited),
          tags: TagList.default(visited),
          type: 'type',
          valid_from: Time.now,
          valid_until: Time.now,
          instance_interruption_behavior: 'instance_interruption_behavior',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('actualBlockHourlyPrice', stub[:actual_block_hourly_price].to_s) unless stub[:actual_block_hourly_price].nil?
        xml << Hearth::XML::Node.new('availabilityZoneGroup', stub[:availability_zone_group].to_s) unless stub[:availability_zone_group].nil?
        xml << Hearth::XML::Node.new('blockDurationMinutes', stub[:block_duration_minutes].to_s) unless stub[:block_duration_minutes].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << SpotInstanceStateFault.stub('fault', stub[:fault]) unless stub[:fault].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('launchGroup', stub[:launch_group].to_s) unless stub[:launch_group].nil?
        xml << LaunchSpecification.stub('launchSpecification', stub[:launch_specification]) unless stub[:launch_specification].nil?
        xml << Hearth::XML::Node.new('launchedAvailabilityZone', stub[:launched_availability_zone].to_s) unless stub[:launched_availability_zone].nil?
        xml << Hearth::XML::Node.new('productDescription', stub[:product_description].to_s) unless stub[:product_description].nil?
        xml << Hearth::XML::Node.new('spotInstanceRequestId', stub[:spot_instance_request_id].to_s) unless stub[:spot_instance_request_id].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << SpotInstanceStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('validFrom', Hearth::TimeHelper.to_date_time(stub[:valid_from])) unless stub[:valid_from].nil?
        xml << Hearth::XML::Node.new('validUntil', Hearth::TimeHelper.to_date_time(stub[:valid_until])) unless stub[:valid_until].nil?
        xml << Hearth::XML::Node.new('instanceInterruptionBehavior', stub[:instance_interruption_behavior].to_s) unless stub[:instance_interruption_behavior].nil?
        xml
      end
    end

    class SpotInstanceRequestList
      def self.default(visited = [])
        return nil if visited.include?('SpotInstanceRequestList')
        visited = visited + ['SpotInstanceRequestList']
        [
          SpotInstanceRequest.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotInstanceRequest.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SpotInstanceStateFault
      def self.default(visited = [])
        return nil if visited.include?('SpotInstanceStateFault')
        visited = visited + ['SpotInstanceStateFault']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class SpotInstanceStatus
      def self.default(visited = [])
        return nil if visited.include?('SpotInstanceStatus')
        visited = visited + ['SpotInstanceStatus']
        {
          code: 'code',
          message: 'message',
          update_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml << Hearth::XML::Node.new('updateTime', Hearth::TimeHelper.to_date_time(stub[:update_time])) unless stub[:update_time].nil?
        xml
      end
    end

    class SpotMaintenanceStrategies
      def self.default(visited = [])
        return nil if visited.include?('SpotMaintenanceStrategies')
        visited = visited + ['SpotMaintenanceStrategies']
        {
          capacity_rebalance: SpotCapacityRebalance.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << SpotCapacityRebalance.stub('capacityRebalance', stub[:capacity_rebalance]) unless stub[:capacity_rebalance].nil?
        xml
      end
    end

    class SpotOptions
      def self.default(visited = [])
        return nil if visited.include?('SpotOptions')
        visited = visited + ['SpotOptions']
        {
          allocation_strategy: 'allocation_strategy',
          maintenance_strategies: FleetSpotMaintenanceStrategies.default(visited),
          instance_interruption_behavior: 'instance_interruption_behavior',
          instance_pools_to_use_count: 1,
          single_instance_type: false,
          single_availability_zone: false,
          min_target_capacity: 1,
          max_total_price: 'max_total_price',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allocationStrategy', stub[:allocation_strategy].to_s) unless stub[:allocation_strategy].nil?
        xml << FleetSpotMaintenanceStrategies.stub('maintenanceStrategies', stub[:maintenance_strategies]) unless stub[:maintenance_strategies].nil?
        xml << Hearth::XML::Node.new('instanceInterruptionBehavior', stub[:instance_interruption_behavior].to_s) unless stub[:instance_interruption_behavior].nil?
        xml << Hearth::XML::Node.new('instancePoolsToUseCount', stub[:instance_pools_to_use_count].to_s) unless stub[:instance_pools_to_use_count].nil?
        xml << Hearth::XML::Node.new('singleInstanceType', stub[:single_instance_type].to_s) unless stub[:single_instance_type].nil?
        xml << Hearth::XML::Node.new('singleAvailabilityZone', stub[:single_availability_zone].to_s) unless stub[:single_availability_zone].nil?
        xml << Hearth::XML::Node.new('minTargetCapacity', stub[:min_target_capacity].to_s) unless stub[:min_target_capacity].nil?
        xml << Hearth::XML::Node.new('maxTotalPrice', stub[:max_total_price].to_s) unless stub[:max_total_price].nil?
        xml
      end
    end

    class SpotPlacement
      def self.default(visited = [])
        return nil if visited.include?('SpotPlacement')
        visited = visited + ['SpotPlacement']
        {
          availability_zone: 'availability_zone',
          group_name: 'group_name',
          tenancy: 'tenancy',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('tenancy', stub[:tenancy].to_s) unless stub[:tenancy].nil?
        xml
      end
    end

    class SpotPlacementScore
      def self.default(visited = [])
        return nil if visited.include?('SpotPlacementScore')
        visited = visited + ['SpotPlacementScore']
        {
          region: 'region',
          availability_zone_id: 'availability_zone_id',
          score: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('region', stub[:region].to_s) unless stub[:region].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('score', stub[:score].to_s) unless stub[:score].nil?
        xml
      end
    end

    class SpotPlacementScores
      def self.default(visited = [])
        return nil if visited.include?('SpotPlacementScores')
        visited = visited + ['SpotPlacementScores']
        [
          SpotPlacementScore.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotPlacementScore.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SpotPrice
      def self.default(visited = [])
        return nil if visited.include?('SpotPrice')
        visited = visited + ['SpotPrice']
        {
          availability_zone: 'availability_zone',
          instance_type: 'instance_type',
          product_description: 'product_description',
          spot_price: 'spot_price',
          timestamp: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('instanceType', stub[:instance_type].to_s) unless stub[:instance_type].nil?
        xml << Hearth::XML::Node.new('productDescription', stub[:product_description].to_s) unless stub[:product_description].nil?
        xml << Hearth::XML::Node.new('spotPrice', stub[:spot_price].to_s) unless stub[:spot_price].nil?
        xml << Hearth::XML::Node.new('timestamp', Hearth::TimeHelper.to_date_time(stub[:timestamp])) unless stub[:timestamp].nil?
        xml
      end
    end

    class SpotPriceHistoryList
      def self.default(visited = [])
        return nil if visited.include?('SpotPriceHistoryList')
        visited = visited + ['SpotPriceHistoryList']
        [
          SpotPrice.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SpotPrice.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class StaleIpPermission
      def self.default(visited = [])
        return nil if visited.include?('StaleIpPermission')
        visited = visited + ['StaleIpPermission']
        {
          from_port: 1,
          ip_protocol: 'ip_protocol',
          ip_ranges: IpRanges.default(visited),
          prefix_list_ids: PrefixListIdSet.default(visited),
          to_port: 1,
          user_id_group_pairs: UserIdGroupPairSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fromPort', stub[:from_port].to_s) unless stub[:from_port].nil?
        xml << Hearth::XML::Node.new('ipProtocol', stub[:ip_protocol].to_s) unless stub[:ip_protocol].nil?
        xml << Hearth::XML::Node.new('ipRanges', IpRanges.stub('item', stub[:ip_ranges])) unless stub[:ip_ranges].nil?
        xml << Hearth::XML::Node.new('prefixListIds', PrefixListIdSet.stub('item', stub[:prefix_list_ids])) unless stub[:prefix_list_ids].nil?
        xml << Hearth::XML::Node.new('toPort', stub[:to_port].to_s) unless stub[:to_port].nil?
        xml << Hearth::XML::Node.new('groups', UserIdGroupPairSet.stub('item', stub[:user_id_group_pairs])) unless stub[:user_id_group_pairs].nil?
        xml
      end
    end

    class StaleIpPermissionSet
      def self.default(visited = [])
        return nil if visited.include?('StaleIpPermissionSet')
        visited = visited + ['StaleIpPermissionSet']
        [
          StaleIpPermission.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << StaleIpPermission.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class StaleSecurityGroup
      def self.default(visited = [])
        return nil if visited.include?('StaleSecurityGroup')
        visited = visited + ['StaleSecurityGroup']
        {
          description: 'description',
          group_id: 'group_id',
          group_name: 'group_name',
          stale_ip_permissions: StaleIpPermissionSet.default(visited),
          stale_ip_permissions_egress: StaleIpPermissionSet.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('staleIpPermissions', StaleIpPermissionSet.stub('item', stub[:stale_ip_permissions])) unless stub[:stale_ip_permissions].nil?
        xml << Hearth::XML::Node.new('staleIpPermissionsEgress', StaleIpPermissionSet.stub('item', stub[:stale_ip_permissions_egress])) unless stub[:stale_ip_permissions_egress].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    class StaleSecurityGroupSet
      def self.default(visited = [])
        return nil if visited.include?('StaleSecurityGroupSet')
        visited = visited + ['StaleSecurityGroupSet']
        [
          StaleSecurityGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << StaleSecurityGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class StartInstances
      def self.build(params, context:)
        Params::StartInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::StartInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          starting_instances: InstanceStateChangeList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StartInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceStateChangeList.stub('item', stub[:starting_instances])) unless stub[:starting_instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class StartNetworkInsightsAccessScopeAnalysis
      def self.build(params, context:)
        Params::StartNetworkInsightsAccessScopeAnalysisOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::StartNetworkInsightsAccessScopeAnalysisOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_access_scope_analysis: NetworkInsightsAccessScopeAnalysis.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StartNetworkInsightsAccessScopeAnalysisResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsAccessScopeAnalysis.stub('networkInsightsAccessScopeAnalysis', stub[:network_insights_access_scope_analysis]) unless stub[:network_insights_access_scope_analysis].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class StartNetworkInsightsAnalysis
      def self.build(params, context:)
        Params::StartNetworkInsightsAnalysisOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::StartNetworkInsightsAnalysisOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_insights_analysis: NetworkInsightsAnalysis.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StartNetworkInsightsAnalysisResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << NetworkInsightsAnalysis.stub('networkInsightsAnalysis', stub[:network_insights_analysis]) unless stub[:network_insights_analysis].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class StartVpcEndpointServicePrivateDnsVerification
      def self.build(params, context:)
        Params::StartVpcEndpointServicePrivateDnsVerificationOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::StartVpcEndpointServicePrivateDnsVerificationOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return_value: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StartVpcEndpointServicePrivateDnsVerificationResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return_value].to_s) unless stub[:return_value].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class StateReason
      def self.default(visited = [])
        return nil if visited.include?('StateReason')
        visited = visited + ['StateReason']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class StopInstances
      def self.build(params, context:)
        Params::StopInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::StopInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          stopping_instances: InstanceStateChangeList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('StopInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceStateChangeList.stub('item', stub[:stopping_instances])) unless stub[:stopping_instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class Storage
      def self.default(visited = [])
        return nil if visited.include?('Storage')
        visited = visited + ['Storage']
        {
          s3: S3Storage.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << S3Storage.stub('S3', stub[:s3]) unless stub[:s3].nil?
        xml
      end
    end

    class StoreImageTaskResult
      def self.default(visited = [])
        return nil if visited.include?('StoreImageTaskResult')
        visited = visited + ['StoreImageTaskResult']
        {
          ami_id: 'ami_id',
          task_start_time: Time.now,
          bucket: 'bucket',
          s3object_key: 's3object_key',
          progress_percentage: 1,
          store_task_state: 'store_task_state',
          store_task_failure_reason: 'store_task_failure_reason',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('amiId', stub[:ami_id].to_s) unless stub[:ami_id].nil?
        xml << Hearth::XML::Node.new('taskStartTime', Hearth::TimeHelper.to_date_time(stub[:task_start_time])) unless stub[:task_start_time].nil?
        xml << Hearth::XML::Node.new('bucket', stub[:bucket].to_s) unless stub[:bucket].nil?
        xml << Hearth::XML::Node.new('s3objectKey', stub[:s3object_key].to_s) unless stub[:s3object_key].nil?
        xml << Hearth::XML::Node.new('progressPercentage', stub[:progress_percentage].to_s) unless stub[:progress_percentage].nil?
        xml << Hearth::XML::Node.new('storeTaskState', stub[:store_task_state].to_s) unless stub[:store_task_state].nil?
        xml << Hearth::XML::Node.new('storeTaskFailureReason', stub[:store_task_failure_reason].to_s) unless stub[:store_task_failure_reason].nil?
        xml
      end
    end

    class StoreImageTaskResultSet
      def self.default(visited = [])
        return nil if visited.include?('StoreImageTaskResultSet')
        visited = visited + ['StoreImageTaskResultSet']
        [
          StoreImageTaskResult.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << StoreImageTaskResult.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class StringList
      def self.default(visited = [])
        return nil if visited.include?('StringList')
        visited = visited + ['StringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class Subnet
      def self.default(visited = [])
        return nil if visited.include?('Subnet')
        visited = visited + ['Subnet']
        {
          availability_zone: 'availability_zone',
          availability_zone_id: 'availability_zone_id',
          available_ip_address_count: 1,
          cidr_block: 'cidr_block',
          default_for_az: false,
          enable_lni_at_device_index: 1,
          map_public_ip_on_launch: false,
          map_customer_owned_ip_on_launch: false,
          customer_owned_ipv4_pool: 'customer_owned_ipv4_pool',
          state: 'state',
          subnet_id: 'subnet_id',
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
          assign_ipv6_address_on_creation: false,
          ipv6_cidr_block_association_set: SubnetIpv6CidrBlockAssociationSet.default(visited),
          tags: TagList.default(visited),
          subnet_arn: 'subnet_arn',
          outpost_arn: 'outpost_arn',
          enable_dns64: false,
          ipv6_native: false,
          private_dns_name_options_on_launch: PrivateDnsNameOptionsOnLaunch.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('availabilityZoneId', stub[:availability_zone_id].to_s) unless stub[:availability_zone_id].nil?
        xml << Hearth::XML::Node.new('availableIpAddressCount', stub[:available_ip_address_count].to_s) unless stub[:available_ip_address_count].nil?
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << Hearth::XML::Node.new('defaultForAz', stub[:default_for_az].to_s) unless stub[:default_for_az].nil?
        xml << Hearth::XML::Node.new('enableLniAtDeviceIndex', stub[:enable_lni_at_device_index].to_s) unless stub[:enable_lni_at_device_index].nil?
        xml << Hearth::XML::Node.new('mapPublicIpOnLaunch', stub[:map_public_ip_on_launch].to_s) unless stub[:map_public_ip_on_launch].nil?
        xml << Hearth::XML::Node.new('mapCustomerOwnedIpOnLaunch', stub[:map_customer_owned_ip_on_launch].to_s) unless stub[:map_customer_owned_ip_on_launch].nil?
        xml << Hearth::XML::Node.new('customerOwnedIpv4Pool', stub[:customer_owned_ipv4_pool].to_s) unless stub[:customer_owned_ipv4_pool].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('assignIpv6AddressOnCreation', stub[:assign_ipv6_address_on_creation].to_s) unless stub[:assign_ipv6_address_on_creation].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlockAssociationSet', SubnetIpv6CidrBlockAssociationSet.stub('item', stub[:ipv6_cidr_block_association_set])) unless stub[:ipv6_cidr_block_association_set].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('subnetArn', stub[:subnet_arn].to_s) unless stub[:subnet_arn].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('enableDns64', stub[:enable_dns64].to_s) unless stub[:enable_dns64].nil?
        xml << Hearth::XML::Node.new('ipv6Native', stub[:ipv6_native].to_s) unless stub[:ipv6_native].nil?
        xml << PrivateDnsNameOptionsOnLaunch.stub('privateDnsNameOptionsOnLaunch', stub[:private_dns_name_options_on_launch]) unless stub[:private_dns_name_options_on_launch].nil?
        xml
      end
    end

    class SubnetAssociation
      def self.default(visited = [])
        return nil if visited.include?('SubnetAssociation')
        visited = visited + ['SubnetAssociation']
        {
          subnet_id: 'subnet_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class SubnetAssociationList
      def self.default(visited = [])
        return nil if visited.include?('SubnetAssociationList')
        visited = visited + ['SubnetAssociationList']
        [
          SubnetAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SubnetAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SubnetCidrBlockState
      def self.default(visited = [])
        return nil if visited.include?('SubnetCidrBlockState')
        visited = visited + ['SubnetCidrBlockState']
        {
          state: 'state',
          status_message: 'status_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml
      end
    end

    class SubnetCidrReservation
      def self.default(visited = [])
        return nil if visited.include?('SubnetCidrReservation')
        visited = visited + ['SubnetCidrReservation']
        {
          subnet_cidr_reservation_id: 'subnet_cidr_reservation_id',
          subnet_id: 'subnet_id',
          cidr: 'cidr',
          reservation_type: 'reservation_type',
          owner_id: 'owner_id',
          description: 'description',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('subnetCidrReservationId', stub[:subnet_cidr_reservation_id].to_s) unless stub[:subnet_cidr_reservation_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('cidr', stub[:cidr].to_s) unless stub[:cidr].nil?
        xml << Hearth::XML::Node.new('reservationType', stub[:reservation_type].to_s) unless stub[:reservation_type].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class SubnetCidrReservationList
      def self.default(visited = [])
        return nil if visited.include?('SubnetCidrReservationList')
        visited = visited + ['SubnetCidrReservationList']
        [
          SubnetCidrReservation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SubnetCidrReservation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SubnetIpv6CidrBlockAssociation
      def self.default(visited = [])
        return nil if visited.include?('SubnetIpv6CidrBlockAssociation')
        visited = visited + ['SubnetIpv6CidrBlockAssociation']
        {
          association_id: 'association_id',
          ipv6_cidr_block: 'ipv6_cidr_block',
          ipv6_cidr_block_state: SubnetCidrBlockState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlock', stub[:ipv6_cidr_block].to_s) unless stub[:ipv6_cidr_block].nil?
        xml << SubnetCidrBlockState.stub('ipv6CidrBlockState', stub[:ipv6_cidr_block_state]) unless stub[:ipv6_cidr_block_state].nil?
        xml
      end
    end

    class SubnetIpv6CidrBlockAssociationSet
      def self.default(visited = [])
        return nil if visited.include?('SubnetIpv6CidrBlockAssociationSet')
        visited = visited + ['SubnetIpv6CidrBlockAssociationSet']
        [
          SubnetIpv6CidrBlockAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SubnetIpv6CidrBlockAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SubnetList
      def self.default(visited = [])
        return nil if visited.include?('SubnetList')
        visited = visited + ['SubnetList']
        [
          Subnet.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Subnet.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Subscription
      def self.default(visited = [])
        return nil if visited.include?('Subscription')
        visited = visited + ['Subscription']
        {
          source: 'source',
          destination: 'destination',
          metric: 'metric',
          statistic: 'statistic',
          period: 'period',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('source', stub[:source].to_s) unless stub[:source].nil?
        xml << Hearth::XML::Node.new('destination', stub[:destination].to_s) unless stub[:destination].nil?
        xml << Hearth::XML::Node.new('metric', stub[:metric].to_s) unless stub[:metric].nil?
        xml << Hearth::XML::Node.new('statistic', stub[:statistic].to_s) unless stub[:statistic].nil?
        xml << Hearth::XML::Node.new('period', stub[:period].to_s) unless stub[:period].nil?
        xml
      end
    end

    class SubscriptionList
      def self.default(visited = [])
        return nil if visited.include?('SubscriptionList')
        visited = visited + ['SubscriptionList']
        [
          Subscription.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Subscription.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SuccessfulInstanceCreditSpecificationItem
      def self.default(visited = [])
        return nil if visited.include?('SuccessfulInstanceCreditSpecificationItem')
        visited = visited + ['SuccessfulInstanceCreditSpecificationItem']
        {
          instance_id: 'instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml
      end
    end

    class SuccessfulInstanceCreditSpecificationSet
      def self.default(visited = [])
        return nil if visited.include?('SuccessfulInstanceCreditSpecificationSet')
        visited = visited + ['SuccessfulInstanceCreditSpecificationSet']
        [
          SuccessfulInstanceCreditSpecificationItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SuccessfulInstanceCreditSpecificationItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SuccessfulQueuedPurchaseDeletion
      def self.default(visited = [])
        return nil if visited.include?('SuccessfulQueuedPurchaseDeletion')
        visited = visited + ['SuccessfulQueuedPurchaseDeletion']
        {
          reserved_instances_id: 'reserved_instances_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('reservedInstancesId', stub[:reserved_instances_id].to_s) unless stub[:reserved_instances_id].nil?
        xml
      end
    end

    class SuccessfulQueuedPurchaseDeletionSet
      def self.default(visited = [])
        return nil if visited.include?('SuccessfulQueuedPurchaseDeletionSet')
        visited = visited + ['SuccessfulQueuedPurchaseDeletionSet']
        [
          SuccessfulQueuedPurchaseDeletion.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SuccessfulQueuedPurchaseDeletion.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class SupportedAdditionalProcessorFeatureList
      def self.default(visited = [])
        return nil if visited.include?('SupportedAdditionalProcessorFeatureList')
        visited = visited + ['SupportedAdditionalProcessorFeatureList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class SupportedIpAddressTypes
      def self.default(visited = [])
        return nil if visited.include?('SupportedIpAddressTypes')
        visited = visited + ['SupportedIpAddressTypes']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class Tag
      def self.default(visited = [])
        return nil if visited.include?('Tag')
        visited = visited + ['Tag']
        {
          key: 'key',
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('key', stub[:key].to_s) unless stub[:key].nil?
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class TagDescription
      def self.default(visited = [])
        return nil if visited.include?('TagDescription')
        visited = visited + ['TagDescription']
        {
          key: 'key',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          value: 'value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('key', stub[:key].to_s) unless stub[:key].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('value', stub[:value].to_s) unless stub[:value].nil?
        xml
      end
    end

    class TagDescriptionList
      def self.default(visited = [])
        return nil if visited.include?('TagDescriptionList')
        visited = visited + ['TagDescriptionList']
        [
          TagDescription.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TagDescription.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TagList
      def self.default(visited = [])
        return nil if visited.include?('TagList')
        visited = visited + ['TagList']
        [
          Tag.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Tag.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TagSpecification
      def self.default(visited = [])
        return nil if visited.include?('TagSpecification')
        visited = visited + ['TagSpecification']
        {
          resource_type: 'resource_type',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('Tag', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TagSpecificationList
      def self.default(visited = [])
        return nil if visited.include?('TagSpecificationList')
        visited = visited + ['TagSpecificationList']
        [
          TagSpecification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TagSpecification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TargetCapacitySpecification
      def self.default(visited = [])
        return nil if visited.include?('TargetCapacitySpecification')
        visited = visited + ['TargetCapacitySpecification']
        {
          total_target_capacity: 1,
          on_demand_target_capacity: 1,
          spot_target_capacity: 1,
          default_target_capacity_type: 'default_target_capacity_type',
          target_capacity_unit_type: 'target_capacity_unit_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('totalTargetCapacity', stub[:total_target_capacity].to_s) unless stub[:total_target_capacity].nil?
        xml << Hearth::XML::Node.new('onDemandTargetCapacity', stub[:on_demand_target_capacity].to_s) unless stub[:on_demand_target_capacity].nil?
        xml << Hearth::XML::Node.new('spotTargetCapacity', stub[:spot_target_capacity].to_s) unless stub[:spot_target_capacity].nil?
        xml << Hearth::XML::Node.new('defaultTargetCapacityType', stub[:default_target_capacity_type].to_s) unless stub[:default_target_capacity_type].nil?
        xml << Hearth::XML::Node.new('targetCapacityUnitType', stub[:target_capacity_unit_type].to_s) unless stub[:target_capacity_unit_type].nil?
        xml
      end
    end

    class TargetConfiguration
      def self.default(visited = [])
        return nil if visited.include?('TargetConfiguration')
        visited = visited + ['TargetConfiguration']
        {
          instance_count: 1,
          offering_id: 'offering_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceCount', stub[:instance_count].to_s) unless stub[:instance_count].nil?
        xml << Hearth::XML::Node.new('offeringId', stub[:offering_id].to_s) unless stub[:offering_id].nil?
        xml
      end
    end

    class TargetGroup
      def self.default(visited = [])
        return nil if visited.include?('TargetGroup')
        visited = visited + ['TargetGroup']
        {
          arn: 'arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('arn', stub[:arn].to_s) unless stub[:arn].nil?
        xml
      end
    end

    class TargetGroups
      def self.default(visited = [])
        return nil if visited.include?('TargetGroups')
        visited = visited + ['TargetGroups']
        [
          TargetGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TargetGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TargetGroupsConfig
      def self.default(visited = [])
        return nil if visited.include?('TargetGroupsConfig')
        visited = visited + ['TargetGroupsConfig']
        {
          target_groups: TargetGroups.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('targetGroups', TargetGroups.stub('item', stub[:target_groups])) unless stub[:target_groups].nil?
        xml
      end
    end

    class TargetNetwork
      def self.default(visited = [])
        return nil if visited.include?('TargetNetwork')
        visited = visited + ['TargetNetwork']
        {
          association_id: 'association_id',
          vpc_id: 'vpc_id',
          target_network_id: 'target_network_id',
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          status: AssociationStatus.default(visited),
          security_groups: ValueStringList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('targetNetworkId', stub[:target_network_id].to_s) unless stub[:target_network_id].nil?
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << AssociationStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('securityGroups', ValueStringList.stub('item', stub[:security_groups])) unless stub[:security_groups].nil?
        xml
      end
    end

    class TargetNetworkSet
      def self.default(visited = [])
        return nil if visited.include?('TargetNetworkSet')
        visited = visited + ['TargetNetworkSet']
        [
          TargetNetwork.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TargetNetwork.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TargetReservationValue
      def self.default(visited = [])
        return nil if visited.include?('TargetReservationValue')
        visited = visited + ['TargetReservationValue']
        {
          reservation_value: ReservationValue.default(visited),
          target_configuration: TargetConfiguration.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << ReservationValue.stub('reservationValue', stub[:reservation_value]) unless stub[:reservation_value].nil?
        xml << TargetConfiguration.stub('targetConfiguration', stub[:target_configuration]) unless stub[:target_configuration].nil?
        xml
      end
    end

    class TargetReservationValueSet
      def self.default(visited = [])
        return nil if visited.include?('TargetReservationValueSet')
        visited = visited + ['TargetReservationValueSet']
        [
          TargetReservationValue.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TargetReservationValue.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TerminateClientVpnConnections
      def self.build(params, context:)
        Params::TerminateClientVpnConnectionsOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::TerminateClientVpnConnectionsOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          client_vpn_endpoint_id: 'client_vpn_endpoint_id',
          username: 'username',
          connection_statuses: TerminateConnectionStatusSet.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('TerminateClientVpnConnectionsResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('clientVpnEndpointId', stub[:client_vpn_endpoint_id].to_s) unless stub[:client_vpn_endpoint_id].nil?
        xml << Hearth::XML::Node.new('username', stub[:username].to_s) unless stub[:username].nil?
        xml << Hearth::XML::Node.new('connectionStatuses', TerminateConnectionStatusSet.stub('item', stub[:connection_statuses])) unless stub[:connection_statuses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class TerminateConnectionStatus
      def self.default(visited = [])
        return nil if visited.include?('TerminateConnectionStatus')
        visited = visited + ['TerminateConnectionStatus']
        {
          connection_id: 'connection_id',
          previous_status: ClientVpnConnectionStatus.default(visited),
          current_status: ClientVpnConnectionStatus.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('connectionId', stub[:connection_id].to_s) unless stub[:connection_id].nil?
        xml << ClientVpnConnectionStatus.stub('previousStatus', stub[:previous_status]) unless stub[:previous_status].nil?
        xml << ClientVpnConnectionStatus.stub('currentStatus', stub[:current_status]) unless stub[:current_status].nil?
        xml
      end
    end

    class TerminateConnectionStatusSet
      def self.default(visited = [])
        return nil if visited.include?('TerminateConnectionStatusSet')
        visited = visited + ['TerminateConnectionStatusSet']
        [
          TerminateConnectionStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TerminateConnectionStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TerminateInstances
      def self.build(params, context:)
        Params::TerminateInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::TerminateInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          terminating_instances: InstanceStateChangeList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('TerminateInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceStateChangeList.stub('item', stub[:terminating_instances])) unless stub[:terminating_instances].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class ThreadsPerCoreList
      def self.default(visited = [])
        return nil if visited.include?('ThreadsPerCoreList')
        visited = visited + ['ThreadsPerCoreList']
        [
          1
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class ThroughResourcesStatement
      def self.default(visited = [])
        return nil if visited.include?('ThroughResourcesStatement')
        visited = visited + ['ThroughResourcesStatement']
        {
          resource_statement: ResourceStatement.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << ResourceStatement.stub('resourceStatement', stub[:resource_statement]) unless stub[:resource_statement].nil?
        xml
      end
    end

    class ThroughResourcesStatementList
      def self.default(visited = [])
        return nil if visited.include?('ThroughResourcesStatementList')
        visited = visited + ['ThroughResourcesStatementList']
        [
          ThroughResourcesStatement.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << ThroughResourcesStatement.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TotalLocalStorageGB
      def self.default(visited = [])
        return nil if visited.include?('TotalLocalStorageGB')
        visited = visited + ['TotalLocalStorageGB']
        {
          min: 1.0,
          max: 1.0,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', Hearth::NumberHelper.serialize(stub[:min]).to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', Hearth::NumberHelper.serialize(stub[:max]).to_s) unless stub[:max].nil?
        xml
      end
    end

    class TrafficMirrorFilter
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorFilter')
        visited = visited + ['TrafficMirrorFilter']
        {
          traffic_mirror_filter_id: 'traffic_mirror_filter_id',
          ingress_filter_rules: TrafficMirrorFilterRuleList.default(visited),
          egress_filter_rules: TrafficMirrorFilterRuleList.default(visited),
          network_services: TrafficMirrorNetworkServiceList.default(visited),
          description: 'description',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('trafficMirrorFilterId', stub[:traffic_mirror_filter_id].to_s) unless stub[:traffic_mirror_filter_id].nil?
        xml << Hearth::XML::Node.new('ingressFilterRuleSet', TrafficMirrorFilterRuleList.stub('item', stub[:ingress_filter_rules])) unless stub[:ingress_filter_rules].nil?
        xml << Hearth::XML::Node.new('egressFilterRuleSet', TrafficMirrorFilterRuleList.stub('item', stub[:egress_filter_rules])) unless stub[:egress_filter_rules].nil?
        xml << Hearth::XML::Node.new('networkServiceSet', TrafficMirrorNetworkServiceList.stub('item', stub[:network_services])) unless stub[:network_services].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TrafficMirrorFilterRule
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorFilterRule')
        visited = visited + ['TrafficMirrorFilterRule']
        {
          traffic_mirror_filter_rule_id: 'traffic_mirror_filter_rule_id',
          traffic_mirror_filter_id: 'traffic_mirror_filter_id',
          traffic_direction: 'traffic_direction',
          rule_number: 1,
          rule_action: 'rule_action',
          protocol: 1,
          destination_port_range: TrafficMirrorPortRange.default(visited),
          source_port_range: TrafficMirrorPortRange.default(visited),
          destination_cidr_block: 'destination_cidr_block',
          source_cidr_block: 'source_cidr_block',
          description: 'description',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('trafficMirrorFilterRuleId', stub[:traffic_mirror_filter_rule_id].to_s) unless stub[:traffic_mirror_filter_rule_id].nil?
        xml << Hearth::XML::Node.new('trafficMirrorFilterId', stub[:traffic_mirror_filter_id].to_s) unless stub[:traffic_mirror_filter_id].nil?
        xml << Hearth::XML::Node.new('trafficDirection', stub[:traffic_direction].to_s) unless stub[:traffic_direction].nil?
        xml << Hearth::XML::Node.new('ruleNumber', stub[:rule_number].to_s) unless stub[:rule_number].nil?
        xml << Hearth::XML::Node.new('ruleAction', stub[:rule_action].to_s) unless stub[:rule_action].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << TrafficMirrorPortRange.stub('destinationPortRange', stub[:destination_port_range]) unless stub[:destination_port_range].nil?
        xml << TrafficMirrorPortRange.stub('sourcePortRange', stub[:source_port_range]) unless stub[:source_port_range].nil?
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('sourceCidrBlock', stub[:source_cidr_block].to_s) unless stub[:source_cidr_block].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml
      end
    end

    class TrafficMirrorFilterRuleList
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorFilterRuleList')
        visited = visited + ['TrafficMirrorFilterRuleList']
        [
          TrafficMirrorFilterRule.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrafficMirrorFilterRule.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TrafficMirrorFilterSet
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorFilterSet')
        visited = visited + ['TrafficMirrorFilterSet']
        [
          TrafficMirrorFilter.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrafficMirrorFilter.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TrafficMirrorNetworkServiceList
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorNetworkServiceList')
        visited = visited + ['TrafficMirrorNetworkServiceList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class TrafficMirrorPortRange
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorPortRange')
        visited = visited + ['TrafficMirrorPortRange']
        {
          from_port: 1,
          to_port: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('fromPort', stub[:from_port].to_s) unless stub[:from_port].nil?
        xml << Hearth::XML::Node.new('toPort', stub[:to_port].to_s) unless stub[:to_port].nil?
        xml
      end
    end

    class TrafficMirrorSession
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorSession')
        visited = visited + ['TrafficMirrorSession']
        {
          traffic_mirror_session_id: 'traffic_mirror_session_id',
          traffic_mirror_target_id: 'traffic_mirror_target_id',
          traffic_mirror_filter_id: 'traffic_mirror_filter_id',
          network_interface_id: 'network_interface_id',
          owner_id: 'owner_id',
          packet_length: 1,
          session_number: 1,
          virtual_network_id: 1,
          description: 'description',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('trafficMirrorSessionId', stub[:traffic_mirror_session_id].to_s) unless stub[:traffic_mirror_session_id].nil?
        xml << Hearth::XML::Node.new('trafficMirrorTargetId', stub[:traffic_mirror_target_id].to_s) unless stub[:traffic_mirror_target_id].nil?
        xml << Hearth::XML::Node.new('trafficMirrorFilterId', stub[:traffic_mirror_filter_id].to_s) unless stub[:traffic_mirror_filter_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('packetLength', stub[:packet_length].to_s) unless stub[:packet_length].nil?
        xml << Hearth::XML::Node.new('sessionNumber', stub[:session_number].to_s) unless stub[:session_number].nil?
        xml << Hearth::XML::Node.new('virtualNetworkId', stub[:virtual_network_id].to_s) unless stub[:virtual_network_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TrafficMirrorSessionSet
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorSessionSet')
        visited = visited + ['TrafficMirrorSessionSet']
        [
          TrafficMirrorSession.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrafficMirrorSession.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TrafficMirrorTarget
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorTarget')
        visited = visited + ['TrafficMirrorTarget']
        {
          traffic_mirror_target_id: 'traffic_mirror_target_id',
          network_interface_id: 'network_interface_id',
          network_load_balancer_arn: 'network_load_balancer_arn',
          type: 'type',
          description: 'description',
          owner_id: 'owner_id',
          tags: TagList.default(visited),
          gateway_load_balancer_endpoint_id: 'gateway_load_balancer_endpoint_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('trafficMirrorTargetId', stub[:traffic_mirror_target_id].to_s) unless stub[:traffic_mirror_target_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('networkLoadBalancerArn', stub[:network_load_balancer_arn].to_s) unless stub[:network_load_balancer_arn].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('gatewayLoadBalancerEndpointId', stub[:gateway_load_balancer_endpoint_id].to_s) unless stub[:gateway_load_balancer_endpoint_id].nil?
        xml
      end
    end

    class TrafficMirrorTargetSet
      def self.default(visited = [])
        return nil if visited.include?('TrafficMirrorTargetSet')
        visited = visited + ['TrafficMirrorTargetSet']
        [
          TrafficMirrorTarget.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrafficMirrorTarget.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGateway
      def self.default(visited = [])
        return nil if visited.include?('TransitGateway')
        visited = visited + ['TransitGateway']
        {
          transit_gateway_id: 'transit_gateway_id',
          transit_gateway_arn: 'transit_gateway_arn',
          state: 'state',
          owner_id: 'owner_id',
          description: 'description',
          creation_time: Time.now,
          options: TransitGatewayOptions.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayArn', stub[:transit_gateway_arn].to_s) unless stub[:transit_gateway_arn].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << TransitGatewayOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayAssociation
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayAssociation')
        visited = visited + ['TransitGatewayAssociation']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class TransitGatewayAttachment
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayAttachment')
        visited = visited + ['TransitGatewayAttachment']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          transit_gateway_id: 'transit_gateway_id',
          transit_gateway_owner_id: 'transit_gateway_owner_id',
          resource_owner_id: 'resource_owner_id',
          resource_type: 'resource_type',
          resource_id: 'resource_id',
          state: 'state',
          association: TransitGatewayAttachmentAssociation.default(visited),
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayOwnerId', stub[:transit_gateway_owner_id].to_s) unless stub[:transit_gateway_owner_id].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << TransitGatewayAttachmentAssociation.stub('association', stub[:association]) unless stub[:association].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayAttachmentAssociation
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayAttachmentAssociation')
        visited = visited + ['TransitGatewayAttachmentAssociation']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class TransitGatewayAttachmentBgpConfiguration
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayAttachmentBgpConfiguration')
        visited = visited + ['TransitGatewayAttachmentBgpConfiguration']
        {
          transit_gateway_asn: 1,
          peer_asn: 1,
          transit_gateway_address: 'transit_gateway_address',
          peer_address: 'peer_address',
          bgp_status: 'bgp_status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAsn', stub[:transit_gateway_asn].to_s) unless stub[:transit_gateway_asn].nil?
        xml << Hearth::XML::Node.new('peerAsn', stub[:peer_asn].to_s) unless stub[:peer_asn].nil?
        xml << Hearth::XML::Node.new('transitGatewayAddress', stub[:transit_gateway_address].to_s) unless stub[:transit_gateway_address].nil?
        xml << Hearth::XML::Node.new('peerAddress', stub[:peer_address].to_s) unless stub[:peer_address].nil?
        xml << Hearth::XML::Node.new('bgpStatus', stub[:bgp_status].to_s) unless stub[:bgp_status].nil?
        xml
      end
    end

    class TransitGatewayAttachmentBgpConfigurationList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayAttachmentBgpConfigurationList')
        visited = visited + ['TransitGatewayAttachmentBgpConfigurationList']
        [
          TransitGatewayAttachmentBgpConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayAttachmentBgpConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayAttachmentList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayAttachmentList')
        visited = visited + ['TransitGatewayAttachmentList']
        [
          TransitGatewayAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayAttachmentPropagation
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayAttachmentPropagation')
        visited = visited + ['TransitGatewayAttachmentPropagation']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class TransitGatewayAttachmentPropagationList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayAttachmentPropagationList')
        visited = visited + ['TransitGatewayAttachmentPropagationList']
        [
          TransitGatewayAttachmentPropagation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayAttachmentPropagation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayConnect
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayConnect')
        visited = visited + ['TransitGatewayConnect']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          transport_transit_gateway_attachment_id: 'transport_transit_gateway_attachment_id',
          transit_gateway_id: 'transit_gateway_id',
          state: 'state',
          creation_time: Time.now,
          options: TransitGatewayConnectOptions.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transportTransitGatewayAttachmentId', stub[:transport_transit_gateway_attachment_id].to_s) unless stub[:transport_transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << TransitGatewayConnectOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayConnectList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayConnectList')
        visited = visited + ['TransitGatewayConnectList']
        [
          TransitGatewayConnect.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayConnect.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayConnectOptions
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayConnectOptions')
        visited = visited + ['TransitGatewayConnectOptions']
        {
          protocol: 'protocol',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml
      end
    end

    class TransitGatewayConnectPeer
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayConnectPeer')
        visited = visited + ['TransitGatewayConnectPeer']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          transit_gateway_connect_peer_id: 'transit_gateway_connect_peer_id',
          state: 'state',
          creation_time: Time.now,
          connect_peer_configuration: TransitGatewayConnectPeerConfiguration.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayConnectPeerId', stub[:transit_gateway_connect_peer_id].to_s) unless stub[:transit_gateway_connect_peer_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << TransitGatewayConnectPeerConfiguration.stub('connectPeerConfiguration', stub[:connect_peer_configuration]) unless stub[:connect_peer_configuration].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayConnectPeerConfiguration
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayConnectPeerConfiguration')
        visited = visited + ['TransitGatewayConnectPeerConfiguration']
        {
          transit_gateway_address: 'transit_gateway_address',
          peer_address: 'peer_address',
          inside_cidr_blocks: InsideCidrBlocksStringList.default(visited),
          protocol: 'protocol',
          bgp_configurations: TransitGatewayAttachmentBgpConfigurationList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAddress', stub[:transit_gateway_address].to_s) unless stub[:transit_gateway_address].nil?
        xml << Hearth::XML::Node.new('peerAddress', stub[:peer_address].to_s) unless stub[:peer_address].nil?
        xml << Hearth::XML::Node.new('insideCidrBlocks', InsideCidrBlocksStringList.stub('item', stub[:inside_cidr_blocks])) unless stub[:inside_cidr_blocks].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('bgpConfigurations', TransitGatewayAttachmentBgpConfigurationList.stub('item', stub[:bgp_configurations])) unless stub[:bgp_configurations].nil?
        xml
      end
    end

    class TransitGatewayConnectPeerList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayConnectPeerList')
        visited = visited + ['TransitGatewayConnectPeerList']
        [
          TransitGatewayConnectPeer.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayConnectPeer.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayList')
        visited = visited + ['TransitGatewayList']
        [
          TransitGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayMulticastDeregisteredGroupMembers
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastDeregisteredGroupMembers')
        visited = visited + ['TransitGatewayMulticastDeregisteredGroupMembers']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          deregistered_network_interface_ids: ValueStringList.default(visited),
          group_ip_address: 'group_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('deregisteredNetworkInterfaceIds', ValueStringList.stub('item', stub[:deregistered_network_interface_ids])) unless stub[:deregistered_network_interface_ids].nil?
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml
      end
    end

    class TransitGatewayMulticastDeregisteredGroupSources
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastDeregisteredGroupSources')
        visited = visited + ['TransitGatewayMulticastDeregisteredGroupSources']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          deregistered_network_interface_ids: ValueStringList.default(visited),
          group_ip_address: 'group_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('deregisteredNetworkInterfaceIds', ValueStringList.stub('item', stub[:deregistered_network_interface_ids])) unless stub[:deregistered_network_interface_ids].nil?
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml
      end
    end

    class TransitGatewayMulticastDomain
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastDomain')
        visited = visited + ['TransitGatewayMulticastDomain']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          transit_gateway_id: 'transit_gateway_id',
          transit_gateway_multicast_domain_arn: 'transit_gateway_multicast_domain_arn',
          owner_id: 'owner_id',
          options: TransitGatewayMulticastDomainOptions.default(visited),
          state: 'state',
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainArn', stub[:transit_gateway_multicast_domain_arn].to_s) unless stub[:transit_gateway_multicast_domain_arn].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << TransitGatewayMulticastDomainOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayMulticastDomainAssociation
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastDomainAssociation')
        visited = visited + ['TransitGatewayMulticastDomainAssociation']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          resource_owner_id: 'resource_owner_id',
          subnet: SubnetAssociation.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << SubnetAssociation.stub('subnet', stub[:subnet]) unless stub[:subnet].nil?
        xml
      end
    end

    class TransitGatewayMulticastDomainAssociationList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastDomainAssociationList')
        visited = visited + ['TransitGatewayMulticastDomainAssociationList']
        [
          TransitGatewayMulticastDomainAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayMulticastDomainAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayMulticastDomainAssociations
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastDomainAssociations')
        visited = visited + ['TransitGatewayMulticastDomainAssociations']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          resource_owner_id: 'resource_owner_id',
          subnets: SubnetAssociationList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('subnets', SubnetAssociationList.stub('item', stub[:subnets])) unless stub[:subnets].nil?
        xml
      end
    end

    class TransitGatewayMulticastDomainList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastDomainList')
        visited = visited + ['TransitGatewayMulticastDomainList']
        [
          TransitGatewayMulticastDomain.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayMulticastDomain.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayMulticastDomainOptions
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastDomainOptions')
        visited = visited + ['TransitGatewayMulticastDomainOptions']
        {
          igmpv2_support: 'igmpv2_support',
          static_sources_support: 'static_sources_support',
          auto_accept_shared_associations: 'auto_accept_shared_associations',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('igmpv2Support', stub[:igmpv2_support].to_s) unless stub[:igmpv2_support].nil?
        xml << Hearth::XML::Node.new('staticSourcesSupport', stub[:static_sources_support].to_s) unless stub[:static_sources_support].nil?
        xml << Hearth::XML::Node.new('autoAcceptSharedAssociations', stub[:auto_accept_shared_associations].to_s) unless stub[:auto_accept_shared_associations].nil?
        xml
      end
    end

    class TransitGatewayMulticastGroup
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastGroup')
        visited = visited + ['TransitGatewayMulticastGroup']
        {
          group_ip_address: 'group_ip_address',
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          subnet_id: 'subnet_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          resource_owner_id: 'resource_owner_id',
          network_interface_id: 'network_interface_id',
          group_member: false,
          group_source: false,
          member_type: 'member_type',
          source_type: 'source_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('subnetId', stub[:subnet_id].to_s) unless stub[:subnet_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceOwnerId', stub[:resource_owner_id].to_s) unless stub[:resource_owner_id].nil?
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('groupMember', stub[:group_member].to_s) unless stub[:group_member].nil?
        xml << Hearth::XML::Node.new('groupSource', stub[:group_source].to_s) unless stub[:group_source].nil?
        xml << Hearth::XML::Node.new('memberType', stub[:member_type].to_s) unless stub[:member_type].nil?
        xml << Hearth::XML::Node.new('sourceType', stub[:source_type].to_s) unless stub[:source_type].nil?
        xml
      end
    end

    class TransitGatewayMulticastGroupList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastGroupList')
        visited = visited + ['TransitGatewayMulticastGroupList']
        [
          TransitGatewayMulticastGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayMulticastGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayMulticastRegisteredGroupMembers
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastRegisteredGroupMembers')
        visited = visited + ['TransitGatewayMulticastRegisteredGroupMembers']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          registered_network_interface_ids: ValueStringList.default(visited),
          group_ip_address: 'group_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('registeredNetworkInterfaceIds', ValueStringList.stub('item', stub[:registered_network_interface_ids])) unless stub[:registered_network_interface_ids].nil?
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml
      end
    end

    class TransitGatewayMulticastRegisteredGroupSources
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayMulticastRegisteredGroupSources')
        visited = visited + ['TransitGatewayMulticastRegisteredGroupSources']
        {
          transit_gateway_multicast_domain_id: 'transit_gateway_multicast_domain_id',
          registered_network_interface_ids: ValueStringList.default(visited),
          group_ip_address: 'group_ip_address',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayMulticastDomainId', stub[:transit_gateway_multicast_domain_id].to_s) unless stub[:transit_gateway_multicast_domain_id].nil?
        xml << Hearth::XML::Node.new('registeredNetworkInterfaceIds', ValueStringList.stub('item', stub[:registered_network_interface_ids])) unless stub[:registered_network_interface_ids].nil?
        xml << Hearth::XML::Node.new('groupIpAddress', stub[:group_ip_address].to_s) unless stub[:group_ip_address].nil?
        xml
      end
    end

    class TransitGatewayOptions
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayOptions')
        visited = visited + ['TransitGatewayOptions']
        {
          amazon_side_asn: 1,
          transit_gateway_cidr_blocks: ValueStringList.default(visited),
          auto_accept_shared_attachments: 'auto_accept_shared_attachments',
          default_route_table_association: 'default_route_table_association',
          association_default_route_table_id: 'association_default_route_table_id',
          default_route_table_propagation: 'default_route_table_propagation',
          propagation_default_route_table_id: 'propagation_default_route_table_id',
          vpn_ecmp_support: 'vpn_ecmp_support',
          dns_support: 'dns_support',
          multicast_support: 'multicast_support',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('amazonSideAsn', stub[:amazon_side_asn].to_s) unless stub[:amazon_side_asn].nil?
        xml << Hearth::XML::Node.new('transitGatewayCidrBlocks', ValueStringList.stub('item', stub[:transit_gateway_cidr_blocks])) unless stub[:transit_gateway_cidr_blocks].nil?
        xml << Hearth::XML::Node.new('autoAcceptSharedAttachments', stub[:auto_accept_shared_attachments].to_s) unless stub[:auto_accept_shared_attachments].nil?
        xml << Hearth::XML::Node.new('defaultRouteTableAssociation', stub[:default_route_table_association].to_s) unless stub[:default_route_table_association].nil?
        xml << Hearth::XML::Node.new('associationDefaultRouteTableId', stub[:association_default_route_table_id].to_s) unless stub[:association_default_route_table_id].nil?
        xml << Hearth::XML::Node.new('defaultRouteTablePropagation', stub[:default_route_table_propagation].to_s) unless stub[:default_route_table_propagation].nil?
        xml << Hearth::XML::Node.new('propagationDefaultRouteTableId', stub[:propagation_default_route_table_id].to_s) unless stub[:propagation_default_route_table_id].nil?
        xml << Hearth::XML::Node.new('vpnEcmpSupport', stub[:vpn_ecmp_support].to_s) unless stub[:vpn_ecmp_support].nil?
        xml << Hearth::XML::Node.new('dnsSupport', stub[:dns_support].to_s) unless stub[:dns_support].nil?
        xml << Hearth::XML::Node.new('multicastSupport', stub[:multicast_support].to_s) unless stub[:multicast_support].nil?
        xml
      end
    end

    class TransitGatewayPeeringAttachment
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPeeringAttachment')
        visited = visited + ['TransitGatewayPeeringAttachment']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          accepter_transit_gateway_attachment_id: 'accepter_transit_gateway_attachment_id',
          requester_tgw_info: PeeringTgwInfo.default(visited),
          accepter_tgw_info: PeeringTgwInfo.default(visited),
          options: TransitGatewayPeeringAttachmentOptions.default(visited),
          status: PeeringAttachmentStatus.default(visited),
          state: 'state',
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('accepterTransitGatewayAttachmentId', stub[:accepter_transit_gateway_attachment_id].to_s) unless stub[:accepter_transit_gateway_attachment_id].nil?
        xml << PeeringTgwInfo.stub('requesterTgwInfo', stub[:requester_tgw_info]) unless stub[:requester_tgw_info].nil?
        xml << PeeringTgwInfo.stub('accepterTgwInfo', stub[:accepter_tgw_info]) unless stub[:accepter_tgw_info].nil?
        xml << TransitGatewayPeeringAttachmentOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << PeeringAttachmentStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayPeeringAttachmentList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPeeringAttachmentList')
        visited = visited + ['TransitGatewayPeeringAttachmentList']
        [
          TransitGatewayPeeringAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayPeeringAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayPeeringAttachmentOptions
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPeeringAttachmentOptions')
        visited = visited + ['TransitGatewayPeeringAttachmentOptions']
        {
          dynamic_routing: 'dynamic_routing',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dynamicRouting', stub[:dynamic_routing].to_s) unless stub[:dynamic_routing].nil?
        xml
      end
    end

    class TransitGatewayPolicyRule
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPolicyRule')
        visited = visited + ['TransitGatewayPolicyRule']
        {
          source_cidr_block: 'source_cidr_block',
          source_port_range: 'source_port_range',
          destination_cidr_block: 'destination_cidr_block',
          destination_port_range: 'destination_port_range',
          protocol: 'protocol',
          meta_data: TransitGatewayPolicyRuleMetaData.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('sourceCidrBlock', stub[:source_cidr_block].to_s) unless stub[:source_cidr_block].nil?
        xml << Hearth::XML::Node.new('sourcePortRange', stub[:source_port_range].to_s) unless stub[:source_port_range].nil?
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('destinationPortRange', stub[:destination_port_range].to_s) unless stub[:destination_port_range].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << TransitGatewayPolicyRuleMetaData.stub('metaData', stub[:meta_data]) unless stub[:meta_data].nil?
        xml
      end
    end

    class TransitGatewayPolicyRuleMetaData
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPolicyRuleMetaData')
        visited = visited + ['TransitGatewayPolicyRuleMetaData']
        {
          meta_data_key: 'meta_data_key',
          meta_data_value: 'meta_data_value',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('metaDataKey', stub[:meta_data_key].to_s) unless stub[:meta_data_key].nil?
        xml << Hearth::XML::Node.new('metaDataValue', stub[:meta_data_value].to_s) unless stub[:meta_data_value].nil?
        xml
      end
    end

    class TransitGatewayPolicyTable
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPolicyTable')
        visited = visited + ['TransitGatewayPolicyTable']
        {
          transit_gateway_policy_table_id: 'transit_gateway_policy_table_id',
          transit_gateway_id: 'transit_gateway_id',
          state: 'state',
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayPolicyTableId', stub[:transit_gateway_policy_table_id].to_s) unless stub[:transit_gateway_policy_table_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayPolicyTableAssociation
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPolicyTableAssociation')
        visited = visited + ['TransitGatewayPolicyTableAssociation']
        {
          transit_gateway_policy_table_id: 'transit_gateway_policy_table_id',
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayPolicyTableId', stub[:transit_gateway_policy_table_id].to_s) unless stub[:transit_gateway_policy_table_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class TransitGatewayPolicyTableAssociationList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPolicyTableAssociationList')
        visited = visited + ['TransitGatewayPolicyTableAssociationList']
        [
          TransitGatewayPolicyTableAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayPolicyTableAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayPolicyTableEntry
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPolicyTableEntry')
        visited = visited + ['TransitGatewayPolicyTableEntry']
        {
          policy_rule_number: 'policy_rule_number',
          policy_rule: TransitGatewayPolicyRule.default(visited),
          target_route_table_id: 'target_route_table_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('policyRuleNumber', stub[:policy_rule_number].to_s) unless stub[:policy_rule_number].nil?
        xml << TransitGatewayPolicyRule.stub('policyRule', stub[:policy_rule]) unless stub[:policy_rule].nil?
        xml << Hearth::XML::Node.new('targetRouteTableId', stub[:target_route_table_id].to_s) unless stub[:target_route_table_id].nil?
        xml
      end
    end

    class TransitGatewayPolicyTableEntryList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPolicyTableEntryList')
        visited = visited + ['TransitGatewayPolicyTableEntryList']
        [
          TransitGatewayPolicyTableEntry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayPolicyTableEntry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayPolicyTableList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPolicyTableList')
        visited = visited + ['TransitGatewayPolicyTableList']
        [
          TransitGatewayPolicyTable.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayPolicyTable.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayPrefixListAttachment
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPrefixListAttachment')
        visited = visited + ['TransitGatewayPrefixListAttachment']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_type: 'resource_type',
          resource_id: 'resource_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml
      end
    end

    class TransitGatewayPrefixListReference
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPrefixListReference')
        visited = visited + ['TransitGatewayPrefixListReference']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          prefix_list_id: 'prefix_list_id',
          prefix_list_owner_id: 'prefix_list_owner_id',
          state: 'state',
          blackhole: false,
          transit_gateway_attachment: TransitGatewayPrefixListAttachment.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('prefixListOwnerId', stub[:prefix_list_owner_id].to_s) unless stub[:prefix_list_owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('blackhole', stub[:blackhole].to_s) unless stub[:blackhole].nil?
        xml << TransitGatewayPrefixListAttachment.stub('transitGatewayAttachment', stub[:transit_gateway_attachment]) unless stub[:transit_gateway_attachment].nil?
        xml
      end
    end

    class TransitGatewayPrefixListReferenceSet
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPrefixListReferenceSet')
        visited = visited + ['TransitGatewayPrefixListReferenceSet']
        [
          TransitGatewayPrefixListReference.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayPrefixListReference.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayPropagation
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayPropagation')
        visited = visited + ['TransitGatewayPropagation']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          state: 'state',
          transit_gateway_route_table_announcement_id: 'transit_gateway_route_table_announcement_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('transitGatewayRouteTableAnnouncementId', stub[:transit_gateway_route_table_announcement_id].to_s) unless stub[:transit_gateway_route_table_announcement_id].nil?
        xml
      end
    end

    class TransitGatewayRoute
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRoute')
        visited = visited + ['TransitGatewayRoute']
        {
          destination_cidr_block: 'destination_cidr_block',
          prefix_list_id: 'prefix_list_id',
          transit_gateway_route_table_announcement_id: 'transit_gateway_route_table_announcement_id',
          transit_gateway_attachments: TransitGatewayRouteAttachmentList.default(visited),
          type: 'type',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayRouteTableAnnouncementId', stub[:transit_gateway_route_table_announcement_id].to_s) unless stub[:transit_gateway_route_table_announcement_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachments', TransitGatewayRouteAttachmentList.stub('item', stub[:transit_gateway_attachments])) unless stub[:transit_gateway_attachments].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class TransitGatewayRouteAttachment
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteAttachment')
        visited = visited + ['TransitGatewayRouteAttachment']
        {
          resource_id: 'resource_id',
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_type: 'resource_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml
      end
    end

    class TransitGatewayRouteAttachmentList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteAttachmentList')
        visited = visited + ['TransitGatewayRouteAttachmentList']
        [
          TransitGatewayRouteAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRouteAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayRouteList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteList')
        visited = visited + ['TransitGatewayRouteList']
        [
          TransitGatewayRoute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRoute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayRouteTable
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteTable')
        visited = visited + ['TransitGatewayRouteTable']
        {
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          transit_gateway_id: 'transit_gateway_id',
          state: 'state',
          default_association_route_table: false,
          default_propagation_route_table: false,
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('defaultAssociationRouteTable', stub[:default_association_route_table].to_s) unless stub[:default_association_route_table].nil?
        xml << Hearth::XML::Node.new('defaultPropagationRouteTable', stub[:default_propagation_route_table].to_s) unless stub[:default_propagation_route_table].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayRouteTableAnnouncement
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteTableAnnouncement')
        visited = visited + ['TransitGatewayRouteTableAnnouncement']
        {
          transit_gateway_route_table_announcement_id: 'transit_gateway_route_table_announcement_id',
          transit_gateway_id: 'transit_gateway_id',
          core_network_id: 'core_network_id',
          peer_transit_gateway_id: 'peer_transit_gateway_id',
          peer_core_network_id: 'peer_core_network_id',
          peering_attachment_id: 'peering_attachment_id',
          announcement_direction: 'announcement_direction',
          transit_gateway_route_table_id: 'transit_gateway_route_table_id',
          state: 'state',
          creation_time: Time.now,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayRouteTableAnnouncementId', stub[:transit_gateway_route_table_announcement_id].to_s) unless stub[:transit_gateway_route_table_announcement_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('coreNetworkId', stub[:core_network_id].to_s) unless stub[:core_network_id].nil?
        xml << Hearth::XML::Node.new('peerTransitGatewayId', stub[:peer_transit_gateway_id].to_s) unless stub[:peer_transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('peerCoreNetworkId', stub[:peer_core_network_id].to_s) unless stub[:peer_core_network_id].nil?
        xml << Hearth::XML::Node.new('peeringAttachmentId', stub[:peering_attachment_id].to_s) unless stub[:peering_attachment_id].nil?
        xml << Hearth::XML::Node.new('announcementDirection', stub[:announcement_direction].to_s) unless stub[:announcement_direction].nil?
        xml << Hearth::XML::Node.new('transitGatewayRouteTableId', stub[:transit_gateway_route_table_id].to_s) unless stub[:transit_gateway_route_table_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayRouteTableAnnouncementList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteTableAnnouncementList')
        visited = visited + ['TransitGatewayRouteTableAnnouncementList']
        [
          TransitGatewayRouteTableAnnouncement.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRouteTableAnnouncement.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayRouteTableAssociation
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteTableAssociation')
        visited = visited + ['TransitGatewayRouteTableAssociation']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class TransitGatewayRouteTableAssociationList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteTableAssociationList')
        visited = visited + ['TransitGatewayRouteTableAssociationList']
        [
          TransitGatewayRouteTableAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRouteTableAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayRouteTableList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteTableList')
        visited = visited + ['TransitGatewayRouteTableList']
        [
          TransitGatewayRouteTable.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRouteTable.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayRouteTablePropagation
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteTablePropagation')
        visited = visited + ['TransitGatewayRouteTablePropagation']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
          state: 'state',
          transit_gateway_route_table_announcement_id: 'transit_gateway_route_table_announcement_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('transitGatewayRouteTableAnnouncementId', stub[:transit_gateway_route_table_announcement_id].to_s) unless stub[:transit_gateway_route_table_announcement_id].nil?
        xml
      end
    end

    class TransitGatewayRouteTablePropagationList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteTablePropagationList')
        visited = visited + ['TransitGatewayRouteTablePropagationList']
        [
          TransitGatewayRouteTablePropagation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayRouteTablePropagation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayRouteTableRoute
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayRouteTableRoute')
        visited = visited + ['TransitGatewayRouteTableRoute']
        {
          destination_cidr: 'destination_cidr',
          state: 'state',
          route_origin: 'route_origin',
          prefix_list_id: 'prefix_list_id',
          attachment_id: 'attachment_id',
          resource_id: 'resource_id',
          resource_type: 'resource_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidr', stub[:destination_cidr].to_s) unless stub[:destination_cidr].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('routeOrigin', stub[:route_origin].to_s) unless stub[:route_origin].nil?
        xml << Hearth::XML::Node.new('prefixListId', stub[:prefix_list_id].to_s) unless stub[:prefix_list_id].nil?
        xml << Hearth::XML::Node.new('attachmentId', stub[:attachment_id].to_s) unless stub[:attachment_id].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml << Hearth::XML::Node.new('resourceType', stub[:resource_type].to_s) unless stub[:resource_type].nil?
        xml
      end
    end

    class TransitGatewayVpcAttachment
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayVpcAttachment')
        visited = visited + ['TransitGatewayVpcAttachment']
        {
          transit_gateway_attachment_id: 'transit_gateway_attachment_id',
          transit_gateway_id: 'transit_gateway_id',
          vpc_id: 'vpc_id',
          vpc_owner_id: 'vpc_owner_id',
          state: 'state',
          subnet_ids: ValueStringList.default(visited),
          creation_time: Time.now,
          options: TransitGatewayVpcAttachmentOptions.default(visited),
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('transitGatewayAttachmentId', stub[:transit_gateway_attachment_id].to_s) unless stub[:transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('vpcOwnerId', stub[:vpc_owner_id].to_s) unless stub[:vpc_owner_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('subnetIds', ValueStringList.stub('item', stub[:subnet_ids])) unless stub[:subnet_ids].nil?
        xml << Hearth::XML::Node.new('creationTime', Hearth::TimeHelper.to_date_time(stub[:creation_time])) unless stub[:creation_time].nil?
        xml << TransitGatewayVpcAttachmentOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TransitGatewayVpcAttachmentList
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayVpcAttachmentList')
        visited = visited + ['TransitGatewayVpcAttachmentList']
        [
          TransitGatewayVpcAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TransitGatewayVpcAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TransitGatewayVpcAttachmentOptions
      def self.default(visited = [])
        return nil if visited.include?('TransitGatewayVpcAttachmentOptions')
        visited = visited + ['TransitGatewayVpcAttachmentOptions']
        {
          dns_support: 'dns_support',
          ipv6_support: 'ipv6_support',
          appliance_mode_support: 'appliance_mode_support',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('dnsSupport', stub[:dns_support].to_s) unless stub[:dns_support].nil?
        xml << Hearth::XML::Node.new('ipv6Support', stub[:ipv6_support].to_s) unless stub[:ipv6_support].nil?
        xml << Hearth::XML::Node.new('applianceModeSupport', stub[:appliance_mode_support].to_s) unless stub[:appliance_mode_support].nil?
        xml
      end
    end

    class TrunkInterfaceAssociation
      def self.default(visited = [])
        return nil if visited.include?('TrunkInterfaceAssociation')
        visited = visited + ['TrunkInterfaceAssociation']
        {
          association_id: 'association_id',
          branch_interface_id: 'branch_interface_id',
          trunk_interface_id: 'trunk_interface_id',
          interface_protocol: 'interface_protocol',
          vlan_id: 1,
          gre_key: 1,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('branchInterfaceId', stub[:branch_interface_id].to_s) unless stub[:branch_interface_id].nil?
        xml << Hearth::XML::Node.new('trunkInterfaceId', stub[:trunk_interface_id].to_s) unless stub[:trunk_interface_id].nil?
        xml << Hearth::XML::Node.new('interfaceProtocol', stub[:interface_protocol].to_s) unless stub[:interface_protocol].nil?
        xml << Hearth::XML::Node.new('vlanId', stub[:vlan_id].to_s) unless stub[:vlan_id].nil?
        xml << Hearth::XML::Node.new('greKey', stub[:gre_key].to_s) unless stub[:gre_key].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class TrunkInterfaceAssociationList
      def self.default(visited = [])
        return nil if visited.include?('TrunkInterfaceAssociationList')
        visited = visited + ['TrunkInterfaceAssociationList']
        [
          TrunkInterfaceAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TrunkInterfaceAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class TunnelOption
      def self.default(visited = [])
        return nil if visited.include?('TunnelOption')
        visited = visited + ['TunnelOption']
        {
          outside_ip_address: 'outside_ip_address',
          tunnel_inside_cidr: 'tunnel_inside_cidr',
          tunnel_inside_ipv6_cidr: 'tunnel_inside_ipv6_cidr',
          pre_shared_key: 'pre_shared_key',
          phase1_lifetime_seconds: 1,
          phase2_lifetime_seconds: 1,
          rekey_margin_time_seconds: 1,
          rekey_fuzz_percentage: 1,
          replay_window_size: 1,
          dpd_timeout_seconds: 1,
          dpd_timeout_action: 'dpd_timeout_action',
          phase1_encryption_algorithms: Phase1EncryptionAlgorithmsList.default(visited),
          phase2_encryption_algorithms: Phase2EncryptionAlgorithmsList.default(visited),
          phase1_integrity_algorithms: Phase1IntegrityAlgorithmsList.default(visited),
          phase2_integrity_algorithms: Phase2IntegrityAlgorithmsList.default(visited),
          phase1_dh_group_numbers: Phase1DHGroupNumbersList.default(visited),
          phase2_dh_group_numbers: Phase2DHGroupNumbersList.default(visited),
          ike_versions: IKEVersionsList.default(visited),
          startup_action: 'startup_action',
          log_options: VpnTunnelLogOptions.default(visited),
          enable_tunnel_lifecycle_control: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('outsideIpAddress', stub[:outside_ip_address].to_s) unless stub[:outside_ip_address].nil?
        xml << Hearth::XML::Node.new('tunnelInsideCidr', stub[:tunnel_inside_cidr].to_s) unless stub[:tunnel_inside_cidr].nil?
        xml << Hearth::XML::Node.new('tunnelInsideIpv6Cidr', stub[:tunnel_inside_ipv6_cidr].to_s) unless stub[:tunnel_inside_ipv6_cidr].nil?
        xml << Hearth::XML::Node.new('preSharedKey', stub[:pre_shared_key].to_s) unless stub[:pre_shared_key].nil?
        xml << Hearth::XML::Node.new('phase1LifetimeSeconds', stub[:phase1_lifetime_seconds].to_s) unless stub[:phase1_lifetime_seconds].nil?
        xml << Hearth::XML::Node.new('phase2LifetimeSeconds', stub[:phase2_lifetime_seconds].to_s) unless stub[:phase2_lifetime_seconds].nil?
        xml << Hearth::XML::Node.new('rekeyMarginTimeSeconds', stub[:rekey_margin_time_seconds].to_s) unless stub[:rekey_margin_time_seconds].nil?
        xml << Hearth::XML::Node.new('rekeyFuzzPercentage', stub[:rekey_fuzz_percentage].to_s) unless stub[:rekey_fuzz_percentage].nil?
        xml << Hearth::XML::Node.new('replayWindowSize', stub[:replay_window_size].to_s) unless stub[:replay_window_size].nil?
        xml << Hearth::XML::Node.new('dpdTimeoutSeconds', stub[:dpd_timeout_seconds].to_s) unless stub[:dpd_timeout_seconds].nil?
        xml << Hearth::XML::Node.new('dpdTimeoutAction', stub[:dpd_timeout_action].to_s) unless stub[:dpd_timeout_action].nil?
        xml << Hearth::XML::Node.new('phase1EncryptionAlgorithmSet', Phase1EncryptionAlgorithmsList.stub('item', stub[:phase1_encryption_algorithms])) unless stub[:phase1_encryption_algorithms].nil?
        xml << Hearth::XML::Node.new('phase2EncryptionAlgorithmSet', Phase2EncryptionAlgorithmsList.stub('item', stub[:phase2_encryption_algorithms])) unless stub[:phase2_encryption_algorithms].nil?
        xml << Hearth::XML::Node.new('phase1IntegrityAlgorithmSet', Phase1IntegrityAlgorithmsList.stub('item', stub[:phase1_integrity_algorithms])) unless stub[:phase1_integrity_algorithms].nil?
        xml << Hearth::XML::Node.new('phase2IntegrityAlgorithmSet', Phase2IntegrityAlgorithmsList.stub('item', stub[:phase2_integrity_algorithms])) unless stub[:phase2_integrity_algorithms].nil?
        xml << Hearth::XML::Node.new('phase1DHGroupNumberSet', Phase1DHGroupNumbersList.stub('item', stub[:phase1_dh_group_numbers])) unless stub[:phase1_dh_group_numbers].nil?
        xml << Hearth::XML::Node.new('phase2DHGroupNumberSet', Phase2DHGroupNumbersList.stub('item', stub[:phase2_dh_group_numbers])) unless stub[:phase2_dh_group_numbers].nil?
        xml << Hearth::XML::Node.new('ikeVersionSet', IKEVersionsList.stub('item', stub[:ike_versions])) unless stub[:ike_versions].nil?
        xml << Hearth::XML::Node.new('startupAction', stub[:startup_action].to_s) unless stub[:startup_action].nil?
        xml << VpnTunnelLogOptions.stub('logOptions', stub[:log_options]) unless stub[:log_options].nil?
        xml << Hearth::XML::Node.new('enableTunnelLifecycleControl', stub[:enable_tunnel_lifecycle_control].to_s) unless stub[:enable_tunnel_lifecycle_control].nil?
        xml
      end
    end

    class TunnelOptionsList
      def self.default(visited = [])
        return nil if visited.include?('TunnelOptionsList')
        visited = visited + ['TunnelOptionsList']
        [
          TunnelOption.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << TunnelOption.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class UnassignIpv6Addresses
      def self.build(params, context:)
        Params::UnassignIpv6AddressesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::UnassignIpv6AddressesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          network_interface_id: 'network_interface_id',
          unassigned_ipv6_addresses: Ipv6AddressList.default(visited),
          unassigned_ipv6_prefixes: IpPrefixList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UnassignIpv6AddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('unassignedIpv6Addresses', Ipv6AddressList.stub('item', stub[:unassigned_ipv6_addresses])) unless stub[:unassigned_ipv6_addresses].nil?
        xml << Hearth::XML::Node.new('unassignedIpv6PrefixSet', IpPrefixList.stub('item', stub[:unassigned_ipv6_prefixes])) unless stub[:unassigned_ipv6_prefixes].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class UnassignPrivateIpAddresses
      def self.build(params, context:)
        Params::UnassignPrivateIpAddressesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::UnassignPrivateIpAddressesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UnassignPrivateIpAddressesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class UnassignPrivateNatGatewayAddress
      def self.build(params, context:)
        Params::UnassignPrivateNatGatewayAddressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::UnassignPrivateNatGatewayAddressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          nat_gateway_id: 'nat_gateway_id',
          nat_gateway_addresses: NatGatewayAddressList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UnassignPrivateNatGatewayAddressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('natGatewayId', stub[:nat_gateway_id].to_s) unless stub[:nat_gateway_id].nil?
        xml << Hearth::XML::Node.new('natGatewayAddressSet', NatGatewayAddressList.stub('item', stub[:nat_gateway_addresses])) unless stub[:nat_gateway_addresses].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class UnmonitorInstances
      def self.build(params, context:)
        Params::UnmonitorInstancesOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::UnmonitorInstancesOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          instance_monitorings: InstanceMonitoringList.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UnmonitorInstancesResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('instancesSet', InstanceMonitoringList.stub('item', stub[:instance_monitorings])) unless stub[:instance_monitorings].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class UnsuccessfulInstanceCreditSpecificationItem
      def self.default(visited = [])
        return nil if visited.include?('UnsuccessfulInstanceCreditSpecificationItem')
        visited = visited + ['UnsuccessfulInstanceCreditSpecificationItem']
        {
          instance_id: 'instance_id',
          error: UnsuccessfulInstanceCreditSpecificationItemError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << UnsuccessfulInstanceCreditSpecificationItemError.stub('error', stub[:error]) unless stub[:error].nil?
        xml
      end
    end

    class UnsuccessfulInstanceCreditSpecificationItemError
      def self.default(visited = [])
        return nil if visited.include?('UnsuccessfulInstanceCreditSpecificationItemError')
        visited = visited + ['UnsuccessfulInstanceCreditSpecificationItemError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class UnsuccessfulInstanceCreditSpecificationSet
      def self.default(visited = [])
        return nil if visited.include?('UnsuccessfulInstanceCreditSpecificationSet')
        visited = visited + ['UnsuccessfulInstanceCreditSpecificationSet']
        [
          UnsuccessfulInstanceCreditSpecificationItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UnsuccessfulInstanceCreditSpecificationItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class UnsuccessfulItem
      def self.default(visited = [])
        return nil if visited.include?('UnsuccessfulItem')
        visited = visited + ['UnsuccessfulItem']
        {
          error: UnsuccessfulItemError.default(visited),
          resource_id: 'resource_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << UnsuccessfulItemError.stub('error', stub[:error]) unless stub[:error].nil?
        xml << Hearth::XML::Node.new('resourceId', stub[:resource_id].to_s) unless stub[:resource_id].nil?
        xml
      end
    end

    class UnsuccessfulItemError
      def self.default(visited = [])
        return nil if visited.include?('UnsuccessfulItemError')
        visited = visited + ['UnsuccessfulItemError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class UnsuccessfulItemList
      def self.default(visited = [])
        return nil if visited.include?('UnsuccessfulItemList')
        visited = visited + ['UnsuccessfulItemList']
        [
          UnsuccessfulItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UnsuccessfulItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class UnsuccessfulItemSet
      def self.default(visited = [])
        return nil if visited.include?('UnsuccessfulItemSet')
        visited = visited + ['UnsuccessfulItemSet']
        [
          UnsuccessfulItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UnsuccessfulItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class UpdateSecurityGroupRuleDescriptionsEgress
      def self.build(params, context:)
        Params::UpdateSecurityGroupRuleDescriptionsEgressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::UpdateSecurityGroupRuleDescriptionsEgressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UpdateSecurityGroupRuleDescriptionsEgressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class UpdateSecurityGroupRuleDescriptionsIngress
      def self.build(params, context:)
        Params::UpdateSecurityGroupRuleDescriptionsIngressOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::UpdateSecurityGroupRuleDescriptionsIngressOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          return: false,
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('UpdateSecurityGroupRuleDescriptionsIngressResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << Hearth::XML::Node.new('return', stub[:return].to_s) unless stub[:return].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class UsageClassTypeList
      def self.default(visited = [])
        return nil if visited.include?('UsageClassTypeList')
        visited = visited + ['UsageClassTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class UserBucketDetails
      def self.default(visited = [])
        return nil if visited.include?('UserBucketDetails')
        visited = visited + ['UserBucketDetails']
        {
          s3_bucket: 's3_bucket',
          s3_key: 's3_key',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('s3Bucket', stub[:s3_bucket].to_s) unless stub[:s3_bucket].nil?
        xml << Hearth::XML::Node.new('s3Key', stub[:s3_key].to_s) unless stub[:s3_key].nil?
        xml
      end
    end

    class UserIdGroupPair
      def self.default(visited = [])
        return nil if visited.include?('UserIdGroupPair')
        visited = visited + ['UserIdGroupPair']
        {
          description: 'description',
          group_id: 'group_id',
          group_name: 'group_name',
          peering_status: 'peering_status',
          user_id: 'user_id',
          vpc_id: 'vpc_id',
          vpc_peering_connection_id: 'vpc_peering_connection_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('groupId', stub[:group_id].to_s) unless stub[:group_id].nil?
        xml << Hearth::XML::Node.new('groupName', stub[:group_name].to_s) unless stub[:group_name].nil?
        xml << Hearth::XML::Node.new('peeringStatus', stub[:peering_status].to_s) unless stub[:peering_status].nil?
        xml << Hearth::XML::Node.new('userId', stub[:user_id].to_s) unless stub[:user_id].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml
      end
    end

    class UserIdGroupPairList
      def self.default(visited = [])
        return nil if visited.include?('UserIdGroupPairList')
        visited = visited + ['UserIdGroupPairList']
        [
          UserIdGroupPair.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UserIdGroupPair.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class UserIdGroupPairSet
      def self.default(visited = [])
        return nil if visited.include?('UserIdGroupPairSet')
        visited = visited + ['UserIdGroupPairSet']
        [
          UserIdGroupPair.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << UserIdGroupPair.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VCpuCountRange
      def self.default(visited = [])
        return nil if visited.include?('VCpuCountRange')
        visited = visited + ['VCpuCountRange']
        {
          min: 1,
          max: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('min', stub[:min].to_s) unless stub[:min].nil?
        xml << Hearth::XML::Node.new('max', stub[:max].to_s) unless stub[:max].nil?
        xml
      end
    end

    class VCpuInfo
      def self.default(visited = [])
        return nil if visited.include?('VCpuInfo')
        visited = visited + ['VCpuInfo']
        {
          default_v_cpus: 1,
          default_cores: 1,
          default_threads_per_core: 1,
          valid_cores: CoreCountList.default(visited),
          valid_threads_per_core: ThreadsPerCoreList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('defaultVCpus', stub[:default_v_cpus].to_s) unless stub[:default_v_cpus].nil?
        xml << Hearth::XML::Node.new('defaultCores', stub[:default_cores].to_s) unless stub[:default_cores].nil?
        xml << Hearth::XML::Node.new('defaultThreadsPerCore', stub[:default_threads_per_core].to_s) unless stub[:default_threads_per_core].nil?
        xml << Hearth::XML::Node.new('validCores', CoreCountList.stub('item', stub[:valid_cores])) unless stub[:valid_cores].nil?
        xml << Hearth::XML::Node.new('validThreadsPerCore', ThreadsPerCoreList.stub('item', stub[:valid_threads_per_core])) unless stub[:valid_threads_per_core].nil?
        xml
      end
    end

    class ValidationError
      def self.default(visited = [])
        return nil if visited.include?('ValidationError')
        visited = visited + ['ValidationError']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class ValidationWarning
      def self.default(visited = [])
        return nil if visited.include?('ValidationWarning')
        visited = visited + ['ValidationWarning']
        {
          errors: ErrorSet.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('errorSet', ErrorSet.stub('item', stub[:errors])) unless stub[:errors].nil?
        xml
      end
    end

    class ValueStringList
      def self.default(visited = [])
        return nil if visited.include?('ValueStringList')
        visited = visited + ['ValueStringList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class VerifiedAccessEndpoint
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessEndpoint')
        visited = visited + ['VerifiedAccessEndpoint']
        {
          verified_access_instance_id: 'verified_access_instance_id',
          verified_access_group_id: 'verified_access_group_id',
          verified_access_endpoint_id: 'verified_access_endpoint_id',
          application_domain: 'application_domain',
          endpoint_type: 'endpoint_type',
          attachment_type: 'attachment_type',
          domain_certificate_arn: 'domain_certificate_arn',
          endpoint_domain: 'endpoint_domain',
          device_validation_domain: 'device_validation_domain',
          security_group_ids: SecurityGroupIdList.default(visited),
          load_balancer_options: VerifiedAccessEndpointLoadBalancerOptions.default(visited),
          network_interface_options: VerifiedAccessEndpointEniOptions.default(visited),
          status: VerifiedAccessEndpointStatus.default(visited),
          description: 'description',
          creation_time: 'creation_time',
          last_updated_time: 'last_updated_time',
          deletion_time: 'deletion_time',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('verifiedAccessInstanceId', stub[:verified_access_instance_id].to_s) unless stub[:verified_access_instance_id].nil?
        xml << Hearth::XML::Node.new('verifiedAccessGroupId', stub[:verified_access_group_id].to_s) unless stub[:verified_access_group_id].nil?
        xml << Hearth::XML::Node.new('verifiedAccessEndpointId', stub[:verified_access_endpoint_id].to_s) unless stub[:verified_access_endpoint_id].nil?
        xml << Hearth::XML::Node.new('applicationDomain', stub[:application_domain].to_s) unless stub[:application_domain].nil?
        xml << Hearth::XML::Node.new('endpointType', stub[:endpoint_type].to_s) unless stub[:endpoint_type].nil?
        xml << Hearth::XML::Node.new('attachmentType', stub[:attachment_type].to_s) unless stub[:attachment_type].nil?
        xml << Hearth::XML::Node.new('domainCertificateArn', stub[:domain_certificate_arn].to_s) unless stub[:domain_certificate_arn].nil?
        xml << Hearth::XML::Node.new('endpointDomain', stub[:endpoint_domain].to_s) unless stub[:endpoint_domain].nil?
        xml << Hearth::XML::Node.new('deviceValidationDomain', stub[:device_validation_domain].to_s) unless stub[:device_validation_domain].nil?
        xml << Hearth::XML::Node.new('securityGroupIdSet', SecurityGroupIdList.stub('item', stub[:security_group_ids])) unless stub[:security_group_ids].nil?
        xml << VerifiedAccessEndpointLoadBalancerOptions.stub('loadBalancerOptions', stub[:load_balancer_options]) unless stub[:load_balancer_options].nil?
        xml << VerifiedAccessEndpointEniOptions.stub('networkInterfaceOptions', stub[:network_interface_options]) unless stub[:network_interface_options].nil?
        xml << VerifiedAccessEndpointStatus.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('creationTime', stub[:creation_time].to_s) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('lastUpdatedTime', stub[:last_updated_time].to_s) unless stub[:last_updated_time].nil?
        xml << Hearth::XML::Node.new('deletionTime', stub[:deletion_time].to_s) unless stub[:deletion_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class VerifiedAccessEndpointEniOptions
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessEndpointEniOptions')
        visited = visited + ['VerifiedAccessEndpointEniOptions']
        {
          network_interface_id: 'network_interface_id',
          protocol: 'protocol',
          port: 1,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('networkInterfaceId', stub[:network_interface_id].to_s) unless stub[:network_interface_id].nil?
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('port', stub[:port].to_s) unless stub[:port].nil?
        xml
      end
    end

    class VerifiedAccessEndpointList
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessEndpointList')
        visited = visited + ['VerifiedAccessEndpointList']
        [
          VerifiedAccessEndpoint.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VerifiedAccessEndpoint.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VerifiedAccessEndpointLoadBalancerOptions
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessEndpointLoadBalancerOptions')
        visited = visited + ['VerifiedAccessEndpointLoadBalancerOptions']
        {
          protocol: 'protocol',
          port: 1,
          load_balancer_arn: 'load_balancer_arn',
          subnet_ids: VerifiedAccessEndpointSubnetIdList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('protocol', stub[:protocol].to_s) unless stub[:protocol].nil?
        xml << Hearth::XML::Node.new('port', stub[:port].to_s) unless stub[:port].nil?
        xml << Hearth::XML::Node.new('loadBalancerArn', stub[:load_balancer_arn].to_s) unless stub[:load_balancer_arn].nil?
        xml << Hearth::XML::Node.new('subnetIdSet', VerifiedAccessEndpointSubnetIdList.stub('item', stub[:subnet_ids])) unless stub[:subnet_ids].nil?
        xml
      end
    end

    class VerifiedAccessEndpointStatus
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessEndpointStatus')
        visited = visited + ['VerifiedAccessEndpointStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class VerifiedAccessEndpointSubnetIdList
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessEndpointSubnetIdList')
        visited = visited + ['VerifiedAccessEndpointSubnetIdList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class VerifiedAccessGroup
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessGroup')
        visited = visited + ['VerifiedAccessGroup']
        {
          verified_access_group_id: 'verified_access_group_id',
          verified_access_instance_id: 'verified_access_instance_id',
          description: 'description',
          owner: 'owner',
          verified_access_group_arn: 'verified_access_group_arn',
          creation_time: 'creation_time',
          last_updated_time: 'last_updated_time',
          deletion_time: 'deletion_time',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('verifiedAccessGroupId', stub[:verified_access_group_id].to_s) unless stub[:verified_access_group_id].nil?
        xml << Hearth::XML::Node.new('verifiedAccessInstanceId', stub[:verified_access_instance_id].to_s) unless stub[:verified_access_instance_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('owner', stub[:owner].to_s) unless stub[:owner].nil?
        xml << Hearth::XML::Node.new('verifiedAccessGroupArn', stub[:verified_access_group_arn].to_s) unless stub[:verified_access_group_arn].nil?
        xml << Hearth::XML::Node.new('creationTime', stub[:creation_time].to_s) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('lastUpdatedTime', stub[:last_updated_time].to_s) unless stub[:last_updated_time].nil?
        xml << Hearth::XML::Node.new('deletionTime', stub[:deletion_time].to_s) unless stub[:deletion_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class VerifiedAccessGroupList
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessGroupList')
        visited = visited + ['VerifiedAccessGroupList']
        [
          VerifiedAccessGroup.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VerifiedAccessGroup.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VerifiedAccessInstance
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessInstance')
        visited = visited + ['VerifiedAccessInstance']
        {
          verified_access_instance_id: 'verified_access_instance_id',
          description: 'description',
          verified_access_trust_providers: VerifiedAccessTrustProviderCondensedList.default(visited),
          creation_time: 'creation_time',
          last_updated_time: 'last_updated_time',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('verifiedAccessInstanceId', stub[:verified_access_instance_id].to_s) unless stub[:verified_access_instance_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('verifiedAccessTrustProviderSet', VerifiedAccessTrustProviderCondensedList.stub('item', stub[:verified_access_trust_providers])) unless stub[:verified_access_trust_providers].nil?
        xml << Hearth::XML::Node.new('creationTime', stub[:creation_time].to_s) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('lastUpdatedTime', stub[:last_updated_time].to_s) unless stub[:last_updated_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class VerifiedAccessInstanceList
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessInstanceList')
        visited = visited + ['VerifiedAccessInstanceList']
        [
          VerifiedAccessInstance.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VerifiedAccessInstance.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VerifiedAccessInstanceLoggingConfiguration
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessInstanceLoggingConfiguration')
        visited = visited + ['VerifiedAccessInstanceLoggingConfiguration']
        {
          verified_access_instance_id: 'verified_access_instance_id',
          access_logs: VerifiedAccessLogs.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('verifiedAccessInstanceId', stub[:verified_access_instance_id].to_s) unless stub[:verified_access_instance_id].nil?
        xml << VerifiedAccessLogs.stub('accessLogs', stub[:access_logs]) unless stub[:access_logs].nil?
        xml
      end
    end

    class VerifiedAccessInstanceLoggingConfigurationList
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessInstanceLoggingConfigurationList')
        visited = visited + ['VerifiedAccessInstanceLoggingConfigurationList']
        [
          VerifiedAccessInstanceLoggingConfiguration.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VerifiedAccessInstanceLoggingConfiguration.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VerifiedAccessLogCloudWatchLogsDestination
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessLogCloudWatchLogsDestination')
        visited = visited + ['VerifiedAccessLogCloudWatchLogsDestination']
        {
          enabled: false,
          delivery_status: VerifiedAccessLogDeliveryStatus.default(visited),
          log_group: 'log_group',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml << VerifiedAccessLogDeliveryStatus.stub('deliveryStatus', stub[:delivery_status]) unless stub[:delivery_status].nil?
        xml << Hearth::XML::Node.new('logGroup', stub[:log_group].to_s) unless stub[:log_group].nil?
        xml
      end
    end

    class VerifiedAccessLogDeliveryStatus
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessLogDeliveryStatus')
        visited = visited + ['VerifiedAccessLogDeliveryStatus']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class VerifiedAccessLogKinesisDataFirehoseDestination
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessLogKinesisDataFirehoseDestination')
        visited = visited + ['VerifiedAccessLogKinesisDataFirehoseDestination']
        {
          enabled: false,
          delivery_status: VerifiedAccessLogDeliveryStatus.default(visited),
          delivery_stream: 'delivery_stream',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml << VerifiedAccessLogDeliveryStatus.stub('deliveryStatus', stub[:delivery_status]) unless stub[:delivery_status].nil?
        xml << Hearth::XML::Node.new('deliveryStream', stub[:delivery_stream].to_s) unless stub[:delivery_stream].nil?
        xml
      end
    end

    class VerifiedAccessLogS3Destination
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessLogS3Destination')
        visited = visited + ['VerifiedAccessLogS3Destination']
        {
          enabled: false,
          delivery_status: VerifiedAccessLogDeliveryStatus.default(visited),
          bucket_name: 'bucket_name',
          prefix: 'prefix',
          bucket_owner: 'bucket_owner',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enabled', stub[:enabled].to_s) unless stub[:enabled].nil?
        xml << VerifiedAccessLogDeliveryStatus.stub('deliveryStatus', stub[:delivery_status]) unless stub[:delivery_status].nil?
        xml << Hearth::XML::Node.new('bucketName', stub[:bucket_name].to_s) unless stub[:bucket_name].nil?
        xml << Hearth::XML::Node.new('prefix', stub[:prefix].to_s) unless stub[:prefix].nil?
        xml << Hearth::XML::Node.new('bucketOwner', stub[:bucket_owner].to_s) unless stub[:bucket_owner].nil?
        xml
      end
    end

    class VerifiedAccessLogs
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessLogs')
        visited = visited + ['VerifiedAccessLogs']
        {
          s3: VerifiedAccessLogS3Destination.default(visited),
          cloud_watch_logs: VerifiedAccessLogCloudWatchLogsDestination.default(visited),
          kinesis_data_firehose: VerifiedAccessLogKinesisDataFirehoseDestination.default(visited),
          log_version: 'log_version',
          include_trust_context: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << VerifiedAccessLogS3Destination.stub('s3', stub[:s3]) unless stub[:s3].nil?
        xml << VerifiedAccessLogCloudWatchLogsDestination.stub('cloudWatchLogs', stub[:cloud_watch_logs]) unless stub[:cloud_watch_logs].nil?
        xml << VerifiedAccessLogKinesisDataFirehoseDestination.stub('kinesisDataFirehose', stub[:kinesis_data_firehose]) unless stub[:kinesis_data_firehose].nil?
        xml << Hearth::XML::Node.new('logVersion', stub[:log_version].to_s) unless stub[:log_version].nil?
        xml << Hearth::XML::Node.new('includeTrustContext', stub[:include_trust_context].to_s) unless stub[:include_trust_context].nil?
        xml
      end
    end

    class VerifiedAccessTrustProvider
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessTrustProvider')
        visited = visited + ['VerifiedAccessTrustProvider']
        {
          verified_access_trust_provider_id: 'verified_access_trust_provider_id',
          description: 'description',
          trust_provider_type: 'trust_provider_type',
          user_trust_provider_type: 'user_trust_provider_type',
          device_trust_provider_type: 'device_trust_provider_type',
          oidc_options: OidcOptions.default(visited),
          device_options: DeviceOptions.default(visited),
          policy_reference_name: 'policy_reference_name',
          creation_time: 'creation_time',
          last_updated_time: 'last_updated_time',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('verifiedAccessTrustProviderId', stub[:verified_access_trust_provider_id].to_s) unless stub[:verified_access_trust_provider_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('trustProviderType', stub[:trust_provider_type].to_s) unless stub[:trust_provider_type].nil?
        xml << Hearth::XML::Node.new('userTrustProviderType', stub[:user_trust_provider_type].to_s) unless stub[:user_trust_provider_type].nil?
        xml << Hearth::XML::Node.new('deviceTrustProviderType', stub[:device_trust_provider_type].to_s) unless stub[:device_trust_provider_type].nil?
        xml << OidcOptions.stub('oidcOptions', stub[:oidc_options]) unless stub[:oidc_options].nil?
        xml << DeviceOptions.stub('deviceOptions', stub[:device_options]) unless stub[:device_options].nil?
        xml << Hearth::XML::Node.new('policyReferenceName', stub[:policy_reference_name].to_s) unless stub[:policy_reference_name].nil?
        xml << Hearth::XML::Node.new('creationTime', stub[:creation_time].to_s) unless stub[:creation_time].nil?
        xml << Hearth::XML::Node.new('lastUpdatedTime', stub[:last_updated_time].to_s) unless stub[:last_updated_time].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class VerifiedAccessTrustProviderCondensed
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessTrustProviderCondensed')
        visited = visited + ['VerifiedAccessTrustProviderCondensed']
        {
          verified_access_trust_provider_id: 'verified_access_trust_provider_id',
          description: 'description',
          trust_provider_type: 'trust_provider_type',
          user_trust_provider_type: 'user_trust_provider_type',
          device_trust_provider_type: 'device_trust_provider_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('verifiedAccessTrustProviderId', stub[:verified_access_trust_provider_id].to_s) unless stub[:verified_access_trust_provider_id].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('trustProviderType', stub[:trust_provider_type].to_s) unless stub[:trust_provider_type].nil?
        xml << Hearth::XML::Node.new('userTrustProviderType', stub[:user_trust_provider_type].to_s) unless stub[:user_trust_provider_type].nil?
        xml << Hearth::XML::Node.new('deviceTrustProviderType', stub[:device_trust_provider_type].to_s) unless stub[:device_trust_provider_type].nil?
        xml
      end
    end

    class VerifiedAccessTrustProviderCondensedList
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessTrustProviderCondensedList')
        visited = visited + ['VerifiedAccessTrustProviderCondensedList']
        [
          VerifiedAccessTrustProviderCondensed.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VerifiedAccessTrustProviderCondensed.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VerifiedAccessTrustProviderList
      def self.default(visited = [])
        return nil if visited.include?('VerifiedAccessTrustProviderList')
        visited = visited + ['VerifiedAccessTrustProviderList']
        [
          VerifiedAccessTrustProvider.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VerifiedAccessTrustProvider.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VgwTelemetry
      def self.default(visited = [])
        return nil if visited.include?('VgwTelemetry')
        visited = visited + ['VgwTelemetry']
        {
          accepted_route_count: 1,
          last_status_change: Time.now,
          outside_ip_address: 'outside_ip_address',
          status: 'status',
          status_message: 'status_message',
          certificate_arn: 'certificate_arn',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('acceptedRouteCount', stub[:accepted_route_count].to_s) unless stub[:accepted_route_count].nil?
        xml << Hearth::XML::Node.new('lastStatusChange', Hearth::TimeHelper.to_date_time(stub[:last_status_change])) unless stub[:last_status_change].nil?
        xml << Hearth::XML::Node.new('outsideIpAddress', stub[:outside_ip_address].to_s) unless stub[:outside_ip_address].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('certificateArn', stub[:certificate_arn].to_s) unless stub[:certificate_arn].nil?
        xml
      end
    end

    class VgwTelemetryList
      def self.default(visited = [])
        return nil if visited.include?('VgwTelemetryList')
        visited = visited + ['VgwTelemetryList']
        [
          VgwTelemetry.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VgwTelemetry.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VirtualizationTypeList
      def self.default(visited = [])
        return nil if visited.include?('VirtualizationTypeList')
        visited = visited + ['VirtualizationTypeList']
        [
          'member'
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Hearth::XML::Node.new(node_name, element.to_s) unless element.nil?
        end
        xml
      end
    end

    class Volume
      def self.default(visited = [])
        return nil if visited.include?('Volume')
        visited = visited + ['Volume']
        {
          attachments: VolumeAttachmentList.default(visited),
          availability_zone: 'availability_zone',
          create_time: Time.now,
          encrypted: false,
          kms_key_id: 'kms_key_id',
          outpost_arn: 'outpost_arn',
          size: 1,
          snapshot_id: 'snapshot_id',
          state: 'state',
          volume_id: 'volume_id',
          iops: 1,
          tags: TagList.default(visited),
          volume_type: 'volume_type',
          fast_restored: false,
          multi_attach_enabled: false,
          throughput: 1,
          sse_type: 'sse_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachmentSet', VolumeAttachmentList.stub('item', stub[:attachments])) unless stub[:attachments].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('createTime', Hearth::TimeHelper.to_date_time(stub[:create_time])) unless stub[:create_time].nil?
        xml << Hearth::XML::Node.new('encrypted', stub[:encrypted].to_s) unless stub[:encrypted].nil?
        xml << Hearth::XML::Node.new('kmsKeyId', stub[:kms_key_id].to_s) unless stub[:kms_key_id].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('size', stub[:size].to_s) unless stub[:size].nil?
        xml << Hearth::XML::Node.new('snapshotId', stub[:snapshot_id].to_s) unless stub[:snapshot_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('iops', stub[:iops].to_s) unless stub[:iops].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('volumeType', stub[:volume_type].to_s) unless stub[:volume_type].nil?
        xml << Hearth::XML::Node.new('fastRestored', stub[:fast_restored].to_s) unless stub[:fast_restored].nil?
        xml << Hearth::XML::Node.new('multiAttachEnabled', stub[:multi_attach_enabled].to_s) unless stub[:multi_attach_enabled].nil?
        xml << Hearth::XML::Node.new('throughput', stub[:throughput].to_s) unless stub[:throughput].nil?
        xml << Hearth::XML::Node.new('sseType', stub[:sse_type].to_s) unless stub[:sse_type].nil?
        xml
      end
    end

    class VolumeAttachment
      def self.default(visited = [])
        return nil if visited.include?('VolumeAttachment')
        visited = visited + ['VolumeAttachment']
        {
          attach_time: Time.now,
          device: 'device',
          instance_id: 'instance_id',
          state: 'state',
          volume_id: 'volume_id',
          delete_on_termination: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('attachTime', Hearth::TimeHelper.to_date_time(stub[:attach_time])) unless stub[:attach_time].nil?
        xml << Hearth::XML::Node.new('device', stub[:device].to_s) unless stub[:device].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml << Hearth::XML::Node.new('status', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('deleteOnTermination', stub[:delete_on_termination].to_s) unless stub[:delete_on_termination].nil?
        xml
      end
    end

    class VolumeAttachmentList
      def self.default(visited = [])
        return nil if visited.include?('VolumeAttachmentList')
        visited = visited + ['VolumeAttachmentList']
        [
          VolumeAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VolumeList
      def self.default(visited = [])
        return nil if visited.include?('VolumeList')
        visited = visited + ['VolumeList']
        [
          Volume.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Volume.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VolumeModification
      def self.default(visited = [])
        return nil if visited.include?('VolumeModification')
        visited = visited + ['VolumeModification']
        {
          volume_id: 'volume_id',
          modification_state: 'modification_state',
          status_message: 'status_message',
          target_size: 1,
          target_iops: 1,
          target_volume_type: 'target_volume_type',
          target_throughput: 1,
          target_multi_attach_enabled: false,
          original_size: 1,
          original_iops: 1,
          original_volume_type: 'original_volume_type',
          original_throughput: 1,
          original_multi_attach_enabled: false,
          progress: 1,
          start_time: Time.now,
          end_time: Time.now,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << Hearth::XML::Node.new('modificationState', stub[:modification_state].to_s) unless stub[:modification_state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml << Hearth::XML::Node.new('targetSize', stub[:target_size].to_s) unless stub[:target_size].nil?
        xml << Hearth::XML::Node.new('targetIops', stub[:target_iops].to_s) unless stub[:target_iops].nil?
        xml << Hearth::XML::Node.new('targetVolumeType', stub[:target_volume_type].to_s) unless stub[:target_volume_type].nil?
        xml << Hearth::XML::Node.new('targetThroughput', stub[:target_throughput].to_s) unless stub[:target_throughput].nil?
        xml << Hearth::XML::Node.new('targetMultiAttachEnabled', stub[:target_multi_attach_enabled].to_s) unless stub[:target_multi_attach_enabled].nil?
        xml << Hearth::XML::Node.new('originalSize', stub[:original_size].to_s) unless stub[:original_size].nil?
        xml << Hearth::XML::Node.new('originalIops', stub[:original_iops].to_s) unless stub[:original_iops].nil?
        xml << Hearth::XML::Node.new('originalVolumeType', stub[:original_volume_type].to_s) unless stub[:original_volume_type].nil?
        xml << Hearth::XML::Node.new('originalThroughput', stub[:original_throughput].to_s) unless stub[:original_throughput].nil?
        xml << Hearth::XML::Node.new('originalMultiAttachEnabled', stub[:original_multi_attach_enabled].to_s) unless stub[:original_multi_attach_enabled].nil?
        xml << Hearth::XML::Node.new('progress', stub[:progress].to_s) unless stub[:progress].nil?
        xml << Hearth::XML::Node.new('startTime', Hearth::TimeHelper.to_date_time(stub[:start_time])) unless stub[:start_time].nil?
        xml << Hearth::XML::Node.new('endTime', Hearth::TimeHelper.to_date_time(stub[:end_time])) unless stub[:end_time].nil?
        xml
      end
    end

    class VolumeModificationList
      def self.default(visited = [])
        return nil if visited.include?('VolumeModificationList')
        visited = visited + ['VolumeModificationList']
        [
          VolumeModification.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeModification.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VolumeStatusAction
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusAction')
        visited = visited + ['VolumeStatusAction']
        {
          code: 'code',
          description: 'description',
          event_id: 'event_id',
          event_type: 'event_type',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('eventId', stub[:event_id].to_s) unless stub[:event_id].nil?
        xml << Hearth::XML::Node.new('eventType', stub[:event_type].to_s) unless stub[:event_type].nil?
        xml
      end
    end

    class VolumeStatusActionsList
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusActionsList')
        visited = visited + ['VolumeStatusActionsList']
        [
          VolumeStatusAction.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusAction.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VolumeStatusAttachmentStatus
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusAttachmentStatus')
        visited = visited + ['VolumeStatusAttachmentStatus']
        {
          io_performance: 'io_performance',
          instance_id: 'instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('ioPerformance', stub[:io_performance].to_s) unless stub[:io_performance].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml
      end
    end

    class VolumeStatusAttachmentStatusList
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusAttachmentStatusList')
        visited = visited + ['VolumeStatusAttachmentStatusList']
        [
          VolumeStatusAttachmentStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusAttachmentStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VolumeStatusDetails
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusDetails')
        visited = visited + ['VolumeStatusDetails']
        {
          name: 'name',
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('name', stub[:name].to_s) unless stub[:name].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    class VolumeStatusDetailsList
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusDetailsList')
        visited = visited + ['VolumeStatusDetailsList']
        [
          VolumeStatusDetails.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusDetails.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VolumeStatusEvent
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusEvent')
        visited = visited + ['VolumeStatusEvent']
        {
          description: 'description',
          event_id: 'event_id',
          event_type: 'event_type',
          not_after: Time.now,
          not_before: Time.now,
          instance_id: 'instance_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('description', stub[:description].to_s) unless stub[:description].nil?
        xml << Hearth::XML::Node.new('eventId', stub[:event_id].to_s) unless stub[:event_id].nil?
        xml << Hearth::XML::Node.new('eventType', stub[:event_type].to_s) unless stub[:event_type].nil?
        xml << Hearth::XML::Node.new('notAfter', Hearth::TimeHelper.to_date_time(stub[:not_after])) unless stub[:not_after].nil?
        xml << Hearth::XML::Node.new('notBefore', Hearth::TimeHelper.to_date_time(stub[:not_before])) unless stub[:not_before].nil?
        xml << Hearth::XML::Node.new('instanceId', stub[:instance_id].to_s) unless stub[:instance_id].nil?
        xml
      end
    end

    class VolumeStatusEventsList
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusEventsList')
        visited = visited + ['VolumeStatusEventsList']
        [
          VolumeStatusEvent.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusEvent.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VolumeStatusInfo
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusInfo')
        visited = visited + ['VolumeStatusInfo']
        {
          details: VolumeStatusDetailsList.default(visited),
          status: 'status',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('details', VolumeStatusDetailsList.stub('item', stub[:details])) unless stub[:details].nil?
        xml << Hearth::XML::Node.new('status', stub[:status].to_s) unless stub[:status].nil?
        xml
      end
    end

    class VolumeStatusItem
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusItem')
        visited = visited + ['VolumeStatusItem']
        {
          actions: VolumeStatusActionsList.default(visited),
          availability_zone: 'availability_zone',
          outpost_arn: 'outpost_arn',
          events: VolumeStatusEventsList.default(visited),
          volume_id: 'volume_id',
          volume_status: VolumeStatusInfo.default(visited),
          attachment_statuses: VolumeStatusAttachmentStatusList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('actionsSet', VolumeStatusActionsList.stub('item', stub[:actions])) unless stub[:actions].nil?
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('outpostArn', stub[:outpost_arn].to_s) unless stub[:outpost_arn].nil?
        xml << Hearth::XML::Node.new('eventsSet', VolumeStatusEventsList.stub('item', stub[:events])) unless stub[:events].nil?
        xml << Hearth::XML::Node.new('volumeId', stub[:volume_id].to_s) unless stub[:volume_id].nil?
        xml << VolumeStatusInfo.stub('volumeStatus', stub[:volume_status]) unless stub[:volume_status].nil?
        xml << Hearth::XML::Node.new('attachmentStatuses', VolumeStatusAttachmentStatusList.stub('item', stub[:attachment_statuses])) unless stub[:attachment_statuses].nil?
        xml
      end
    end

    class VolumeStatusList
      def self.default(visited = [])
        return nil if visited.include?('VolumeStatusList')
        visited = visited + ['VolumeStatusList']
        [
          VolumeStatusItem.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VolumeStatusItem.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class Vpc
      def self.default(visited = [])
        return nil if visited.include?('Vpc')
        visited = visited + ['Vpc']
        {
          cidr_block: 'cidr_block',
          dhcp_options_id: 'dhcp_options_id',
          state: 'state',
          vpc_id: 'vpc_id',
          owner_id: 'owner_id',
          instance_tenancy: 'instance_tenancy',
          ipv6_cidr_block_association_set: VpcIpv6CidrBlockAssociationSet.default(visited),
          cidr_block_association_set: VpcCidrBlockAssociationSet.default(visited),
          is_default: false,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << Hearth::XML::Node.new('dhcpOptionsId', stub[:dhcp_options_id].to_s) unless stub[:dhcp_options_id].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << Hearth::XML::Node.new('instanceTenancy', stub[:instance_tenancy].to_s) unless stub[:instance_tenancy].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlockAssociationSet', VpcIpv6CidrBlockAssociationSet.stub('item', stub[:ipv6_cidr_block_association_set])) unless stub[:ipv6_cidr_block_association_set].nil?
        xml << Hearth::XML::Node.new('cidrBlockAssociationSet', VpcCidrBlockAssociationSet.stub('item', stub[:cidr_block_association_set])) unless stub[:cidr_block_association_set].nil?
        xml << Hearth::XML::Node.new('isDefault', stub[:is_default].to_s) unless stub[:is_default].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class VpcAttachment
      def self.default(visited = [])
        return nil if visited.include?('VpcAttachment')
        visited = visited + ['VpcAttachment']
        {
          state: 'state',
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    class VpcAttachmentList
      def self.default(visited = [])
        return nil if visited.include?('VpcAttachmentList')
        visited = visited + ['VpcAttachmentList']
        [
          VpcAttachment.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcAttachment.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpcCidrBlockAssociation
      def self.default(visited = [])
        return nil if visited.include?('VpcCidrBlockAssociation')
        visited = visited + ['VpcCidrBlockAssociation']
        {
          association_id: 'association_id',
          cidr_block: 'cidr_block',
          cidr_block_state: VpcCidrBlockState.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << VpcCidrBlockState.stub('cidrBlockState', stub[:cidr_block_state]) unless stub[:cidr_block_state].nil?
        xml
      end
    end

    class VpcCidrBlockAssociationSet
      def self.default(visited = [])
        return nil if visited.include?('VpcCidrBlockAssociationSet')
        visited = visited + ['VpcCidrBlockAssociationSet']
        [
          VpcCidrBlockAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcCidrBlockAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpcCidrBlockState
      def self.default(visited = [])
        return nil if visited.include?('VpcCidrBlockState')
        visited = visited + ['VpcCidrBlockState']
        {
          state: 'state',
          status_message: 'status_message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('statusMessage', stub[:status_message].to_s) unless stub[:status_message].nil?
        xml
      end
    end

    class VpcClassicLink
      def self.default(visited = [])
        return nil if visited.include?('VpcClassicLink')
        visited = visited + ['VpcClassicLink']
        {
          classic_link_enabled: false,
          tags: TagList.default(visited),
          vpc_id: 'vpc_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('classicLinkEnabled', stub[:classic_link_enabled].to_s) unless stub[:classic_link_enabled].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml
      end
    end

    class VpcClassicLinkList
      def self.default(visited = [])
        return nil if visited.include?('VpcClassicLinkList')
        visited = visited + ['VpcClassicLinkList']
        [
          VpcClassicLink.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcClassicLink.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpcEndpoint
      def self.default(visited = [])
        return nil if visited.include?('VpcEndpoint')
        visited = visited + ['VpcEndpoint']
        {
          vpc_endpoint_id: 'vpc_endpoint_id',
          vpc_endpoint_type: 'vpc_endpoint_type',
          vpc_id: 'vpc_id',
          service_name: 'service_name',
          state: 'state',
          policy_document: 'policy_document',
          route_table_ids: ValueStringList.default(visited),
          subnet_ids: ValueStringList.default(visited),
          groups: GroupIdentifierSet.default(visited),
          ip_address_type: 'ip_address_type',
          dns_options: DnsOptions.default(visited),
          private_dns_enabled: false,
          requester_managed: false,
          network_interface_ids: ValueStringList.default(visited),
          dns_entries: DnsEntrySet.default(visited),
          creation_timestamp: Time.now,
          tags: TagList.default(visited),
          owner_id: 'owner_id',
          last_error: LastError.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('vpcEndpointId', stub[:vpc_endpoint_id].to_s) unless stub[:vpc_endpoint_id].nil?
        xml << Hearth::XML::Node.new('vpcEndpointType', stub[:vpc_endpoint_type].to_s) unless stub[:vpc_endpoint_type].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('serviceName', stub[:service_name].to_s) unless stub[:service_name].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('policyDocument', stub[:policy_document].to_s) unless stub[:policy_document].nil?
        xml << Hearth::XML::Node.new('routeTableIdSet', ValueStringList.stub('item', stub[:route_table_ids])) unless stub[:route_table_ids].nil?
        xml << Hearth::XML::Node.new('subnetIdSet', ValueStringList.stub('item', stub[:subnet_ids])) unless stub[:subnet_ids].nil?
        xml << Hearth::XML::Node.new('groupSet', GroupIdentifierSet.stub('item', stub[:groups])) unless stub[:groups].nil?
        xml << Hearth::XML::Node.new('ipAddressType', stub[:ip_address_type].to_s) unless stub[:ip_address_type].nil?
        xml << DnsOptions.stub('dnsOptions', stub[:dns_options]) unless stub[:dns_options].nil?
        xml << Hearth::XML::Node.new('privateDnsEnabled', stub[:private_dns_enabled].to_s) unless stub[:private_dns_enabled].nil?
        xml << Hearth::XML::Node.new('requesterManaged', stub[:requester_managed].to_s) unless stub[:requester_managed].nil?
        xml << Hearth::XML::Node.new('networkInterfaceIdSet', ValueStringList.stub('item', stub[:network_interface_ids])) unless stub[:network_interface_ids].nil?
        xml << Hearth::XML::Node.new('dnsEntrySet', DnsEntrySet.stub('item', stub[:dns_entries])) unless stub[:dns_entries].nil?
        xml << Hearth::XML::Node.new('creationTimestamp', Hearth::TimeHelper.to_date_time(stub[:creation_timestamp])) unless stub[:creation_timestamp].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << LastError.stub('lastError', stub[:last_error]) unless stub[:last_error].nil?
        xml
      end
    end

    class VpcEndpointConnection
      def self.default(visited = [])
        return nil if visited.include?('VpcEndpointConnection')
        visited = visited + ['VpcEndpointConnection']
        {
          service_id: 'service_id',
          vpc_endpoint_id: 'vpc_endpoint_id',
          vpc_endpoint_owner: 'vpc_endpoint_owner',
          vpc_endpoint_state: 'vpc_endpoint_state',
          creation_timestamp: Time.now,
          dns_entries: DnsEntrySet.default(visited),
          network_load_balancer_arns: ValueStringList.default(visited),
          gateway_load_balancer_arns: ValueStringList.default(visited),
          ip_address_type: 'ip_address_type',
          vpc_endpoint_connection_id: 'vpc_endpoint_connection_id',
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('serviceId', stub[:service_id].to_s) unless stub[:service_id].nil?
        xml << Hearth::XML::Node.new('vpcEndpointId', stub[:vpc_endpoint_id].to_s) unless stub[:vpc_endpoint_id].nil?
        xml << Hearth::XML::Node.new('vpcEndpointOwner', stub[:vpc_endpoint_owner].to_s) unless stub[:vpc_endpoint_owner].nil?
        xml << Hearth::XML::Node.new('vpcEndpointState', stub[:vpc_endpoint_state].to_s) unless stub[:vpc_endpoint_state].nil?
        xml << Hearth::XML::Node.new('creationTimestamp', Hearth::TimeHelper.to_date_time(stub[:creation_timestamp])) unless stub[:creation_timestamp].nil?
        xml << Hearth::XML::Node.new('dnsEntrySet', DnsEntrySet.stub('item', stub[:dns_entries])) unless stub[:dns_entries].nil?
        xml << Hearth::XML::Node.new('networkLoadBalancerArnSet', ValueStringList.stub('item', stub[:network_load_balancer_arns])) unless stub[:network_load_balancer_arns].nil?
        xml << Hearth::XML::Node.new('gatewayLoadBalancerArnSet', ValueStringList.stub('item', stub[:gateway_load_balancer_arns])) unless stub[:gateway_load_balancer_arns].nil?
        xml << Hearth::XML::Node.new('ipAddressType', stub[:ip_address_type].to_s) unless stub[:ip_address_type].nil?
        xml << Hearth::XML::Node.new('vpcEndpointConnectionId', stub[:vpc_endpoint_connection_id].to_s) unless stub[:vpc_endpoint_connection_id].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class VpcEndpointConnectionSet
      def self.default(visited = [])
        return nil if visited.include?('VpcEndpointConnectionSet')
        visited = visited + ['VpcEndpointConnectionSet']
        [
          VpcEndpointConnection.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcEndpointConnection.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpcEndpointSet
      def self.default(visited = [])
        return nil if visited.include?('VpcEndpointSet')
        visited = visited + ['VpcEndpointSet']
        [
          VpcEndpoint.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcEndpoint.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpcIpv6CidrBlockAssociation
      def self.default(visited = [])
        return nil if visited.include?('VpcIpv6CidrBlockAssociation')
        visited = visited + ['VpcIpv6CidrBlockAssociation']
        {
          association_id: 'association_id',
          ipv6_cidr_block: 'ipv6_cidr_block',
          ipv6_cidr_block_state: VpcCidrBlockState.default(visited),
          network_border_group: 'network_border_group',
          ipv6_pool: 'ipv6_pool',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('associationId', stub[:association_id].to_s) unless stub[:association_id].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlock', stub[:ipv6_cidr_block].to_s) unless stub[:ipv6_cidr_block].nil?
        xml << VpcCidrBlockState.stub('ipv6CidrBlockState', stub[:ipv6_cidr_block_state]) unless stub[:ipv6_cidr_block_state].nil?
        xml << Hearth::XML::Node.new('networkBorderGroup', stub[:network_border_group].to_s) unless stub[:network_border_group].nil?
        xml << Hearth::XML::Node.new('ipv6Pool', stub[:ipv6_pool].to_s) unless stub[:ipv6_pool].nil?
        xml
      end
    end

    class VpcIpv6CidrBlockAssociationSet
      def self.default(visited = [])
        return nil if visited.include?('VpcIpv6CidrBlockAssociationSet')
        visited = visited + ['VpcIpv6CidrBlockAssociationSet']
        [
          VpcIpv6CidrBlockAssociation.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcIpv6CidrBlockAssociation.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpcList
      def self.default(visited = [])
        return nil if visited.include?('VpcList')
        visited = visited + ['VpcList']
        [
          Vpc.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << Vpc.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpcPeeringConnection
      def self.default(visited = [])
        return nil if visited.include?('VpcPeeringConnection')
        visited = visited + ['VpcPeeringConnection']
        {
          accepter_vpc_info: VpcPeeringConnectionVpcInfo.default(visited),
          expiration_time: Time.now,
          requester_vpc_info: VpcPeeringConnectionVpcInfo.default(visited),
          status: VpcPeeringConnectionStateReason.default(visited),
          tags: TagList.default(visited),
          vpc_peering_connection_id: 'vpc_peering_connection_id',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << VpcPeeringConnectionVpcInfo.stub('accepterVpcInfo', stub[:accepter_vpc_info]) unless stub[:accepter_vpc_info].nil?
        xml << Hearth::XML::Node.new('expirationTime', Hearth::TimeHelper.to_date_time(stub[:expiration_time])) unless stub[:expiration_time].nil?
        xml << VpcPeeringConnectionVpcInfo.stub('requesterVpcInfo', stub[:requester_vpc_info]) unless stub[:requester_vpc_info].nil?
        xml << VpcPeeringConnectionStateReason.stub('status', stub[:status]) unless stub[:status].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vpcPeeringConnectionId', stub[:vpc_peering_connection_id].to_s) unless stub[:vpc_peering_connection_id].nil?
        xml
      end
    end

    class VpcPeeringConnectionList
      def self.default(visited = [])
        return nil if visited.include?('VpcPeeringConnectionList')
        visited = visited + ['VpcPeeringConnectionList']
        [
          VpcPeeringConnection.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpcPeeringConnection.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpcPeeringConnectionOptionsDescription
      def self.default(visited = [])
        return nil if visited.include?('VpcPeeringConnectionOptionsDescription')
        visited = visited + ['VpcPeeringConnectionOptionsDescription']
        {
          allow_dns_resolution_from_remote_vpc: false,
          allow_egress_from_local_classic_link_to_remote_vpc: false,
          allow_egress_from_local_vpc_to_remote_classic_link: false,
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('allowDnsResolutionFromRemoteVpc', stub[:allow_dns_resolution_from_remote_vpc].to_s) unless stub[:allow_dns_resolution_from_remote_vpc].nil?
        xml << Hearth::XML::Node.new('allowEgressFromLocalClassicLinkToRemoteVpc', stub[:allow_egress_from_local_classic_link_to_remote_vpc].to_s) unless stub[:allow_egress_from_local_classic_link_to_remote_vpc].nil?
        xml << Hearth::XML::Node.new('allowEgressFromLocalVpcToRemoteClassicLink', stub[:allow_egress_from_local_vpc_to_remote_classic_link].to_s) unless stub[:allow_egress_from_local_vpc_to_remote_classic_link].nil?
        xml
      end
    end

    class VpcPeeringConnectionStateReason
      def self.default(visited = [])
        return nil if visited.include?('VpcPeeringConnectionStateReason')
        visited = visited + ['VpcPeeringConnectionStateReason']
        {
          code: 'code',
          message: 'message',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('code', stub[:code].to_s) unless stub[:code].nil?
        xml << Hearth::XML::Node.new('message', stub[:message].to_s) unless stub[:message].nil?
        xml
      end
    end

    class VpcPeeringConnectionVpcInfo
      def self.default(visited = [])
        return nil if visited.include?('VpcPeeringConnectionVpcInfo')
        visited = visited + ['VpcPeeringConnectionVpcInfo']
        {
          cidr_block: 'cidr_block',
          ipv6_cidr_block_set: Ipv6CidrBlockSet.default(visited),
          cidr_block_set: CidrBlockSet.default(visited),
          owner_id: 'owner_id',
          peering_options: VpcPeeringConnectionOptionsDescription.default(visited),
          vpc_id: 'vpc_id',
          region: 'region',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('cidrBlock', stub[:cidr_block].to_s) unless stub[:cidr_block].nil?
        xml << Hearth::XML::Node.new('ipv6CidrBlockSet', Ipv6CidrBlockSet.stub('item', stub[:ipv6_cidr_block_set])) unless stub[:ipv6_cidr_block_set].nil?
        xml << Hearth::XML::Node.new('cidrBlockSet', CidrBlockSet.stub('item', stub[:cidr_block_set])) unless stub[:cidr_block_set].nil?
        xml << Hearth::XML::Node.new('ownerId', stub[:owner_id].to_s) unless stub[:owner_id].nil?
        xml << VpcPeeringConnectionOptionsDescription.stub('peeringOptions', stub[:peering_options]) unless stub[:peering_options].nil?
        xml << Hearth::XML::Node.new('vpcId', stub[:vpc_id].to_s) unless stub[:vpc_id].nil?
        xml << Hearth::XML::Node.new('region', stub[:region].to_s) unless stub[:region].nil?
        xml
      end
    end

    class VpnConnection
      def self.default(visited = [])
        return nil if visited.include?('VpnConnection')
        visited = visited + ['VpnConnection']
        {
          customer_gateway_configuration: 'customer_gateway_configuration',
          customer_gateway_id: 'customer_gateway_id',
          category: 'category',
          state: 'state',
          type: 'type',
          vpn_connection_id: 'vpn_connection_id',
          vpn_gateway_id: 'vpn_gateway_id',
          transit_gateway_id: 'transit_gateway_id',
          core_network_arn: 'core_network_arn',
          core_network_attachment_arn: 'core_network_attachment_arn',
          gateway_association_state: 'gateway_association_state',
          options: VpnConnectionOptions.default(visited),
          routes: VpnStaticRouteList.default(visited),
          tags: TagList.default(visited),
          vgw_telemetry: VgwTelemetryList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('customerGatewayConfiguration', stub[:customer_gateway_configuration].to_s) unless stub[:customer_gateway_configuration].nil?
        xml << Hearth::XML::Node.new('customerGatewayId', stub[:customer_gateway_id].to_s) unless stub[:customer_gateway_id].nil?
        xml << Hearth::XML::Node.new('category', stub[:category].to_s) unless stub[:category].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('vpnConnectionId', stub[:vpn_connection_id].to_s) unless stub[:vpn_connection_id].nil?
        xml << Hearth::XML::Node.new('vpnGatewayId', stub[:vpn_gateway_id].to_s) unless stub[:vpn_gateway_id].nil?
        xml << Hearth::XML::Node.new('transitGatewayId', stub[:transit_gateway_id].to_s) unless stub[:transit_gateway_id].nil?
        xml << Hearth::XML::Node.new('coreNetworkArn', stub[:core_network_arn].to_s) unless stub[:core_network_arn].nil?
        xml << Hearth::XML::Node.new('coreNetworkAttachmentArn', stub[:core_network_attachment_arn].to_s) unless stub[:core_network_attachment_arn].nil?
        xml << Hearth::XML::Node.new('gatewayAssociationState', stub[:gateway_association_state].to_s) unless stub[:gateway_association_state].nil?
        xml << VpnConnectionOptions.stub('options', stub[:options]) unless stub[:options].nil?
        xml << Hearth::XML::Node.new('routes', VpnStaticRouteList.stub('item', stub[:routes])) unless stub[:routes].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml << Hearth::XML::Node.new('vgwTelemetry', VgwTelemetryList.stub('item', stub[:vgw_telemetry])) unless stub[:vgw_telemetry].nil?
        xml
      end
    end

    class VpnConnectionDeviceType
      def self.default(visited = [])
        return nil if visited.include?('VpnConnectionDeviceType')
        visited = visited + ['VpnConnectionDeviceType']
        {
          vpn_connection_device_type_id: 'vpn_connection_device_type_id',
          vendor: 'vendor',
          platform: 'platform',
          software: 'software',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('vpnConnectionDeviceTypeId', stub[:vpn_connection_device_type_id].to_s) unless stub[:vpn_connection_device_type_id].nil?
        xml << Hearth::XML::Node.new('vendor', stub[:vendor].to_s) unless stub[:vendor].nil?
        xml << Hearth::XML::Node.new('platform', stub[:platform].to_s) unless stub[:platform].nil?
        xml << Hearth::XML::Node.new('software', stub[:software].to_s) unless stub[:software].nil?
        xml
      end
    end

    class VpnConnectionDeviceTypeList
      def self.default(visited = [])
        return nil if visited.include?('VpnConnectionDeviceTypeList')
        visited = visited + ['VpnConnectionDeviceTypeList']
        [
          VpnConnectionDeviceType.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpnConnectionDeviceType.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpnConnectionList
      def self.default(visited = [])
        return nil if visited.include?('VpnConnectionList')
        visited = visited + ['VpnConnectionList']
        [
          VpnConnection.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpnConnection.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpnConnectionOptions
      def self.default(visited = [])
        return nil if visited.include?('VpnConnectionOptions')
        visited = visited + ['VpnConnectionOptions']
        {
          enable_acceleration: false,
          static_routes_only: false,
          local_ipv4_network_cidr: 'local_ipv4_network_cidr',
          remote_ipv4_network_cidr: 'remote_ipv4_network_cidr',
          local_ipv6_network_cidr: 'local_ipv6_network_cidr',
          remote_ipv6_network_cidr: 'remote_ipv6_network_cidr',
          outside_ip_address_type: 'outside_ip_address_type',
          transport_transit_gateway_attachment_id: 'transport_transit_gateway_attachment_id',
          tunnel_inside_ip_version: 'tunnel_inside_ip_version',
          tunnel_options: TunnelOptionsList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('enableAcceleration', stub[:enable_acceleration].to_s) unless stub[:enable_acceleration].nil?
        xml << Hearth::XML::Node.new('staticRoutesOnly', stub[:static_routes_only].to_s) unless stub[:static_routes_only].nil?
        xml << Hearth::XML::Node.new('localIpv4NetworkCidr', stub[:local_ipv4_network_cidr].to_s) unless stub[:local_ipv4_network_cidr].nil?
        xml << Hearth::XML::Node.new('remoteIpv4NetworkCidr', stub[:remote_ipv4_network_cidr].to_s) unless stub[:remote_ipv4_network_cidr].nil?
        xml << Hearth::XML::Node.new('localIpv6NetworkCidr', stub[:local_ipv6_network_cidr].to_s) unless stub[:local_ipv6_network_cidr].nil?
        xml << Hearth::XML::Node.new('remoteIpv6NetworkCidr', stub[:remote_ipv6_network_cidr].to_s) unless stub[:remote_ipv6_network_cidr].nil?
        xml << Hearth::XML::Node.new('outsideIpAddressType', stub[:outside_ip_address_type].to_s) unless stub[:outside_ip_address_type].nil?
        xml << Hearth::XML::Node.new('transportTransitGatewayAttachmentId', stub[:transport_transit_gateway_attachment_id].to_s) unless stub[:transport_transit_gateway_attachment_id].nil?
        xml << Hearth::XML::Node.new('tunnelInsideIpVersion', stub[:tunnel_inside_ip_version].to_s) unless stub[:tunnel_inside_ip_version].nil?
        xml << Hearth::XML::Node.new('tunnelOptionSet', TunnelOptionsList.stub('item', stub[:tunnel_options])) unless stub[:tunnel_options].nil?
        xml
      end
    end

    class VpnGateway
      def self.default(visited = [])
        return nil if visited.include?('VpnGateway')
        visited = visited + ['VpnGateway']
        {
          availability_zone: 'availability_zone',
          state: 'state',
          type: 'type',
          vpc_attachments: VpcAttachmentList.default(visited),
          vpn_gateway_id: 'vpn_gateway_id',
          amazon_side_asn: 1,
          tags: TagList.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('availabilityZone', stub[:availability_zone].to_s) unless stub[:availability_zone].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml << Hearth::XML::Node.new('type', stub[:type].to_s) unless stub[:type].nil?
        xml << Hearth::XML::Node.new('attachments', VpcAttachmentList.stub('item', stub[:vpc_attachments])) unless stub[:vpc_attachments].nil?
        xml << Hearth::XML::Node.new('vpnGatewayId', stub[:vpn_gateway_id].to_s) unless stub[:vpn_gateway_id].nil?
        xml << Hearth::XML::Node.new('amazonSideAsn', stub[:amazon_side_asn].to_s) unless stub[:amazon_side_asn].nil?
        xml << Hearth::XML::Node.new('tagSet', TagList.stub('item', stub[:tags])) unless stub[:tags].nil?
        xml
      end
    end

    class VpnGatewayList
      def self.default(visited = [])
        return nil if visited.include?('VpnGatewayList')
        visited = visited + ['VpnGatewayList']
        [
          VpnGateway.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpnGateway.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpnStaticRoute
      def self.default(visited = [])
        return nil if visited.include?('VpnStaticRoute')
        visited = visited + ['VpnStaticRoute']
        {
          destination_cidr_block: 'destination_cidr_block',
          source: 'source',
          state: 'state',
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << Hearth::XML::Node.new('destinationCidrBlock', stub[:destination_cidr_block].to_s) unless stub[:destination_cidr_block].nil?
        xml << Hearth::XML::Node.new('source', stub[:source].to_s) unless stub[:source].nil?
        xml << Hearth::XML::Node.new('state', stub[:state].to_s) unless stub[:state].nil?
        xml
      end
    end

    class VpnStaticRouteList
      def self.default(visited = [])
        return nil if visited.include?('VpnStaticRouteList')
        visited = visited + ['VpnStaticRouteList']
        [
          VpnStaticRoute.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << VpnStaticRoute.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end

    class VpnTunnelLogOptions
      def self.default(visited = [])
        return nil if visited.include?('VpnTunnelLogOptions')
        visited = visited + ['VpnTunnelLogOptions']
        {
          cloud_watch_log_options: CloudWatchLogOptions.default(visited),
        }
      end

      def self.stub(node_name, stub = {})
        xml = Hearth::XML::Node.new(node_name)
        xml << CloudWatchLogOptions.stub('cloudWatchLogOptions', stub[:cloud_watch_log_options]) unless stub[:cloud_watch_log_options].nil?
        xml
      end
    end

    class WithdrawByoipCidr
      def self.build(params, context:)
        Params::WithdrawByoipCidrOutput.build(params, context: context)
      end

      def self.validate!(output, context:)
        Validators::WithdrawByoipCidrOutput.validate!(output, context: context)
      end

      def self.default(visited = [])
        {
          byoip_cidr: ByoipCidr.default(visited),
        }
      end

      def self.stub(http_resp, stub:)
        http_resp.headers['Content-Type'] = 'application/xml'
        xml = Hearth::XML::Node.new('WithdrawByoipCidrResponse')
        xml.attributes['xmlns'] = 'http://ec2.amazonaws.com/doc/2016-11-15'
        xml << ByoipCidr.stub('byoipCidr', stub[:byoip_cidr]) unless stub[:byoip_cidr].nil?
        http_resp.body = ::StringIO.new(xml.to_str)
        http_resp.status = 200
      end
    end

    class SnapshotTierStatusSet
      def self.default(visited = [])
        return nil if visited.include?('SnapshotTierStatusSet')
        visited = visited + ['SnapshotTierStatusSet']
        [
          SnapshotTierStatus.default(visited)
        ]
      end

      def self.stub(node_name, stub = [])
        xml = []
        stub.each do |element|
          xml << SnapshotTierStatus.stub(node_name, element) unless element.nil?
        end
        xml
      end
    end
  end
end
