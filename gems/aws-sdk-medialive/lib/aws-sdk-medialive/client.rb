# frozen_string_literal: true

# WARNING ABOUT GENERATED CODE
#
# This file was code generated using smithy-ruby.
# https://github.com/awslabs/smithy-ruby
#
# WARNING ABOUT GENERATED CODE

require 'stringio'

require_relative 'middleware/request_id'

module AWS::SDK::MediaLive
  # An API client for MediaLive
  # See {#initialize} for a full list of supported configuration options
  # API for AWS Elemental MediaLive
  #
  class Client
    include Hearth::ClientStubs

    @middleware = Hearth::MiddlewareBuilder.new

    def self.middleware
      @middleware
    end

    # @param [Config] config
    #   An instance of {Config}
    #
    def initialize(config = AWS::SDK::MediaLive::Config.new, options = {})
      @config = config
      @middleware = Hearth::MiddlewareBuilder.new(options[:middleware])
      @stubs = Hearth::Stubbing::Stubs.new
      @retry_quota = Hearth::Retry::RetryQuota.new
      @client_rate_limiter = Hearth::Retry::ClientRateLimiter.new
    end

    # Accept an incoming input device transfer. The ownership of the device will transfer to your AWS account.
    #
    # @param [Hash] params
    #   See {Types::AcceptInputDeviceTransferInput}.
    #
    # @option params [String] :input_device_id
    #   The unique ID of the input device to accept. For example, hd-123456789abcdef.
    #
    # @return [Types::AcceptInputDeviceTransferOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.accept_input_device_transfer(
    #     input_device_id: 'InputDeviceId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::AcceptInputDeviceTransferOutput
    #
    def accept_input_device_transfer(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::AcceptInputDeviceTransferInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::AcceptInputDeviceTransferInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::AcceptInputDeviceTransfer
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::AcceptInputDeviceTransfer
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::AcceptInputDeviceTransfer,
        stubs: @stubs,
        params_class: Params::AcceptInputDeviceTransferOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :accept_input_device_transfer
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Starts delete of resources.
    #
    # @param [Hash] params
    #   See {Types::BatchDeleteInput}.
    #
    # @option params [Array<String>] :channel_ids
    #   List of channel IDs
    #
    # @option params [Array<String>] :input_ids
    #   List of input IDs
    #
    # @option params [Array<String>] :input_security_group_ids
    #   List of input security group IDs
    #
    # @option params [Array<String>] :multiplex_ids
    #   List of multiplex IDs
    #
    # @return [Types::BatchDeleteOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.batch_delete(
    #     channel_ids: [
    #       'member'
    #     ],
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::BatchDeleteOutput
    #   resp.data.failed #=> Array<BatchFailedResultModel>
    #   resp.data.failed[0] #=> Types::BatchFailedResultModel
    #   resp.data.failed[0].arn #=> String
    #   resp.data.failed[0].code #=> String
    #   resp.data.failed[0].id #=> String
    #   resp.data.failed[0].message #=> String
    #   resp.data.successful #=> Array<BatchSuccessfulResultModel>
    #   resp.data.successful[0] #=> Types::BatchSuccessfulResultModel
    #   resp.data.successful[0].arn #=> String
    #   resp.data.successful[0].id #=> String
    #   resp.data.successful[0].state #=> String
    #
    def batch_delete(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::BatchDeleteInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::BatchDeleteInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::BatchDelete
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::BatchDelete
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::BatchDelete,
        stubs: @stubs,
        params_class: Params::BatchDeleteOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :batch_delete
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Starts existing resources
    #
    # @param [Hash] params
    #   See {Types::BatchStartInput}.
    #
    # @option params [Array<String>] :channel_ids
    #   List of channel IDs
    #
    # @option params [Array<String>] :multiplex_ids
    #   List of multiplex IDs
    #
    # @return [Types::BatchStartOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.batch_start(
    #     channel_ids: [
    #       'member'
    #     ],
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::BatchStartOutput
    #   resp.data.failed #=> Array<BatchFailedResultModel>
    #   resp.data.failed[0] #=> Types::BatchFailedResultModel
    #   resp.data.failed[0].arn #=> String
    #   resp.data.failed[0].code #=> String
    #   resp.data.failed[0].id #=> String
    #   resp.data.failed[0].message #=> String
    #   resp.data.successful #=> Array<BatchSuccessfulResultModel>
    #   resp.data.successful[0] #=> Types::BatchSuccessfulResultModel
    #   resp.data.successful[0].arn #=> String
    #   resp.data.successful[0].id #=> String
    #   resp.data.successful[0].state #=> String
    #
    def batch_start(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::BatchStartInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::BatchStartInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::BatchStart
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::BatchStart
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::BatchStart,
        stubs: @stubs,
        params_class: Params::BatchStartOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :batch_start
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Stops running resources
    #
    # @param [Hash] params
    #   See {Types::BatchStopInput}.
    #
    # @option params [Array<String>] :channel_ids
    #   List of channel IDs
    #
    # @option params [Array<String>] :multiplex_ids
    #   List of multiplex IDs
    #
    # @return [Types::BatchStopOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.batch_stop(
    #     channel_ids: [
    #       'member'
    #     ],
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::BatchStopOutput
    #   resp.data.failed #=> Array<BatchFailedResultModel>
    #   resp.data.failed[0] #=> Types::BatchFailedResultModel
    #   resp.data.failed[0].arn #=> String
    #   resp.data.failed[0].code #=> String
    #   resp.data.failed[0].id #=> String
    #   resp.data.failed[0].message #=> String
    #   resp.data.successful #=> Array<BatchSuccessfulResultModel>
    #   resp.data.successful[0] #=> Types::BatchSuccessfulResultModel
    #   resp.data.successful[0].arn #=> String
    #   resp.data.successful[0].id #=> String
    #   resp.data.successful[0].state #=> String
    #
    def batch_stop(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::BatchStopInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::BatchStopInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::BatchStop
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::BatchStop
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::BatchStop,
        stubs: @stubs,
        params_class: Params::BatchStopOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :batch_stop
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Update a channel schedule
    #
    # @param [Hash] params
    #   See {Types::BatchUpdateScheduleInput}.
    #
    # @option params [String] :channel_id
    #   Id of the channel whose schedule is being updated.
    #
    # @option params [BatchScheduleActionCreateRequest] :creates
    #   Schedule actions to create in the schedule.
    #
    # @option params [BatchScheduleActionDeleteRequest] :deletes
    #   Schedule actions to delete from the schedule.
    #
    # @return [Types::BatchUpdateScheduleOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.batch_update_schedule(
    #     channel_id: 'ChannelId', # required
    #     creates: {
    #       schedule_actions: [
    #         {
    #           action_name: 'ActionName', # required
    #           schedule_action_settings: {
    #             hls_id3_segment_tagging_settings: {
    #               tag: 'Tag' # required
    #             },
    #             hls_timed_metadata_settings: {
    #               id3: 'Id3' # required
    #             },
    #             input_prepare_settings: {
    #               input_attachment_name_reference: 'InputAttachmentNameReference',
    #               input_clipping_settings: {
    #                 input_timecode_source: 'ZEROBASED', # required - accepts ["ZEROBASED", "EMBEDDED"]
    #                 start_timecode: {
    #                   timecode: 'Timecode'
    #                 },
    #                 stop_timecode: {
    #                   last_frame_clipping_behavior: 'EXCLUDE_LAST_FRAME', # accepts ["EXCLUDE_LAST_FRAME", "INCLUDE_LAST_FRAME"]
    #                   timecode: 'Timecode'
    #                 }
    #               },
    #               url_path: [
    #                 'member'
    #               ]
    #             },
    #             input_switch_settings: {
    #               input_attachment_name_reference: 'InputAttachmentNameReference', # required
    #             },
    #             motion_graphics_image_activate_settings: {
    #               duration: 1,
    #               password_param: 'PasswordParam',
    #               url: 'Url',
    #               username: 'Username'
    #             },
    #             motion_graphics_image_deactivate_settings: { },
    #             pause_state_settings: {
    #               pipelines: [
    #                 {
    #                   pipeline_id: 'PIPELINE_0' # required - accepts ["PIPELINE_0", "PIPELINE_1"]
    #                 }
    #               ]
    #             },
    #             scte35_return_to_network_settings: {
    #               splice_event_id: 1 # required
    #             },
    #             scte35_splice_insert_settings: {
    #               duration: 1,
    #               splice_event_id: 1 # required
    #             },
    #             scte35_time_signal_settings: {
    #               scte35_descriptors: [
    #                 {
    #                   scte35_descriptor_settings: {
    #                     segmentation_descriptor_scte35_descriptor_settings: {
    #                       delivery_restrictions: {
    #                         archive_allowed_flag: 'ARCHIVE_NOT_ALLOWED', # required - accepts ["ARCHIVE_NOT_ALLOWED", "ARCHIVE_ALLOWED"]
    #                         device_restrictions: 'NONE', # required - accepts ["NONE", "RESTRICT_GROUP0", "RESTRICT_GROUP1", "RESTRICT_GROUP2"]
    #                         no_regional_blackout_flag: 'REGIONAL_BLACKOUT', # required - accepts ["REGIONAL_BLACKOUT", "NO_REGIONAL_BLACKOUT"]
    #                         web_delivery_allowed_flag: 'WEB_DELIVERY_NOT_ALLOWED' # required - accepts ["WEB_DELIVERY_NOT_ALLOWED", "WEB_DELIVERY_ALLOWED"]
    #                       },
    #                       segment_num: 1,
    #                       segmentation_cancel_indicator: 'SEGMENTATION_EVENT_NOT_CANCELED', # required - accepts ["SEGMENTATION_EVENT_NOT_CANCELED", "SEGMENTATION_EVENT_CANCELED"]
    #                       segmentation_duration: 1,
    #                       segmentation_event_id: 1, # required
    #                       segmentation_type_id: 1,
    #                       segmentation_upid: 'SegmentationUpid',
    #                       segmentation_upid_type: 1,
    #                       segments_expected: 1,
    #                       sub_segment_num: 1,
    #                       sub_segments_expected: 1
    #                     } # required
    #                   } # required
    #                 }
    #               ] # required
    #             },
    #             static_image_activate_settings: {
    #               duration: 1,
    #               fade_in: 1,
    #               fade_out: 1,
    #               height: 1,
    #               image: {
    #                 password_param: 'PasswordParam',
    #                 uri: 'Uri', # required
    #                 username: 'Username'
    #               }, # required
    #               image_x: 1,
    #               image_y: 1,
    #               layer: 1,
    #               opacity: 1,
    #               width: 1
    #             },
    #             static_image_deactivate_settings: {
    #               fade_out: 1,
    #               layer: 1
    #             }
    #           }, # required
    #           schedule_action_start_settings: {
    #             fixed_mode_schedule_action_start_settings: {
    #               time: 'Time' # required
    #             },
    #             follow_mode_schedule_action_start_settings: {
    #               follow_point: 'END', # required - accepts ["END", "START"]
    #               reference_action_name: 'ReferenceActionName' # required
    #             },
    #             immediate_mode_schedule_action_start_settings: { }
    #           } # required
    #         }
    #       ] # required
    #     },
    #     deletes: {
    #     }
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::BatchUpdateScheduleOutput
    #   resp.data.creates #=> Types::BatchScheduleActionCreateResult
    #   resp.data.creates.schedule_actions #=> Array<ScheduleAction>
    #   resp.data.creates.schedule_actions[0] #=> Types::ScheduleAction
    #   resp.data.creates.schedule_actions[0].action_name #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings #=> Types::ScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.hls_id3_segment_tagging_settings #=> Types::HlsId3SegmentTaggingScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.hls_id3_segment_tagging_settings.tag #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.hls_timed_metadata_settings #=> Types::HlsTimedMetadataScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.hls_timed_metadata_settings.id3 #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings #=> Types::InputPrepareScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_attachment_name_reference #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings #=> Types::InputClippingSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.input_timecode_source #=> String, one of ["ZEROBASED", "EMBEDDED"]
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.start_timecode #=> Types::StartTimecode
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.start_timecode.timecode #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.stop_timecode #=> Types::StopTimecode
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.stop_timecode.last_frame_clipping_behavior #=> String, one of ["EXCLUDE_LAST_FRAME", "INCLUDE_LAST_FRAME"]
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.stop_timecode.timecode #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.url_path #=> Array<String>
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_prepare_settings.url_path[0] #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_switch_settings #=> Types::InputSwitchScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_switch_settings.input_attachment_name_reference #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_switch_settings.input_clipping_settings #=> Types::InputClippingSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.input_switch_settings.url_path #=> Array<String>
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings #=> Types::MotionGraphicsActivateScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings.duration #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings.password_param #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings.url #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings.username #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.motion_graphics_image_deactivate_settings #=> Types::MotionGraphicsDeactivateScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.pause_state_settings #=> Types::PauseStateScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.pause_state_settings.pipelines #=> Array<PipelinePauseStateSettings>
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.pause_state_settings.pipelines[0] #=> Types::PipelinePauseStateSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.pause_state_settings.pipelines[0].pipeline_id #=> String, one of ["PIPELINE_0", "PIPELINE_1"]
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_return_to_network_settings #=> Types::Scte35ReturnToNetworkScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_return_to_network_settings.splice_event_id #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_splice_insert_settings #=> Types::Scte35SpliceInsertScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_splice_insert_settings.duration #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_splice_insert_settings.splice_event_id #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings #=> Types::Scte35TimeSignalScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors #=> Array<Scte35Descriptor>
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0] #=> Types::Scte35Descriptor
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings #=> Types::Scte35DescriptorSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings #=> Types::Scte35SegmentationDescriptor
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions #=> Types::Scte35DeliveryRestrictions
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions.archive_allowed_flag #=> String, one of ["ARCHIVE_NOT_ALLOWED", "ARCHIVE_ALLOWED"]
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions.device_restrictions #=> String, one of ["NONE", "RESTRICT_GROUP0", "RESTRICT_GROUP1", "RESTRICT_GROUP2"]
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions.no_regional_blackout_flag #=> String, one of ["REGIONAL_BLACKOUT", "NO_REGIONAL_BLACKOUT"]
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions.web_delivery_allowed_flag #=> String, one of ["WEB_DELIVERY_NOT_ALLOWED", "WEB_DELIVERY_ALLOWED"]
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segment_num #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_cancel_indicator #=> String, one of ["SEGMENTATION_EVENT_NOT_CANCELED", "SEGMENTATION_EVENT_CANCELED"]
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_duration #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_event_id #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_type_id #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_upid #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_upid_type #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segments_expected #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.sub_segment_num #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.sub_segments_expected #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings #=> Types::StaticImageActivateScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.duration #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.fade_in #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.fade_out #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.height #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image #=> Types::InputLocation
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image.password_param #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image.uri #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image.username #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image_x #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image_y #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.layer #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.opacity #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_activate_settings.width #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_deactivate_settings #=> Types::StaticImageDeactivateScheduleActionSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_deactivate_settings.fade_out #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_settings.static_image_deactivate_settings.layer #=> Integer
    #   resp.data.creates.schedule_actions[0].schedule_action_start_settings #=> Types::ScheduleActionStartSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_start_settings.fixed_mode_schedule_action_start_settings #=> Types::FixedModeScheduleActionStartSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_start_settings.fixed_mode_schedule_action_start_settings.time #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_start_settings.follow_mode_schedule_action_start_settings #=> Types::FollowModeScheduleActionStartSettings
    #   resp.data.creates.schedule_actions[0].schedule_action_start_settings.follow_mode_schedule_action_start_settings.follow_point #=> String, one of ["END", "START"]
    #   resp.data.creates.schedule_actions[0].schedule_action_start_settings.follow_mode_schedule_action_start_settings.reference_action_name #=> String
    #   resp.data.creates.schedule_actions[0].schedule_action_start_settings.immediate_mode_schedule_action_start_settings #=> Types::ImmediateModeScheduleActionStartSettings
    #   resp.data.deletes #=> Types::BatchScheduleActionDeleteResult
    #   resp.data.deletes.schedule_actions #=> Array<ScheduleAction>
    #
    def batch_update_schedule(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::BatchUpdateScheduleInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::BatchUpdateScheduleInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::BatchUpdateSchedule
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::BatchUpdateSchedule
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::BatchUpdateSchedule,
        stubs: @stubs,
        params_class: Params::BatchUpdateScheduleOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :batch_update_schedule
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Cancel an input device transfer that you have requested.
    #
    # @param [Hash] params
    #   See {Types::CancelInputDeviceTransferInput}.
    #
    # @option params [String] :input_device_id
    #   The unique ID of the input device to cancel. For example, hd-123456789abcdef.
    #
    # @return [Types::CancelInputDeviceTransferOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.cancel_input_device_transfer(
    #     input_device_id: 'InputDeviceId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::CancelInputDeviceTransferOutput
    #
    def cancel_input_device_transfer(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::CancelInputDeviceTransferInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::CancelInputDeviceTransferInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::CancelInputDeviceTransfer
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::CancelInputDeviceTransfer
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::CancelInputDeviceTransfer,
        stubs: @stubs,
        params_class: Params::CancelInputDeviceTransferOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :cancel_input_device_transfer
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Send a request to claim an AWS Elemental device that you have purchased from a third-party vendor. After the request succeeds, you will own the device.
    #
    # @param [Hash] params
    #   See {Types::ClaimDeviceInput}.
    #
    # @option params [String] :id
    #   The id of the device you want to claim.
    #
    # @return [Types::ClaimDeviceOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.claim_device(
    #     id: 'Id'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ClaimDeviceOutput
    #
    def claim_device(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ClaimDeviceInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ClaimDeviceInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ClaimDevice
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::ClaimDevice
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ClaimDevice,
        stubs: @stubs,
        params_class: Params::ClaimDeviceOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :claim_device
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Creates a new channel
    #
    # @param [Hash] params
    #   See {Types::CreateChannelInput}.
    #
    # @option params [CdiInputSpecification] :cdi_input_specification
    #   Specification of CDI inputs for this channel
    #
    # @option params [String] :channel_class
    #   The class for this channel. STANDARD for a channel with two pipelines or SINGLE_PIPELINE for a channel with one pipeline.
    #
    # @option params [Array<OutputDestination>] :destinations
    #   Placeholder documentation for __listOfOutputDestination
    #
    # @option params [EncoderSettings] :encoder_settings
    #   Encoder Settings
    #
    # @option params [Array<InputAttachment>] :input_attachments
    #   List of input attachments for channel.
    #
    # @option params [InputSpecification] :input_specification
    #   Specification of network and file inputs for this channel
    #
    # @option params [String] :log_level
    #   The log level to write to CloudWatch Logs.
    #
    # @option params [MaintenanceCreateSettings] :maintenance
    #   Maintenance settings for this channel.
    #
    # @option params [String] :name
    #   Name of channel.
    #
    # @option params [String] :request_id
    #   Unique request ID to be specified. This is needed to prevent retries from
    #   creating multiple resources.
    #
    # @option params [String] :reserved
    #   Deprecated field that's only usable by whitelisted customers.
    #
    # @option params [String] :role_arn
    #   An optional Amazon Resource Name (ARN) of the role to assume when running the Channel.
    #
    # @option params [Hash<String, String>] :tags
    #   A collection of key-value pairs.
    #
    # @option params [VpcOutputSettings] :vpc
    #   Settings for the VPC outputs
    #
    # @return [Types::CreateChannelOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.create_channel(
    #     cdi_input_specification: {
    #       resolution: 'SD' # accepts ["SD", "HD", "FHD", "UHD"]
    #     },
    #     channel_class: 'STANDARD', # accepts ["STANDARD", "SINGLE_PIPELINE"]
    #     destinations: [
    #       {
    #         id: 'Id',
    #         media_package_settings: [
    #           {
    #             channel_id: 'ChannelId'
    #           }
    #         ],
    #         multiplex_settings: {
    #           multiplex_id: 'MultiplexId',
    #           program_name: 'ProgramName'
    #         },
    #         settings: [
    #           {
    #             password_param: 'PasswordParam',
    #             stream_name: 'StreamName',
    #             url: 'Url',
    #             username: 'Username'
    #           }
    #         ]
    #       }
    #     ],
    #     encoder_settings: {
    #       audio_descriptions: [
    #         {
    #           audio_normalization_settings: {
    #             algorithm: 'ITU_1770_1', # accepts ["ITU_1770_1", "ITU_1770_2"]
    #             algorithm_control: 'CORRECT_AUDIO', # accepts ["CORRECT_AUDIO"]
    #             target_lkfs: 1.0
    #           },
    #           audio_selector_name: 'AudioSelectorName', # required
    #           audio_type: 'CLEAN_EFFECTS', # accepts ["CLEAN_EFFECTS", "HEARING_IMPAIRED", "UNDEFINED", "VISUAL_IMPAIRED_COMMENTARY"]
    #           audio_type_control: 'FOLLOW_INPUT', # accepts ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #           audio_watermarking_settings: {
    #             nielsen_watermarks_settings: {
    #               nielsen_cbet_settings: {
    #                 cbet_check_digit_string: 'CbetCheckDigitString', # required
    #                 cbet_stepaside: 'DISABLED', # required - accepts ["DISABLED", "ENABLED"]
    #                 csid: 'Csid' # required
    #               },
    #               nielsen_distribution_type: 'FINAL_DISTRIBUTOR', # accepts ["FINAL_DISTRIBUTOR", "PROGRAM_CONTENT"]
    #               nielsen_naes_ii_nw_settings: {
    #                 check_digit_string: 'CheckDigitString', # required
    #                 sid: 1.0 # required
    #               }
    #             }
    #           },
    #           codec_settings: {
    #             aac_settings: {
    #               bitrate: 1.0,
    #               coding_mode: 'AD_RECEIVER_MIX', # accepts ["AD_RECEIVER_MIX", "CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_5_1"]
    #               input_type: 'BROADCASTER_MIXED_AD', # accepts ["BROADCASTER_MIXED_AD", "NORMAL"]
    #               profile: 'HEV1', # accepts ["HEV1", "HEV2", "LC"]
    #               rate_control_mode: 'CBR', # accepts ["CBR", "VBR"]
    #               raw_format: 'LATM_LOAS', # accepts ["LATM_LOAS", "NONE"]
    #               sample_rate: 1.0,
    #               spec: 'MPEG2', # accepts ["MPEG2", "MPEG4"]
    #               vbr_quality: 'HIGH' # accepts ["HIGH", "LOW", "MEDIUM_HIGH", "MEDIUM_LOW"]
    #             },
    #             ac3_settings: {
    #               bitrate: 1.0,
    #               bitstream_mode: 'COMMENTARY', # accepts ["COMMENTARY", "COMPLETE_MAIN", "DIALOGUE", "EMERGENCY", "HEARING_IMPAIRED", "MUSIC_AND_EFFECTS", "VISUALLY_IMPAIRED", "VOICE_OVER"]
    #               coding_mode: 'CODING_MODE_1_0', # accepts ["CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_3_2_LFE"]
    #               dialnorm: 1,
    #               drc_profile: 'FILM_STANDARD', # accepts ["FILM_STANDARD", "NONE"]
    #               lfe_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               metadata_control: 'FOLLOW_INPUT' # accepts ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #             },
    #             eac3_settings: {
    #               attenuation_control: 'ATTENUATE_3_DB', # accepts ["ATTENUATE_3_DB", "NONE"]
    #               bitrate: 1.0,
    #               bitstream_mode: 'COMMENTARY', # accepts ["COMMENTARY", "COMPLETE_MAIN", "EMERGENCY", "HEARING_IMPAIRED", "VISUALLY_IMPAIRED"]
    #               coding_mode: 'CODING_MODE_1_0', # accepts ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_3_2"]
    #               dc_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               dialnorm: 1,
    #               drc_line: 'FILM_LIGHT', # accepts ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #               drc_rf: 'FILM_LIGHT', # accepts ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #               lfe_control: 'LFE', # accepts ["LFE", "NO_LFE"]
    #               lfe_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               lo_ro_center_mix_level: 1.0,
    #               lo_ro_surround_mix_level: 1.0,
    #               lt_rt_center_mix_level: 1.0,
    #               lt_rt_surround_mix_level: 1.0,
    #               metadata_control: 'FOLLOW_INPUT', # accepts ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #               passthrough_control: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "WHEN_POSSIBLE"]
    #               phase_control: 'NO_SHIFT', # accepts ["NO_SHIFT", "SHIFT_90_DEGREES"]
    #               stereo_downmix: 'DPL2', # accepts ["DPL2", "LO_RO", "LT_RT", "NOT_INDICATED"]
    #               surround_ex_mode: 'DISABLED', # accepts ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #               surround_mode: 'DISABLED' # accepts ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #             },
    #             mp2_settings: {
    #               bitrate: 1.0,
    #               coding_mode: 'CODING_MODE_1_0', # accepts ["CODING_MODE_1_0", "CODING_MODE_2_0"]
    #               sample_rate: 1.0
    #             },
    #             pass_through_settings: { },
    #             wav_settings: {
    #               bit_depth: 1.0,
    #               coding_mode: 'CODING_MODE_1_0', # accepts ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_4_0", "CODING_MODE_8_0"]
    #               sample_rate: 1.0
    #             }
    #           },
    #           language_code: 'LanguageCode',
    #           language_code_control: 'FOLLOW_INPUT', # accepts ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #           name: 'Name', # required
    #           remix_settings: {
    #             channel_mappings: [
    #               {
    #                 input_channel_levels: [
    #                   {
    #                     gain: 1, # required
    #                     input_channel: 1 # required
    #                   }
    #                 ], # required
    #                 output_channel: 1 # required
    #               }
    #             ], # required
    #             channels_in: 1,
    #             channels_out: 1
    #           },
    #           stream_name: 'StreamName'
    #         }
    #       ], # required
    #       avail_blanking: {
    #         avail_blanking_image: {
    #           password_param: 'PasswordParam',
    #           uri: 'Uri', # required
    #           username: 'Username'
    #         },
    #         state: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       avail_configuration: {
    #         avail_settings: {
    #           scte35_splice_insert: {
    #             ad_avail_offset: 1,
    #             no_regional_blackout_flag: 'FOLLOW', # accepts ["FOLLOW", "IGNORE"]
    #             web_delivery_allowed_flag: 'FOLLOW' # accepts ["FOLLOW", "IGNORE"]
    #           },
    #           scte35_time_signal_apos: {
    #             ad_avail_offset: 1,
    #             no_regional_blackout_flag: 'FOLLOW', # accepts ["FOLLOW", "IGNORE"]
    #             web_delivery_allowed_flag: 'FOLLOW' # accepts ["FOLLOW", "IGNORE"]
    #           }
    #         }
    #       },
    #       blackout_slate: {
    #         network_end_blackout: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #         network_id: 'NetworkId',
    #         state: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       caption_descriptions: [
    #         {
    #           caption_selector_name: 'CaptionSelectorName', # required
    #           destination_settings: {
    #             arib_destination_settings: { },
    #             burn_in_destination_settings: {
    #               alignment: 'CENTERED', # accepts ["CENTERED", "LEFT", "SMART"]
    #               background_color: 'BLACK', # accepts ["BLACK", "NONE", "WHITE"]
    #               background_opacity: 1,
    #               font_color: 'BLACK', # accepts ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #               font_opacity: 1,
    #               font_resolution: 1,
    #               font_size: 'FontSize',
    #               outline_color: 'BLACK', # accepts ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #               outline_size: 1,
    #               shadow_color: 'BLACK', # accepts ["BLACK", "NONE", "WHITE"]
    #               shadow_opacity: 1,
    #               shadow_x_offset: 1,
    #               shadow_y_offset: 1,
    #               teletext_grid_control: 'FIXED', # accepts ["FIXED", "SCALED"]
    #               x_position: 1,
    #               y_position: 1
    #             },
    #             dvb_sub_destination_settings: {
    #               alignment: 'CENTERED', # accepts ["CENTERED", "LEFT", "SMART"]
    #               background_color: 'BLACK', # accepts ["BLACK", "NONE", "WHITE"]
    #               background_opacity: 1,
    #               font_color: 'BLACK', # accepts ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #               font_opacity: 1,
    #               font_resolution: 1,
    #               font_size: 'FontSize',
    #               outline_color: 'BLACK', # accepts ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #               outline_size: 1,
    #               shadow_color: 'BLACK', # accepts ["BLACK", "NONE", "WHITE"]
    #               shadow_opacity: 1,
    #               shadow_x_offset: 1,
    #               shadow_y_offset: 1,
    #               teletext_grid_control: 'FIXED', # accepts ["FIXED", "SCALED"]
    #               x_position: 1,
    #               y_position: 1
    #             },
    #             ebu_tt_d_destination_settings: {
    #               copyright_holder: 'CopyrightHolder',
    #               fill_line_gap: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               font_family: 'FontFamily',
    #               style_control: 'EXCLUDE' # accepts ["EXCLUDE", "INCLUDE"]
    #             },
    #             embedded_destination_settings: { },
    #             embedded_plus_scte20_destination_settings: { },
    #             rtmp_caption_info_destination_settings: { },
    #             scte20_plus_embedded_destination_settings: { },
    #             scte27_destination_settings: { },
    #             smpte_tt_destination_settings: { },
    #             teletext_destination_settings: { },
    #             ttml_destination_settings: {
    #               style_control: 'PASSTHROUGH' # accepts ["PASSTHROUGH", "USE_CONFIGURED"]
    #             },
    #             webvtt_destination_settings: {
    #               style_control: 'NO_STYLE_DATA' # accepts ["NO_STYLE_DATA", "PASSTHROUGH"]
    #             }
    #           },
    #           language_code: 'LanguageCode',
    #           language_description: 'LanguageDescription',
    #           name: 'Name' # required
    #         }
    #       ],
    #       feature_activations: {
    #         input_prepare_schedule_actions: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       global_configuration: {
    #         initial_audio_gain: 1,
    #         input_end_action: 'NONE', # accepts ["NONE", "SWITCH_AND_LOOP_INPUTS"]
    #         input_loss_behavior: {
    #           black_frame_msec: 1,
    #           input_loss_image_color: 'InputLossImageColor',
    #           input_loss_image_type: 'COLOR', # accepts ["COLOR", "SLATE"]
    #           repeat_frame_msec: 1
    #         },
    #         output_locking_mode: 'EPOCH_LOCKING', # accepts ["EPOCH_LOCKING", "PIPELINE_LOCKING"]
    #         output_timing_source: 'INPUT_CLOCK', # accepts ["INPUT_CLOCK", "SYSTEM_CLOCK"]
    #         support_low_framerate_inputs: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       motion_graphics_configuration: {
    #         motion_graphics_insertion: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #         motion_graphics_settings: {
    #           html_motion_graphics_settings: { }
    #         } # required
    #       },
    #       nielsen_configuration: {
    #         distributor_id: 'DistributorId',
    #         nielsen_pcm_to_id3_tagging: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       output_groups: [
    #         {
    #           name: 'Name',
    #           output_group_settings: {
    #             archive_group_settings: {
    #               archive_cdn_settings: {
    #                 archive_s3_settings: {
    #                   canned_acl: 'AUTHENTICATED_READ' # accepts ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #                 }
    #               },
    #               destination: {
    #                 destination_ref_id: 'DestinationRefId'
    #               }, # required
    #               rollover_interval: 1
    #             },
    #             frame_capture_group_settings: {
    #               frame_capture_cdn_settings: {
    #                 frame_capture_s3_settings: {
    #                   canned_acl: 'AUTHENTICATED_READ' # accepts ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #                 }
    #               }
    #             },
    #             hls_group_settings: {
    #               ad_markers: [
    #                 'ADOBE' # accepts ["ADOBE", "ELEMENTAL", "ELEMENTAL_SCTE35"]
    #               ],
    #               base_url_content: 'BaseUrlContent',
    #               base_url_content1: 'BaseUrlContent1',
    #               base_url_manifest: 'BaseUrlManifest',
    #               base_url_manifest1: 'BaseUrlManifest1',
    #               caption_language_mappings: [
    #                 {
    #                   caption_channel: 1, # required
    #                   language_code: 'LanguageCode', # required
    #                   language_description: 'LanguageDescription' # required
    #                 }
    #               ],
    #               caption_language_setting: 'INSERT', # accepts ["INSERT", "NONE", "OMIT"]
    #               client_cache: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               codec_specification: 'RFC_4281', # accepts ["RFC_4281", "RFC_6381"]
    #               constant_iv: 'ConstantIv',
    #               directory_structure: 'SINGLE_DIRECTORY', # accepts ["SINGLE_DIRECTORY", "SUBDIRECTORY_PER_STREAM"]
    #               discontinuity_tags: 'INSERT', # accepts ["INSERT", "NEVER_INSERT"]
    #               encryption_type: 'AES128', # accepts ["AES128", "SAMPLE_AES"]
    #               hls_cdn_settings: {
    #                 hls_akamai_settings: {
    #                   connection_retry_interval: 1,
    #                   filecache_duration: 1,
    #                   http_transfer_mode: 'CHUNKED', # accepts ["CHUNKED", "NON_CHUNKED"]
    #                   num_retries: 1,
    #                   restart_delay: 1,
    #                   salt: 'Salt',
    #                   token: 'Token'
    #                 },
    #                 hls_basic_put_settings: {
    #                   connection_retry_interval: 1,
    #                   filecache_duration: 1,
    #                   num_retries: 1,
    #                   restart_delay: 1
    #                 },
    #                 hls_media_store_settings: {
    #                   connection_retry_interval: 1,
    #                   filecache_duration: 1,
    #                   media_store_storage_class: 'TEMPORAL', # accepts ["TEMPORAL"]
    #                   num_retries: 1,
    #                   restart_delay: 1
    #                 },
    #                 hls_s3_settings: {
    #                   canned_acl: 'AUTHENTICATED_READ' # accepts ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #                 },
    #                 hls_webdav_settings: {
    #                   connection_retry_interval: 1,
    #                   filecache_duration: 1,
    #                   http_transfer_mode: 'CHUNKED', # accepts ["CHUNKED", "NON_CHUNKED"]
    #                   num_retries: 1,
    #                   restart_delay: 1
    #                 }
    #               },
    #               hls_id3_segment_tagging: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               i_frame_only_playlists: 'DISABLED', # accepts ["DISABLED", "STANDARD"]
    #               incomplete_segment_behavior: 'AUTO', # accepts ["AUTO", "SUPPRESS"]
    #               index_n_segments: 1,
    #               input_loss_action: 'EMIT_OUTPUT', # accepts ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #               iv_in_manifest: 'EXCLUDE', # accepts ["EXCLUDE", "INCLUDE"]
    #               iv_source: 'EXPLICIT', # accepts ["EXPLICIT", "FOLLOWS_SEGMENT_NUMBER"]
    #               keep_segments: 1,
    #               key_format: 'KeyFormat',
    #               key_format_versions: 'KeyFormatVersions',
    #               key_provider_settings: {
    #                 static_key_settings: {
    #                   static_key_value: 'StaticKeyValue' # required
    #                 }
    #               },
    #               manifest_compression: 'GZIP', # accepts ["GZIP", "NONE"]
    #               manifest_duration_format: 'FLOATING_POINT', # accepts ["FLOATING_POINT", "INTEGER"]
    #               min_segment_length: 1,
    #               mode: 'LIVE', # accepts ["LIVE", "VOD"]
    #               output_selection: 'MANIFESTS_AND_SEGMENTS', # accepts ["MANIFESTS_AND_SEGMENTS", "SEGMENTS_ONLY", "VARIANT_MANIFESTS_AND_SEGMENTS"]
    #               program_date_time: 'EXCLUDE', # accepts ["EXCLUDE", "INCLUDE"]
    #               program_date_time_clock: 'INITIALIZE_FROM_OUTPUT_TIMECODE', # accepts ["INITIALIZE_FROM_OUTPUT_TIMECODE", "SYSTEM_CLOCK"]
    #               program_date_time_period: 1,
    #               redundant_manifest: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               segment_length: 1,
    #               segmentation_mode: 'USE_INPUT_SEGMENTATION', # accepts ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #               segments_per_subdirectory: 1,
    #               stream_inf_resolution: 'EXCLUDE', # accepts ["EXCLUDE", "INCLUDE"]
    #               timed_metadata_id3_frame: 'NONE', # accepts ["NONE", "PRIV", "TDRL"]
    #               timed_metadata_id3_period: 1,
    #               timestamp_delta_milliseconds: 1,
    #               ts_file_mode: 'SEGMENTED_FILES' # accepts ["SEGMENTED_FILES", "SINGLE_FILE"]
    #             },
    #             media_package_group_settings: {
    #             },
    #             ms_smooth_group_settings: {
    #               acquisition_point_id: 'AcquisitionPointId',
    #               audio_only_timecode_control: 'PASSTHROUGH', # accepts ["PASSTHROUGH", "USE_CONFIGURED_CLOCK"]
    #               certificate_mode: 'SELF_SIGNED', # accepts ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #               connection_retry_interval: 1,
    #               event_id: 'EventId',
    #               event_id_mode: 'NO_EVENT_ID', # accepts ["NO_EVENT_ID", "USE_CONFIGURED", "USE_TIMESTAMP"]
    #               event_stop_behavior: 'NONE', # accepts ["NONE", "SEND_EOS"]
    #               filecache_duration: 1,
    #               fragment_length: 1,
    #               input_loss_action: 'EMIT_OUTPUT', # accepts ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #               num_retries: 1,
    #               restart_delay: 1,
    #               segmentation_mode: 'USE_INPUT_SEGMENTATION', # accepts ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #               send_delay_ms: 1,
    #               sparse_track_type: 'NONE', # accepts ["NONE", "SCTE_35", "SCTE_35_WITHOUT_SEGMENTATION"]
    #               stream_manifest_behavior: 'DO_NOT_SEND', # accepts ["DO_NOT_SEND", "SEND"]
    #               timestamp_offset: 'TimestampOffset',
    #               timestamp_offset_mode: 'USE_CONFIGURED_OFFSET' # accepts ["USE_CONFIGURED_OFFSET", "USE_EVENT_START_DATE"]
    #             },
    #             multiplex_group_settings: { },
    #             rtmp_group_settings: {
    #               ad_markers: [
    #                 'ON_CUE_POINT_SCTE35' # accepts ["ON_CUE_POINT_SCTE35"]
    #               ],
    #               authentication_scheme: 'AKAMAI', # accepts ["AKAMAI", "COMMON"]
    #               cache_full_behavior: 'DISCONNECT_IMMEDIATELY', # accepts ["DISCONNECT_IMMEDIATELY", "WAIT_FOR_SERVER"]
    #               cache_length: 1,
    #               caption_data: 'ALL', # accepts ["ALL", "FIELD1_608", "FIELD1_AND_FIELD2_608"]
    #               input_loss_action: 'EMIT_OUTPUT', # accepts ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #               restart_delay: 1
    #             },
    #             udp_group_settings: {
    #               input_loss_action: 'DROP_PROGRAM', # accepts ["DROP_PROGRAM", "DROP_TS", "EMIT_PROGRAM"]
    #               timed_metadata_id3_frame: 'NONE', # accepts ["NONE", "PRIV", "TDRL"]
    #               timed_metadata_id3_period: 1
    #             }
    #           }, # required
    #           outputs: [
    #             {
    #               audio_description_names: [
    #                 'member'
    #               ],
    #               output_name: 'OutputName',
    #               output_settings: {
    #                 archive_output_settings: {
    #                   container_settings: {
    #                     m2ts_settings: {
    #                       absent_input_audio_behavior: 'DROP', # accepts ["DROP", "ENCODE_SILENCE"]
    #                       arib: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #                       arib_captions_pid: 'AribCaptionsPid',
    #                       arib_captions_pid_control: 'AUTO', # accepts ["AUTO", "USE_CONFIGURED"]
    #                       audio_buffer_model: 'ATSC', # accepts ["ATSC", "DVB"]
    #                       audio_frames_per_pes: 1,
    #                       audio_pids: 'AudioPids',
    #                       audio_stream_type: 'ATSC', # accepts ["ATSC", "DVB"]
    #                       bitrate: 1,
    #                       buffer_model: 'MULTIPLEX', # accepts ["MULTIPLEX", "NONE"]
    #                       cc_descriptor: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #                       dvb_nit_settings: {
    #                         network_id: 1, # required
    #                         network_name: 'NetworkName', # required
    #                         rep_interval: 1
    #                       },
    #                       dvb_sdt_settings: {
    #                         output_sdt: 'SDT_FOLLOW', # accepts ["SDT_FOLLOW", "SDT_FOLLOW_IF_PRESENT", "SDT_MANUAL", "SDT_NONE"]
    #                         rep_interval: 1,
    #                         service_name: 'ServiceName',
    #                         service_provider_name: 'ServiceProviderName'
    #                       },
    #                       dvb_sub_pids: 'DvbSubPids',
    #                       dvb_tdt_settings: {
    #                         rep_interval: 1
    #                       },
    #                       dvb_teletext_pid: 'DvbTeletextPid',
    #                       ebif: 'NONE', # accepts ["NONE", "PASSTHROUGH"]
    #                       ebp_audio_interval: 'VIDEO_AND_FIXED_INTERVALS', # accepts ["VIDEO_AND_FIXED_INTERVALS", "VIDEO_INTERVAL"]
    #                       ebp_lookahead_ms: 1,
    #                       ebp_placement: 'VIDEO_AND_AUDIO_PIDS', # accepts ["VIDEO_AND_AUDIO_PIDS", "VIDEO_PID"]
    #                       ecm_pid: 'EcmPid',
    #                       es_rate_in_pes: 'EXCLUDE', # accepts ["EXCLUDE", "INCLUDE"]
    #                       etv_platform_pid: 'EtvPlatformPid',
    #                       etv_signal_pid: 'EtvSignalPid',
    #                       fragment_time: 1.0,
    #                       klv: 'NONE', # accepts ["NONE", "PASSTHROUGH"]
    #                       klv_data_pids: 'KlvDataPids',
    #                       nielsen_id3_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                       null_packet_bitrate: 1.0,
    #                       pat_interval: 1,
    #                       pcr_control: 'CONFIGURED_PCR_PERIOD', # accepts ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #                       pcr_period: 1,
    #                       pcr_pid: 'PcrPid',
    #                       pmt_interval: 1,
    #                       pmt_pid: 'PmtPid',
    #                       program_num: 1,
    #                       rate_mode: 'CBR', # accepts ["CBR", "VBR"]
    #                       scte27_pids: 'Scte27Pids',
    #                       scte35_control: 'NONE', # accepts ["NONE", "PASSTHROUGH"]
    #                       scte35_pid: 'Scte35Pid',
    #                       segmentation_markers: 'EBP', # accepts ["EBP", "EBP_LEGACY", "NONE", "PSI_SEGSTART", "RAI_ADAPT", "RAI_SEGSTART"]
    #                       segmentation_style: 'MAINTAIN_CADENCE', # accepts ["MAINTAIN_CADENCE", "RESET_CADENCE"]
    #                       segmentation_time: 1.0,
    #                       timed_metadata_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                       timed_metadata_pid: 'TimedMetadataPid',
    #                       transport_stream_id: 1,
    #                       video_pid: 'VideoPid'
    #                     },
    #                     raw_settings: { }
    #                   }, # required
    #                   extension: 'Extension',
    #                   name_modifier: 'NameModifier'
    #                 },
    #                 frame_capture_output_settings: {
    #                   name_modifier: 'NameModifier'
    #                 },
    #                 hls_output_settings: {
    #                   h265_packaging_type: 'HEV1', # accepts ["HEV1", "HVC1"]
    #                   hls_settings: {
    #                     audio_only_hls_settings: {
    #                       audio_group_id: 'AudioGroupId',
    #                       audio_track_type: 'ALTERNATE_AUDIO_AUTO_SELECT', # accepts ["ALTERNATE_AUDIO_AUTO_SELECT", "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT", "ALTERNATE_AUDIO_NOT_AUTO_SELECT", "AUDIO_ONLY_VARIANT_STREAM"]
    #                       segment_type: 'AAC' # accepts ["AAC", "FMP4"]
    #                     },
    #                     fmp4_hls_settings: {
    #                       audio_rendition_sets: 'AudioRenditionSets',
    #                       nielsen_id3_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                       timed_metadata_behavior: 'NO_PASSTHROUGH' # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                     },
    #                     frame_capture_hls_settings: { },
    #                     standard_hls_settings: {
    #                       audio_rendition_sets: 'AudioRenditionSets',
    #                       m3u8_settings: {
    #                         audio_frames_per_pes: 1,
    #                         audio_pids: 'AudioPids',
    #                         ecm_pid: 'EcmPid',
    #                         nielsen_id3_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                         pat_interval: 1,
    #                         pcr_control: 'CONFIGURED_PCR_PERIOD', # accepts ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #                         pcr_period: 1,
    #                         pcr_pid: 'PcrPid',
    #                         pmt_interval: 1,
    #                         pmt_pid: 'PmtPid',
    #                         program_num: 1,
    #                         scte35_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                         scte35_pid: 'Scte35Pid',
    #                         timed_metadata_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                         timed_metadata_pid: 'TimedMetadataPid',
    #                         transport_stream_id: 1,
    #                         video_pid: 'VideoPid'
    #                       } # required
    #                     }
    #                   }, # required
    #                   name_modifier: 'NameModifier',
    #                   segment_modifier: 'SegmentModifier'
    #                 },
    #                 media_package_output_settings: { },
    #                 ms_smooth_output_settings: {
    #                   h265_packaging_type: 'HEV1', # accepts ["HEV1", "HVC1"]
    #                   name_modifier: 'NameModifier'
    #                 },
    #                 multiplex_output_settings: {
    #                 },
    #                 rtmp_output_settings: {
    #                   certificate_mode: 'SELF_SIGNED', # accepts ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #                   connection_retry_interval: 1,
    #                   num_retries: 1
    #                 },
    #                 udp_output_settings: {
    #                   buffer_msec: 1,
    #                   container_settings: {
    #                   }, # required
    #                   fec_output_settings: {
    #                     column_depth: 1,
    #                     include_fec: 'COLUMN', # accepts ["COLUMN", "COLUMN_AND_ROW"]
    #                     row_length: 1
    #                   }
    #                 }
    #               }, # required
    #               video_description_name: 'VideoDescriptionName'
    #             }
    #           ] # required
    #         }
    #       ], # required
    #       timecode_config: {
    #         source: 'EMBEDDED', # required - accepts ["EMBEDDED", "SYSTEMCLOCK", "ZEROBASED"]
    #         sync_threshold: 1
    #       }, # required
    #       video_descriptions: [
    #         {
    #           codec_settings: {
    #             frame_capture_settings: {
    #               capture_interval: 1,
    #               capture_interval_units: 'MILLISECONDS' # accepts ["MILLISECONDS", "SECONDS"]
    #             },
    #             h264_settings: {
    #               adaptive_quantization: 'AUTO', # accepts ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #               afd_signaling: 'AUTO', # accepts ["AUTO", "FIXED", "NONE"]
    #               bitrate: 1,
    #               buf_fill_pct: 1,
    #               buf_size: 1,
    #               color_metadata: 'IGNORE', # accepts ["IGNORE", "INSERT"]
    #               color_space_settings: {
    #                 color_space_passthrough_settings: { },
    #                 rec601_settings: { },
    #                 rec709_settings: { }
    #               },
    #               entropy_encoding: 'CABAC', # accepts ["CABAC", "CAVLC"]
    #               filter_settings: {
    #                 temporal_filter_settings: {
    #                   post_filter_sharpening: 'AUTO', # accepts ["AUTO", "DISABLED", "ENABLED"]
    #                   strength: 'AUTO' # accepts ["AUTO", "STRENGTH_1", "STRENGTH_2", "STRENGTH_3", "STRENGTH_4", "STRENGTH_5", "STRENGTH_6", "STRENGTH_7", "STRENGTH_8", "STRENGTH_9", "STRENGTH_10", "STRENGTH_11", "STRENGTH_12", "STRENGTH_13", "STRENGTH_14", "STRENGTH_15", "STRENGTH_16"]
    #                 }
    #               },
    #               fixed_afd: 'AFD_0000', # accepts ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #               flicker_aq: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               force_field_pictures: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               framerate_control: 'INITIALIZE_FROM_SOURCE', # accepts ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #               framerate_denominator: 1,
    #               framerate_numerator: 1,
    #               gop_b_reference: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               gop_closed_cadence: 1,
    #               gop_num_b_frames: 1,
    #               gop_size: 1.0,
    #               gop_size_units: 'FRAMES', # accepts ["FRAMES", "SECONDS"]
    #               level: 'H264_LEVEL_1', # accepts ["H264_LEVEL_1", "H264_LEVEL_1_1", "H264_LEVEL_1_2", "H264_LEVEL_1_3", "H264_LEVEL_2", "H264_LEVEL_2_1", "H264_LEVEL_2_2", "H264_LEVEL_3", "H264_LEVEL_3_1", "H264_LEVEL_3_2", "H264_LEVEL_4", "H264_LEVEL_4_1", "H264_LEVEL_4_2", "H264_LEVEL_5", "H264_LEVEL_5_1", "H264_LEVEL_5_2", "H264_LEVEL_AUTO"]
    #               look_ahead_rate_control: 'HIGH', # accepts ["HIGH", "LOW", "MEDIUM"]
    #               max_bitrate: 1,
    #               min_i_interval: 1,
    #               num_ref_frames: 1,
    #               par_control: 'INITIALIZE_FROM_SOURCE', # accepts ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #               par_denominator: 1,
    #               par_numerator: 1,
    #               profile: 'BASELINE', # accepts ["BASELINE", "HIGH", "HIGH_10BIT", "HIGH_422", "HIGH_422_10BIT", "MAIN"]
    #               quality_level: 'ENHANCED_QUALITY', # accepts ["ENHANCED_QUALITY", "STANDARD_QUALITY"]
    #               qvbr_quality_level: 1,
    #               rate_control_mode: 'CBR', # accepts ["CBR", "MULTIPLEX", "QVBR", "VBR"]
    #               scan_type: 'INTERLACED', # accepts ["INTERLACED", "PROGRESSIVE"]
    #               scene_change_detect: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               slices: 1,
    #               softness: 1,
    #               spatial_aq: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               subgop_length: 'DYNAMIC', # accepts ["DYNAMIC", "FIXED"]
    #               syntax: 'DEFAULT', # accepts ["DEFAULT", "RP2027"]
    #               temporal_aq: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               timecode_insertion: 'DISABLED' # accepts ["DISABLED", "PIC_TIMING_SEI"]
    #             },
    #             h265_settings: {
    #               adaptive_quantization: 'AUTO', # accepts ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #               afd_signaling: 'AUTO', # accepts ["AUTO", "FIXED", "NONE"]
    #               alternative_transfer_function: 'INSERT', # accepts ["INSERT", "OMIT"]
    #               bitrate: 1,
    #               buf_size: 1,
    #               color_metadata: 'IGNORE', # accepts ["IGNORE", "INSERT"]
    #               color_space_settings: {
    #                 hdr10_settings: {
    #                   max_cll: 1,
    #                   max_fall: 1
    #                 },
    #               },
    #               filter_settings: {
    #               },
    #               fixed_afd: 'AFD_0000', # accepts ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #               flicker_aq: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               framerate_denominator: 1, # required
    #               framerate_numerator: 1, # required
    #               gop_closed_cadence: 1,
    #               gop_size: 1.0,
    #               gop_size_units: 'FRAMES', # accepts ["FRAMES", "SECONDS"]
    #               level: 'H265_LEVEL_1', # accepts ["H265_LEVEL_1", "H265_LEVEL_2", "H265_LEVEL_2_1", "H265_LEVEL_3", "H265_LEVEL_3_1", "H265_LEVEL_4", "H265_LEVEL_4_1", "H265_LEVEL_5", "H265_LEVEL_5_1", "H265_LEVEL_5_2", "H265_LEVEL_6", "H265_LEVEL_6_1", "H265_LEVEL_6_2", "H265_LEVEL_AUTO"]
    #               look_ahead_rate_control: 'HIGH', # accepts ["HIGH", "LOW", "MEDIUM"]
    #               max_bitrate: 1,
    #               min_i_interval: 1,
    #               par_denominator: 1,
    #               par_numerator: 1,
    #               profile: 'MAIN', # accepts ["MAIN", "MAIN_10BIT"]
    #               qvbr_quality_level: 1,
    #               rate_control_mode: 'CBR', # accepts ["CBR", "MULTIPLEX", "QVBR"]
    #               scan_type: 'INTERLACED', # accepts ["INTERLACED", "PROGRESSIVE"]
    #               scene_change_detect: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               slices: 1,
    #               tier: 'HIGH', # accepts ["HIGH", "MAIN"]
    #               timecode_insertion: 'DISABLED' # accepts ["DISABLED", "PIC_TIMING_SEI"]
    #             },
    #             mpeg2_settings: {
    #               adaptive_quantization: 'AUTO', # accepts ["AUTO", "HIGH", "LOW", "MEDIUM", "OFF"]
    #               afd_signaling: 'AUTO', # accepts ["AUTO", "FIXED", "NONE"]
    #               color_metadata: 'IGNORE', # accepts ["IGNORE", "INSERT"]
    #               color_space: 'AUTO', # accepts ["AUTO", "PASSTHROUGH"]
    #               display_aspect_ratio: 'DISPLAYRATIO16X9', # accepts ["DISPLAYRATIO16X9", "DISPLAYRATIO4X3"]
    #               filter_settings: {
    #               },
    #               fixed_afd: 'AFD_0000', # accepts ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #               framerate_denominator: 1, # required
    #               framerate_numerator: 1, # required
    #               gop_closed_cadence: 1,
    #               gop_num_b_frames: 1,
    #               gop_size: 1.0,
    #               gop_size_units: 'FRAMES', # accepts ["FRAMES", "SECONDS"]
    #               scan_type: 'INTERLACED', # accepts ["INTERLACED", "PROGRESSIVE"]
    #               subgop_length: 'DYNAMIC', # accepts ["DYNAMIC", "FIXED"]
    #               timecode_insertion: 'DISABLED' # accepts ["DISABLED", "GOP_TIMECODE"]
    #             }
    #           },
    #           height: 1,
    #           name: 'Name', # required
    #           respond_to_afd: 'NONE', # accepts ["NONE", "PASSTHROUGH", "RESPOND"]
    #           scaling_behavior: 'DEFAULT', # accepts ["DEFAULT", "STRETCH_TO_OUTPUT"]
    #           sharpness: 1,
    #           width: 1
    #         }
    #       ] # required
    #     },
    #     input_attachments: [
    #       {
    #         automatic_input_failover_settings: {
    #           error_clear_time_msec: 1,
    #           failover_conditions: [
    #             {
    #               failover_condition_settings: {
    #                 audio_silence_settings: {
    #                   audio_selector_name: 'AudioSelectorName', # required
    #                   audio_silence_threshold_msec: 1
    #                 },
    #                 input_loss_settings: {
    #                   input_loss_threshold_msec: 1
    #                 },
    #                 video_black_settings: {
    #                   black_detect_threshold: 1.0,
    #                   video_black_threshold_msec: 1
    #                 }
    #               }
    #             }
    #           ],
    #           input_preference: 'EQUAL_INPUT_PREFERENCE', # accepts ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #           secondary_input_id: 'SecondaryInputId' # required
    #         },
    #         input_attachment_name: 'InputAttachmentName',
    #         input_id: 'InputId',
    #         input_settings: {
    #           audio_selectors: [
    #             {
    #               name: 'Name', # required
    #               selector_settings: {
    #                 audio_hls_rendition_selection: {
    #                   group_id: 'GroupId', # required
    #                   name: 'Name' # required
    #                 },
    #                 audio_language_selection: {
    #                   language_code: 'LanguageCode', # required
    #                   language_selection_policy: 'LOOSE' # accepts ["LOOSE", "STRICT"]
    #                 },
    #                 audio_pid_selection: {
    #                   pid: 1 # required
    #                 },
    #                 audio_track_selection: {
    #                   tracks: [
    #                     {
    #                       track: 1 # required
    #                     }
    #                   ] # required
    #                 }
    #               }
    #             }
    #           ],
    #           caption_selectors: [
    #             {
    #               language_code: 'LanguageCode',
    #               name: 'Name', # required
    #               selector_settings: {
    #                 ancillary_source_settings: {
    #                   source_ancillary_channel_number: 1
    #                 },
    #                 arib_source_settings: { },
    #                 dvb_sub_source_settings: {
    #                   ocr_language: 'DEU', # accepts ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #                   pid: 1
    #                 },
    #                 embedded_source_settings: {
    #                   convert608_to708: 'DISABLED', # accepts ["DISABLED", "UPCONVERT"]
    #                   scte20_detection: 'AUTO', # accepts ["AUTO", "OFF"]
    #                   source608_channel_number: 1,
    #                   source608_track_number: 1
    #                 },
    #                 scte20_source_settings: {
    #                   convert608_to708: 'DISABLED', # accepts ["DISABLED", "UPCONVERT"]
    #                   source608_channel_number: 1
    #                 },
    #                 scte27_source_settings: {
    #                   ocr_language: 'DEU', # accepts ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #                   pid: 1
    #                 },
    #                 teletext_source_settings: {
    #                   output_rectangle: {
    #                     height: 1.0, # required
    #                     left_offset: 1.0, # required
    #                     top_offset: 1.0, # required
    #                     width: 1.0 # required
    #                   },
    #                   page_number: 'PageNumber'
    #                 }
    #               }
    #             }
    #           ],
    #           deblock_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #           denoise_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #           filter_strength: 1,
    #           input_filter: 'AUTO', # accepts ["AUTO", "DISABLED", "FORCED"]
    #           network_input_settings: {
    #             hls_input_settings: {
    #               bandwidth: 1,
    #               buffer_segments: 1,
    #               retries: 1,
    #               retry_interval: 1,
    #               scte35_source: 'MANIFEST' # accepts ["MANIFEST", "SEGMENTS"]
    #             },
    #             server_validation: 'CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME' # accepts ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #           },
    #           scte35_pid: 1,
    #           smpte2038_data_preference: 'IGNORE', # accepts ["IGNORE", "PREFER"]
    #           source_end_behavior: 'CONTINUE', # accepts ["CONTINUE", "LOOP"]
    #           video_selector: {
    #             color_space: 'FOLLOW', # accepts ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #             color_space_settings: {
    #             },
    #             color_space_usage: 'FALLBACK', # accepts ["FALLBACK", "FORCE"]
    #             selector_settings: {
    #               video_selector_pid: {
    #                 pid: 1
    #               },
    #               video_selector_program_id: {
    #                 program_id: 1
    #               }
    #             }
    #           }
    #         }
    #       }
    #     ],
    #     input_specification: {
    #       codec: 'MPEG2', # accepts ["MPEG2", "AVC", "HEVC"]
    #       maximum_bitrate: 'MAX_10_MBPS', # accepts ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #       resolution: 'SD' # accepts ["SD", "HD", "UHD"]
    #     },
    #     log_level: 'ERROR', # accepts ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #     maintenance: {
    #       maintenance_day: 'MONDAY', # accepts ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #       maintenance_start_time: 'MaintenanceStartTime'
    #     },
    #     name: 'Name',
    #     request_id: 'RequestId',
    #     reserved: 'Reserved',
    #     role_arn: 'RoleArn',
    #     tags: {
    #       'key' => 'value'
    #     },
    #     vpc: {
    #     }
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::CreateChannelOutput
    #   resp.data.channel #=> Types::Channel
    #   resp.data.channel.arn #=> String
    #   resp.data.channel.cdi_input_specification #=> Types::CdiInputSpecification
    #   resp.data.channel.cdi_input_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.channel.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.channel.destinations #=> Array<OutputDestination>
    #   resp.data.channel.destinations[0] #=> Types::OutputDestination
    #   resp.data.channel.destinations[0].id #=> String
    #   resp.data.channel.destinations[0].media_package_settings #=> Array<MediaPackageOutputDestinationSettings>
    #   resp.data.channel.destinations[0].media_package_settings[0] #=> Types::MediaPackageOutputDestinationSettings
    #   resp.data.channel.destinations[0].media_package_settings[0].channel_id #=> String
    #   resp.data.channel.destinations[0].multiplex_settings #=> Types::MultiplexProgramChannelDestinationSettings
    #   resp.data.channel.destinations[0].multiplex_settings.multiplex_id #=> String
    #   resp.data.channel.destinations[0].multiplex_settings.program_name #=> String
    #   resp.data.channel.destinations[0].settings #=> Array<OutputDestinationSettings>
    #   resp.data.channel.destinations[0].settings[0] #=> Types::OutputDestinationSettings
    #   resp.data.channel.destinations[0].settings[0].password_param #=> String
    #   resp.data.channel.destinations[0].settings[0].stream_name #=> String
    #   resp.data.channel.destinations[0].settings[0].url #=> String
    #   resp.data.channel.destinations[0].settings[0].username #=> String
    #   resp.data.channel.egress_endpoints #=> Array<ChannelEgressEndpoint>
    #   resp.data.channel.egress_endpoints[0] #=> Types::ChannelEgressEndpoint
    #   resp.data.channel.egress_endpoints[0].source_ip #=> String
    #   resp.data.channel.encoder_settings #=> Types::EncoderSettings
    #   resp.data.channel.encoder_settings.audio_descriptions #=> Array<AudioDescription>
    #   resp.data.channel.encoder_settings.audio_descriptions[0] #=> Types::AudioDescription
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings #=> Types::AudioNormalizationSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm #=> String, one of ["ITU_1770_1", "ITU_1770_2"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm_control #=> String, one of ["CORRECT_AUDIO"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings.target_lkfs #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_selector_name #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_type #=> String, one of ["CLEAN_EFFECTS", "HEARING_IMPAIRED", "UNDEFINED", "VISUAL_IMPAIRED_COMMENTARY"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_type_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings #=> Types::AudioWatermarkSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings #=> Types::NielsenWatermarksSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings #=> Types::NielsenCBET
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_check_digit_string #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_stepaside #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.csid #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_distribution_type #=> String, one of ["FINAL_DISTRIBUTOR", "PROGRAM_CONTENT"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings #=> Types::NielsenNaesIiNw
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.check_digit_string #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.sid #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings #=> Types::AudioCodecSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings #=> Types::AacSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.coding_mode #=> String, one of ["AD_RECEIVER_MIX", "CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_5_1"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.input_type #=> String, one of ["BROADCASTER_MIXED_AD", "NORMAL"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.profile #=> String, one of ["HEV1", "HEV2", "LC"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.rate_control_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.raw_format #=> String, one of ["LATM_LOAS", "NONE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.sample_rate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.spec #=> String, one of ["MPEG2", "MPEG4"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.vbr_quality #=> String, one of ["HIGH", "LOW", "MEDIUM_HIGH", "MEDIUM_LOW"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings #=> Types::Ac3Settings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "DIALOGUE", "EMERGENCY", "HEARING_IMPAIRED", "MUSIC_AND_EFFECTS", "VISUALLY_IMPAIRED", "VOICE_OVER"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_3_2_LFE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.dialnorm #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.drc_profile #=> String, one of ["FILM_STANDARD", "NONE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings #=> Types::Eac3Settings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.attenuation_control #=> String, one of ["ATTENUATE_3_DB", "NONE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "EMERGENCY", "HEARING_IMPAIRED", "VISUALLY_IMPAIRED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_3_2"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dc_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dialnorm #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_line #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_rf #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_control #=> String, one of ["LFE", "NO_LFE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_center_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_surround_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_center_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_surround_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.passthrough_control #=> String, one of ["NO_PASSTHROUGH", "WHEN_POSSIBLE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.phase_control #=> String, one of ["NO_SHIFT", "SHIFT_90_DEGREES"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.stereo_downmix #=> String, one of ["DPL2", "LO_RO", "LT_RT", "NOT_INDICATED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_ex_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings #=> Types::Mp2Settings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.sample_rate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.pass_through_settings #=> Types::PassThroughSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings #=> Types::WavSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.bit_depth #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_4_0", "CODING_MODE_8_0"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.sample_rate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].language_code #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].language_code_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].name #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings #=> Types::RemixSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings #=> Array<AudioChannelMapping>
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0] #=> Types::AudioChannelMapping
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels #=> Array<InputChannelLevel>
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0] #=> Types::InputChannelLevel
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].gain #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].input_channel #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].output_channel #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channels_in #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channels_out #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].stream_name #=> String
    #   resp.data.channel.encoder_settings.avail_blanking #=> Types::AvailBlanking
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image.password_param #=> String
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image.uri #=> String
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image.username #=> String
    #   resp.data.channel.encoder_settings.avail_blanking.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.avail_configuration #=> Types::AvailConfiguration
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings #=> Types::AvailSettings
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert #=> Types::Scte35SpliceInsert
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.ad_avail_offset #=> Integer
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos #=> Types::Scte35TimeSignalApos
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.ad_avail_offset #=> Integer
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.blackout_slate #=> Types::BlackoutSlate
    #   resp.data.channel.encoder_settings.blackout_slate.blackout_slate_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.blackout_slate.network_end_blackout #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.blackout_slate.network_end_blackout_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.blackout_slate.network_id #=> String
    #   resp.data.channel.encoder_settings.blackout_slate.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.caption_descriptions #=> Array<CaptionDescription>
    #   resp.data.channel.encoder_settings.caption_descriptions[0] #=> Types::CaptionDescription
    #   resp.data.channel.encoder_settings.caption_descriptions[0].caption_selector_name #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings #=> Types::CaptionDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.arib_destination_settings #=> Types::AribDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings #=> Types::BurnInDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_resolution #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_size #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_size #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.x_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.y_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings #=> Types::DvbSubDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_resolution #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_size #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_size #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.x_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.y_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings #=> Types::EbuTtDDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.copyright_holder #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.fill_line_gap #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.font_family #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.style_control #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.embedded_destination_settings #=> Types::EmbeddedDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.embedded_plus_scte20_destination_settings #=> Types::EmbeddedPlusScte20DestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.rtmp_caption_info_destination_settings #=> Types::RtmpCaptionInfoDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.scte20_plus_embedded_destination_settings #=> Types::Scte20PlusEmbeddedDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.scte27_destination_settings #=> Types::Scte27DestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.smpte_tt_destination_settings #=> Types::SmpteTtDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.teletext_destination_settings #=> Types::TeletextDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings #=> Types::TtmlDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings.style_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings #=> Types::WebvttDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings.style_control #=> String, one of ["NO_STYLE_DATA", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].language_code #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].language_description #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].name #=> String
    #   resp.data.channel.encoder_settings.feature_activations #=> Types::FeatureActivations
    #   resp.data.channel.encoder_settings.feature_activations.input_prepare_schedule_actions #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.global_configuration #=> Types::GlobalConfiguration
    #   resp.data.channel.encoder_settings.global_configuration.initial_audio_gain #=> Integer
    #   resp.data.channel.encoder_settings.global_configuration.input_end_action #=> String, one of ["NONE", "SWITCH_AND_LOOP_INPUTS"]
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior #=> Types::InputLossBehavior
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.black_frame_msec #=> Integer
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_color #=> String
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_slate #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_type #=> String, one of ["COLOR", "SLATE"]
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.repeat_frame_msec #=> Integer
    #   resp.data.channel.encoder_settings.global_configuration.output_locking_mode #=> String, one of ["EPOCH_LOCKING", "PIPELINE_LOCKING"]
    #   resp.data.channel.encoder_settings.global_configuration.output_timing_source #=> String, one of ["INPUT_CLOCK", "SYSTEM_CLOCK"]
    #   resp.data.channel.encoder_settings.global_configuration.support_low_framerate_inputs #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.motion_graphics_configuration #=> Types::MotionGraphicsConfiguration
    #   resp.data.channel.encoder_settings.motion_graphics_configuration.motion_graphics_insertion #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.motion_graphics_configuration.motion_graphics_settings #=> Types::MotionGraphicsSettings
    #   resp.data.channel.encoder_settings.motion_graphics_configuration.motion_graphics_settings.html_motion_graphics_settings #=> Types::HtmlMotionGraphicsSettings
    #   resp.data.channel.encoder_settings.nielsen_configuration #=> Types::NielsenConfiguration
    #   resp.data.channel.encoder_settings.nielsen_configuration.distributor_id #=> String
    #   resp.data.channel.encoder_settings.nielsen_configuration.nielsen_pcm_to_id3_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups #=> Array<OutputGroup>
    #   resp.data.channel.encoder_settings.output_groups[0] #=> Types::OutputGroup
    #   resp.data.channel.encoder_settings.output_groups[0].name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings #=> Types::OutputGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings #=> Types::ArchiveGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings #=> Types::ArchiveCdnSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings #=> Types::ArchiveS3Settings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination.destination_ref_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.rollover_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings #=> Types::FrameCaptureGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings #=> Types::FrameCaptureCdnSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings #=> Types::FrameCaptureS3Settings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings #=> Types::HlsGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers[0] #=> String, one of ["ADOBE", "ELEMENTAL", "ELEMENTAL_SCTE35"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content1 #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest1 #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings #=> Array<CaptionLanguageMapping>
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0] #=> Types::CaptionLanguageMapping
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].caption_channel #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_code #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_description #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_setting #=> String, one of ["INSERT", "NONE", "OMIT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.client_cache #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.codec_specification #=> String, one of ["RFC_4281", "RFC_6381"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.constant_iv #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.directory_structure #=> String, one of ["SINGLE_DIRECTORY", "SUBDIRECTORY_PER_STREAM"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.discontinuity_tags #=> String, one of ["INSERT", "NEVER_INSERT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.encryption_type #=> String, one of ["AES128", "SAMPLE_AES"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings #=> Types::HlsCdnSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings #=> Types::HlsAkamaiSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.salt #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.token #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings #=> Types::HlsBasicPutSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings #=> Types::HlsMediaStoreSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.media_store_storage_class #=> String, one of ["TEMPORAL"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings #=> Types::HlsS3Settings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings #=> Types::HlsWebdavSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_id3_segment_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.i_frame_only_playlists #=> String, one of ["DISABLED", "STANDARD"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.incomplete_segment_behavior #=> String, one of ["AUTO", "SUPPRESS"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.index_n_segments #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_in_manifest #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_source #=> String, one of ["EXPLICIT", "FOLLOWS_SEGMENT_NUMBER"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.keep_segments #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format_versions #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings #=> Types::KeyProviderSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings #=> Types::StaticKeySettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.key_provider_server #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.static_key_value #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_compression #=> String, one of ["GZIP", "NONE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_duration_format #=> String, one of ["FLOATING_POINT", "INTEGER"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.min_segment_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.mode #=> String, one of ["LIVE", "VOD"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.output_selection #=> String, one of ["MANIFESTS_AND_SEGMENTS", "SEGMENTS_ONLY", "VARIANT_MANIFESTS_AND_SEGMENTS"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_clock #=> String, one of ["INITIALIZE_FROM_OUTPUT_TIMECODE", "SYSTEM_CLOCK"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.redundant_manifest #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segment_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segments_per_subdirectory #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.stream_inf_resolution #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timestamp_delta_milliseconds #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ts_file_mode #=> String, one of ["SEGMENTED_FILES", "SINGLE_FILE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings #=> Types::MediaPackageGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings #=> Types::MsSmoothGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.acquisition_point_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.audio_only_timecode_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED_CLOCK"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id_mode #=> String, one of ["NO_EVENT_ID", "USE_CONFIGURED", "USE_TIMESTAMP"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_stop_behavior #=> String, one of ["NONE", "SEND_EOS"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.fragment_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.send_delay_ms #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.sparse_track_type #=> String, one of ["NONE", "SCTE_35", "SCTE_35_WITHOUT_SEGMENTATION"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.stream_manifest_behavior #=> String, one of ["DO_NOT_SEND", "SEND"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset_mode #=> String, one of ["USE_CONFIGURED_OFFSET", "USE_EVENT_START_DATE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.multiplex_group_settings #=> Types::MultiplexGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings #=> Types::RtmpGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers[0] #=> String, one of ["ON_CUE_POINT_SCTE35"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.authentication_scheme #=> String, one of ["AKAMAI", "COMMON"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_full_behavior #=> String, one of ["DISCONNECT_IMMEDIATELY", "WAIT_FOR_SERVER"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.caption_data #=> String, one of ["ALL", "FIELD1_608", "FIELD1_AND_FIELD2_608"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings #=> Types::UdpGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.input_loss_action #=> String, one of ["DROP_PROGRAM", "DROP_TS", "EMIT_PROGRAM"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs #=> Array<Output>
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0] #=> Types::Output
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].audio_description_names #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].audio_description_names[0] #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].caption_description_names #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings #=> Types::OutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings #=> Types::ArchiveOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings #=> Types::ArchiveContainerSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.absent_input_audio_behavior #=> String, one of ["DROP", "ENCODE_SILENCE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid_control #=> String, one of ["AUTO", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_buffer_model #=> String, one of ["ATSC", "DVB"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_frames_per_pes #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_stream_type #=> String, one of ["ATSC", "DVB"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.bitrate #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.buffer_model #=> String, one of ["MULTIPLEX", "NONE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.cc_descriptor #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings #=> Types::DvbNitSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_id #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.rep_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings #=> Types::DvbSdtSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.output_sdt #=> String, one of ["SDT_FOLLOW", "SDT_FOLLOW_IF_PRESENT", "SDT_MANUAL", "SDT_NONE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.rep_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_provider_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sub_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings #=> Types::DvbTdtSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings.rep_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_teletext_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebif #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_audio_interval #=> String, one of ["VIDEO_AND_FIXED_INTERVALS", "VIDEO_INTERVAL"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_lookahead_ms #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_placement #=> String, one of ["VIDEO_AND_AUDIO_PIDS", "VIDEO_PID"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ecm_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.es_rate_in_pes #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_platform_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_signal_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.fragment_time #=> Float
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv_data_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.null_packet_bitrate #=> Float
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pat_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.program_num #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.rate_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte27_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_control #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_markers #=> String, one of ["EBP", "EBP_LEGACY", "NONE", "PSI_SEGSTART", "RAI_ADAPT", "RAI_SEGSTART"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_style #=> String, one of ["MAINTAIN_CADENCE", "RESET_CADENCE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_time #=> Float
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.transport_stream_id #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.video_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.raw_settings #=> Types::RawSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.extension #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings #=> Types::FrameCaptureOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings #=> Types::HlsOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings #=> Types::HlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings #=> Types::AudioOnlyHlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_group_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_only_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_track_type #=> String, one of ["ALTERNATE_AUDIO_AUTO_SELECT", "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT", "ALTERNATE_AUDIO_NOT_AUTO_SELECT", "AUDIO_ONLY_VARIANT_STREAM"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.segment_type #=> String, one of ["AAC", "FMP4"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings #=> Types::Fmp4HlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.audio_rendition_sets #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.frame_capture_hls_settings #=> Types::FrameCaptureHlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings #=> Types::StandardHlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.audio_rendition_sets #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings #=> Types::M3u8Settings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_frames_per_pes #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.ecm_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pat_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.program_num #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.transport_stream_id #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.video_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.segment_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.media_package_output_settings #=> Types::MediaPackageOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings #=> Types::MsSmoothOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings #=> Types::MultiplexOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings #=> Types::RtmpOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings #=> Types::UdpOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.buffer_msec #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings #=> Types::UdpContainerSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings #=> Types::FecOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.column_depth #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.include_fec #=> String, one of ["COLUMN", "COLUMN_AND_ROW"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.row_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].video_description_name #=> String
    #   resp.data.channel.encoder_settings.timecode_config #=> Types::TimecodeConfig
    #   resp.data.channel.encoder_settings.timecode_config.source #=> String, one of ["EMBEDDED", "SYSTEMCLOCK", "ZEROBASED"]
    #   resp.data.channel.encoder_settings.timecode_config.sync_threshold #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions #=> Array<VideoDescription>
    #   resp.data.channel.encoder_settings.video_descriptions[0] #=> Types::VideoDescription
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings #=> Types::VideoCodecSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings #=> Types::FrameCaptureSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval_units #=> String, one of ["MILLISECONDS", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings #=> Types::H264Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_fill_pct #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_size #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings #=> Types::H264ColorSpaceSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.entropy_encoding #=> String, one of ["CABAC", "CAVLC"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings #=> Types::H264FilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.post_filter_sharpening #=> String, one of ["AUTO", "DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.strength #=> String, one of ["AUTO", "STRENGTH_1", "STRENGTH_2", "STRENGTH_3", "STRENGTH_4", "STRENGTH_5", "STRENGTH_6", "STRENGTH_7", "STRENGTH_8", "STRENGTH_9", "STRENGTH_10", "STRENGTH_11", "STRENGTH_12", "STRENGTH_13", "STRENGTH_14", "STRENGTH_15", "STRENGTH_16"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.force_field_pictures #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_b_reference #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_closed_cadence #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_num_b_frames #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size #=> Float
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.level #=> String, one of ["H264_LEVEL_1", "H264_LEVEL_1_1", "H264_LEVEL_1_2", "H264_LEVEL_1_3", "H264_LEVEL_2", "H264_LEVEL_2_1", "H264_LEVEL_2_2", "H264_LEVEL_3", "H264_LEVEL_3_1", "H264_LEVEL_3_2", "H264_LEVEL_4", "H264_LEVEL_4_1", "H264_LEVEL_4_2", "H264_LEVEL_5", "H264_LEVEL_5_1", "H264_LEVEL_5_2", "H264_LEVEL_AUTO"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.max_bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.min_i_interval #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.num_ref_frames #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.profile #=> String, one of ["BASELINE", "HIGH", "HIGH_10BIT", "HIGH_422", "HIGH_422_10BIT", "MAIN"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.quality_level #=> String, one of ["ENHANCED_QUALITY", "STANDARD_QUALITY"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.qvbr_quality_level #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR", "VBR"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.slices #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.softness #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.spatial_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.syntax #=> String, one of ["DEFAULT", "RP2027"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.temporal_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings #=> Types::H265Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.alternative_transfer_function #=> String, one of ["INSERT", "OMIT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.buf_size #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings #=> Types::H265ColorSpaceSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_cll #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_fall #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings #=> Types::H265FilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_closed_cadence #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size #=> Float
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.level #=> String, one of ["H265_LEVEL_1", "H265_LEVEL_2", "H265_LEVEL_2_1", "H265_LEVEL_3", "H265_LEVEL_3_1", "H265_LEVEL_4", "H265_LEVEL_4_1", "H265_LEVEL_5", "H265_LEVEL_5_1", "H265_LEVEL_5_2", "H265_LEVEL_6", "H265_LEVEL_6_1", "H265_LEVEL_6_2", "H265_LEVEL_AUTO"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.max_bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.min_i_interval #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.profile #=> String, one of ["MAIN", "MAIN_10BIT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.qvbr_quality_level #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.slices #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.tier #=> String, one of ["HIGH", "MAIN"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings #=> Types::Mpeg2Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "LOW", "MEDIUM", "OFF"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_space #=> String, one of ["AUTO", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.display_aspect_ratio #=> String, one of ["DISPLAYRATIO16X9", "DISPLAYRATIO4X3"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings #=> Types::Mpeg2FilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_closed_cadence #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_num_b_frames #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size #=> Float
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.timecode_insertion #=> String, one of ["DISABLED", "GOP_TIMECODE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].height #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].name #=> String
    #   resp.data.channel.encoder_settings.video_descriptions[0].respond_to_afd #=> String, one of ["NONE", "PASSTHROUGH", "RESPOND"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].scaling_behavior #=> String, one of ["DEFAULT", "STRETCH_TO_OUTPUT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].sharpness #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].width #=> Integer
    #   resp.data.channel.id #=> String
    #   resp.data.channel.input_attachments #=> Array<InputAttachment>
    #   resp.data.channel.input_attachments[0] #=> Types::InputAttachment
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings #=> Types::AutomaticInputFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.error_clear_time_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions #=> Array<FailoverCondition>
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0] #=> Types::FailoverCondition
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings #=> Types::FailoverConditionSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings #=> Types::AudioSilenceFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_selector_name #=> String
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_silence_threshold_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings #=> Types::InputLossFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings.input_loss_threshold_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings #=> Types::VideoBlackFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.black_detect_threshold #=> Float
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.video_black_threshold_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.input_preference #=> String, one of ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.secondary_input_id #=> String
    #   resp.data.channel.input_attachments[0].input_attachment_name #=> String
    #   resp.data.channel.input_attachments[0].input_id #=> String
    #   resp.data.channel.input_attachments[0].input_settings #=> Types::InputSettings
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors #=> Array<AudioSelector>
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0] #=> Types::AudioSelector
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].name #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings #=> Types::AudioSelectorSettings
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection #=> Types::AudioHlsRenditionSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.group_id #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.name #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection #=> Types::AudioLanguageSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_code #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_selection_policy #=> String, one of ["LOOSE", "STRICT"]
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection #=> Types::AudioPidSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection #=> Types::AudioTrackSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks #=> Array<AudioTrack>
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0] #=> Types::AudioTrack
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0].track #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors #=> Array<CaptionSelector>
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0] #=> Types::CaptionSelector
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].language_code #=> String
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].name #=> String
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings #=> Types::CaptionSelectorSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings #=> Types::AncillarySourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings.source_ancillary_channel_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.arib_source_settings #=> Types::AribSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings #=> Types::DvbSubSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings #=> Types::EmbeddedSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.scte20_detection #=> String, one of ["AUTO", "OFF"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_channel_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_track_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings #=> Types::Scte20SourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.source608_channel_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings #=> Types::Scte27SourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings #=> Types::TeletextSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle #=> Types::CaptionRectangle
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.height #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.left_offset #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.top_offset #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.width #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.page_number #=> String
    #   resp.data.channel.input_attachments[0].input_settings.deblock_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.input_attachments[0].input_settings.denoise_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.input_attachments[0].input_settings.filter_strength #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.input_filter #=> String, one of ["AUTO", "DISABLED", "FORCED"]
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings #=> Types::NetworkInputSettings
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings #=> Types::HlsInputSettings
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.bandwidth #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.buffer_segments #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retries #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retry_interval #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.scte35_source #=> String, one of ["MANIFEST", "SEGMENTS"]
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.server_validation #=> String, one of ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #   resp.data.channel.input_attachments[0].input_settings.scte35_pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.smpte2038_data_preference #=> String, one of ["IGNORE", "PREFER"]
    #   resp.data.channel.input_attachments[0].input_settings.source_end_behavior #=> String, one of ["CONTINUE", "LOOP"]
    #   resp.data.channel.input_attachments[0].input_settings.video_selector #=> Types::VideoSelector
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space #=> String, one of ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space_settings #=> Types::VideoSelectorColorSpaceSettings
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space_usage #=> String, one of ["FALLBACK", "FORCE"]
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings #=> Types::VideoSelectorSettings
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid #=> Types::VideoSelectorPid
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id #=> Types::VideoSelectorProgramId
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id.program_id #=> Integer
    #   resp.data.channel.input_specification #=> Types::InputSpecification
    #   resp.data.channel.input_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC"]
    #   resp.data.channel.input_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.channel.input_specification.resolution #=> String, one of ["SD", "HD", "UHD"]
    #   resp.data.channel.log_level #=> String, one of ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #   resp.data.channel.maintenance #=> Types::MaintenanceStatus
    #   resp.data.channel.maintenance.maintenance_day #=> String, one of ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #   resp.data.channel.maintenance.maintenance_deadline #=> String
    #   resp.data.channel.maintenance.maintenance_scheduled_date #=> String
    #   resp.data.channel.maintenance.maintenance_start_time #=> String
    #   resp.data.channel.name #=> String
    #   resp.data.channel.pipeline_details #=> Array<PipelineDetail>
    #   resp.data.channel.pipeline_details[0] #=> Types::PipelineDetail
    #   resp.data.channel.pipeline_details[0].active_input_attachment_name #=> String
    #   resp.data.channel.pipeline_details[0].active_input_switch_action_name #=> String
    #   resp.data.channel.pipeline_details[0].active_motion_graphics_action_name #=> String
    #   resp.data.channel.pipeline_details[0].active_motion_graphics_uri #=> String
    #   resp.data.channel.pipeline_details[0].pipeline_id #=> String
    #   resp.data.channel.pipelines_running_count #=> Integer
    #   resp.data.channel.role_arn #=> String
    #   resp.data.channel.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED", "UPDATING", "UPDATE_FAILED"]
    #   resp.data.channel.tags #=> Hash<String, String>
    #   resp.data.channel.tags['key'] #=> String
    #   resp.data.channel.vpc #=> Types::VpcOutputSettingsDescription
    #   resp.data.channel.vpc.availability_zones #=> Array<String>
    #   resp.data.channel.vpc.network_interface_ids #=> Array<String>
    #   resp.data.channel.vpc.security_group_ids #=> Array<String>
    #   resp.data.channel.vpc.subnet_ids #=> Array<String>
    #
    def create_channel(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::CreateChannelInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::CreateChannelInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::CreateChannel
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 201, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::CreateChannel
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::CreateChannel,
        stubs: @stubs,
        params_class: Params::CreateChannelOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :create_channel
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Create an input
    #
    # @param [Hash] params
    #   See {Types::CreateInputInput}.
    #
    # @option params [Array<InputDestinationRequest>] :destinations
    #   Destination settings for PUSH type inputs.
    #
    # @option params [Array<InputDeviceSettings>] :input_devices
    #   Settings for the devices.
    #
    # @option params [Array<String>] :input_security_groups
    #   A list of security groups referenced by IDs to attach to the input.
    #
    # @option params [Array<MediaConnectFlowRequest>] :media_connect_flows
    #   A list of the MediaConnect Flows that you want to use in this input. You can specify as few as one
    #   Flow and presently, as many as two. The only requirement is when you have more than one is that each Flow is in a
    #   separate Availability Zone as this ensures your EML input is redundant to AZ issues.
    #
    # @option params [String] :name
    #   Name of the input.
    #
    # @option params [String] :request_id
    #   Unique identifier of the request to ensure the request is handled
    #   exactly once in case of retries.
    #
    # @option params [String] :role_arn
    #   The Amazon Resource Name (ARN) of the role this input assumes during and after creation.
    #
    # @option params [Array<InputSourceRequest>] :sources
    #   The source URLs for a PULL-type input. Every PULL type input needs
    #   exactly two source URLs for redundancy.
    #   Only specify sources for PULL type Inputs. Leave Destinations empty.
    #
    # @option params [Hash<String, String>] :tags
    #   A collection of key-value pairs.
    #
    # @option params [String] :type
    #   The different types of inputs that AWS Elemental MediaLive supports.
    #
    # @option params [InputVpcRequest] :vpc
    #   Settings for a private VPC Input.
    #   When this property is specified, the input destination addresses will be created in a VPC rather than with public Internet addresses.
    #   This property requires setting the roleArn property on Input creation.
    #   Not compatible with the inputSecurityGroups property.
    #
    # @return [Types::CreateInputOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.create_input(
    #     destinations: [
    #       {
    #         stream_name: 'StreamName'
    #       }
    #     ],
    #     input_devices: [
    #       {
    #         id: 'Id'
    #       }
    #     ],
    #     input_security_groups: [
    #       'member'
    #     ],
    #     media_connect_flows: [
    #       {
    #         flow_arn: 'FlowArn'
    #       }
    #     ],
    #     name: 'Name',
    #     request_id: 'RequestId',
    #     role_arn: 'RoleArn',
    #     sources: [
    #       {
    #         password_param: 'PasswordParam',
    #         url: 'Url',
    #         username: 'Username'
    #       }
    #     ],
    #     tags: {
    #       'key' => 'value'
    #     },
    #     type: 'UDP_PUSH', # accepts ["UDP_PUSH", "RTP_PUSH", "RTMP_PUSH", "RTMP_PULL", "URL_PULL", "MP4_FILE", "MEDIACONNECT", "INPUT_DEVICE", "AWS_CDI", "TS_FILE"]
    #     vpc: {
    #     }
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::CreateInputOutput
    #   resp.data.input #=> Types::Input
    #   resp.data.input.arn #=> String
    #   resp.data.input.attached_channels #=> Array<String>
    #   resp.data.input.attached_channels[0] #=> String
    #   resp.data.input.destinations #=> Array<InputDestination>
    #   resp.data.input.destinations[0] #=> Types::InputDestination
    #   resp.data.input.destinations[0].ip #=> String
    #   resp.data.input.destinations[0].port #=> String
    #   resp.data.input.destinations[0].url #=> String
    #   resp.data.input.destinations[0].vpc #=> Types::InputDestinationVpc
    #   resp.data.input.destinations[0].vpc.availability_zone #=> String
    #   resp.data.input.destinations[0].vpc.network_interface_id #=> String
    #   resp.data.input.id #=> String
    #   resp.data.input.input_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.input.input_devices #=> Array<InputDeviceSettings>
    #   resp.data.input.input_devices[0] #=> Types::InputDeviceSettings
    #   resp.data.input.input_devices[0].id #=> String
    #   resp.data.input.input_partner_ids #=> Array<String>
    #   resp.data.input.input_source_type #=> String, one of ["STATIC", "DYNAMIC"]
    #   resp.data.input.media_connect_flows #=> Array<MediaConnectFlow>
    #   resp.data.input.media_connect_flows[0] #=> Types::MediaConnectFlow
    #   resp.data.input.media_connect_flows[0].flow_arn #=> String
    #   resp.data.input.name #=> String
    #   resp.data.input.role_arn #=> String
    #   resp.data.input.security_groups #=> Array<String>
    #   resp.data.input.sources #=> Array<InputSource>
    #   resp.data.input.sources[0] #=> Types::InputSource
    #   resp.data.input.sources[0].password_param #=> String
    #   resp.data.input.sources[0].url #=> String
    #   resp.data.input.sources[0].username #=> String
    #   resp.data.input.state #=> String, one of ["CREATING", "DETACHED", "ATTACHED", "DELETING", "DELETED"]
    #   resp.data.input.tags #=> Hash<String, String>
    #   resp.data.input.tags['key'] #=> String
    #   resp.data.input.type #=> String, one of ["UDP_PUSH", "RTP_PUSH", "RTMP_PUSH", "RTMP_PULL", "URL_PULL", "MP4_FILE", "MEDIACONNECT", "INPUT_DEVICE", "AWS_CDI", "TS_FILE"]
    #
    def create_input(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::CreateInputInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::CreateInputInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::CreateInput
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 201, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::CreateInput
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::CreateInput,
        stubs: @stubs,
        params_class: Params::CreateInputOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :create_input
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Creates a Input Security Group
    #
    # @param [Hash] params
    #   See {Types::CreateInputSecurityGroupInput}.
    #
    # @option params [Hash<String, String>] :tags
    #   A collection of key-value pairs.
    #
    # @option params [Array<InputWhitelistRuleCidr>] :whitelist_rules
    #   List of IPv4 CIDR addresses to whitelist
    #
    # @return [Types::CreateInputSecurityGroupOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.create_input_security_group(
    #     tags: {
    #       'key' => 'value'
    #     },
    #     whitelist_rules: [
    #       {
    #         cidr: 'Cidr'
    #       }
    #     ]
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::CreateInputSecurityGroupOutput
    #   resp.data.security_group #=> Types::InputSecurityGroup
    #   resp.data.security_group.arn #=> String
    #   resp.data.security_group.id #=> String
    #   resp.data.security_group.inputs #=> Array<String>
    #   resp.data.security_group.inputs[0] #=> String
    #   resp.data.security_group.state #=> String, one of ["IDLE", "IN_USE", "UPDATING", "DELETED"]
    #   resp.data.security_group.tags #=> Hash<String, String>
    #   resp.data.security_group.tags['key'] #=> String
    #   resp.data.security_group.whitelist_rules #=> Array<InputWhitelistRule>
    #   resp.data.security_group.whitelist_rules[0] #=> Types::InputWhitelistRule
    #   resp.data.security_group.whitelist_rules[0].cidr #=> String
    #
    def create_input_security_group(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::CreateInputSecurityGroupInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::CreateInputSecurityGroupInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::CreateInputSecurityGroup
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::CreateInputSecurityGroup
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::CreateInputSecurityGroup,
        stubs: @stubs,
        params_class: Params::CreateInputSecurityGroupOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :create_input_security_group
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Create a new multiplex.
    #
    # @param [Hash] params
    #   See {Types::CreateMultiplexInput}.
    #
    # @option params [Array<String>] :availability_zones
    #   A list of availability zones for the multiplex. You must specify exactly two.
    #
    # @option params [MultiplexSettings] :multiplex_settings
    #   Configuration for a multiplex event.
    #
    # @option params [String] :name
    #   Name of multiplex.
    #
    # @option params [String] :request_id
    #   Unique request ID. This prevents retries from creating multiple
    #   resources.
    #
    # @option params [Hash<String, String>] :tags
    #   A collection of key-value pairs.
    #
    # @return [Types::CreateMultiplexOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.create_multiplex(
    #     availability_zones: [
    #       'member'
    #     ], # required
    #     multiplex_settings: {
    #       maximum_video_buffer_delay_milliseconds: 1,
    #       transport_stream_bitrate: 1, # required
    #       transport_stream_id: 1, # required
    #       transport_stream_reserved_bitrate: 1
    #     }, # required
    #     name: 'Name', # required
    #     request_id: 'RequestId', # required
    #     tags: {
    #       'key' => 'value'
    #     }
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::CreateMultiplexOutput
    #   resp.data.multiplex #=> Types::Multiplex
    #   resp.data.multiplex.arn #=> String
    #   resp.data.multiplex.availability_zones #=> Array<String>
    #   resp.data.multiplex.availability_zones[0] #=> String
    #   resp.data.multiplex.destinations #=> Array<MultiplexOutputDestination>
    #   resp.data.multiplex.destinations[0] #=> Types::MultiplexOutputDestination
    #   resp.data.multiplex.destinations[0].media_connect_settings #=> Types::MultiplexMediaConnectOutputDestinationSettings
    #   resp.data.multiplex.destinations[0].media_connect_settings.entitlement_arn #=> String
    #   resp.data.multiplex.id #=> String
    #   resp.data.multiplex.multiplex_settings #=> Types::MultiplexSettings
    #   resp.data.multiplex.multiplex_settings.maximum_video_buffer_delay_milliseconds #=> Integer
    #   resp.data.multiplex.multiplex_settings.transport_stream_bitrate #=> Integer
    #   resp.data.multiplex.multiplex_settings.transport_stream_id #=> Integer
    #   resp.data.multiplex.multiplex_settings.transport_stream_reserved_bitrate #=> Integer
    #   resp.data.multiplex.name #=> String
    #   resp.data.multiplex.pipelines_running_count #=> Integer
    #   resp.data.multiplex.program_count #=> Integer
    #   resp.data.multiplex.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED"]
    #   resp.data.multiplex.tags #=> Hash<String, String>
    #   resp.data.multiplex.tags['key'] #=> String
    #
    def create_multiplex(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::CreateMultiplexInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::CreateMultiplexInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::CreateMultiplex
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 201, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::CreateMultiplex
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::CreateMultiplex,
        stubs: @stubs,
        params_class: Params::CreateMultiplexOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :create_multiplex
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Create a new program in the multiplex.
    #
    # @param [Hash] params
    #   See {Types::CreateMultiplexProgramInput}.
    #
    # @option params [String] :multiplex_id
    #   ID of the multiplex where the program is to be created.
    #
    # @option params [MultiplexProgramSettings] :multiplex_program_settings
    #   The settings for this multiplex program.
    #
    # @option params [String] :program_name
    #   Name of multiplex program.
    #
    # @option params [String] :request_id
    #   Unique request ID. This prevents retries from creating multiple
    #   resources.
    #
    # @return [Types::CreateMultiplexProgramOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.create_multiplex_program(
    #     multiplex_id: 'MultiplexId', # required
    #     multiplex_program_settings: {
    #       preferred_channel_pipeline: 'CURRENTLY_ACTIVE', # accepts ["CURRENTLY_ACTIVE", "PIPELINE_0", "PIPELINE_1"]
    #       program_number: 1, # required
    #       service_descriptor: {
    #         provider_name: 'ProviderName', # required
    #         service_name: 'ServiceName' # required
    #       },
    #       video_settings: {
    #         constant_bitrate: 1,
    #         statmux_settings: {
    #           maximum_bitrate: 1,
    #           minimum_bitrate: 1,
    #           priority: 1
    #         }
    #       }
    #     }, # required
    #     program_name: 'ProgramName', # required
    #     request_id: 'RequestId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::CreateMultiplexProgramOutput
    #   resp.data.multiplex_program #=> Types::MultiplexProgram
    #   resp.data.multiplex_program.channel_id #=> String
    #   resp.data.multiplex_program.multiplex_program_settings #=> Types::MultiplexProgramSettings
    #   resp.data.multiplex_program.multiplex_program_settings.preferred_channel_pipeline #=> String, one of ["CURRENTLY_ACTIVE", "PIPELINE_0", "PIPELINE_1"]
    #   resp.data.multiplex_program.multiplex_program_settings.program_number #=> Integer
    #   resp.data.multiplex_program.multiplex_program_settings.service_descriptor #=> Types::MultiplexProgramServiceDescriptor
    #   resp.data.multiplex_program.multiplex_program_settings.service_descriptor.provider_name #=> String
    #   resp.data.multiplex_program.multiplex_program_settings.service_descriptor.service_name #=> String
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings #=> Types::MultiplexVideoSettings
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.constant_bitrate #=> Integer
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.statmux_settings #=> Types::MultiplexStatmuxVideoSettings
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.statmux_settings.maximum_bitrate #=> Integer
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.statmux_settings.minimum_bitrate #=> Integer
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.statmux_settings.priority #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map #=> Types::MultiplexProgramPacketIdentifiersMap
    #   resp.data.multiplex_program.packet_identifiers_map.audio_pids #=> Array<Integer>
    #   resp.data.multiplex_program.packet_identifiers_map.audio_pids[0] #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.dvb_sub_pids #=> Array<Integer>
    #   resp.data.multiplex_program.packet_identifiers_map.dvb_teletext_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.etv_platform_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.etv_signal_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.klv_data_pids #=> Array<Integer>
    #   resp.data.multiplex_program.packet_identifiers_map.pcr_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.pmt_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.private_metadata_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.scte27_pids #=> Array<Integer>
    #   resp.data.multiplex_program.packet_identifiers_map.scte35_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.timed_metadata_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.video_pid #=> Integer
    #   resp.data.multiplex_program.pipeline_details #=> Array<MultiplexProgramPipelineDetail>
    #   resp.data.multiplex_program.pipeline_details[0] #=> Types::MultiplexProgramPipelineDetail
    #   resp.data.multiplex_program.pipeline_details[0].active_channel_pipeline #=> String
    #   resp.data.multiplex_program.pipeline_details[0].pipeline_id #=> String
    #   resp.data.multiplex_program.program_name #=> String
    #
    def create_multiplex_program(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::CreateMultiplexProgramInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::CreateMultiplexProgramInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::CreateMultiplexProgram
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 201, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::CreateMultiplexProgram
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::CreateMultiplexProgram,
        stubs: @stubs,
        params_class: Params::CreateMultiplexProgramOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :create_multiplex_program
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Create a partner input
    #
    # @param [Hash] params
    #   See {Types::CreatePartnerInputInput}.
    #
    # @option params [String] :input_id
    #   Unique ID of the input.
    #
    # @option params [String] :request_id
    #   Unique identifier of the request to ensure the request is handled
    #   exactly once in case of retries.
    #
    # @option params [Hash<String, String>] :tags
    #   A collection of key-value pairs.
    #
    # @return [Types::CreatePartnerInputOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.create_partner_input(
    #     input_id: 'InputId', # required
    #     request_id: 'RequestId',
    #     tags: {
    #       'key' => 'value'
    #     }
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::CreatePartnerInputOutput
    #   resp.data.input #=> Types::Input
    #   resp.data.input.arn #=> String
    #   resp.data.input.attached_channels #=> Array<String>
    #   resp.data.input.attached_channels[0] #=> String
    #   resp.data.input.destinations #=> Array<InputDestination>
    #   resp.data.input.destinations[0] #=> Types::InputDestination
    #   resp.data.input.destinations[0].ip #=> String
    #   resp.data.input.destinations[0].port #=> String
    #   resp.data.input.destinations[0].url #=> String
    #   resp.data.input.destinations[0].vpc #=> Types::InputDestinationVpc
    #   resp.data.input.destinations[0].vpc.availability_zone #=> String
    #   resp.data.input.destinations[0].vpc.network_interface_id #=> String
    #   resp.data.input.id #=> String
    #   resp.data.input.input_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.input.input_devices #=> Array<InputDeviceSettings>
    #   resp.data.input.input_devices[0] #=> Types::InputDeviceSettings
    #   resp.data.input.input_devices[0].id #=> String
    #   resp.data.input.input_partner_ids #=> Array<String>
    #   resp.data.input.input_source_type #=> String, one of ["STATIC", "DYNAMIC"]
    #   resp.data.input.media_connect_flows #=> Array<MediaConnectFlow>
    #   resp.data.input.media_connect_flows[0] #=> Types::MediaConnectFlow
    #   resp.data.input.media_connect_flows[0].flow_arn #=> String
    #   resp.data.input.name #=> String
    #   resp.data.input.role_arn #=> String
    #   resp.data.input.security_groups #=> Array<String>
    #   resp.data.input.sources #=> Array<InputSource>
    #   resp.data.input.sources[0] #=> Types::InputSource
    #   resp.data.input.sources[0].password_param #=> String
    #   resp.data.input.sources[0].url #=> String
    #   resp.data.input.sources[0].username #=> String
    #   resp.data.input.state #=> String, one of ["CREATING", "DETACHED", "ATTACHED", "DELETING", "DELETED"]
    #   resp.data.input.tags #=> Hash<String, String>
    #   resp.data.input.tags['key'] #=> String
    #   resp.data.input.type #=> String, one of ["UDP_PUSH", "RTP_PUSH", "RTMP_PUSH", "RTMP_PULL", "URL_PULL", "MP4_FILE", "MEDIACONNECT", "INPUT_DEVICE", "AWS_CDI", "TS_FILE"]
    #
    def create_partner_input(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::CreatePartnerInputInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::CreatePartnerInputInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::CreatePartnerInput
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 201, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::CreatePartnerInput
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::CreatePartnerInput,
        stubs: @stubs,
        params_class: Params::CreatePartnerInputOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :create_partner_input
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Create tags for a resource
    #
    # @param [Hash] params
    #   See {Types::CreateTagsInput}.
    #
    # @option params [String] :resource_arn
    #   Placeholder documentation for __string
    #
    # @option params [Hash<String, String>] :tags
    #   Placeholder documentation for Tags
    #
    # @return [Types::CreateTagsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.create_tags(
    #     resource_arn: 'ResourceArn', # required
    #     tags: {
    #       'key' => 'value'
    #     }
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::CreateTagsOutput
    #
    def create_tags(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::CreateTagsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::CreateTagsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::CreateTags
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 204, errors: [Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::NotFoundException]),
        data_parser: Parsers::CreateTags
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::CreateTags,
        stubs: @stubs,
        params_class: Params::CreateTagsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :create_tags
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Starts deletion of channel. The associated outputs are also deleted.
    #
    # @param [Hash] params
    #   See {Types::DeleteChannelInput}.
    #
    # @option params [String] :channel_id
    #   Unique ID of the channel.
    #
    # @return [Types::DeleteChannelOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.delete_channel(
    #     channel_id: 'ChannelId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DeleteChannelOutput
    #   resp.data.arn #=> String
    #   resp.data.cdi_input_specification #=> Types::CdiInputSpecification
    #   resp.data.cdi_input_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.destinations #=> Array<OutputDestination>
    #   resp.data.destinations[0] #=> Types::OutputDestination
    #   resp.data.destinations[0].id #=> String
    #   resp.data.destinations[0].media_package_settings #=> Array<MediaPackageOutputDestinationSettings>
    #   resp.data.destinations[0].media_package_settings[0] #=> Types::MediaPackageOutputDestinationSettings
    #   resp.data.destinations[0].media_package_settings[0].channel_id #=> String
    #   resp.data.destinations[0].multiplex_settings #=> Types::MultiplexProgramChannelDestinationSettings
    #   resp.data.destinations[0].multiplex_settings.multiplex_id #=> String
    #   resp.data.destinations[0].multiplex_settings.program_name #=> String
    #   resp.data.destinations[0].settings #=> Array<OutputDestinationSettings>
    #   resp.data.destinations[0].settings[0] #=> Types::OutputDestinationSettings
    #   resp.data.destinations[0].settings[0].password_param #=> String
    #   resp.data.destinations[0].settings[0].stream_name #=> String
    #   resp.data.destinations[0].settings[0].url #=> String
    #   resp.data.destinations[0].settings[0].username #=> String
    #   resp.data.egress_endpoints #=> Array<ChannelEgressEndpoint>
    #   resp.data.egress_endpoints[0] #=> Types::ChannelEgressEndpoint
    #   resp.data.egress_endpoints[0].source_ip #=> String
    #   resp.data.encoder_settings #=> Types::EncoderSettings
    #   resp.data.encoder_settings.audio_descriptions #=> Array<AudioDescription>
    #   resp.data.encoder_settings.audio_descriptions[0] #=> Types::AudioDescription
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings #=> Types::AudioNormalizationSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm #=> String, one of ["ITU_1770_1", "ITU_1770_2"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm_control #=> String, one of ["CORRECT_AUDIO"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.target_lkfs #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].audio_selector_name #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_type #=> String, one of ["CLEAN_EFFECTS", "HEARING_IMPAIRED", "UNDEFINED", "VISUAL_IMPAIRED_COMMENTARY"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_type_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings #=> Types::AudioWatermarkSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings #=> Types::NielsenWatermarksSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings #=> Types::NielsenCBET
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_check_digit_string #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_stepaside #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.csid #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_distribution_type #=> String, one of ["FINAL_DISTRIBUTOR", "PROGRAM_CONTENT"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings #=> Types::NielsenNaesIiNw
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.check_digit_string #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.sid #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings #=> Types::AudioCodecSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings #=> Types::AacSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.coding_mode #=> String, one of ["AD_RECEIVER_MIX", "CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_5_1"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.input_type #=> String, one of ["BROADCASTER_MIXED_AD", "NORMAL"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.profile #=> String, one of ["HEV1", "HEV2", "LC"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.rate_control_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.raw_format #=> String, one of ["LATM_LOAS", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.spec #=> String, one of ["MPEG2", "MPEG4"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.vbr_quality #=> String, one of ["HIGH", "LOW", "MEDIUM_HIGH", "MEDIUM_LOW"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings #=> Types::Ac3Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "DIALOGUE", "EMERGENCY", "HEARING_IMPAIRED", "MUSIC_AND_EFFECTS", "VISUALLY_IMPAIRED", "VOICE_OVER"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_3_2_LFE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.dialnorm #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.drc_profile #=> String, one of ["FILM_STANDARD", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings #=> Types::Eac3Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.attenuation_control #=> String, one of ["ATTENUATE_3_DB", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "EMERGENCY", "HEARING_IMPAIRED", "VISUALLY_IMPAIRED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_3_2"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dc_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dialnorm #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_line #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_rf #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_control #=> String, one of ["LFE", "NO_LFE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_center_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_surround_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_center_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_surround_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.passthrough_control #=> String, one of ["NO_PASSTHROUGH", "WHEN_POSSIBLE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.phase_control #=> String, one of ["NO_SHIFT", "SHIFT_90_DEGREES"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.stereo_downmix #=> String, one of ["DPL2", "LO_RO", "LT_RT", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_ex_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings #=> Types::Mp2Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.pass_through_settings #=> Types::PassThroughSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings #=> Types::WavSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.bit_depth #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_4_0", "CODING_MODE_8_0"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].language_code #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].language_code_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].name #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings #=> Types::RemixSettings
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings #=> Array<AudioChannelMapping>
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0] #=> Types::AudioChannelMapping
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels #=> Array<InputChannelLevel>
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0] #=> Types::InputChannelLevel
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].gain #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].input_channel #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].output_channel #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channels_in #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channels_out #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].stream_name #=> String
    #   resp.data.encoder_settings.avail_blanking #=> Types::AvailBlanking
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image #=> Types::InputLocation
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.password_param #=> String
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.uri #=> String
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.username #=> String
    #   resp.data.encoder_settings.avail_blanking.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.avail_configuration #=> Types::AvailConfiguration
    #   resp.data.encoder_settings.avail_configuration.avail_settings #=> Types::AvailSettings
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert #=> Types::Scte35SpliceInsert
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.ad_avail_offset #=> Integer
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos #=> Types::Scte35TimeSignalApos
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.ad_avail_offset #=> Integer
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.blackout_slate #=> Types::BlackoutSlate
    #   resp.data.encoder_settings.blackout_slate.blackout_slate_image #=> Types::InputLocation
    #   resp.data.encoder_settings.blackout_slate.network_end_blackout #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.blackout_slate.network_end_blackout_image #=> Types::InputLocation
    #   resp.data.encoder_settings.blackout_slate.network_id #=> String
    #   resp.data.encoder_settings.blackout_slate.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.caption_descriptions #=> Array<CaptionDescription>
    #   resp.data.encoder_settings.caption_descriptions[0] #=> Types::CaptionDescription
    #   resp.data.encoder_settings.caption_descriptions[0].caption_selector_name #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings #=> Types::CaptionDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.arib_destination_settings #=> Types::AribDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings #=> Types::BurnInDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font #=> Types::InputLocation
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_resolution #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_size #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_size #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.x_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.y_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings #=> Types::DvbSubDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font #=> Types::InputLocation
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_resolution #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_size #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_size #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.x_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.y_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings #=> Types::EbuTtDDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.copyright_holder #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.fill_line_gap #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.font_family #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.style_control #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.embedded_destination_settings #=> Types::EmbeddedDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.embedded_plus_scte20_destination_settings #=> Types::EmbeddedPlusScte20DestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.rtmp_caption_info_destination_settings #=> Types::RtmpCaptionInfoDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.scte20_plus_embedded_destination_settings #=> Types::Scte20PlusEmbeddedDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.scte27_destination_settings #=> Types::Scte27DestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.smpte_tt_destination_settings #=> Types::SmpteTtDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.teletext_destination_settings #=> Types::TeletextDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings #=> Types::TtmlDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings.style_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings #=> Types::WebvttDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings.style_control #=> String, one of ["NO_STYLE_DATA", "PASSTHROUGH"]
    #   resp.data.encoder_settings.caption_descriptions[0].language_code #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].language_description #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].name #=> String
    #   resp.data.encoder_settings.feature_activations #=> Types::FeatureActivations
    #   resp.data.encoder_settings.feature_activations.input_prepare_schedule_actions #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.global_configuration #=> Types::GlobalConfiguration
    #   resp.data.encoder_settings.global_configuration.initial_audio_gain #=> Integer
    #   resp.data.encoder_settings.global_configuration.input_end_action #=> String, one of ["NONE", "SWITCH_AND_LOOP_INPUTS"]
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior #=> Types::InputLossBehavior
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.black_frame_msec #=> Integer
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_color #=> String
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_slate #=> Types::InputLocation
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_type #=> String, one of ["COLOR", "SLATE"]
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.repeat_frame_msec #=> Integer
    #   resp.data.encoder_settings.global_configuration.output_locking_mode #=> String, one of ["EPOCH_LOCKING", "PIPELINE_LOCKING"]
    #   resp.data.encoder_settings.global_configuration.output_timing_source #=> String, one of ["INPUT_CLOCK", "SYSTEM_CLOCK"]
    #   resp.data.encoder_settings.global_configuration.support_low_framerate_inputs #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.motion_graphics_configuration #=> Types::MotionGraphicsConfiguration
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_insertion #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_settings #=> Types::MotionGraphicsSettings
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_settings.html_motion_graphics_settings #=> Types::HtmlMotionGraphicsSettings
    #   resp.data.encoder_settings.nielsen_configuration #=> Types::NielsenConfiguration
    #   resp.data.encoder_settings.nielsen_configuration.distributor_id #=> String
    #   resp.data.encoder_settings.nielsen_configuration.nielsen_pcm_to_id3_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups #=> Array<OutputGroup>
    #   resp.data.encoder_settings.output_groups[0] #=> Types::OutputGroup
    #   resp.data.encoder_settings.output_groups[0].name #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings #=> Types::OutputGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings #=> Types::ArchiveGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings #=> Types::ArchiveCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings #=> Types::ArchiveS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination.destination_ref_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.rollover_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings #=> Types::FrameCaptureGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings #=> Types::FrameCaptureCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings #=> Types::FrameCaptureS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings #=> Types::HlsGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers[0] #=> String, one of ["ADOBE", "ELEMENTAL", "ELEMENTAL_SCTE35"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content1 #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest1 #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings #=> Array<CaptionLanguageMapping>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0] #=> Types::CaptionLanguageMapping
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].caption_channel #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_code #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_description #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_setting #=> String, one of ["INSERT", "NONE", "OMIT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.client_cache #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.codec_specification #=> String, one of ["RFC_4281", "RFC_6381"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.constant_iv #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.directory_structure #=> String, one of ["SINGLE_DIRECTORY", "SUBDIRECTORY_PER_STREAM"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.discontinuity_tags #=> String, one of ["INSERT", "NEVER_INSERT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.encryption_type #=> String, one of ["AES128", "SAMPLE_AES"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings #=> Types::HlsCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings #=> Types::HlsAkamaiSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.salt #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.token #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings #=> Types::HlsBasicPutSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings #=> Types::HlsMediaStoreSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.media_store_storage_class #=> String, one of ["TEMPORAL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings #=> Types::HlsS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings #=> Types::HlsWebdavSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_id3_segment_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.i_frame_only_playlists #=> String, one of ["DISABLED", "STANDARD"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.incomplete_segment_behavior #=> String, one of ["AUTO", "SUPPRESS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.index_n_segments #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_in_manifest #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_source #=> String, one of ["EXPLICIT", "FOLLOWS_SEGMENT_NUMBER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.keep_segments #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format_versions #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings #=> Types::KeyProviderSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings #=> Types::StaticKeySettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.key_provider_server #=> Types::InputLocation
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.static_key_value #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_compression #=> String, one of ["GZIP", "NONE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_duration_format #=> String, one of ["FLOATING_POINT", "INTEGER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.min_segment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.mode #=> String, one of ["LIVE", "VOD"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.output_selection #=> String, one of ["MANIFESTS_AND_SEGMENTS", "SEGMENTS_ONLY", "VARIANT_MANIFESTS_AND_SEGMENTS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_clock #=> String, one of ["INITIALIZE_FROM_OUTPUT_TIMECODE", "SYSTEM_CLOCK"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.redundant_manifest #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segments_per_subdirectory #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.stream_inf_resolution #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timestamp_delta_milliseconds #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ts_file_mode #=> String, one of ["SEGMENTED_FILES", "SINGLE_FILE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings #=> Types::MediaPackageGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings #=> Types::MsSmoothGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.acquisition_point_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.audio_only_timecode_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED_CLOCK"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id_mode #=> String, one of ["NO_EVENT_ID", "USE_CONFIGURED", "USE_TIMESTAMP"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_stop_behavior #=> String, one of ["NONE", "SEND_EOS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.fragment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.send_delay_ms #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.sparse_track_type #=> String, one of ["NONE", "SCTE_35", "SCTE_35_WITHOUT_SEGMENTATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.stream_manifest_behavior #=> String, one of ["DO_NOT_SEND", "SEND"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset_mode #=> String, one of ["USE_CONFIGURED_OFFSET", "USE_EVENT_START_DATE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.multiplex_group_settings #=> Types::MultiplexGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings #=> Types::RtmpGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers[0] #=> String, one of ["ON_CUE_POINT_SCTE35"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.authentication_scheme #=> String, one of ["AKAMAI", "COMMON"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_full_behavior #=> String, one of ["DISCONNECT_IMMEDIATELY", "WAIT_FOR_SERVER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.caption_data #=> String, one of ["ALL", "FIELD1_608", "FIELD1_AND_FIELD2_608"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings #=> Types::UdpGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.input_loss_action #=> String, one of ["DROP_PROGRAM", "DROP_TS", "EMIT_PROGRAM"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs #=> Array<Output>
    #   resp.data.encoder_settings.output_groups[0].outputs[0] #=> Types::Output
    #   resp.data.encoder_settings.output_groups[0].outputs[0].audio_description_names #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].outputs[0].audio_description_names[0] #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].caption_description_names #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings #=> Types::OutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings #=> Types::ArchiveOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings #=> Types::ArchiveContainerSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.absent_input_audio_behavior #=> String, one of ["DROP", "ENCODE_SILENCE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid_control #=> String, one of ["AUTO", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_buffer_model #=> String, one of ["ATSC", "DVB"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_frames_per_pes #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_stream_type #=> String, one of ["ATSC", "DVB"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.buffer_model #=> String, one of ["MULTIPLEX", "NONE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.cc_descriptor #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings #=> Types::DvbNitSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings #=> Types::DvbSdtSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.output_sdt #=> String, one of ["SDT_FOLLOW", "SDT_FOLLOW_IF_PRESENT", "SDT_MANUAL", "SDT_NONE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_provider_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sub_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings #=> Types::DvbTdtSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_teletext_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebif #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_audio_interval #=> String, one of ["VIDEO_AND_FIXED_INTERVALS", "VIDEO_INTERVAL"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_lookahead_ms #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_placement #=> String, one of ["VIDEO_AND_AUDIO_PIDS", "VIDEO_PID"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ecm_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.es_rate_in_pes #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_platform_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_signal_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.fragment_time #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv_data_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.null_packet_bitrate #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pat_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.program_num #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.rate_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte27_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_control #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_markers #=> String, one of ["EBP", "EBP_LEGACY", "NONE", "PSI_SEGSTART", "RAI_ADAPT", "RAI_SEGSTART"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_style #=> String, one of ["MAINTAIN_CADENCE", "RESET_CADENCE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_time #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.transport_stream_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.video_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.raw_settings #=> Types::RawSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.extension #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings #=> Types::FrameCaptureOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings #=> Types::HlsOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings #=> Types::HlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings #=> Types::AudioOnlyHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_group_id #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_only_image #=> Types::InputLocation
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_track_type #=> String, one of ["ALTERNATE_AUDIO_AUTO_SELECT", "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT", "ALTERNATE_AUDIO_NOT_AUTO_SELECT", "AUDIO_ONLY_VARIANT_STREAM"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.segment_type #=> String, one of ["AAC", "FMP4"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings #=> Types::Fmp4HlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.audio_rendition_sets #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.frame_capture_hls_settings #=> Types::FrameCaptureHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings #=> Types::StandardHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.audio_rendition_sets #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings #=> Types::M3u8Settings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_frames_per_pes #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.ecm_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pat_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.program_num #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.transport_stream_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.video_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.segment_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.media_package_output_settings #=> Types::MediaPackageOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings #=> Types::MsSmoothOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings #=> Types::MultiplexOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings #=> Types::RtmpOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings #=> Types::UdpOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.buffer_msec #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings #=> Types::UdpContainerSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings #=> Types::FecOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.column_depth #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.include_fec #=> String, one of ["COLUMN", "COLUMN_AND_ROW"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.row_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].video_description_name #=> String
    #   resp.data.encoder_settings.timecode_config #=> Types::TimecodeConfig
    #   resp.data.encoder_settings.timecode_config.source #=> String, one of ["EMBEDDED", "SYSTEMCLOCK", "ZEROBASED"]
    #   resp.data.encoder_settings.timecode_config.sync_threshold #=> Integer
    #   resp.data.encoder_settings.video_descriptions #=> Array<VideoDescription>
    #   resp.data.encoder_settings.video_descriptions[0] #=> Types::VideoDescription
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings #=> Types::VideoCodecSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings #=> Types::FrameCaptureSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval_units #=> String, one of ["MILLISECONDS", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings #=> Types::H264Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_fill_pct #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_size #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings #=> Types::H264ColorSpaceSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.entropy_encoding #=> String, one of ["CABAC", "CAVLC"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings #=> Types::H264FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.post_filter_sharpening #=> String, one of ["AUTO", "DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.strength #=> String, one of ["AUTO", "STRENGTH_1", "STRENGTH_2", "STRENGTH_3", "STRENGTH_4", "STRENGTH_5", "STRENGTH_6", "STRENGTH_7", "STRENGTH_8", "STRENGTH_9", "STRENGTH_10", "STRENGTH_11", "STRENGTH_12", "STRENGTH_13", "STRENGTH_14", "STRENGTH_15", "STRENGTH_16"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.force_field_pictures #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_b_reference #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_num_b_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.level #=> String, one of ["H264_LEVEL_1", "H264_LEVEL_1_1", "H264_LEVEL_1_2", "H264_LEVEL_1_3", "H264_LEVEL_2", "H264_LEVEL_2_1", "H264_LEVEL_2_2", "H264_LEVEL_3", "H264_LEVEL_3_1", "H264_LEVEL_3_2", "H264_LEVEL_4", "H264_LEVEL_4_1", "H264_LEVEL_4_2", "H264_LEVEL_5", "H264_LEVEL_5_1", "H264_LEVEL_5_2", "H264_LEVEL_AUTO"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.max_bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.min_i_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.num_ref_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.profile #=> String, one of ["BASELINE", "HIGH", "HIGH_10BIT", "HIGH_422", "HIGH_422_10BIT", "MAIN"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.quality_level #=> String, one of ["ENHANCED_QUALITY", "STANDARD_QUALITY"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.qvbr_quality_level #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR", "VBR"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.slices #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.softness #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.spatial_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.syntax #=> String, one of ["DEFAULT", "RP2027"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.temporal_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings #=> Types::H265Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.alternative_transfer_function #=> String, one of ["INSERT", "OMIT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.buf_size #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings #=> Types::H265ColorSpaceSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_cll #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_fall #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings #=> Types::H265FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.level #=> String, one of ["H265_LEVEL_1", "H265_LEVEL_2", "H265_LEVEL_2_1", "H265_LEVEL_3", "H265_LEVEL_3_1", "H265_LEVEL_4", "H265_LEVEL_4_1", "H265_LEVEL_5", "H265_LEVEL_5_1", "H265_LEVEL_5_2", "H265_LEVEL_6", "H265_LEVEL_6_1", "H265_LEVEL_6_2", "H265_LEVEL_AUTO"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.max_bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.min_i_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.profile #=> String, one of ["MAIN", "MAIN_10BIT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.qvbr_quality_level #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.slices #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.tier #=> String, one of ["HIGH", "MAIN"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings #=> Types::Mpeg2Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "LOW", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_space #=> String, one of ["AUTO", "PASSTHROUGH"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.display_aspect_ratio #=> String, one of ["DISPLAYRATIO16X9", "DISPLAYRATIO4X3"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings #=> Types::Mpeg2FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_num_b_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.timecode_insertion #=> String, one of ["DISABLED", "GOP_TIMECODE"]
    #   resp.data.encoder_settings.video_descriptions[0].height #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].name #=> String
    #   resp.data.encoder_settings.video_descriptions[0].respond_to_afd #=> String, one of ["NONE", "PASSTHROUGH", "RESPOND"]
    #   resp.data.encoder_settings.video_descriptions[0].scaling_behavior #=> String, one of ["DEFAULT", "STRETCH_TO_OUTPUT"]
    #   resp.data.encoder_settings.video_descriptions[0].sharpness #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].width #=> Integer
    #   resp.data.id #=> String
    #   resp.data.input_attachments #=> Array<InputAttachment>
    #   resp.data.input_attachments[0] #=> Types::InputAttachment
    #   resp.data.input_attachments[0].automatic_input_failover_settings #=> Types::AutomaticInputFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.error_clear_time_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions #=> Array<FailoverCondition>
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0] #=> Types::FailoverCondition
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings #=> Types::FailoverConditionSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings #=> Types::AudioSilenceFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_selector_name #=> String
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_silence_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings #=> Types::InputLossFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings.input_loss_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings #=> Types::VideoBlackFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.black_detect_threshold #=> Float
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.video_black_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.input_preference #=> String, one of ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #   resp.data.input_attachments[0].automatic_input_failover_settings.secondary_input_id #=> String
    #   resp.data.input_attachments[0].input_attachment_name #=> String
    #   resp.data.input_attachments[0].input_id #=> String
    #   resp.data.input_attachments[0].input_settings #=> Types::InputSettings
    #   resp.data.input_attachments[0].input_settings.audio_selectors #=> Array<AudioSelector>
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0] #=> Types::AudioSelector
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].name #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings #=> Types::AudioSelectorSettings
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection #=> Types::AudioHlsRenditionSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.group_id #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.name #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection #=> Types::AudioLanguageSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_code #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_selection_policy #=> String, one of ["LOOSE", "STRICT"]
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection #=> Types::AudioPidSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection #=> Types::AudioTrackSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks #=> Array<AudioTrack>
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0] #=> Types::AudioTrack
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0].track #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors #=> Array<CaptionSelector>
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0] #=> Types::CaptionSelector
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].language_code #=> String
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].name #=> String
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings #=> Types::CaptionSelectorSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings #=> Types::AncillarySourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings.source_ancillary_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.arib_source_settings #=> Types::AribSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings #=> Types::DvbSubSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings #=> Types::EmbeddedSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.scte20_detection #=> String, one of ["AUTO", "OFF"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_track_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings #=> Types::Scte20SourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.source608_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings #=> Types::Scte27SourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings #=> Types::TeletextSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle #=> Types::CaptionRectangle
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.height #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.left_offset #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.top_offset #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.width #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.page_number #=> String
    #   resp.data.input_attachments[0].input_settings.deblock_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.input_attachments[0].input_settings.denoise_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.input_attachments[0].input_settings.filter_strength #=> Integer
    #   resp.data.input_attachments[0].input_settings.input_filter #=> String, one of ["AUTO", "DISABLED", "FORCED"]
    #   resp.data.input_attachments[0].input_settings.network_input_settings #=> Types::NetworkInputSettings
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings #=> Types::HlsInputSettings
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.bandwidth #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.buffer_segments #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retries #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retry_interval #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.scte35_source #=> String, one of ["MANIFEST", "SEGMENTS"]
    #   resp.data.input_attachments[0].input_settings.network_input_settings.server_validation #=> String, one of ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #   resp.data.input_attachments[0].input_settings.scte35_pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.smpte2038_data_preference #=> String, one of ["IGNORE", "PREFER"]
    #   resp.data.input_attachments[0].input_settings.source_end_behavior #=> String, one of ["CONTINUE", "LOOP"]
    #   resp.data.input_attachments[0].input_settings.video_selector #=> Types::VideoSelector
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space #=> String, one of ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_settings #=> Types::VideoSelectorColorSpaceSettings
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_usage #=> String, one of ["FALLBACK", "FORCE"]
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings #=> Types::VideoSelectorSettings
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid #=> Types::VideoSelectorPid
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id #=> Types::VideoSelectorProgramId
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id.program_id #=> Integer
    #   resp.data.input_specification #=> Types::InputSpecification
    #   resp.data.input_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC"]
    #   resp.data.input_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.input_specification.resolution #=> String, one of ["SD", "HD", "UHD"]
    #   resp.data.log_level #=> String, one of ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #   resp.data.maintenance #=> Types::MaintenanceStatus
    #   resp.data.maintenance.maintenance_day #=> String, one of ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #   resp.data.maintenance.maintenance_deadline #=> String
    #   resp.data.maintenance.maintenance_scheduled_date #=> String
    #   resp.data.maintenance.maintenance_start_time #=> String
    #   resp.data.name #=> String
    #   resp.data.pipeline_details #=> Array<PipelineDetail>
    #   resp.data.pipeline_details[0] #=> Types::PipelineDetail
    #   resp.data.pipeline_details[0].active_input_attachment_name #=> String
    #   resp.data.pipeline_details[0].active_input_switch_action_name #=> String
    #   resp.data.pipeline_details[0].active_motion_graphics_action_name #=> String
    #   resp.data.pipeline_details[0].active_motion_graphics_uri #=> String
    #   resp.data.pipeline_details[0].pipeline_id #=> String
    #   resp.data.pipelines_running_count #=> Integer
    #   resp.data.role_arn #=> String
    #   resp.data.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED", "UPDATING", "UPDATE_FAILED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #   resp.data.vpc #=> Types::VpcOutputSettingsDescription
    #   resp.data.vpc.availability_zones #=> Array<String>
    #   resp.data.vpc.network_interface_ids #=> Array<String>
    #   resp.data.vpc.security_group_ids #=> Array<String>
    #   resp.data.vpc.subnet_ids #=> Array<String>
    #
    def delete_channel(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DeleteChannelInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DeleteChannelInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DeleteChannel
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DeleteChannel
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DeleteChannel,
        stubs: @stubs,
        params_class: Params::DeleteChannelOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :delete_channel
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Deletes the input end point
    #
    # @param [Hash] params
    #   See {Types::DeleteInputInput}.
    #
    # @option params [String] :input_id
    #   Unique ID of the input
    #
    # @return [Types::DeleteInputOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.delete_input(
    #     input_id: 'InputId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DeleteInputOutput
    #
    def delete_input(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DeleteInputInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DeleteInputInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DeleteInput
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DeleteInput
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DeleteInput,
        stubs: @stubs,
        params_class: Params::DeleteInputOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :delete_input
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Deletes an Input Security Group
    #
    # @param [Hash] params
    #   See {Types::DeleteInputSecurityGroupInput}.
    #
    # @option params [String] :input_security_group_id
    #   The Input Security Group to delete
    #
    # @return [Types::DeleteInputSecurityGroupOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.delete_input_security_group(
    #     input_security_group_id: 'InputSecurityGroupId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DeleteInputSecurityGroupOutput
    #
    def delete_input_security_group(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DeleteInputSecurityGroupInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DeleteInputSecurityGroupInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DeleteInputSecurityGroup
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DeleteInputSecurityGroup
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DeleteInputSecurityGroup,
        stubs: @stubs,
        params_class: Params::DeleteInputSecurityGroupOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :delete_input_security_group
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Delete a multiplex. The multiplex must be idle.
    #
    # @param [Hash] params
    #   See {Types::DeleteMultiplexInput}.
    #
    # @option params [String] :multiplex_id
    #   The ID of the multiplex.
    #
    # @return [Types::DeleteMultiplexOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.delete_multiplex(
    #     multiplex_id: 'MultiplexId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DeleteMultiplexOutput
    #   resp.data.arn #=> String
    #   resp.data.availability_zones #=> Array<String>
    #   resp.data.availability_zones[0] #=> String
    #   resp.data.destinations #=> Array<MultiplexOutputDestination>
    #   resp.data.destinations[0] #=> Types::MultiplexOutputDestination
    #   resp.data.destinations[0].media_connect_settings #=> Types::MultiplexMediaConnectOutputDestinationSettings
    #   resp.data.destinations[0].media_connect_settings.entitlement_arn #=> String
    #   resp.data.id #=> String
    #   resp.data.multiplex_settings #=> Types::MultiplexSettings
    #   resp.data.multiplex_settings.maximum_video_buffer_delay_milliseconds #=> Integer
    #   resp.data.multiplex_settings.transport_stream_bitrate #=> Integer
    #   resp.data.multiplex_settings.transport_stream_id #=> Integer
    #   resp.data.multiplex_settings.transport_stream_reserved_bitrate #=> Integer
    #   resp.data.name #=> String
    #   resp.data.pipelines_running_count #=> Integer
    #   resp.data.program_count #=> Integer
    #   resp.data.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #
    def delete_multiplex(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DeleteMultiplexInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DeleteMultiplexInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DeleteMultiplex
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 202, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DeleteMultiplex
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DeleteMultiplex,
        stubs: @stubs,
        params_class: Params::DeleteMultiplexOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :delete_multiplex
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Delete a program from a multiplex.
    #
    # @param [Hash] params
    #   See {Types::DeleteMultiplexProgramInput}.
    #
    # @option params [String] :multiplex_id
    #   The ID of the multiplex that the program belongs to.
    #
    # @option params [String] :program_name
    #   The multiplex program name.
    #
    # @return [Types::DeleteMultiplexProgramOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.delete_multiplex_program(
    #     multiplex_id: 'MultiplexId', # required
    #     program_name: 'ProgramName' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DeleteMultiplexProgramOutput
    #   resp.data.channel_id #=> String
    #   resp.data.multiplex_program_settings #=> Types::MultiplexProgramSettings
    #   resp.data.multiplex_program_settings.preferred_channel_pipeline #=> String, one of ["CURRENTLY_ACTIVE", "PIPELINE_0", "PIPELINE_1"]
    #   resp.data.multiplex_program_settings.program_number #=> Integer
    #   resp.data.multiplex_program_settings.service_descriptor #=> Types::MultiplexProgramServiceDescriptor
    #   resp.data.multiplex_program_settings.service_descriptor.provider_name #=> String
    #   resp.data.multiplex_program_settings.service_descriptor.service_name #=> String
    #   resp.data.multiplex_program_settings.video_settings #=> Types::MultiplexVideoSettings
    #   resp.data.multiplex_program_settings.video_settings.constant_bitrate #=> Integer
    #   resp.data.multiplex_program_settings.video_settings.statmux_settings #=> Types::MultiplexStatmuxVideoSettings
    #   resp.data.multiplex_program_settings.video_settings.statmux_settings.maximum_bitrate #=> Integer
    #   resp.data.multiplex_program_settings.video_settings.statmux_settings.minimum_bitrate #=> Integer
    #   resp.data.multiplex_program_settings.video_settings.statmux_settings.priority #=> Integer
    #   resp.data.packet_identifiers_map #=> Types::MultiplexProgramPacketIdentifiersMap
    #   resp.data.packet_identifiers_map.audio_pids #=> Array<Integer>
    #   resp.data.packet_identifiers_map.audio_pids[0] #=> Integer
    #   resp.data.packet_identifiers_map.dvb_sub_pids #=> Array<Integer>
    #   resp.data.packet_identifiers_map.dvb_teletext_pid #=> Integer
    #   resp.data.packet_identifiers_map.etv_platform_pid #=> Integer
    #   resp.data.packet_identifiers_map.etv_signal_pid #=> Integer
    #   resp.data.packet_identifiers_map.klv_data_pids #=> Array<Integer>
    #   resp.data.packet_identifiers_map.pcr_pid #=> Integer
    #   resp.data.packet_identifiers_map.pmt_pid #=> Integer
    #   resp.data.packet_identifiers_map.private_metadata_pid #=> Integer
    #   resp.data.packet_identifiers_map.scte27_pids #=> Array<Integer>
    #   resp.data.packet_identifiers_map.scte35_pid #=> Integer
    #   resp.data.packet_identifiers_map.timed_metadata_pid #=> Integer
    #   resp.data.packet_identifiers_map.video_pid #=> Integer
    #   resp.data.pipeline_details #=> Array<MultiplexProgramPipelineDetail>
    #   resp.data.pipeline_details[0] #=> Types::MultiplexProgramPipelineDetail
    #   resp.data.pipeline_details[0].active_channel_pipeline #=> String
    #   resp.data.pipeline_details[0].pipeline_id #=> String
    #   resp.data.program_name #=> String
    #
    def delete_multiplex_program(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DeleteMultiplexProgramInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DeleteMultiplexProgramInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DeleteMultiplexProgram
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DeleteMultiplexProgram
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DeleteMultiplexProgram,
        stubs: @stubs,
        params_class: Params::DeleteMultiplexProgramOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :delete_multiplex_program
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Delete an expired reservation.
    #
    # @param [Hash] params
    #   See {Types::DeleteReservationInput}.
    #
    # @option params [String] :reservation_id
    #   Unique reservation ID, e.g. '1234567'
    #
    # @return [Types::DeleteReservationOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.delete_reservation(
    #     reservation_id: 'ReservationId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DeleteReservationOutput
    #   resp.data.arn #=> String
    #   resp.data.count #=> Integer
    #   resp.data.currency_code #=> String
    #   resp.data.duration #=> Integer
    #   resp.data.duration_units #=> String, one of ["MONTHS"]
    #   resp.data.end #=> String
    #   resp.data.fixed_price #=> Float
    #   resp.data.name #=> String
    #   resp.data.offering_description #=> String
    #   resp.data.offering_id #=> String
    #   resp.data.offering_type #=> String, one of ["NO_UPFRONT"]
    #   resp.data.region #=> String
    #   resp.data.reservation_id #=> String
    #   resp.data.resource_specification #=> Types::ReservationResourceSpecification
    #   resp.data.resource_specification.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.resource_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC", "AUDIO", "LINK"]
    #   resp.data.resource_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.resource_specification.maximum_framerate #=> String, one of ["MAX_30_FPS", "MAX_60_FPS"]
    #   resp.data.resource_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.resource_specification.resource_type #=> String, one of ["INPUT", "OUTPUT", "MULTIPLEX", "CHANNEL"]
    #   resp.data.resource_specification.special_feature #=> String, one of ["ADVANCED_AUDIO", "AUDIO_NORMALIZATION", "MGHD", "MGUHD"]
    #   resp.data.resource_specification.video_quality #=> String, one of ["STANDARD", "ENHANCED", "PREMIUM"]
    #   resp.data.start #=> String
    #   resp.data.state #=> String, one of ["ACTIVE", "EXPIRED", "CANCELED", "DELETED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #   resp.data.usage_price #=> Float
    #
    def delete_reservation(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DeleteReservationInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DeleteReservationInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DeleteReservation
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DeleteReservation
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DeleteReservation,
        stubs: @stubs,
        params_class: Params::DeleteReservationOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :delete_reservation
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Delete all schedule actions on a channel.
    #
    # @param [Hash] params
    #   See {Types::DeleteScheduleInput}.
    #
    # @option params [String] :channel_id
    #   Id of the channel whose schedule is being deleted.
    #
    # @return [Types::DeleteScheduleOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.delete_schedule(
    #     channel_id: 'ChannelId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DeleteScheduleOutput
    #
    def delete_schedule(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DeleteScheduleInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DeleteScheduleInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DeleteSchedule
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DeleteSchedule
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DeleteSchedule,
        stubs: @stubs,
        params_class: Params::DeleteScheduleOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :delete_schedule
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Removes tags for a resource
    #
    # @param [Hash] params
    #   See {Types::DeleteTagsInput}.
    #
    # @option params [String] :resource_arn
    #   Placeholder documentation for __string
    #
    # @option params [Array<String>] :tag_keys
    #   An array of tag keys to delete
    #
    # @return [Types::DeleteTagsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.delete_tags(
    #     resource_arn: 'ResourceArn', # required
    #     tag_keys: [
    #       'member'
    #     ] # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DeleteTagsOutput
    #
    def delete_tags(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DeleteTagsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DeleteTagsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DeleteTags
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 204, errors: [Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::NotFoundException]),
        data_parser: Parsers::DeleteTags
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DeleteTags,
        stubs: @stubs,
        params_class: Params::DeleteTagsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :delete_tags
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Gets details about a channel
    #
    # @param [Hash] params
    #   See {Types::DescribeChannelInput}.
    #
    # @option params [String] :channel_id
    #   channel ID
    #
    # @return [Types::DescribeChannelOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_channel(
    #     channel_id: 'ChannelId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeChannelOutput
    #   resp.data.arn #=> String
    #   resp.data.cdi_input_specification #=> Types::CdiInputSpecification
    #   resp.data.cdi_input_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.destinations #=> Array<OutputDestination>
    #   resp.data.destinations[0] #=> Types::OutputDestination
    #   resp.data.destinations[0].id #=> String
    #   resp.data.destinations[0].media_package_settings #=> Array<MediaPackageOutputDestinationSettings>
    #   resp.data.destinations[0].media_package_settings[0] #=> Types::MediaPackageOutputDestinationSettings
    #   resp.data.destinations[0].media_package_settings[0].channel_id #=> String
    #   resp.data.destinations[0].multiplex_settings #=> Types::MultiplexProgramChannelDestinationSettings
    #   resp.data.destinations[0].multiplex_settings.multiplex_id #=> String
    #   resp.data.destinations[0].multiplex_settings.program_name #=> String
    #   resp.data.destinations[0].settings #=> Array<OutputDestinationSettings>
    #   resp.data.destinations[0].settings[0] #=> Types::OutputDestinationSettings
    #   resp.data.destinations[0].settings[0].password_param #=> String
    #   resp.data.destinations[0].settings[0].stream_name #=> String
    #   resp.data.destinations[0].settings[0].url #=> String
    #   resp.data.destinations[0].settings[0].username #=> String
    #   resp.data.egress_endpoints #=> Array<ChannelEgressEndpoint>
    #   resp.data.egress_endpoints[0] #=> Types::ChannelEgressEndpoint
    #   resp.data.egress_endpoints[0].source_ip #=> String
    #   resp.data.encoder_settings #=> Types::EncoderSettings
    #   resp.data.encoder_settings.audio_descriptions #=> Array<AudioDescription>
    #   resp.data.encoder_settings.audio_descriptions[0] #=> Types::AudioDescription
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings #=> Types::AudioNormalizationSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm #=> String, one of ["ITU_1770_1", "ITU_1770_2"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm_control #=> String, one of ["CORRECT_AUDIO"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.target_lkfs #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].audio_selector_name #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_type #=> String, one of ["CLEAN_EFFECTS", "HEARING_IMPAIRED", "UNDEFINED", "VISUAL_IMPAIRED_COMMENTARY"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_type_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings #=> Types::AudioWatermarkSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings #=> Types::NielsenWatermarksSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings #=> Types::NielsenCBET
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_check_digit_string #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_stepaside #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.csid #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_distribution_type #=> String, one of ["FINAL_DISTRIBUTOR", "PROGRAM_CONTENT"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings #=> Types::NielsenNaesIiNw
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.check_digit_string #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.sid #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings #=> Types::AudioCodecSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings #=> Types::AacSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.coding_mode #=> String, one of ["AD_RECEIVER_MIX", "CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_5_1"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.input_type #=> String, one of ["BROADCASTER_MIXED_AD", "NORMAL"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.profile #=> String, one of ["HEV1", "HEV2", "LC"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.rate_control_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.raw_format #=> String, one of ["LATM_LOAS", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.spec #=> String, one of ["MPEG2", "MPEG4"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.vbr_quality #=> String, one of ["HIGH", "LOW", "MEDIUM_HIGH", "MEDIUM_LOW"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings #=> Types::Ac3Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "DIALOGUE", "EMERGENCY", "HEARING_IMPAIRED", "MUSIC_AND_EFFECTS", "VISUALLY_IMPAIRED", "VOICE_OVER"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_3_2_LFE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.dialnorm #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.drc_profile #=> String, one of ["FILM_STANDARD", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings #=> Types::Eac3Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.attenuation_control #=> String, one of ["ATTENUATE_3_DB", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "EMERGENCY", "HEARING_IMPAIRED", "VISUALLY_IMPAIRED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_3_2"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dc_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dialnorm #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_line #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_rf #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_control #=> String, one of ["LFE", "NO_LFE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_center_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_surround_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_center_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_surround_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.passthrough_control #=> String, one of ["NO_PASSTHROUGH", "WHEN_POSSIBLE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.phase_control #=> String, one of ["NO_SHIFT", "SHIFT_90_DEGREES"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.stereo_downmix #=> String, one of ["DPL2", "LO_RO", "LT_RT", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_ex_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings #=> Types::Mp2Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.pass_through_settings #=> Types::PassThroughSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings #=> Types::WavSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.bit_depth #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_4_0", "CODING_MODE_8_0"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].language_code #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].language_code_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].name #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings #=> Types::RemixSettings
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings #=> Array<AudioChannelMapping>
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0] #=> Types::AudioChannelMapping
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels #=> Array<InputChannelLevel>
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0] #=> Types::InputChannelLevel
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].gain #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].input_channel #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].output_channel #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channels_in #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channels_out #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].stream_name #=> String
    #   resp.data.encoder_settings.avail_blanking #=> Types::AvailBlanking
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image #=> Types::InputLocation
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.password_param #=> String
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.uri #=> String
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.username #=> String
    #   resp.data.encoder_settings.avail_blanking.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.avail_configuration #=> Types::AvailConfiguration
    #   resp.data.encoder_settings.avail_configuration.avail_settings #=> Types::AvailSettings
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert #=> Types::Scte35SpliceInsert
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.ad_avail_offset #=> Integer
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos #=> Types::Scte35TimeSignalApos
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.ad_avail_offset #=> Integer
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.blackout_slate #=> Types::BlackoutSlate
    #   resp.data.encoder_settings.blackout_slate.blackout_slate_image #=> Types::InputLocation
    #   resp.data.encoder_settings.blackout_slate.network_end_blackout #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.blackout_slate.network_end_blackout_image #=> Types::InputLocation
    #   resp.data.encoder_settings.blackout_slate.network_id #=> String
    #   resp.data.encoder_settings.blackout_slate.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.caption_descriptions #=> Array<CaptionDescription>
    #   resp.data.encoder_settings.caption_descriptions[0] #=> Types::CaptionDescription
    #   resp.data.encoder_settings.caption_descriptions[0].caption_selector_name #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings #=> Types::CaptionDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.arib_destination_settings #=> Types::AribDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings #=> Types::BurnInDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font #=> Types::InputLocation
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_resolution #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_size #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_size #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.x_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.y_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings #=> Types::DvbSubDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font #=> Types::InputLocation
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_resolution #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_size #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_size #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.x_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.y_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings #=> Types::EbuTtDDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.copyright_holder #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.fill_line_gap #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.font_family #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.style_control #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.embedded_destination_settings #=> Types::EmbeddedDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.embedded_plus_scte20_destination_settings #=> Types::EmbeddedPlusScte20DestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.rtmp_caption_info_destination_settings #=> Types::RtmpCaptionInfoDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.scte20_plus_embedded_destination_settings #=> Types::Scte20PlusEmbeddedDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.scte27_destination_settings #=> Types::Scte27DestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.smpte_tt_destination_settings #=> Types::SmpteTtDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.teletext_destination_settings #=> Types::TeletextDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings #=> Types::TtmlDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings.style_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings #=> Types::WebvttDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings.style_control #=> String, one of ["NO_STYLE_DATA", "PASSTHROUGH"]
    #   resp.data.encoder_settings.caption_descriptions[0].language_code #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].language_description #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].name #=> String
    #   resp.data.encoder_settings.feature_activations #=> Types::FeatureActivations
    #   resp.data.encoder_settings.feature_activations.input_prepare_schedule_actions #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.global_configuration #=> Types::GlobalConfiguration
    #   resp.data.encoder_settings.global_configuration.initial_audio_gain #=> Integer
    #   resp.data.encoder_settings.global_configuration.input_end_action #=> String, one of ["NONE", "SWITCH_AND_LOOP_INPUTS"]
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior #=> Types::InputLossBehavior
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.black_frame_msec #=> Integer
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_color #=> String
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_slate #=> Types::InputLocation
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_type #=> String, one of ["COLOR", "SLATE"]
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.repeat_frame_msec #=> Integer
    #   resp.data.encoder_settings.global_configuration.output_locking_mode #=> String, one of ["EPOCH_LOCKING", "PIPELINE_LOCKING"]
    #   resp.data.encoder_settings.global_configuration.output_timing_source #=> String, one of ["INPUT_CLOCK", "SYSTEM_CLOCK"]
    #   resp.data.encoder_settings.global_configuration.support_low_framerate_inputs #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.motion_graphics_configuration #=> Types::MotionGraphicsConfiguration
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_insertion #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_settings #=> Types::MotionGraphicsSettings
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_settings.html_motion_graphics_settings #=> Types::HtmlMotionGraphicsSettings
    #   resp.data.encoder_settings.nielsen_configuration #=> Types::NielsenConfiguration
    #   resp.data.encoder_settings.nielsen_configuration.distributor_id #=> String
    #   resp.data.encoder_settings.nielsen_configuration.nielsen_pcm_to_id3_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups #=> Array<OutputGroup>
    #   resp.data.encoder_settings.output_groups[0] #=> Types::OutputGroup
    #   resp.data.encoder_settings.output_groups[0].name #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings #=> Types::OutputGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings #=> Types::ArchiveGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings #=> Types::ArchiveCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings #=> Types::ArchiveS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination.destination_ref_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.rollover_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings #=> Types::FrameCaptureGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings #=> Types::FrameCaptureCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings #=> Types::FrameCaptureS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings #=> Types::HlsGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers[0] #=> String, one of ["ADOBE", "ELEMENTAL", "ELEMENTAL_SCTE35"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content1 #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest1 #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings #=> Array<CaptionLanguageMapping>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0] #=> Types::CaptionLanguageMapping
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].caption_channel #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_code #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_description #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_setting #=> String, one of ["INSERT", "NONE", "OMIT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.client_cache #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.codec_specification #=> String, one of ["RFC_4281", "RFC_6381"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.constant_iv #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.directory_structure #=> String, one of ["SINGLE_DIRECTORY", "SUBDIRECTORY_PER_STREAM"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.discontinuity_tags #=> String, one of ["INSERT", "NEVER_INSERT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.encryption_type #=> String, one of ["AES128", "SAMPLE_AES"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings #=> Types::HlsCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings #=> Types::HlsAkamaiSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.salt #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.token #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings #=> Types::HlsBasicPutSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings #=> Types::HlsMediaStoreSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.media_store_storage_class #=> String, one of ["TEMPORAL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings #=> Types::HlsS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings #=> Types::HlsWebdavSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_id3_segment_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.i_frame_only_playlists #=> String, one of ["DISABLED", "STANDARD"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.incomplete_segment_behavior #=> String, one of ["AUTO", "SUPPRESS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.index_n_segments #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_in_manifest #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_source #=> String, one of ["EXPLICIT", "FOLLOWS_SEGMENT_NUMBER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.keep_segments #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format_versions #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings #=> Types::KeyProviderSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings #=> Types::StaticKeySettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.key_provider_server #=> Types::InputLocation
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.static_key_value #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_compression #=> String, one of ["GZIP", "NONE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_duration_format #=> String, one of ["FLOATING_POINT", "INTEGER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.min_segment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.mode #=> String, one of ["LIVE", "VOD"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.output_selection #=> String, one of ["MANIFESTS_AND_SEGMENTS", "SEGMENTS_ONLY", "VARIANT_MANIFESTS_AND_SEGMENTS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_clock #=> String, one of ["INITIALIZE_FROM_OUTPUT_TIMECODE", "SYSTEM_CLOCK"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.redundant_manifest #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segments_per_subdirectory #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.stream_inf_resolution #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timestamp_delta_milliseconds #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ts_file_mode #=> String, one of ["SEGMENTED_FILES", "SINGLE_FILE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings #=> Types::MediaPackageGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings #=> Types::MsSmoothGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.acquisition_point_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.audio_only_timecode_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED_CLOCK"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id_mode #=> String, one of ["NO_EVENT_ID", "USE_CONFIGURED", "USE_TIMESTAMP"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_stop_behavior #=> String, one of ["NONE", "SEND_EOS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.fragment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.send_delay_ms #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.sparse_track_type #=> String, one of ["NONE", "SCTE_35", "SCTE_35_WITHOUT_SEGMENTATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.stream_manifest_behavior #=> String, one of ["DO_NOT_SEND", "SEND"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset_mode #=> String, one of ["USE_CONFIGURED_OFFSET", "USE_EVENT_START_DATE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.multiplex_group_settings #=> Types::MultiplexGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings #=> Types::RtmpGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers[0] #=> String, one of ["ON_CUE_POINT_SCTE35"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.authentication_scheme #=> String, one of ["AKAMAI", "COMMON"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_full_behavior #=> String, one of ["DISCONNECT_IMMEDIATELY", "WAIT_FOR_SERVER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.caption_data #=> String, one of ["ALL", "FIELD1_608", "FIELD1_AND_FIELD2_608"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings #=> Types::UdpGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.input_loss_action #=> String, one of ["DROP_PROGRAM", "DROP_TS", "EMIT_PROGRAM"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs #=> Array<Output>
    #   resp.data.encoder_settings.output_groups[0].outputs[0] #=> Types::Output
    #   resp.data.encoder_settings.output_groups[0].outputs[0].audio_description_names #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].outputs[0].audio_description_names[0] #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].caption_description_names #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings #=> Types::OutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings #=> Types::ArchiveOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings #=> Types::ArchiveContainerSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.absent_input_audio_behavior #=> String, one of ["DROP", "ENCODE_SILENCE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid_control #=> String, one of ["AUTO", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_buffer_model #=> String, one of ["ATSC", "DVB"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_frames_per_pes #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_stream_type #=> String, one of ["ATSC", "DVB"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.buffer_model #=> String, one of ["MULTIPLEX", "NONE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.cc_descriptor #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings #=> Types::DvbNitSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings #=> Types::DvbSdtSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.output_sdt #=> String, one of ["SDT_FOLLOW", "SDT_FOLLOW_IF_PRESENT", "SDT_MANUAL", "SDT_NONE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_provider_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sub_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings #=> Types::DvbTdtSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_teletext_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebif #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_audio_interval #=> String, one of ["VIDEO_AND_FIXED_INTERVALS", "VIDEO_INTERVAL"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_lookahead_ms #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_placement #=> String, one of ["VIDEO_AND_AUDIO_PIDS", "VIDEO_PID"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ecm_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.es_rate_in_pes #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_platform_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_signal_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.fragment_time #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv_data_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.null_packet_bitrate #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pat_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.program_num #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.rate_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte27_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_control #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_markers #=> String, one of ["EBP", "EBP_LEGACY", "NONE", "PSI_SEGSTART", "RAI_ADAPT", "RAI_SEGSTART"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_style #=> String, one of ["MAINTAIN_CADENCE", "RESET_CADENCE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_time #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.transport_stream_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.video_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.raw_settings #=> Types::RawSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.extension #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings #=> Types::FrameCaptureOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings #=> Types::HlsOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings #=> Types::HlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings #=> Types::AudioOnlyHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_group_id #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_only_image #=> Types::InputLocation
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_track_type #=> String, one of ["ALTERNATE_AUDIO_AUTO_SELECT", "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT", "ALTERNATE_AUDIO_NOT_AUTO_SELECT", "AUDIO_ONLY_VARIANT_STREAM"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.segment_type #=> String, one of ["AAC", "FMP4"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings #=> Types::Fmp4HlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.audio_rendition_sets #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.frame_capture_hls_settings #=> Types::FrameCaptureHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings #=> Types::StandardHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.audio_rendition_sets #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings #=> Types::M3u8Settings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_frames_per_pes #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.ecm_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pat_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.program_num #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.transport_stream_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.video_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.segment_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.media_package_output_settings #=> Types::MediaPackageOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings #=> Types::MsSmoothOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings #=> Types::MultiplexOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings #=> Types::RtmpOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings #=> Types::UdpOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.buffer_msec #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings #=> Types::UdpContainerSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings #=> Types::FecOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.column_depth #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.include_fec #=> String, one of ["COLUMN", "COLUMN_AND_ROW"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.row_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].video_description_name #=> String
    #   resp.data.encoder_settings.timecode_config #=> Types::TimecodeConfig
    #   resp.data.encoder_settings.timecode_config.source #=> String, one of ["EMBEDDED", "SYSTEMCLOCK", "ZEROBASED"]
    #   resp.data.encoder_settings.timecode_config.sync_threshold #=> Integer
    #   resp.data.encoder_settings.video_descriptions #=> Array<VideoDescription>
    #   resp.data.encoder_settings.video_descriptions[0] #=> Types::VideoDescription
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings #=> Types::VideoCodecSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings #=> Types::FrameCaptureSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval_units #=> String, one of ["MILLISECONDS", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings #=> Types::H264Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_fill_pct #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_size #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings #=> Types::H264ColorSpaceSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.entropy_encoding #=> String, one of ["CABAC", "CAVLC"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings #=> Types::H264FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.post_filter_sharpening #=> String, one of ["AUTO", "DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.strength #=> String, one of ["AUTO", "STRENGTH_1", "STRENGTH_2", "STRENGTH_3", "STRENGTH_4", "STRENGTH_5", "STRENGTH_6", "STRENGTH_7", "STRENGTH_8", "STRENGTH_9", "STRENGTH_10", "STRENGTH_11", "STRENGTH_12", "STRENGTH_13", "STRENGTH_14", "STRENGTH_15", "STRENGTH_16"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.force_field_pictures #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_b_reference #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_num_b_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.level #=> String, one of ["H264_LEVEL_1", "H264_LEVEL_1_1", "H264_LEVEL_1_2", "H264_LEVEL_1_3", "H264_LEVEL_2", "H264_LEVEL_2_1", "H264_LEVEL_2_2", "H264_LEVEL_3", "H264_LEVEL_3_1", "H264_LEVEL_3_2", "H264_LEVEL_4", "H264_LEVEL_4_1", "H264_LEVEL_4_2", "H264_LEVEL_5", "H264_LEVEL_5_1", "H264_LEVEL_5_2", "H264_LEVEL_AUTO"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.max_bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.min_i_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.num_ref_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.profile #=> String, one of ["BASELINE", "HIGH", "HIGH_10BIT", "HIGH_422", "HIGH_422_10BIT", "MAIN"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.quality_level #=> String, one of ["ENHANCED_QUALITY", "STANDARD_QUALITY"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.qvbr_quality_level #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR", "VBR"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.slices #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.softness #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.spatial_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.syntax #=> String, one of ["DEFAULT", "RP2027"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.temporal_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings #=> Types::H265Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.alternative_transfer_function #=> String, one of ["INSERT", "OMIT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.buf_size #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings #=> Types::H265ColorSpaceSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_cll #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_fall #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings #=> Types::H265FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.level #=> String, one of ["H265_LEVEL_1", "H265_LEVEL_2", "H265_LEVEL_2_1", "H265_LEVEL_3", "H265_LEVEL_3_1", "H265_LEVEL_4", "H265_LEVEL_4_1", "H265_LEVEL_5", "H265_LEVEL_5_1", "H265_LEVEL_5_2", "H265_LEVEL_6", "H265_LEVEL_6_1", "H265_LEVEL_6_2", "H265_LEVEL_AUTO"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.max_bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.min_i_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.profile #=> String, one of ["MAIN", "MAIN_10BIT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.qvbr_quality_level #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.slices #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.tier #=> String, one of ["HIGH", "MAIN"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings #=> Types::Mpeg2Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "LOW", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_space #=> String, one of ["AUTO", "PASSTHROUGH"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.display_aspect_ratio #=> String, one of ["DISPLAYRATIO16X9", "DISPLAYRATIO4X3"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings #=> Types::Mpeg2FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_num_b_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.timecode_insertion #=> String, one of ["DISABLED", "GOP_TIMECODE"]
    #   resp.data.encoder_settings.video_descriptions[0].height #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].name #=> String
    #   resp.data.encoder_settings.video_descriptions[0].respond_to_afd #=> String, one of ["NONE", "PASSTHROUGH", "RESPOND"]
    #   resp.data.encoder_settings.video_descriptions[0].scaling_behavior #=> String, one of ["DEFAULT", "STRETCH_TO_OUTPUT"]
    #   resp.data.encoder_settings.video_descriptions[0].sharpness #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].width #=> Integer
    #   resp.data.id #=> String
    #   resp.data.input_attachments #=> Array<InputAttachment>
    #   resp.data.input_attachments[0] #=> Types::InputAttachment
    #   resp.data.input_attachments[0].automatic_input_failover_settings #=> Types::AutomaticInputFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.error_clear_time_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions #=> Array<FailoverCondition>
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0] #=> Types::FailoverCondition
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings #=> Types::FailoverConditionSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings #=> Types::AudioSilenceFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_selector_name #=> String
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_silence_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings #=> Types::InputLossFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings.input_loss_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings #=> Types::VideoBlackFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.black_detect_threshold #=> Float
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.video_black_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.input_preference #=> String, one of ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #   resp.data.input_attachments[0].automatic_input_failover_settings.secondary_input_id #=> String
    #   resp.data.input_attachments[0].input_attachment_name #=> String
    #   resp.data.input_attachments[0].input_id #=> String
    #   resp.data.input_attachments[0].input_settings #=> Types::InputSettings
    #   resp.data.input_attachments[0].input_settings.audio_selectors #=> Array<AudioSelector>
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0] #=> Types::AudioSelector
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].name #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings #=> Types::AudioSelectorSettings
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection #=> Types::AudioHlsRenditionSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.group_id #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.name #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection #=> Types::AudioLanguageSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_code #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_selection_policy #=> String, one of ["LOOSE", "STRICT"]
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection #=> Types::AudioPidSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection #=> Types::AudioTrackSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks #=> Array<AudioTrack>
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0] #=> Types::AudioTrack
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0].track #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors #=> Array<CaptionSelector>
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0] #=> Types::CaptionSelector
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].language_code #=> String
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].name #=> String
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings #=> Types::CaptionSelectorSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings #=> Types::AncillarySourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings.source_ancillary_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.arib_source_settings #=> Types::AribSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings #=> Types::DvbSubSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings #=> Types::EmbeddedSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.scte20_detection #=> String, one of ["AUTO", "OFF"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_track_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings #=> Types::Scte20SourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.source608_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings #=> Types::Scte27SourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings #=> Types::TeletextSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle #=> Types::CaptionRectangle
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.height #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.left_offset #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.top_offset #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.width #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.page_number #=> String
    #   resp.data.input_attachments[0].input_settings.deblock_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.input_attachments[0].input_settings.denoise_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.input_attachments[0].input_settings.filter_strength #=> Integer
    #   resp.data.input_attachments[0].input_settings.input_filter #=> String, one of ["AUTO", "DISABLED", "FORCED"]
    #   resp.data.input_attachments[0].input_settings.network_input_settings #=> Types::NetworkInputSettings
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings #=> Types::HlsInputSettings
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.bandwidth #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.buffer_segments #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retries #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retry_interval #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.scte35_source #=> String, one of ["MANIFEST", "SEGMENTS"]
    #   resp.data.input_attachments[0].input_settings.network_input_settings.server_validation #=> String, one of ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #   resp.data.input_attachments[0].input_settings.scte35_pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.smpte2038_data_preference #=> String, one of ["IGNORE", "PREFER"]
    #   resp.data.input_attachments[0].input_settings.source_end_behavior #=> String, one of ["CONTINUE", "LOOP"]
    #   resp.data.input_attachments[0].input_settings.video_selector #=> Types::VideoSelector
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space #=> String, one of ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_settings #=> Types::VideoSelectorColorSpaceSettings
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_usage #=> String, one of ["FALLBACK", "FORCE"]
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings #=> Types::VideoSelectorSettings
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid #=> Types::VideoSelectorPid
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id #=> Types::VideoSelectorProgramId
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id.program_id #=> Integer
    #   resp.data.input_specification #=> Types::InputSpecification
    #   resp.data.input_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC"]
    #   resp.data.input_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.input_specification.resolution #=> String, one of ["SD", "HD", "UHD"]
    #   resp.data.log_level #=> String, one of ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #   resp.data.maintenance #=> Types::MaintenanceStatus
    #   resp.data.maintenance.maintenance_day #=> String, one of ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #   resp.data.maintenance.maintenance_deadline #=> String
    #   resp.data.maintenance.maintenance_scheduled_date #=> String
    #   resp.data.maintenance.maintenance_start_time #=> String
    #   resp.data.name #=> String
    #   resp.data.pipeline_details #=> Array<PipelineDetail>
    #   resp.data.pipeline_details[0] #=> Types::PipelineDetail
    #   resp.data.pipeline_details[0].active_input_attachment_name #=> String
    #   resp.data.pipeline_details[0].active_input_switch_action_name #=> String
    #   resp.data.pipeline_details[0].active_motion_graphics_action_name #=> String
    #   resp.data.pipeline_details[0].active_motion_graphics_uri #=> String
    #   resp.data.pipeline_details[0].pipeline_id #=> String
    #   resp.data.pipelines_running_count #=> Integer
    #   resp.data.role_arn #=> String
    #   resp.data.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED", "UPDATING", "UPDATE_FAILED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #   resp.data.vpc #=> Types::VpcOutputSettingsDescription
    #   resp.data.vpc.availability_zones #=> Array<String>
    #   resp.data.vpc.network_interface_ids #=> Array<String>
    #   resp.data.vpc.security_group_ids #=> Array<String>
    #   resp.data.vpc.subnet_ids #=> Array<String>
    #
    def describe_channel(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeChannelInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeChannelInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeChannel
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeChannel
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeChannel,
        stubs: @stubs,
        params_class: Params::DescribeChannelOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_channel
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Produces details about an input
    #
    # @param [Hash] params
    #   See {Types::DescribeInputInput}.
    #
    # @option params [String] :input_id
    #   Unique ID of the input
    #
    # @return [Types::DescribeInputOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_input(
    #     input_id: 'InputId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeInputOutput
    #   resp.data.arn #=> String
    #   resp.data.attached_channels #=> Array<String>
    #   resp.data.attached_channels[0] #=> String
    #   resp.data.destinations #=> Array<InputDestination>
    #   resp.data.destinations[0] #=> Types::InputDestination
    #   resp.data.destinations[0].ip #=> String
    #   resp.data.destinations[0].port #=> String
    #   resp.data.destinations[0].url #=> String
    #   resp.data.destinations[0].vpc #=> Types::InputDestinationVpc
    #   resp.data.destinations[0].vpc.availability_zone #=> String
    #   resp.data.destinations[0].vpc.network_interface_id #=> String
    #   resp.data.id #=> String
    #   resp.data.input_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.input_devices #=> Array<InputDeviceSettings>
    #   resp.data.input_devices[0] #=> Types::InputDeviceSettings
    #   resp.data.input_devices[0].id #=> String
    #   resp.data.input_partner_ids #=> Array<String>
    #   resp.data.input_source_type #=> String, one of ["STATIC", "DYNAMIC"]
    #   resp.data.media_connect_flows #=> Array<MediaConnectFlow>
    #   resp.data.media_connect_flows[0] #=> Types::MediaConnectFlow
    #   resp.data.media_connect_flows[0].flow_arn #=> String
    #   resp.data.name #=> String
    #   resp.data.role_arn #=> String
    #   resp.data.security_groups #=> Array<String>
    #   resp.data.sources #=> Array<InputSource>
    #   resp.data.sources[0] #=> Types::InputSource
    #   resp.data.sources[0].password_param #=> String
    #   resp.data.sources[0].url #=> String
    #   resp.data.sources[0].username #=> String
    #   resp.data.state #=> String, one of ["CREATING", "DETACHED", "ATTACHED", "DELETING", "DELETED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #   resp.data.type #=> String, one of ["UDP_PUSH", "RTP_PUSH", "RTMP_PUSH", "RTMP_PULL", "URL_PULL", "MP4_FILE", "MEDIACONNECT", "INPUT_DEVICE", "AWS_CDI", "TS_FILE"]
    #
    def describe_input(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeInputInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeInputInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeInput
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeInput
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeInput,
        stubs: @stubs,
        params_class: Params::DescribeInputOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_input
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Gets the details for the input device
    #
    # @param [Hash] params
    #   See {Types::DescribeInputDeviceInput}.
    #
    # @option params [String] :input_device_id
    #   The unique ID of this input device. For example, hd-123456789abcdef.
    #
    # @return [Types::DescribeInputDeviceOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_input_device(
    #     input_device_id: 'InputDeviceId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeInputDeviceOutput
    #   resp.data.arn #=> String
    #   resp.data.connection_state #=> String, one of ["DISCONNECTED", "CONNECTED"]
    #   resp.data.device_settings_sync_state #=> String, one of ["SYNCED", "SYNCING"]
    #   resp.data.device_update_status #=> String, one of ["UP_TO_DATE", "NOT_UP_TO_DATE"]
    #   resp.data.hd_device_settings #=> Types::InputDeviceHdSettings
    #   resp.data.hd_device_settings.active_input #=> String, one of ["HDMI", "SDI"]
    #   resp.data.hd_device_settings.configured_input #=> String, one of ["AUTO", "HDMI", "SDI"]
    #   resp.data.hd_device_settings.device_state #=> String, one of ["IDLE", "STREAMING"]
    #   resp.data.hd_device_settings.framerate #=> Float
    #   resp.data.hd_device_settings.height #=> Integer
    #   resp.data.hd_device_settings.max_bitrate #=> Integer
    #   resp.data.hd_device_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.hd_device_settings.width #=> Integer
    #   resp.data.id #=> String
    #   resp.data.mac_address #=> String
    #   resp.data.name #=> String
    #   resp.data.network_settings #=> Types::InputDeviceNetworkSettings
    #   resp.data.network_settings.dns_addresses #=> Array<String>
    #   resp.data.network_settings.dns_addresses[0] #=> String
    #   resp.data.network_settings.gateway #=> String
    #   resp.data.network_settings.ip_address #=> String
    #   resp.data.network_settings.ip_scheme #=> String, one of ["STATIC", "DHCP"]
    #   resp.data.network_settings.subnet_mask #=> String
    #   resp.data.serial_number #=> String
    #   resp.data.type #=> String, one of ["HD"]
    #   resp.data.uhd_device_settings #=> Types::InputDeviceUhdSettings
    #   resp.data.uhd_device_settings.active_input #=> String, one of ["HDMI", "SDI"]
    #   resp.data.uhd_device_settings.configured_input #=> String, one of ["AUTO", "HDMI", "SDI"]
    #   resp.data.uhd_device_settings.device_state #=> String, one of ["IDLE", "STREAMING"]
    #   resp.data.uhd_device_settings.framerate #=> Float
    #   resp.data.uhd_device_settings.height #=> Integer
    #   resp.data.uhd_device_settings.max_bitrate #=> Integer
    #   resp.data.uhd_device_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.uhd_device_settings.width #=> Integer
    #
    def describe_input_device(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeInputDeviceInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeInputDeviceInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeInputDevice
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeInputDevice
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeInputDevice,
        stubs: @stubs,
        params_class: Params::DescribeInputDeviceOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_input_device
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Get the latest thumbnail data for the input device.
    #
    # @param [Hash] params
    #   See {Types::DescribeInputDeviceThumbnailInput}.
    #
    # @option params [String] :input_device_id
    #   The unique ID of this input device. For example, hd-123456789abcdef.
    #
    # @option params [String] :accept
    #   The HTTP Accept header. Indicates the requested type for the thumbnail.
    #
    # @return [Types::DescribeInputDeviceThumbnailOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_input_device_thumbnail(
    #     input_device_id: 'InputDeviceId', # required
    #     accept: 'image/jpeg' # required - accepts ["image/jpeg"]
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeInputDeviceThumbnailOutput
    #   resp.data.body #=> String
    #   resp.data.content_type #=> String, one of ["image/jpeg"]
    #   resp.data.content_length #=> Integer
    #   resp.data.e_tag #=> String
    #   resp.data.last_modified #=> Time
    #
    def describe_input_device_thumbnail(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeInputDeviceThumbnailInput.build(params)
      response_body = output_stream(options, &block)
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeInputDeviceThumbnailInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeInputDeviceThumbnail
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeInputDeviceThumbnail
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeInputDeviceThumbnail,
        stubs: @stubs,
        params_class: Params::DescribeInputDeviceThumbnailOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_input_device_thumbnail
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Produces a summary of an Input Security Group
    #
    # @param [Hash] params
    #   See {Types::DescribeInputSecurityGroupInput}.
    #
    # @option params [String] :input_security_group_id
    #   The id of the Input Security Group to describe
    #
    # @return [Types::DescribeInputSecurityGroupOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_input_security_group(
    #     input_security_group_id: 'InputSecurityGroupId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeInputSecurityGroupOutput
    #   resp.data.arn #=> String
    #   resp.data.id #=> String
    #   resp.data.inputs #=> Array<String>
    #   resp.data.inputs[0] #=> String
    #   resp.data.state #=> String, one of ["IDLE", "IN_USE", "UPDATING", "DELETED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #   resp.data.whitelist_rules #=> Array<InputWhitelistRule>
    #   resp.data.whitelist_rules[0] #=> Types::InputWhitelistRule
    #   resp.data.whitelist_rules[0].cidr #=> String
    #
    def describe_input_security_group(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeInputSecurityGroupInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeInputSecurityGroupInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeInputSecurityGroup
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeInputSecurityGroup
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeInputSecurityGroup,
        stubs: @stubs,
        params_class: Params::DescribeInputSecurityGroupOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_input_security_group
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Gets details about a multiplex.
    #
    # @param [Hash] params
    #   See {Types::DescribeMultiplexInput}.
    #
    # @option params [String] :multiplex_id
    #   The ID of the multiplex.
    #
    # @return [Types::DescribeMultiplexOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_multiplex(
    #     multiplex_id: 'MultiplexId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeMultiplexOutput
    #   resp.data.arn #=> String
    #   resp.data.availability_zones #=> Array<String>
    #   resp.data.availability_zones[0] #=> String
    #   resp.data.destinations #=> Array<MultiplexOutputDestination>
    #   resp.data.destinations[0] #=> Types::MultiplexOutputDestination
    #   resp.data.destinations[0].media_connect_settings #=> Types::MultiplexMediaConnectOutputDestinationSettings
    #   resp.data.destinations[0].media_connect_settings.entitlement_arn #=> String
    #   resp.data.id #=> String
    #   resp.data.multiplex_settings #=> Types::MultiplexSettings
    #   resp.data.multiplex_settings.maximum_video_buffer_delay_milliseconds #=> Integer
    #   resp.data.multiplex_settings.transport_stream_bitrate #=> Integer
    #   resp.data.multiplex_settings.transport_stream_id #=> Integer
    #   resp.data.multiplex_settings.transport_stream_reserved_bitrate #=> Integer
    #   resp.data.name #=> String
    #   resp.data.pipelines_running_count #=> Integer
    #   resp.data.program_count #=> Integer
    #   resp.data.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #
    def describe_multiplex(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeMultiplexInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeMultiplexInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeMultiplex
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeMultiplex
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeMultiplex,
        stubs: @stubs,
        params_class: Params::DescribeMultiplexOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_multiplex
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Get the details for a program in a multiplex.
    #
    # @param [Hash] params
    #   See {Types::DescribeMultiplexProgramInput}.
    #
    # @option params [String] :multiplex_id
    #   The ID of the multiplex that the program belongs to.
    #
    # @option params [String] :program_name
    #   The name of the program.
    #
    # @return [Types::DescribeMultiplexProgramOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_multiplex_program(
    #     multiplex_id: 'MultiplexId', # required
    #     program_name: 'ProgramName' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeMultiplexProgramOutput
    #   resp.data.channel_id #=> String
    #   resp.data.multiplex_program_settings #=> Types::MultiplexProgramSettings
    #   resp.data.multiplex_program_settings.preferred_channel_pipeline #=> String, one of ["CURRENTLY_ACTIVE", "PIPELINE_0", "PIPELINE_1"]
    #   resp.data.multiplex_program_settings.program_number #=> Integer
    #   resp.data.multiplex_program_settings.service_descriptor #=> Types::MultiplexProgramServiceDescriptor
    #   resp.data.multiplex_program_settings.service_descriptor.provider_name #=> String
    #   resp.data.multiplex_program_settings.service_descriptor.service_name #=> String
    #   resp.data.multiplex_program_settings.video_settings #=> Types::MultiplexVideoSettings
    #   resp.data.multiplex_program_settings.video_settings.constant_bitrate #=> Integer
    #   resp.data.multiplex_program_settings.video_settings.statmux_settings #=> Types::MultiplexStatmuxVideoSettings
    #   resp.data.multiplex_program_settings.video_settings.statmux_settings.maximum_bitrate #=> Integer
    #   resp.data.multiplex_program_settings.video_settings.statmux_settings.minimum_bitrate #=> Integer
    #   resp.data.multiplex_program_settings.video_settings.statmux_settings.priority #=> Integer
    #   resp.data.packet_identifiers_map #=> Types::MultiplexProgramPacketIdentifiersMap
    #   resp.data.packet_identifiers_map.audio_pids #=> Array<Integer>
    #   resp.data.packet_identifiers_map.audio_pids[0] #=> Integer
    #   resp.data.packet_identifiers_map.dvb_sub_pids #=> Array<Integer>
    #   resp.data.packet_identifiers_map.dvb_teletext_pid #=> Integer
    #   resp.data.packet_identifiers_map.etv_platform_pid #=> Integer
    #   resp.data.packet_identifiers_map.etv_signal_pid #=> Integer
    #   resp.data.packet_identifiers_map.klv_data_pids #=> Array<Integer>
    #   resp.data.packet_identifiers_map.pcr_pid #=> Integer
    #   resp.data.packet_identifiers_map.pmt_pid #=> Integer
    #   resp.data.packet_identifiers_map.private_metadata_pid #=> Integer
    #   resp.data.packet_identifiers_map.scte27_pids #=> Array<Integer>
    #   resp.data.packet_identifiers_map.scte35_pid #=> Integer
    #   resp.data.packet_identifiers_map.timed_metadata_pid #=> Integer
    #   resp.data.packet_identifiers_map.video_pid #=> Integer
    #   resp.data.pipeline_details #=> Array<MultiplexProgramPipelineDetail>
    #   resp.data.pipeline_details[0] #=> Types::MultiplexProgramPipelineDetail
    #   resp.data.pipeline_details[0].active_channel_pipeline #=> String
    #   resp.data.pipeline_details[0].pipeline_id #=> String
    #   resp.data.program_name #=> String
    #
    def describe_multiplex_program(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeMultiplexProgramInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeMultiplexProgramInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeMultiplexProgram
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeMultiplexProgram
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeMultiplexProgram,
        stubs: @stubs,
        params_class: Params::DescribeMultiplexProgramOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_multiplex_program
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Get details for an offering.
    #
    # @param [Hash] params
    #   See {Types::DescribeOfferingInput}.
    #
    # @option params [String] :offering_id
    #   Unique offering ID, e.g. '87654321'
    #
    # @return [Types::DescribeOfferingOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_offering(
    #     offering_id: 'OfferingId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeOfferingOutput
    #   resp.data.arn #=> String
    #   resp.data.currency_code #=> String
    #   resp.data.duration #=> Integer
    #   resp.data.duration_units #=> String, one of ["MONTHS"]
    #   resp.data.fixed_price #=> Float
    #   resp.data.offering_description #=> String
    #   resp.data.offering_id #=> String
    #   resp.data.offering_type #=> String, one of ["NO_UPFRONT"]
    #   resp.data.region #=> String
    #   resp.data.resource_specification #=> Types::ReservationResourceSpecification
    #   resp.data.resource_specification.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.resource_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC", "AUDIO", "LINK"]
    #   resp.data.resource_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.resource_specification.maximum_framerate #=> String, one of ["MAX_30_FPS", "MAX_60_FPS"]
    #   resp.data.resource_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.resource_specification.resource_type #=> String, one of ["INPUT", "OUTPUT", "MULTIPLEX", "CHANNEL"]
    #   resp.data.resource_specification.special_feature #=> String, one of ["ADVANCED_AUDIO", "AUDIO_NORMALIZATION", "MGHD", "MGUHD"]
    #   resp.data.resource_specification.video_quality #=> String, one of ["STANDARD", "ENHANCED", "PREMIUM"]
    #   resp.data.usage_price #=> Float
    #
    def describe_offering(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeOfferingInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeOfferingInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeOffering
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeOffering
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeOffering,
        stubs: @stubs,
        params_class: Params::DescribeOfferingOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_offering
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Get details for a reservation.
    #
    # @param [Hash] params
    #   See {Types::DescribeReservationInput}.
    #
    # @option params [String] :reservation_id
    #   Unique reservation ID, e.g. '1234567'
    #
    # @return [Types::DescribeReservationOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_reservation(
    #     reservation_id: 'ReservationId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeReservationOutput
    #   resp.data.arn #=> String
    #   resp.data.count #=> Integer
    #   resp.data.currency_code #=> String
    #   resp.data.duration #=> Integer
    #   resp.data.duration_units #=> String, one of ["MONTHS"]
    #   resp.data.end #=> String
    #   resp.data.fixed_price #=> Float
    #   resp.data.name #=> String
    #   resp.data.offering_description #=> String
    #   resp.data.offering_id #=> String
    #   resp.data.offering_type #=> String, one of ["NO_UPFRONT"]
    #   resp.data.region #=> String
    #   resp.data.reservation_id #=> String
    #   resp.data.resource_specification #=> Types::ReservationResourceSpecification
    #   resp.data.resource_specification.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.resource_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC", "AUDIO", "LINK"]
    #   resp.data.resource_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.resource_specification.maximum_framerate #=> String, one of ["MAX_30_FPS", "MAX_60_FPS"]
    #   resp.data.resource_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.resource_specification.resource_type #=> String, one of ["INPUT", "OUTPUT", "MULTIPLEX", "CHANNEL"]
    #   resp.data.resource_specification.special_feature #=> String, one of ["ADVANCED_AUDIO", "AUDIO_NORMALIZATION", "MGHD", "MGUHD"]
    #   resp.data.resource_specification.video_quality #=> String, one of ["STANDARD", "ENHANCED", "PREMIUM"]
    #   resp.data.start #=> String
    #   resp.data.state #=> String, one of ["ACTIVE", "EXPIRED", "CANCELED", "DELETED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #   resp.data.usage_price #=> Float
    #
    def describe_reservation(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeReservationInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeReservationInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeReservation
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeReservation
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeReservation,
        stubs: @stubs,
        params_class: Params::DescribeReservationOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_reservation
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Get a channel schedule
    #
    # @param [Hash] params
    #   See {Types::DescribeScheduleInput}.
    #
    # @option params [String] :channel_id
    #   Id of the channel whose schedule is being updated.
    #
    # @option params [Integer] :max_results
    #   Placeholder documentation for MaxResults
    #
    # @option params [String] :next_token
    #   Placeholder documentation for __string
    #
    # @return [Types::DescribeScheduleOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.describe_schedule(
    #     channel_id: 'ChannelId', # required
    #     max_results: 1,
    #     next_token: 'NextToken'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::DescribeScheduleOutput
    #   resp.data.next_token #=> String
    #   resp.data.schedule_actions #=> Array<ScheduleAction>
    #   resp.data.schedule_actions[0] #=> Types::ScheduleAction
    #   resp.data.schedule_actions[0].action_name #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings #=> Types::ScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.hls_id3_segment_tagging_settings #=> Types::HlsId3SegmentTaggingScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.hls_id3_segment_tagging_settings.tag #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.hls_timed_metadata_settings #=> Types::HlsTimedMetadataScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.hls_timed_metadata_settings.id3 #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings #=> Types::InputPrepareScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_attachment_name_reference #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings #=> Types::InputClippingSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.input_timecode_source #=> String, one of ["ZEROBASED", "EMBEDDED"]
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.start_timecode #=> Types::StartTimecode
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.start_timecode.timecode #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.stop_timecode #=> Types::StopTimecode
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.stop_timecode.last_frame_clipping_behavior #=> String, one of ["EXCLUDE_LAST_FRAME", "INCLUDE_LAST_FRAME"]
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.input_clipping_settings.stop_timecode.timecode #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.url_path #=> Array<String>
    #   resp.data.schedule_actions[0].schedule_action_settings.input_prepare_settings.url_path[0] #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.input_switch_settings #=> Types::InputSwitchScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.input_switch_settings.input_attachment_name_reference #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.input_switch_settings.input_clipping_settings #=> Types::InputClippingSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.input_switch_settings.url_path #=> Array<String>
    #   resp.data.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings #=> Types::MotionGraphicsActivateScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings.duration #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings.password_param #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings.url #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.motion_graphics_image_activate_settings.username #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.motion_graphics_image_deactivate_settings #=> Types::MotionGraphicsDeactivateScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.pause_state_settings #=> Types::PauseStateScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.pause_state_settings.pipelines #=> Array<PipelinePauseStateSettings>
    #   resp.data.schedule_actions[0].schedule_action_settings.pause_state_settings.pipelines[0] #=> Types::PipelinePauseStateSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.pause_state_settings.pipelines[0].pipeline_id #=> String, one of ["PIPELINE_0", "PIPELINE_1"]
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_return_to_network_settings #=> Types::Scte35ReturnToNetworkScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_return_to_network_settings.splice_event_id #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_splice_insert_settings #=> Types::Scte35SpliceInsertScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_splice_insert_settings.duration #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_splice_insert_settings.splice_event_id #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings #=> Types::Scte35TimeSignalScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors #=> Array<Scte35Descriptor>
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0] #=> Types::Scte35Descriptor
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings #=> Types::Scte35DescriptorSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings #=> Types::Scte35SegmentationDescriptor
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions #=> Types::Scte35DeliveryRestrictions
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions.archive_allowed_flag #=> String, one of ["ARCHIVE_NOT_ALLOWED", "ARCHIVE_ALLOWED"]
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions.device_restrictions #=> String, one of ["NONE", "RESTRICT_GROUP0", "RESTRICT_GROUP1", "RESTRICT_GROUP2"]
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions.no_regional_blackout_flag #=> String, one of ["REGIONAL_BLACKOUT", "NO_REGIONAL_BLACKOUT"]
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.delivery_restrictions.web_delivery_allowed_flag #=> String, one of ["WEB_DELIVERY_NOT_ALLOWED", "WEB_DELIVERY_ALLOWED"]
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segment_num #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_cancel_indicator #=> String, one of ["SEGMENTATION_EVENT_NOT_CANCELED", "SEGMENTATION_EVENT_CANCELED"]
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_duration #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_event_id #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_type_id #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_upid #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segmentation_upid_type #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.segments_expected #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.sub_segment_num #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.scte35_time_signal_settings.scte35_descriptors[0].scte35_descriptor_settings.segmentation_descriptor_scte35_descriptor_settings.sub_segments_expected #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings #=> Types::StaticImageActivateScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.duration #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.fade_in #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.fade_out #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.height #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image #=> Types::InputLocation
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image.password_param #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image.uri #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image.username #=> String
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image_x #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.image_y #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.layer #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.opacity #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_activate_settings.width #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_deactivate_settings #=> Types::StaticImageDeactivateScheduleActionSettings
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_deactivate_settings.fade_out #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_settings.static_image_deactivate_settings.layer #=> Integer
    #   resp.data.schedule_actions[0].schedule_action_start_settings #=> Types::ScheduleActionStartSettings
    #   resp.data.schedule_actions[0].schedule_action_start_settings.fixed_mode_schedule_action_start_settings #=> Types::FixedModeScheduleActionStartSettings
    #   resp.data.schedule_actions[0].schedule_action_start_settings.fixed_mode_schedule_action_start_settings.time #=> String
    #   resp.data.schedule_actions[0].schedule_action_start_settings.follow_mode_schedule_action_start_settings #=> Types::FollowModeScheduleActionStartSettings
    #   resp.data.schedule_actions[0].schedule_action_start_settings.follow_mode_schedule_action_start_settings.follow_point #=> String, one of ["END", "START"]
    #   resp.data.schedule_actions[0].schedule_action_start_settings.follow_mode_schedule_action_start_settings.reference_action_name #=> String
    #   resp.data.schedule_actions[0].schedule_action_start_settings.immediate_mode_schedule_action_start_settings #=> Types::ImmediateModeScheduleActionStartSettings
    #
    def describe_schedule(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::DescribeScheduleInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::DescribeScheduleInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::DescribeSchedule
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::DescribeSchedule
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::DescribeSchedule,
        stubs: @stubs,
        params_class: Params::DescribeScheduleOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :describe_schedule
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Produces list of channels that have been created
    #
    # @param [Hash] params
    #   See {Types::ListChannelsInput}.
    #
    # @option params [Integer] :max_results
    #   Placeholder documentation for MaxResults
    #
    # @option params [String] :next_token
    #   Placeholder documentation for __string
    #
    # @return [Types::ListChannelsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_channels(
    #     max_results: 1,
    #     next_token: 'NextToken'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListChannelsOutput
    #   resp.data.channels #=> Array<ChannelSummary>
    #   resp.data.channels[0] #=> Types::ChannelSummary
    #   resp.data.channels[0].arn #=> String
    #   resp.data.channels[0].cdi_input_specification #=> Types::CdiInputSpecification
    #   resp.data.channels[0].cdi_input_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.channels[0].channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.channels[0].destinations #=> Array<OutputDestination>
    #   resp.data.channels[0].destinations[0] #=> Types::OutputDestination
    #   resp.data.channels[0].destinations[0].id #=> String
    #   resp.data.channels[0].destinations[0].media_package_settings #=> Array<MediaPackageOutputDestinationSettings>
    #   resp.data.channels[0].destinations[0].media_package_settings[0] #=> Types::MediaPackageOutputDestinationSettings
    #   resp.data.channels[0].destinations[0].media_package_settings[0].channel_id #=> String
    #   resp.data.channels[0].destinations[0].multiplex_settings #=> Types::MultiplexProgramChannelDestinationSettings
    #   resp.data.channels[0].destinations[0].multiplex_settings.multiplex_id #=> String
    #   resp.data.channels[0].destinations[0].multiplex_settings.program_name #=> String
    #   resp.data.channels[0].destinations[0].settings #=> Array<OutputDestinationSettings>
    #   resp.data.channels[0].destinations[0].settings[0] #=> Types::OutputDestinationSettings
    #   resp.data.channels[0].destinations[0].settings[0].password_param #=> String
    #   resp.data.channels[0].destinations[0].settings[0].stream_name #=> String
    #   resp.data.channels[0].destinations[0].settings[0].url #=> String
    #   resp.data.channels[0].destinations[0].settings[0].username #=> String
    #   resp.data.channels[0].egress_endpoints #=> Array<ChannelEgressEndpoint>
    #   resp.data.channels[0].egress_endpoints[0] #=> Types::ChannelEgressEndpoint
    #   resp.data.channels[0].egress_endpoints[0].source_ip #=> String
    #   resp.data.channels[0].id #=> String
    #   resp.data.channels[0].input_attachments #=> Array<InputAttachment>
    #   resp.data.channels[0].input_attachments[0] #=> Types::InputAttachment
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings #=> Types::AutomaticInputFailoverSettings
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.error_clear_time_msec #=> Integer
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions #=> Array<FailoverCondition>
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0] #=> Types::FailoverCondition
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings #=> Types::FailoverConditionSettings
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings #=> Types::AudioSilenceFailoverSettings
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_selector_name #=> String
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_silence_threshold_msec #=> Integer
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings #=> Types::InputLossFailoverSettings
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings.input_loss_threshold_msec #=> Integer
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings #=> Types::VideoBlackFailoverSettings
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.black_detect_threshold #=> Float
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.video_black_threshold_msec #=> Integer
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.input_preference #=> String, one of ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #   resp.data.channels[0].input_attachments[0].automatic_input_failover_settings.secondary_input_id #=> String
    #   resp.data.channels[0].input_attachments[0].input_attachment_name #=> String
    #   resp.data.channels[0].input_attachments[0].input_id #=> String
    #   resp.data.channels[0].input_attachments[0].input_settings #=> Types::InputSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors #=> Array<AudioSelector>
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0] #=> Types::AudioSelector
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].name #=> String
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings #=> Types::AudioSelectorSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection #=> Types::AudioHlsRenditionSelection
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.group_id #=> String
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.name #=> String
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection #=> Types::AudioLanguageSelection
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_code #=> String
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_selection_policy #=> String, one of ["LOOSE", "STRICT"]
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection #=> Types::AudioPidSelection
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection.pid #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection #=> Types::AudioTrackSelection
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks #=> Array<AudioTrack>
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0] #=> Types::AudioTrack
    #   resp.data.channels[0].input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0].track #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors #=> Array<CaptionSelector>
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0] #=> Types::CaptionSelector
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].language_code #=> String
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].name #=> String
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings #=> Types::CaptionSelectorSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings #=> Types::AncillarySourceSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings.source_ancillary_channel_number #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.arib_source_settings #=> Types::AribSourceSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings #=> Types::DvbSubSourceSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.pid #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings #=> Types::EmbeddedSourceSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.scte20_detection #=> String, one of ["AUTO", "OFF"]
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_channel_number #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_track_number #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings #=> Types::Scte20SourceSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.source608_channel_number #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings #=> Types::Scte27SourceSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.pid #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings #=> Types::TeletextSourceSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle #=> Types::CaptionRectangle
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.height #=> Float
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.left_offset #=> Float
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.top_offset #=> Float
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.width #=> Float
    #   resp.data.channels[0].input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.page_number #=> String
    #   resp.data.channels[0].input_attachments[0].input_settings.deblock_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channels[0].input_attachments[0].input_settings.denoise_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channels[0].input_attachments[0].input_settings.filter_strength #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.input_filter #=> String, one of ["AUTO", "DISABLED", "FORCED"]
    #   resp.data.channels[0].input_attachments[0].input_settings.network_input_settings #=> Types::NetworkInputSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.network_input_settings.hls_input_settings #=> Types::HlsInputSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.network_input_settings.hls_input_settings.bandwidth #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.network_input_settings.hls_input_settings.buffer_segments #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.network_input_settings.hls_input_settings.retries #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.network_input_settings.hls_input_settings.retry_interval #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.network_input_settings.hls_input_settings.scte35_source #=> String, one of ["MANIFEST", "SEGMENTS"]
    #   resp.data.channels[0].input_attachments[0].input_settings.network_input_settings.server_validation #=> String, one of ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #   resp.data.channels[0].input_attachments[0].input_settings.scte35_pid #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.smpte2038_data_preference #=> String, one of ["IGNORE", "PREFER"]
    #   resp.data.channels[0].input_attachments[0].input_settings.source_end_behavior #=> String, one of ["CONTINUE", "LOOP"]
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector #=> Types::VideoSelector
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.color_space #=> String, one of ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.color_space_settings #=> Types::VideoSelectorColorSpaceSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings.max_cll #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings.max_fall #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.color_space_usage #=> String, one of ["FALLBACK", "FORCE"]
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.selector_settings #=> Types::VideoSelectorSettings
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid #=> Types::VideoSelectorPid
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid.pid #=> Integer
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id #=> Types::VideoSelectorProgramId
    #   resp.data.channels[0].input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id.program_id #=> Integer
    #   resp.data.channels[0].input_specification #=> Types::InputSpecification
    #   resp.data.channels[0].input_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC"]
    #   resp.data.channels[0].input_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.channels[0].input_specification.resolution #=> String, one of ["SD", "HD", "UHD"]
    #   resp.data.channels[0].log_level #=> String, one of ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #   resp.data.channels[0].maintenance #=> Types::MaintenanceStatus
    #   resp.data.channels[0].maintenance.maintenance_day #=> String, one of ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #   resp.data.channels[0].maintenance.maintenance_deadline #=> String
    #   resp.data.channels[0].maintenance.maintenance_scheduled_date #=> String
    #   resp.data.channels[0].maintenance.maintenance_start_time #=> String
    #   resp.data.channels[0].name #=> String
    #   resp.data.channels[0].pipelines_running_count #=> Integer
    #   resp.data.channels[0].role_arn #=> String
    #   resp.data.channels[0].state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED", "UPDATING", "UPDATE_FAILED"]
    #   resp.data.channels[0].tags #=> Hash<String, String>
    #   resp.data.channels[0].tags['key'] #=> String
    #   resp.data.channels[0].vpc #=> Types::VpcOutputSettingsDescription
    #   resp.data.channels[0].vpc.availability_zones #=> Array<String>
    #   resp.data.channels[0].vpc.availability_zones[0] #=> String
    #   resp.data.channels[0].vpc.network_interface_ids #=> Array<String>
    #   resp.data.channels[0].vpc.security_group_ids #=> Array<String>
    #   resp.data.channels[0].vpc.subnet_ids #=> Array<String>
    #   resp.data.next_token #=> String
    #
    def list_channels(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListChannelsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListChannelsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListChannels
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::ListChannels
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListChannels,
        stubs: @stubs,
        params_class: Params::ListChannelsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_channels
        )
      )
      raise resp.error if resp.error
      resp
    end

    # List input devices that are currently being transferred. List input devices that you are transferring from your AWS account or input devices that another AWS account is transferring to you.
    #
    # @param [Hash] params
    #   See {Types::ListInputDeviceTransfersInput}.
    #
    # @option params [Integer] :max_results
    #   Placeholder documentation for MaxResults
    #
    # @option params [String] :next_token
    #   Placeholder documentation for __string
    #
    # @option params [String] :transfer_type
    #   Placeholder documentation for __string
    #
    # @return [Types::ListInputDeviceTransfersOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_input_device_transfers(
    #     max_results: 1,
    #     next_token: 'NextToken',
    #     transfer_type: 'TransferType' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListInputDeviceTransfersOutput
    #   resp.data.input_device_transfers #=> Array<TransferringInputDeviceSummary>
    #   resp.data.input_device_transfers[0] #=> Types::TransferringInputDeviceSummary
    #   resp.data.input_device_transfers[0].id #=> String
    #   resp.data.input_device_transfers[0].message #=> String
    #   resp.data.input_device_transfers[0].target_customer_id #=> String
    #   resp.data.input_device_transfers[0].transfer_type #=> String, one of ["OUTGOING", "INCOMING"]
    #   resp.data.next_token #=> String
    #
    def list_input_device_transfers(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListInputDeviceTransfersInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListInputDeviceTransfersInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListInputDeviceTransfers
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::ListInputDeviceTransfers
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListInputDeviceTransfers,
        stubs: @stubs,
        params_class: Params::ListInputDeviceTransfersOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_input_device_transfers
        )
      )
      raise resp.error if resp.error
      resp
    end

    # List input devices
    #
    # @param [Hash] params
    #   See {Types::ListInputDevicesInput}.
    #
    # @option params [Integer] :max_results
    #   Placeholder documentation for MaxResults
    #
    # @option params [String] :next_token
    #   Placeholder documentation for __string
    #
    # @return [Types::ListInputDevicesOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_input_devices(
    #     max_results: 1,
    #     next_token: 'NextToken'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListInputDevicesOutput
    #   resp.data.input_devices #=> Array<InputDeviceSummary>
    #   resp.data.input_devices[0] #=> Types::InputDeviceSummary
    #   resp.data.input_devices[0].arn #=> String
    #   resp.data.input_devices[0].connection_state #=> String, one of ["DISCONNECTED", "CONNECTED"]
    #   resp.data.input_devices[0].device_settings_sync_state #=> String, one of ["SYNCED", "SYNCING"]
    #   resp.data.input_devices[0].device_update_status #=> String, one of ["UP_TO_DATE", "NOT_UP_TO_DATE"]
    #   resp.data.input_devices[0].hd_device_settings #=> Types::InputDeviceHdSettings
    #   resp.data.input_devices[0].hd_device_settings.active_input #=> String, one of ["HDMI", "SDI"]
    #   resp.data.input_devices[0].hd_device_settings.configured_input #=> String, one of ["AUTO", "HDMI", "SDI"]
    #   resp.data.input_devices[0].hd_device_settings.device_state #=> String, one of ["IDLE", "STREAMING"]
    #   resp.data.input_devices[0].hd_device_settings.framerate #=> Float
    #   resp.data.input_devices[0].hd_device_settings.height #=> Integer
    #   resp.data.input_devices[0].hd_device_settings.max_bitrate #=> Integer
    #   resp.data.input_devices[0].hd_device_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.input_devices[0].hd_device_settings.width #=> Integer
    #   resp.data.input_devices[0].id #=> String
    #   resp.data.input_devices[0].mac_address #=> String
    #   resp.data.input_devices[0].name #=> String
    #   resp.data.input_devices[0].network_settings #=> Types::InputDeviceNetworkSettings
    #   resp.data.input_devices[0].network_settings.dns_addresses #=> Array<String>
    #   resp.data.input_devices[0].network_settings.dns_addresses[0] #=> String
    #   resp.data.input_devices[0].network_settings.gateway #=> String
    #   resp.data.input_devices[0].network_settings.ip_address #=> String
    #   resp.data.input_devices[0].network_settings.ip_scheme #=> String, one of ["STATIC", "DHCP"]
    #   resp.data.input_devices[0].network_settings.subnet_mask #=> String
    #   resp.data.input_devices[0].serial_number #=> String
    #   resp.data.input_devices[0].type #=> String, one of ["HD"]
    #   resp.data.input_devices[0].uhd_device_settings #=> Types::InputDeviceUhdSettings
    #   resp.data.input_devices[0].uhd_device_settings.active_input #=> String, one of ["HDMI", "SDI"]
    #   resp.data.input_devices[0].uhd_device_settings.configured_input #=> String, one of ["AUTO", "HDMI", "SDI"]
    #   resp.data.input_devices[0].uhd_device_settings.device_state #=> String, one of ["IDLE", "STREAMING"]
    #   resp.data.input_devices[0].uhd_device_settings.framerate #=> Float
    #   resp.data.input_devices[0].uhd_device_settings.height #=> Integer
    #   resp.data.input_devices[0].uhd_device_settings.max_bitrate #=> Integer
    #   resp.data.input_devices[0].uhd_device_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.input_devices[0].uhd_device_settings.width #=> Integer
    #   resp.data.next_token #=> String
    #
    def list_input_devices(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListInputDevicesInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListInputDevicesInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListInputDevices
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::ListInputDevices
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListInputDevices,
        stubs: @stubs,
        params_class: Params::ListInputDevicesOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_input_devices
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Produces a list of Input Security Groups for an account
    #
    # @param [Hash] params
    #   See {Types::ListInputSecurityGroupsInput}.
    #
    # @option params [Integer] :max_results
    #   Placeholder documentation for MaxResults
    #
    # @option params [String] :next_token
    #   Placeholder documentation for __string
    #
    # @return [Types::ListInputSecurityGroupsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_input_security_groups(
    #     max_results: 1,
    #     next_token: 'NextToken'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListInputSecurityGroupsOutput
    #   resp.data.input_security_groups #=> Array<InputSecurityGroup>
    #   resp.data.input_security_groups[0] #=> Types::InputSecurityGroup
    #   resp.data.input_security_groups[0].arn #=> String
    #   resp.data.input_security_groups[0].id #=> String
    #   resp.data.input_security_groups[0].inputs #=> Array<String>
    #   resp.data.input_security_groups[0].inputs[0] #=> String
    #   resp.data.input_security_groups[0].state #=> String, one of ["IDLE", "IN_USE", "UPDATING", "DELETED"]
    #   resp.data.input_security_groups[0].tags #=> Hash<String, String>
    #   resp.data.input_security_groups[0].tags['key'] #=> String
    #   resp.data.input_security_groups[0].whitelist_rules #=> Array<InputWhitelistRule>
    #   resp.data.input_security_groups[0].whitelist_rules[0] #=> Types::InputWhitelistRule
    #   resp.data.input_security_groups[0].whitelist_rules[0].cidr #=> String
    #   resp.data.next_token #=> String
    #
    def list_input_security_groups(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListInputSecurityGroupsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListInputSecurityGroupsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListInputSecurityGroups
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::ListInputSecurityGroups
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListInputSecurityGroups,
        stubs: @stubs,
        params_class: Params::ListInputSecurityGroupsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_input_security_groups
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Produces list of inputs that have been created
    #
    # @param [Hash] params
    #   See {Types::ListInputsInput}.
    #
    # @option params [Integer] :max_results
    #   Placeholder documentation for MaxResults
    #
    # @option params [String] :next_token
    #   Placeholder documentation for __string
    #
    # @return [Types::ListInputsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_inputs(
    #     max_results: 1,
    #     next_token: 'NextToken'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListInputsOutput
    #   resp.data.inputs #=> Array<Input>
    #   resp.data.inputs[0] #=> Types::Input
    #   resp.data.inputs[0].arn #=> String
    #   resp.data.inputs[0].attached_channels #=> Array<String>
    #   resp.data.inputs[0].attached_channels[0] #=> String
    #   resp.data.inputs[0].destinations #=> Array<InputDestination>
    #   resp.data.inputs[0].destinations[0] #=> Types::InputDestination
    #   resp.data.inputs[0].destinations[0].ip #=> String
    #   resp.data.inputs[0].destinations[0].port #=> String
    #   resp.data.inputs[0].destinations[0].url #=> String
    #   resp.data.inputs[0].destinations[0].vpc #=> Types::InputDestinationVpc
    #   resp.data.inputs[0].destinations[0].vpc.availability_zone #=> String
    #   resp.data.inputs[0].destinations[0].vpc.network_interface_id #=> String
    #   resp.data.inputs[0].id #=> String
    #   resp.data.inputs[0].input_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.inputs[0].input_devices #=> Array<InputDeviceSettings>
    #   resp.data.inputs[0].input_devices[0] #=> Types::InputDeviceSettings
    #   resp.data.inputs[0].input_devices[0].id #=> String
    #   resp.data.inputs[0].input_partner_ids #=> Array<String>
    #   resp.data.inputs[0].input_source_type #=> String, one of ["STATIC", "DYNAMIC"]
    #   resp.data.inputs[0].media_connect_flows #=> Array<MediaConnectFlow>
    #   resp.data.inputs[0].media_connect_flows[0] #=> Types::MediaConnectFlow
    #   resp.data.inputs[0].media_connect_flows[0].flow_arn #=> String
    #   resp.data.inputs[0].name #=> String
    #   resp.data.inputs[0].role_arn #=> String
    #   resp.data.inputs[0].security_groups #=> Array<String>
    #   resp.data.inputs[0].sources #=> Array<InputSource>
    #   resp.data.inputs[0].sources[0] #=> Types::InputSource
    #   resp.data.inputs[0].sources[0].password_param #=> String
    #   resp.data.inputs[0].sources[0].url #=> String
    #   resp.data.inputs[0].sources[0].username #=> String
    #   resp.data.inputs[0].state #=> String, one of ["CREATING", "DETACHED", "ATTACHED", "DELETING", "DELETED"]
    #   resp.data.inputs[0].tags #=> Hash<String, String>
    #   resp.data.inputs[0].tags['key'] #=> String
    #   resp.data.inputs[0].type #=> String, one of ["UDP_PUSH", "RTP_PUSH", "RTMP_PUSH", "RTMP_PULL", "URL_PULL", "MP4_FILE", "MEDIACONNECT", "INPUT_DEVICE", "AWS_CDI", "TS_FILE"]
    #   resp.data.next_token #=> String
    #
    def list_inputs(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListInputsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListInputsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListInputs
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::ListInputs
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListInputs,
        stubs: @stubs,
        params_class: Params::ListInputsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_inputs
        )
      )
      raise resp.error if resp.error
      resp
    end

    # List the programs that currently exist for a specific multiplex.
    #
    # @param [Hash] params
    #   See {Types::ListMultiplexProgramsInput}.
    #
    # @option params [Integer] :max_results
    #   The maximum number of items to return.
    #
    # @option params [String] :multiplex_id
    #   The ID of the multiplex that the programs belong to.
    #
    # @option params [String] :next_token
    #   The token to retrieve the next page of results.
    #
    # @return [Types::ListMultiplexProgramsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_multiplex_programs(
    #     max_results: 1,
    #     multiplex_id: 'MultiplexId', # required
    #     next_token: 'NextToken'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListMultiplexProgramsOutput
    #   resp.data.multiplex_programs #=> Array<MultiplexProgramSummary>
    #   resp.data.multiplex_programs[0] #=> Types::MultiplexProgramSummary
    #   resp.data.multiplex_programs[0].channel_id #=> String
    #   resp.data.multiplex_programs[0].program_name #=> String
    #   resp.data.next_token #=> String
    #
    def list_multiplex_programs(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListMultiplexProgramsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListMultiplexProgramsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListMultiplexPrograms
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::ListMultiplexPrograms
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListMultiplexPrograms,
        stubs: @stubs,
        params_class: Params::ListMultiplexProgramsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_multiplex_programs
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Retrieve a list of the existing multiplexes.
    #
    # @param [Hash] params
    #   See {Types::ListMultiplexesInput}.
    #
    # @option params [Integer] :max_results
    #   The maximum number of items to return.
    #
    # @option params [String] :next_token
    #   The token to retrieve the next page of results.
    #
    # @return [Types::ListMultiplexesOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_multiplexes(
    #     max_results: 1,
    #     next_token: 'NextToken'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListMultiplexesOutput
    #   resp.data.multiplexes #=> Array<MultiplexSummary>
    #   resp.data.multiplexes[0] #=> Types::MultiplexSummary
    #   resp.data.multiplexes[0].arn #=> String
    #   resp.data.multiplexes[0].availability_zones #=> Array<String>
    #   resp.data.multiplexes[0].availability_zones[0] #=> String
    #   resp.data.multiplexes[0].id #=> String
    #   resp.data.multiplexes[0].multiplex_settings #=> Types::MultiplexSettingsSummary
    #   resp.data.multiplexes[0].multiplex_settings.transport_stream_bitrate #=> Integer
    #   resp.data.multiplexes[0].name #=> String
    #   resp.data.multiplexes[0].pipelines_running_count #=> Integer
    #   resp.data.multiplexes[0].program_count #=> Integer
    #   resp.data.multiplexes[0].state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED"]
    #   resp.data.multiplexes[0].tags #=> Hash<String, String>
    #   resp.data.multiplexes[0].tags['key'] #=> String
    #   resp.data.next_token #=> String
    #
    def list_multiplexes(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListMultiplexesInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListMultiplexesInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListMultiplexes
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::ListMultiplexes
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListMultiplexes,
        stubs: @stubs,
        params_class: Params::ListMultiplexesOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_multiplexes
        )
      )
      raise resp.error if resp.error
      resp
    end

    # List offerings available for purchase.
    #
    # @param [Hash] params
    #   See {Types::ListOfferingsInput}.
    #
    # @option params [String] :channel_class
    #   Filter by channel class, 'STANDARD' or 'SINGLE_PIPELINE'
    #
    # @option params [String] :channel_configuration
    #   Filter to offerings that match the configuration of an existing channel, e.g. '2345678' (a channel ID)
    #
    # @option params [String] :codec
    #   Filter by codec, 'AVC', 'HEVC', 'MPEG2', 'AUDIO', or 'LINK'
    #
    # @option params [String] :duration
    #   Filter by offering duration, e.g. '12'
    #
    # @option params [Integer] :max_results
    #   Placeholder documentation for MaxResults
    #
    # @option params [String] :maximum_bitrate
    #   Filter by bitrate, 'MAX_10_MBPS', 'MAX_20_MBPS', or 'MAX_50_MBPS'
    #
    # @option params [String] :maximum_framerate
    #   Filter by framerate, 'MAX_30_FPS' or 'MAX_60_FPS'
    #
    # @option params [String] :next_token
    #   Placeholder documentation for __string
    #
    # @option params [String] :resolution
    #   Filter by resolution, 'SD', 'HD', 'FHD', or 'UHD'
    #
    # @option params [String] :resource_type
    #   Filter by resource type, 'INPUT', 'OUTPUT', 'MULTIPLEX', or 'CHANNEL'
    #
    # @option params [String] :special_feature
    #   Filter by special feature, 'ADVANCED_AUDIO' or 'AUDIO_NORMALIZATION'
    #
    # @option params [String] :video_quality
    #   Filter by video quality, 'STANDARD', 'ENHANCED', or 'PREMIUM'
    #
    # @return [Types::ListOfferingsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_offerings(
    #     channel_class: 'ChannelClass',
    #     channel_configuration: 'ChannelConfiguration',
    #     codec: 'Codec',
    #     duration: 'Duration',
    #     max_results: 1,
    #     maximum_bitrate: 'MaximumBitrate',
    #     maximum_framerate: 'MaximumFramerate',
    #     next_token: 'NextToken',
    #     resolution: 'Resolution',
    #     resource_type: 'ResourceType',
    #     special_feature: 'SpecialFeature',
    #     video_quality: 'VideoQuality'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListOfferingsOutput
    #   resp.data.next_token #=> String
    #   resp.data.offerings #=> Array<Offering>
    #   resp.data.offerings[0] #=> Types::Offering
    #   resp.data.offerings[0].arn #=> String
    #   resp.data.offerings[0].currency_code #=> String
    #   resp.data.offerings[0].duration #=> Integer
    #   resp.data.offerings[0].duration_units #=> String, one of ["MONTHS"]
    #   resp.data.offerings[0].fixed_price #=> Float
    #   resp.data.offerings[0].offering_description #=> String
    #   resp.data.offerings[0].offering_id #=> String
    #   resp.data.offerings[0].offering_type #=> String, one of ["NO_UPFRONT"]
    #   resp.data.offerings[0].region #=> String
    #   resp.data.offerings[0].resource_specification #=> Types::ReservationResourceSpecification
    #   resp.data.offerings[0].resource_specification.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.offerings[0].resource_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC", "AUDIO", "LINK"]
    #   resp.data.offerings[0].resource_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.offerings[0].resource_specification.maximum_framerate #=> String, one of ["MAX_30_FPS", "MAX_60_FPS"]
    #   resp.data.offerings[0].resource_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.offerings[0].resource_specification.resource_type #=> String, one of ["INPUT", "OUTPUT", "MULTIPLEX", "CHANNEL"]
    #   resp.data.offerings[0].resource_specification.special_feature #=> String, one of ["ADVANCED_AUDIO", "AUDIO_NORMALIZATION", "MGHD", "MGUHD"]
    #   resp.data.offerings[0].resource_specification.video_quality #=> String, one of ["STANDARD", "ENHANCED", "PREMIUM"]
    #   resp.data.offerings[0].usage_price #=> Float
    #
    def list_offerings(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListOfferingsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListOfferingsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListOfferings
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::ListOfferings
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListOfferings,
        stubs: @stubs,
        params_class: Params::ListOfferingsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_offerings
        )
      )
      raise resp.error if resp.error
      resp
    end

    # List purchased reservations.
    #
    # @param [Hash] params
    #   See {Types::ListReservationsInput}.
    #
    # @option params [String] :channel_class
    #   Filter by channel class, 'STANDARD' or 'SINGLE_PIPELINE'
    #
    # @option params [String] :codec
    #   Filter by codec, 'AVC', 'HEVC', 'MPEG2', 'AUDIO', or 'LINK'
    #
    # @option params [Integer] :max_results
    #   Placeholder documentation for MaxResults
    #
    # @option params [String] :maximum_bitrate
    #   Filter by bitrate, 'MAX_10_MBPS', 'MAX_20_MBPS', or 'MAX_50_MBPS'
    #
    # @option params [String] :maximum_framerate
    #   Filter by framerate, 'MAX_30_FPS' or 'MAX_60_FPS'
    #
    # @option params [String] :next_token
    #   Placeholder documentation for __string
    #
    # @option params [String] :resolution
    #   Filter by resolution, 'SD', 'HD', 'FHD', or 'UHD'
    #
    # @option params [String] :resource_type
    #   Filter by resource type, 'INPUT', 'OUTPUT', 'MULTIPLEX', or 'CHANNEL'
    #
    # @option params [String] :special_feature
    #   Filter by special feature, 'ADVANCED_AUDIO' or 'AUDIO_NORMALIZATION'
    #
    # @option params [String] :video_quality
    #   Filter by video quality, 'STANDARD', 'ENHANCED', or 'PREMIUM'
    #
    # @return [Types::ListReservationsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_reservations(
    #     channel_class: 'ChannelClass',
    #     codec: 'Codec',
    #     max_results: 1,
    #     maximum_bitrate: 'MaximumBitrate',
    #     maximum_framerate: 'MaximumFramerate',
    #     next_token: 'NextToken',
    #     resolution: 'Resolution',
    #     resource_type: 'ResourceType',
    #     special_feature: 'SpecialFeature',
    #     video_quality: 'VideoQuality'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListReservationsOutput
    #   resp.data.next_token #=> String
    #   resp.data.reservations #=> Array<Reservation>
    #   resp.data.reservations[0] #=> Types::Reservation
    #   resp.data.reservations[0].arn #=> String
    #   resp.data.reservations[0].count #=> Integer
    #   resp.data.reservations[0].currency_code #=> String
    #   resp.data.reservations[0].duration #=> Integer
    #   resp.data.reservations[0].duration_units #=> String, one of ["MONTHS"]
    #   resp.data.reservations[0].end #=> String
    #   resp.data.reservations[0].fixed_price #=> Float
    #   resp.data.reservations[0].name #=> String
    #   resp.data.reservations[0].offering_description #=> String
    #   resp.data.reservations[0].offering_id #=> String
    #   resp.data.reservations[0].offering_type #=> String, one of ["NO_UPFRONT"]
    #   resp.data.reservations[0].region #=> String
    #   resp.data.reservations[0].reservation_id #=> String
    #   resp.data.reservations[0].resource_specification #=> Types::ReservationResourceSpecification
    #   resp.data.reservations[0].resource_specification.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.reservations[0].resource_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC", "AUDIO", "LINK"]
    #   resp.data.reservations[0].resource_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.reservations[0].resource_specification.maximum_framerate #=> String, one of ["MAX_30_FPS", "MAX_60_FPS"]
    #   resp.data.reservations[0].resource_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.reservations[0].resource_specification.resource_type #=> String, one of ["INPUT", "OUTPUT", "MULTIPLEX", "CHANNEL"]
    #   resp.data.reservations[0].resource_specification.special_feature #=> String, one of ["ADVANCED_AUDIO", "AUDIO_NORMALIZATION", "MGHD", "MGUHD"]
    #   resp.data.reservations[0].resource_specification.video_quality #=> String, one of ["STANDARD", "ENHANCED", "PREMIUM"]
    #   resp.data.reservations[0].start #=> String
    #   resp.data.reservations[0].state #=> String, one of ["ACTIVE", "EXPIRED", "CANCELED", "DELETED"]
    #   resp.data.reservations[0].tags #=> Hash<String, String>
    #   resp.data.reservations[0].tags['key'] #=> String
    #   resp.data.reservations[0].usage_price #=> Float
    #
    def list_reservations(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListReservationsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListReservationsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListReservations
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::ListReservations
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListReservations,
        stubs: @stubs,
        params_class: Params::ListReservationsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_reservations
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Produces list of tags that have been created for a resource
    #
    # @param [Hash] params
    #   See {Types::ListTagsForResourceInput}.
    #
    # @option params [String] :resource_arn
    #   Placeholder documentation for __string
    #
    # @return [Types::ListTagsForResourceOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.list_tags_for_resource(
    #     resource_arn: 'ResourceArn' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::ListTagsForResourceOutput
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #
    def list_tags_for_resource(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::ListTagsForResourceInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::ListTagsForResourceInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::ListTagsForResource
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::NotFoundException]),
        data_parser: Parsers::ListTagsForResource
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::ListTagsForResource,
        stubs: @stubs,
        params_class: Params::ListTagsForResourceOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :list_tags_for_resource
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Purchase an offering and create a reservation.
    #
    # @param [Hash] params
    #   See {Types::PurchaseOfferingInput}.
    #
    # @option params [Integer] :count
    #   Number of resources
    #
    # @option params [String] :name
    #   Name for the new reservation
    #
    # @option params [String] :offering_id
    #   Offering to purchase, e.g. '87654321'
    #
    # @option params [String] :request_id
    #   Unique request ID to be specified. This is needed to prevent retries from creating multiple resources.
    #
    # @option params [String] :start
    #   Requested reservation start time (UTC) in ISO-8601 format. The specified time must be between the first day of the current month and one year from now. If no value is given, the default is now.
    #
    # @option params [Hash<String, String>] :tags
    #   A collection of key-value pairs
    #
    # @return [Types::PurchaseOfferingOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.purchase_offering(
    #     count: 1, # required
    #     name: 'Name',
    #     offering_id: 'OfferingId', # required
    #     request_id: 'RequestId',
    #     start: 'Start',
    #     tags: {
    #       'key' => 'value'
    #     }
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::PurchaseOfferingOutput
    #   resp.data.reservation #=> Types::Reservation
    #   resp.data.reservation.arn #=> String
    #   resp.data.reservation.count #=> Integer
    #   resp.data.reservation.currency_code #=> String
    #   resp.data.reservation.duration #=> Integer
    #   resp.data.reservation.duration_units #=> String, one of ["MONTHS"]
    #   resp.data.reservation.end #=> String
    #   resp.data.reservation.fixed_price #=> Float
    #   resp.data.reservation.name #=> String
    #   resp.data.reservation.offering_description #=> String
    #   resp.data.reservation.offering_id #=> String
    #   resp.data.reservation.offering_type #=> String, one of ["NO_UPFRONT"]
    #   resp.data.reservation.region #=> String
    #   resp.data.reservation.reservation_id #=> String
    #   resp.data.reservation.resource_specification #=> Types::ReservationResourceSpecification
    #   resp.data.reservation.resource_specification.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.reservation.resource_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC", "AUDIO", "LINK"]
    #   resp.data.reservation.resource_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.reservation.resource_specification.maximum_framerate #=> String, one of ["MAX_30_FPS", "MAX_60_FPS"]
    #   resp.data.reservation.resource_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.reservation.resource_specification.resource_type #=> String, one of ["INPUT", "OUTPUT", "MULTIPLEX", "CHANNEL"]
    #   resp.data.reservation.resource_specification.special_feature #=> String, one of ["ADVANCED_AUDIO", "AUDIO_NORMALIZATION", "MGHD", "MGUHD"]
    #   resp.data.reservation.resource_specification.video_quality #=> String, one of ["STANDARD", "ENHANCED", "PREMIUM"]
    #   resp.data.reservation.start #=> String
    #   resp.data.reservation.state #=> String, one of ["ACTIVE", "EXPIRED", "CANCELED", "DELETED"]
    #   resp.data.reservation.tags #=> Hash<String, String>
    #   resp.data.reservation.tags['key'] #=> String
    #   resp.data.reservation.usage_price #=> Float
    #
    def purchase_offering(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::PurchaseOfferingInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::PurchaseOfferingInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::PurchaseOffering
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 201, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::PurchaseOffering
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::PurchaseOffering,
        stubs: @stubs,
        params_class: Params::PurchaseOfferingOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :purchase_offering
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Reject the transfer of the specified input device to your AWS account.
    #
    # @param [Hash] params
    #   See {Types::RejectInputDeviceTransferInput}.
    #
    # @option params [String] :input_device_id
    #   The unique ID of the input device to reject. For example, hd-123456789abcdef.
    #
    # @return [Types::RejectInputDeviceTransferOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.reject_input_device_transfer(
    #     input_device_id: 'InputDeviceId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::RejectInputDeviceTransferOutput
    #
    def reject_input_device_transfer(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::RejectInputDeviceTransferInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::RejectInputDeviceTransferInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::RejectInputDeviceTransfer
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::RejectInputDeviceTransfer
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::RejectInputDeviceTransfer,
        stubs: @stubs,
        params_class: Params::RejectInputDeviceTransferOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :reject_input_device_transfer
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Starts an existing channel
    #
    # @param [Hash] params
    #   See {Types::StartChannelInput}.
    #
    # @option params [String] :channel_id
    #   A request to start a channel
    #
    # @return [Types::StartChannelOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.start_channel(
    #     channel_id: 'ChannelId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::StartChannelOutput
    #   resp.data.arn #=> String
    #   resp.data.cdi_input_specification #=> Types::CdiInputSpecification
    #   resp.data.cdi_input_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.destinations #=> Array<OutputDestination>
    #   resp.data.destinations[0] #=> Types::OutputDestination
    #   resp.data.destinations[0].id #=> String
    #   resp.data.destinations[0].media_package_settings #=> Array<MediaPackageOutputDestinationSettings>
    #   resp.data.destinations[0].media_package_settings[0] #=> Types::MediaPackageOutputDestinationSettings
    #   resp.data.destinations[0].media_package_settings[0].channel_id #=> String
    #   resp.data.destinations[0].multiplex_settings #=> Types::MultiplexProgramChannelDestinationSettings
    #   resp.data.destinations[0].multiplex_settings.multiplex_id #=> String
    #   resp.data.destinations[0].multiplex_settings.program_name #=> String
    #   resp.data.destinations[0].settings #=> Array<OutputDestinationSettings>
    #   resp.data.destinations[0].settings[0] #=> Types::OutputDestinationSettings
    #   resp.data.destinations[0].settings[0].password_param #=> String
    #   resp.data.destinations[0].settings[0].stream_name #=> String
    #   resp.data.destinations[0].settings[0].url #=> String
    #   resp.data.destinations[0].settings[0].username #=> String
    #   resp.data.egress_endpoints #=> Array<ChannelEgressEndpoint>
    #   resp.data.egress_endpoints[0] #=> Types::ChannelEgressEndpoint
    #   resp.data.egress_endpoints[0].source_ip #=> String
    #   resp.data.encoder_settings #=> Types::EncoderSettings
    #   resp.data.encoder_settings.audio_descriptions #=> Array<AudioDescription>
    #   resp.data.encoder_settings.audio_descriptions[0] #=> Types::AudioDescription
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings #=> Types::AudioNormalizationSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm #=> String, one of ["ITU_1770_1", "ITU_1770_2"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm_control #=> String, one of ["CORRECT_AUDIO"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.target_lkfs #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].audio_selector_name #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_type #=> String, one of ["CLEAN_EFFECTS", "HEARING_IMPAIRED", "UNDEFINED", "VISUAL_IMPAIRED_COMMENTARY"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_type_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings #=> Types::AudioWatermarkSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings #=> Types::NielsenWatermarksSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings #=> Types::NielsenCBET
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_check_digit_string #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_stepaside #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.csid #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_distribution_type #=> String, one of ["FINAL_DISTRIBUTOR", "PROGRAM_CONTENT"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings #=> Types::NielsenNaesIiNw
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.check_digit_string #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.sid #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings #=> Types::AudioCodecSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings #=> Types::AacSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.coding_mode #=> String, one of ["AD_RECEIVER_MIX", "CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_5_1"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.input_type #=> String, one of ["BROADCASTER_MIXED_AD", "NORMAL"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.profile #=> String, one of ["HEV1", "HEV2", "LC"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.rate_control_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.raw_format #=> String, one of ["LATM_LOAS", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.spec #=> String, one of ["MPEG2", "MPEG4"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.vbr_quality #=> String, one of ["HIGH", "LOW", "MEDIUM_HIGH", "MEDIUM_LOW"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings #=> Types::Ac3Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "DIALOGUE", "EMERGENCY", "HEARING_IMPAIRED", "MUSIC_AND_EFFECTS", "VISUALLY_IMPAIRED", "VOICE_OVER"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_3_2_LFE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.dialnorm #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.drc_profile #=> String, one of ["FILM_STANDARD", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings #=> Types::Eac3Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.attenuation_control #=> String, one of ["ATTENUATE_3_DB", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "EMERGENCY", "HEARING_IMPAIRED", "VISUALLY_IMPAIRED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_3_2"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dc_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dialnorm #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_line #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_rf #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_control #=> String, one of ["LFE", "NO_LFE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_center_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_surround_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_center_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_surround_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.passthrough_control #=> String, one of ["NO_PASSTHROUGH", "WHEN_POSSIBLE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.phase_control #=> String, one of ["NO_SHIFT", "SHIFT_90_DEGREES"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.stereo_downmix #=> String, one of ["DPL2", "LO_RO", "LT_RT", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_ex_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings #=> Types::Mp2Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.pass_through_settings #=> Types::PassThroughSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings #=> Types::WavSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.bit_depth #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_4_0", "CODING_MODE_8_0"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].language_code #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].language_code_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].name #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings #=> Types::RemixSettings
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings #=> Array<AudioChannelMapping>
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0] #=> Types::AudioChannelMapping
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels #=> Array<InputChannelLevel>
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0] #=> Types::InputChannelLevel
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].gain #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].input_channel #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].output_channel #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channels_in #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channels_out #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].stream_name #=> String
    #   resp.data.encoder_settings.avail_blanking #=> Types::AvailBlanking
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image #=> Types::InputLocation
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.password_param #=> String
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.uri #=> String
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.username #=> String
    #   resp.data.encoder_settings.avail_blanking.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.avail_configuration #=> Types::AvailConfiguration
    #   resp.data.encoder_settings.avail_configuration.avail_settings #=> Types::AvailSettings
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert #=> Types::Scte35SpliceInsert
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.ad_avail_offset #=> Integer
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos #=> Types::Scte35TimeSignalApos
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.ad_avail_offset #=> Integer
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.blackout_slate #=> Types::BlackoutSlate
    #   resp.data.encoder_settings.blackout_slate.blackout_slate_image #=> Types::InputLocation
    #   resp.data.encoder_settings.blackout_slate.network_end_blackout #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.blackout_slate.network_end_blackout_image #=> Types::InputLocation
    #   resp.data.encoder_settings.blackout_slate.network_id #=> String
    #   resp.data.encoder_settings.blackout_slate.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.caption_descriptions #=> Array<CaptionDescription>
    #   resp.data.encoder_settings.caption_descriptions[0] #=> Types::CaptionDescription
    #   resp.data.encoder_settings.caption_descriptions[0].caption_selector_name #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings #=> Types::CaptionDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.arib_destination_settings #=> Types::AribDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings #=> Types::BurnInDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font #=> Types::InputLocation
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_resolution #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_size #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_size #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.x_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.y_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings #=> Types::DvbSubDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font #=> Types::InputLocation
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_resolution #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_size #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_size #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.x_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.y_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings #=> Types::EbuTtDDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.copyright_holder #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.fill_line_gap #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.font_family #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.style_control #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.embedded_destination_settings #=> Types::EmbeddedDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.embedded_plus_scte20_destination_settings #=> Types::EmbeddedPlusScte20DestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.rtmp_caption_info_destination_settings #=> Types::RtmpCaptionInfoDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.scte20_plus_embedded_destination_settings #=> Types::Scte20PlusEmbeddedDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.scte27_destination_settings #=> Types::Scte27DestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.smpte_tt_destination_settings #=> Types::SmpteTtDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.teletext_destination_settings #=> Types::TeletextDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings #=> Types::TtmlDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings.style_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings #=> Types::WebvttDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings.style_control #=> String, one of ["NO_STYLE_DATA", "PASSTHROUGH"]
    #   resp.data.encoder_settings.caption_descriptions[0].language_code #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].language_description #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].name #=> String
    #   resp.data.encoder_settings.feature_activations #=> Types::FeatureActivations
    #   resp.data.encoder_settings.feature_activations.input_prepare_schedule_actions #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.global_configuration #=> Types::GlobalConfiguration
    #   resp.data.encoder_settings.global_configuration.initial_audio_gain #=> Integer
    #   resp.data.encoder_settings.global_configuration.input_end_action #=> String, one of ["NONE", "SWITCH_AND_LOOP_INPUTS"]
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior #=> Types::InputLossBehavior
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.black_frame_msec #=> Integer
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_color #=> String
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_slate #=> Types::InputLocation
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_type #=> String, one of ["COLOR", "SLATE"]
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.repeat_frame_msec #=> Integer
    #   resp.data.encoder_settings.global_configuration.output_locking_mode #=> String, one of ["EPOCH_LOCKING", "PIPELINE_LOCKING"]
    #   resp.data.encoder_settings.global_configuration.output_timing_source #=> String, one of ["INPUT_CLOCK", "SYSTEM_CLOCK"]
    #   resp.data.encoder_settings.global_configuration.support_low_framerate_inputs #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.motion_graphics_configuration #=> Types::MotionGraphicsConfiguration
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_insertion #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_settings #=> Types::MotionGraphicsSettings
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_settings.html_motion_graphics_settings #=> Types::HtmlMotionGraphicsSettings
    #   resp.data.encoder_settings.nielsen_configuration #=> Types::NielsenConfiguration
    #   resp.data.encoder_settings.nielsen_configuration.distributor_id #=> String
    #   resp.data.encoder_settings.nielsen_configuration.nielsen_pcm_to_id3_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups #=> Array<OutputGroup>
    #   resp.data.encoder_settings.output_groups[0] #=> Types::OutputGroup
    #   resp.data.encoder_settings.output_groups[0].name #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings #=> Types::OutputGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings #=> Types::ArchiveGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings #=> Types::ArchiveCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings #=> Types::ArchiveS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination.destination_ref_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.rollover_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings #=> Types::FrameCaptureGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings #=> Types::FrameCaptureCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings #=> Types::FrameCaptureS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings #=> Types::HlsGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers[0] #=> String, one of ["ADOBE", "ELEMENTAL", "ELEMENTAL_SCTE35"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content1 #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest1 #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings #=> Array<CaptionLanguageMapping>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0] #=> Types::CaptionLanguageMapping
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].caption_channel #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_code #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_description #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_setting #=> String, one of ["INSERT", "NONE", "OMIT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.client_cache #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.codec_specification #=> String, one of ["RFC_4281", "RFC_6381"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.constant_iv #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.directory_structure #=> String, one of ["SINGLE_DIRECTORY", "SUBDIRECTORY_PER_STREAM"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.discontinuity_tags #=> String, one of ["INSERT", "NEVER_INSERT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.encryption_type #=> String, one of ["AES128", "SAMPLE_AES"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings #=> Types::HlsCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings #=> Types::HlsAkamaiSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.salt #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.token #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings #=> Types::HlsBasicPutSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings #=> Types::HlsMediaStoreSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.media_store_storage_class #=> String, one of ["TEMPORAL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings #=> Types::HlsS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings #=> Types::HlsWebdavSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_id3_segment_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.i_frame_only_playlists #=> String, one of ["DISABLED", "STANDARD"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.incomplete_segment_behavior #=> String, one of ["AUTO", "SUPPRESS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.index_n_segments #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_in_manifest #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_source #=> String, one of ["EXPLICIT", "FOLLOWS_SEGMENT_NUMBER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.keep_segments #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format_versions #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings #=> Types::KeyProviderSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings #=> Types::StaticKeySettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.key_provider_server #=> Types::InputLocation
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.static_key_value #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_compression #=> String, one of ["GZIP", "NONE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_duration_format #=> String, one of ["FLOATING_POINT", "INTEGER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.min_segment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.mode #=> String, one of ["LIVE", "VOD"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.output_selection #=> String, one of ["MANIFESTS_AND_SEGMENTS", "SEGMENTS_ONLY", "VARIANT_MANIFESTS_AND_SEGMENTS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_clock #=> String, one of ["INITIALIZE_FROM_OUTPUT_TIMECODE", "SYSTEM_CLOCK"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.redundant_manifest #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segments_per_subdirectory #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.stream_inf_resolution #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timestamp_delta_milliseconds #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ts_file_mode #=> String, one of ["SEGMENTED_FILES", "SINGLE_FILE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings #=> Types::MediaPackageGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings #=> Types::MsSmoothGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.acquisition_point_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.audio_only_timecode_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED_CLOCK"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id_mode #=> String, one of ["NO_EVENT_ID", "USE_CONFIGURED", "USE_TIMESTAMP"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_stop_behavior #=> String, one of ["NONE", "SEND_EOS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.fragment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.send_delay_ms #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.sparse_track_type #=> String, one of ["NONE", "SCTE_35", "SCTE_35_WITHOUT_SEGMENTATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.stream_manifest_behavior #=> String, one of ["DO_NOT_SEND", "SEND"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset_mode #=> String, one of ["USE_CONFIGURED_OFFSET", "USE_EVENT_START_DATE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.multiplex_group_settings #=> Types::MultiplexGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings #=> Types::RtmpGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers[0] #=> String, one of ["ON_CUE_POINT_SCTE35"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.authentication_scheme #=> String, one of ["AKAMAI", "COMMON"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_full_behavior #=> String, one of ["DISCONNECT_IMMEDIATELY", "WAIT_FOR_SERVER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.caption_data #=> String, one of ["ALL", "FIELD1_608", "FIELD1_AND_FIELD2_608"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings #=> Types::UdpGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.input_loss_action #=> String, one of ["DROP_PROGRAM", "DROP_TS", "EMIT_PROGRAM"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs #=> Array<Output>
    #   resp.data.encoder_settings.output_groups[0].outputs[0] #=> Types::Output
    #   resp.data.encoder_settings.output_groups[0].outputs[0].audio_description_names #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].outputs[0].audio_description_names[0] #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].caption_description_names #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings #=> Types::OutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings #=> Types::ArchiveOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings #=> Types::ArchiveContainerSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.absent_input_audio_behavior #=> String, one of ["DROP", "ENCODE_SILENCE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid_control #=> String, one of ["AUTO", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_buffer_model #=> String, one of ["ATSC", "DVB"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_frames_per_pes #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_stream_type #=> String, one of ["ATSC", "DVB"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.buffer_model #=> String, one of ["MULTIPLEX", "NONE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.cc_descriptor #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings #=> Types::DvbNitSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings #=> Types::DvbSdtSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.output_sdt #=> String, one of ["SDT_FOLLOW", "SDT_FOLLOW_IF_PRESENT", "SDT_MANUAL", "SDT_NONE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_provider_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sub_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings #=> Types::DvbTdtSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_teletext_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebif #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_audio_interval #=> String, one of ["VIDEO_AND_FIXED_INTERVALS", "VIDEO_INTERVAL"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_lookahead_ms #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_placement #=> String, one of ["VIDEO_AND_AUDIO_PIDS", "VIDEO_PID"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ecm_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.es_rate_in_pes #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_platform_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_signal_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.fragment_time #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv_data_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.null_packet_bitrate #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pat_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.program_num #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.rate_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte27_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_control #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_markers #=> String, one of ["EBP", "EBP_LEGACY", "NONE", "PSI_SEGSTART", "RAI_ADAPT", "RAI_SEGSTART"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_style #=> String, one of ["MAINTAIN_CADENCE", "RESET_CADENCE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_time #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.transport_stream_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.video_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.raw_settings #=> Types::RawSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.extension #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings #=> Types::FrameCaptureOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings #=> Types::HlsOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings #=> Types::HlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings #=> Types::AudioOnlyHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_group_id #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_only_image #=> Types::InputLocation
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_track_type #=> String, one of ["ALTERNATE_AUDIO_AUTO_SELECT", "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT", "ALTERNATE_AUDIO_NOT_AUTO_SELECT", "AUDIO_ONLY_VARIANT_STREAM"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.segment_type #=> String, one of ["AAC", "FMP4"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings #=> Types::Fmp4HlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.audio_rendition_sets #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.frame_capture_hls_settings #=> Types::FrameCaptureHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings #=> Types::StandardHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.audio_rendition_sets #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings #=> Types::M3u8Settings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_frames_per_pes #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.ecm_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pat_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.program_num #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.transport_stream_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.video_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.segment_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.media_package_output_settings #=> Types::MediaPackageOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings #=> Types::MsSmoothOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings #=> Types::MultiplexOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings #=> Types::RtmpOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings #=> Types::UdpOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.buffer_msec #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings #=> Types::UdpContainerSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings #=> Types::FecOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.column_depth #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.include_fec #=> String, one of ["COLUMN", "COLUMN_AND_ROW"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.row_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].video_description_name #=> String
    #   resp.data.encoder_settings.timecode_config #=> Types::TimecodeConfig
    #   resp.data.encoder_settings.timecode_config.source #=> String, one of ["EMBEDDED", "SYSTEMCLOCK", "ZEROBASED"]
    #   resp.data.encoder_settings.timecode_config.sync_threshold #=> Integer
    #   resp.data.encoder_settings.video_descriptions #=> Array<VideoDescription>
    #   resp.data.encoder_settings.video_descriptions[0] #=> Types::VideoDescription
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings #=> Types::VideoCodecSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings #=> Types::FrameCaptureSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval_units #=> String, one of ["MILLISECONDS", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings #=> Types::H264Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_fill_pct #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_size #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings #=> Types::H264ColorSpaceSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.entropy_encoding #=> String, one of ["CABAC", "CAVLC"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings #=> Types::H264FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.post_filter_sharpening #=> String, one of ["AUTO", "DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.strength #=> String, one of ["AUTO", "STRENGTH_1", "STRENGTH_2", "STRENGTH_3", "STRENGTH_4", "STRENGTH_5", "STRENGTH_6", "STRENGTH_7", "STRENGTH_8", "STRENGTH_9", "STRENGTH_10", "STRENGTH_11", "STRENGTH_12", "STRENGTH_13", "STRENGTH_14", "STRENGTH_15", "STRENGTH_16"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.force_field_pictures #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_b_reference #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_num_b_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.level #=> String, one of ["H264_LEVEL_1", "H264_LEVEL_1_1", "H264_LEVEL_1_2", "H264_LEVEL_1_3", "H264_LEVEL_2", "H264_LEVEL_2_1", "H264_LEVEL_2_2", "H264_LEVEL_3", "H264_LEVEL_3_1", "H264_LEVEL_3_2", "H264_LEVEL_4", "H264_LEVEL_4_1", "H264_LEVEL_4_2", "H264_LEVEL_5", "H264_LEVEL_5_1", "H264_LEVEL_5_2", "H264_LEVEL_AUTO"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.max_bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.min_i_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.num_ref_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.profile #=> String, one of ["BASELINE", "HIGH", "HIGH_10BIT", "HIGH_422", "HIGH_422_10BIT", "MAIN"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.quality_level #=> String, one of ["ENHANCED_QUALITY", "STANDARD_QUALITY"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.qvbr_quality_level #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR", "VBR"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.slices #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.softness #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.spatial_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.syntax #=> String, one of ["DEFAULT", "RP2027"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.temporal_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings #=> Types::H265Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.alternative_transfer_function #=> String, one of ["INSERT", "OMIT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.buf_size #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings #=> Types::H265ColorSpaceSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_cll #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_fall #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings #=> Types::H265FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.level #=> String, one of ["H265_LEVEL_1", "H265_LEVEL_2", "H265_LEVEL_2_1", "H265_LEVEL_3", "H265_LEVEL_3_1", "H265_LEVEL_4", "H265_LEVEL_4_1", "H265_LEVEL_5", "H265_LEVEL_5_1", "H265_LEVEL_5_2", "H265_LEVEL_6", "H265_LEVEL_6_1", "H265_LEVEL_6_2", "H265_LEVEL_AUTO"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.max_bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.min_i_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.profile #=> String, one of ["MAIN", "MAIN_10BIT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.qvbr_quality_level #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.slices #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.tier #=> String, one of ["HIGH", "MAIN"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings #=> Types::Mpeg2Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "LOW", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_space #=> String, one of ["AUTO", "PASSTHROUGH"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.display_aspect_ratio #=> String, one of ["DISPLAYRATIO16X9", "DISPLAYRATIO4X3"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings #=> Types::Mpeg2FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_num_b_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.timecode_insertion #=> String, one of ["DISABLED", "GOP_TIMECODE"]
    #   resp.data.encoder_settings.video_descriptions[0].height #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].name #=> String
    #   resp.data.encoder_settings.video_descriptions[0].respond_to_afd #=> String, one of ["NONE", "PASSTHROUGH", "RESPOND"]
    #   resp.data.encoder_settings.video_descriptions[0].scaling_behavior #=> String, one of ["DEFAULT", "STRETCH_TO_OUTPUT"]
    #   resp.data.encoder_settings.video_descriptions[0].sharpness #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].width #=> Integer
    #   resp.data.id #=> String
    #   resp.data.input_attachments #=> Array<InputAttachment>
    #   resp.data.input_attachments[0] #=> Types::InputAttachment
    #   resp.data.input_attachments[0].automatic_input_failover_settings #=> Types::AutomaticInputFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.error_clear_time_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions #=> Array<FailoverCondition>
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0] #=> Types::FailoverCondition
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings #=> Types::FailoverConditionSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings #=> Types::AudioSilenceFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_selector_name #=> String
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_silence_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings #=> Types::InputLossFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings.input_loss_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings #=> Types::VideoBlackFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.black_detect_threshold #=> Float
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.video_black_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.input_preference #=> String, one of ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #   resp.data.input_attachments[0].automatic_input_failover_settings.secondary_input_id #=> String
    #   resp.data.input_attachments[0].input_attachment_name #=> String
    #   resp.data.input_attachments[0].input_id #=> String
    #   resp.data.input_attachments[0].input_settings #=> Types::InputSettings
    #   resp.data.input_attachments[0].input_settings.audio_selectors #=> Array<AudioSelector>
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0] #=> Types::AudioSelector
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].name #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings #=> Types::AudioSelectorSettings
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection #=> Types::AudioHlsRenditionSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.group_id #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.name #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection #=> Types::AudioLanguageSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_code #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_selection_policy #=> String, one of ["LOOSE", "STRICT"]
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection #=> Types::AudioPidSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection #=> Types::AudioTrackSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks #=> Array<AudioTrack>
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0] #=> Types::AudioTrack
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0].track #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors #=> Array<CaptionSelector>
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0] #=> Types::CaptionSelector
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].language_code #=> String
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].name #=> String
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings #=> Types::CaptionSelectorSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings #=> Types::AncillarySourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings.source_ancillary_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.arib_source_settings #=> Types::AribSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings #=> Types::DvbSubSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings #=> Types::EmbeddedSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.scte20_detection #=> String, one of ["AUTO", "OFF"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_track_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings #=> Types::Scte20SourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.source608_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings #=> Types::Scte27SourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings #=> Types::TeletextSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle #=> Types::CaptionRectangle
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.height #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.left_offset #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.top_offset #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.width #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.page_number #=> String
    #   resp.data.input_attachments[0].input_settings.deblock_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.input_attachments[0].input_settings.denoise_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.input_attachments[0].input_settings.filter_strength #=> Integer
    #   resp.data.input_attachments[0].input_settings.input_filter #=> String, one of ["AUTO", "DISABLED", "FORCED"]
    #   resp.data.input_attachments[0].input_settings.network_input_settings #=> Types::NetworkInputSettings
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings #=> Types::HlsInputSettings
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.bandwidth #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.buffer_segments #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retries #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retry_interval #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.scte35_source #=> String, one of ["MANIFEST", "SEGMENTS"]
    #   resp.data.input_attachments[0].input_settings.network_input_settings.server_validation #=> String, one of ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #   resp.data.input_attachments[0].input_settings.scte35_pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.smpte2038_data_preference #=> String, one of ["IGNORE", "PREFER"]
    #   resp.data.input_attachments[0].input_settings.source_end_behavior #=> String, one of ["CONTINUE", "LOOP"]
    #   resp.data.input_attachments[0].input_settings.video_selector #=> Types::VideoSelector
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space #=> String, one of ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_settings #=> Types::VideoSelectorColorSpaceSettings
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_usage #=> String, one of ["FALLBACK", "FORCE"]
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings #=> Types::VideoSelectorSettings
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid #=> Types::VideoSelectorPid
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id #=> Types::VideoSelectorProgramId
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id.program_id #=> Integer
    #   resp.data.input_specification #=> Types::InputSpecification
    #   resp.data.input_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC"]
    #   resp.data.input_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.input_specification.resolution #=> String, one of ["SD", "HD", "UHD"]
    #   resp.data.log_level #=> String, one of ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #   resp.data.maintenance #=> Types::MaintenanceStatus
    #   resp.data.maintenance.maintenance_day #=> String, one of ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #   resp.data.maintenance.maintenance_deadline #=> String
    #   resp.data.maintenance.maintenance_scheduled_date #=> String
    #   resp.data.maintenance.maintenance_start_time #=> String
    #   resp.data.name #=> String
    #   resp.data.pipeline_details #=> Array<PipelineDetail>
    #   resp.data.pipeline_details[0] #=> Types::PipelineDetail
    #   resp.data.pipeline_details[0].active_input_attachment_name #=> String
    #   resp.data.pipeline_details[0].active_input_switch_action_name #=> String
    #   resp.data.pipeline_details[0].active_motion_graphics_action_name #=> String
    #   resp.data.pipeline_details[0].active_motion_graphics_uri #=> String
    #   resp.data.pipeline_details[0].pipeline_id #=> String
    #   resp.data.pipelines_running_count #=> Integer
    #   resp.data.role_arn #=> String
    #   resp.data.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED", "UPDATING", "UPDATE_FAILED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #   resp.data.vpc #=> Types::VpcOutputSettingsDescription
    #   resp.data.vpc.availability_zones #=> Array<String>
    #   resp.data.vpc.network_interface_ids #=> Array<String>
    #   resp.data.vpc.security_group_ids #=> Array<String>
    #   resp.data.vpc.subnet_ids #=> Array<String>
    #
    def start_channel(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::StartChannelInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::StartChannelInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::StartChannel
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::StartChannel
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::StartChannel,
        stubs: @stubs,
        params_class: Params::StartChannelOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :start_channel
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Start (run) the multiplex. Starting the multiplex does not start the channels. You must explicitly start each channel.
    #
    # @param [Hash] params
    #   See {Types::StartMultiplexInput}.
    #
    # @option params [String] :multiplex_id
    #   The ID of the multiplex.
    #
    # @return [Types::StartMultiplexOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.start_multiplex(
    #     multiplex_id: 'MultiplexId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::StartMultiplexOutput
    #   resp.data.arn #=> String
    #   resp.data.availability_zones #=> Array<String>
    #   resp.data.availability_zones[0] #=> String
    #   resp.data.destinations #=> Array<MultiplexOutputDestination>
    #   resp.data.destinations[0] #=> Types::MultiplexOutputDestination
    #   resp.data.destinations[0].media_connect_settings #=> Types::MultiplexMediaConnectOutputDestinationSettings
    #   resp.data.destinations[0].media_connect_settings.entitlement_arn #=> String
    #   resp.data.id #=> String
    #   resp.data.multiplex_settings #=> Types::MultiplexSettings
    #   resp.data.multiplex_settings.maximum_video_buffer_delay_milliseconds #=> Integer
    #   resp.data.multiplex_settings.transport_stream_bitrate #=> Integer
    #   resp.data.multiplex_settings.transport_stream_id #=> Integer
    #   resp.data.multiplex_settings.transport_stream_reserved_bitrate #=> Integer
    #   resp.data.name #=> String
    #   resp.data.pipelines_running_count #=> Integer
    #   resp.data.program_count #=> Integer
    #   resp.data.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #
    def start_multiplex(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::StartMultiplexInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::StartMultiplexInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::StartMultiplex
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 202, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::StartMultiplex
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::StartMultiplex,
        stubs: @stubs,
        params_class: Params::StartMultiplexOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :start_multiplex
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Stops a running channel
    #
    # @param [Hash] params
    #   See {Types::StopChannelInput}.
    #
    # @option params [String] :channel_id
    #   A request to stop a running channel
    #
    # @return [Types::StopChannelOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.stop_channel(
    #     channel_id: 'ChannelId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::StopChannelOutput
    #   resp.data.arn #=> String
    #   resp.data.cdi_input_specification #=> Types::CdiInputSpecification
    #   resp.data.cdi_input_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.destinations #=> Array<OutputDestination>
    #   resp.data.destinations[0] #=> Types::OutputDestination
    #   resp.data.destinations[0].id #=> String
    #   resp.data.destinations[0].media_package_settings #=> Array<MediaPackageOutputDestinationSettings>
    #   resp.data.destinations[0].media_package_settings[0] #=> Types::MediaPackageOutputDestinationSettings
    #   resp.data.destinations[0].media_package_settings[0].channel_id #=> String
    #   resp.data.destinations[0].multiplex_settings #=> Types::MultiplexProgramChannelDestinationSettings
    #   resp.data.destinations[0].multiplex_settings.multiplex_id #=> String
    #   resp.data.destinations[0].multiplex_settings.program_name #=> String
    #   resp.data.destinations[0].settings #=> Array<OutputDestinationSettings>
    #   resp.data.destinations[0].settings[0] #=> Types::OutputDestinationSettings
    #   resp.data.destinations[0].settings[0].password_param #=> String
    #   resp.data.destinations[0].settings[0].stream_name #=> String
    #   resp.data.destinations[0].settings[0].url #=> String
    #   resp.data.destinations[0].settings[0].username #=> String
    #   resp.data.egress_endpoints #=> Array<ChannelEgressEndpoint>
    #   resp.data.egress_endpoints[0] #=> Types::ChannelEgressEndpoint
    #   resp.data.egress_endpoints[0].source_ip #=> String
    #   resp.data.encoder_settings #=> Types::EncoderSettings
    #   resp.data.encoder_settings.audio_descriptions #=> Array<AudioDescription>
    #   resp.data.encoder_settings.audio_descriptions[0] #=> Types::AudioDescription
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings #=> Types::AudioNormalizationSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm #=> String, one of ["ITU_1770_1", "ITU_1770_2"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm_control #=> String, one of ["CORRECT_AUDIO"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_normalization_settings.target_lkfs #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].audio_selector_name #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_type #=> String, one of ["CLEAN_EFFECTS", "HEARING_IMPAIRED", "UNDEFINED", "VISUAL_IMPAIRED_COMMENTARY"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_type_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings #=> Types::AudioWatermarkSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings #=> Types::NielsenWatermarksSettings
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings #=> Types::NielsenCBET
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_check_digit_string #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_stepaside #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.csid #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_distribution_type #=> String, one of ["FINAL_DISTRIBUTOR", "PROGRAM_CONTENT"]
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings #=> Types::NielsenNaesIiNw
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.check_digit_string #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.sid #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings #=> Types::AudioCodecSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings #=> Types::AacSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.coding_mode #=> String, one of ["AD_RECEIVER_MIX", "CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_5_1"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.input_type #=> String, one of ["BROADCASTER_MIXED_AD", "NORMAL"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.profile #=> String, one of ["HEV1", "HEV2", "LC"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.rate_control_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.raw_format #=> String, one of ["LATM_LOAS", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.spec #=> String, one of ["MPEG2", "MPEG4"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.vbr_quality #=> String, one of ["HIGH", "LOW", "MEDIUM_HIGH", "MEDIUM_LOW"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings #=> Types::Ac3Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "DIALOGUE", "EMERGENCY", "HEARING_IMPAIRED", "MUSIC_AND_EFFECTS", "VISUALLY_IMPAIRED", "VOICE_OVER"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_3_2_LFE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.dialnorm #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.drc_profile #=> String, one of ["FILM_STANDARD", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings #=> Types::Eac3Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.attenuation_control #=> String, one of ["ATTENUATE_3_DB", "NONE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "EMERGENCY", "HEARING_IMPAIRED", "VISUALLY_IMPAIRED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_3_2"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dc_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dialnorm #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_line #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_rf #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_control #=> String, one of ["LFE", "NO_LFE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_center_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_surround_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_center_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_surround_mix_level #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.passthrough_control #=> String, one of ["NO_PASSTHROUGH", "WHEN_POSSIBLE"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.phase_control #=> String, one of ["NO_SHIFT", "SHIFT_90_DEGREES"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.stereo_downmix #=> String, one of ["DPL2", "LO_RO", "LT_RT", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_ex_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings #=> Types::Mp2Settings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.bitrate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.pass_through_settings #=> Types::PassThroughSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings #=> Types::WavSettings
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.bit_depth #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_4_0", "CODING_MODE_8_0"]
    #   resp.data.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.sample_rate #=> Float
    #   resp.data.encoder_settings.audio_descriptions[0].language_code #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].language_code_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.audio_descriptions[0].name #=> String
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings #=> Types::RemixSettings
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings #=> Array<AudioChannelMapping>
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0] #=> Types::AudioChannelMapping
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels #=> Array<InputChannelLevel>
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0] #=> Types::InputChannelLevel
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].gain #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].input_channel #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].output_channel #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channels_in #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].remix_settings.channels_out #=> Integer
    #   resp.data.encoder_settings.audio_descriptions[0].stream_name #=> String
    #   resp.data.encoder_settings.avail_blanking #=> Types::AvailBlanking
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image #=> Types::InputLocation
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.password_param #=> String
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.uri #=> String
    #   resp.data.encoder_settings.avail_blanking.avail_blanking_image.username #=> String
    #   resp.data.encoder_settings.avail_blanking.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.avail_configuration #=> Types::AvailConfiguration
    #   resp.data.encoder_settings.avail_configuration.avail_settings #=> Types::AvailSettings
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert #=> Types::Scte35SpliceInsert
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.ad_avail_offset #=> Integer
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos #=> Types::Scte35TimeSignalApos
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.ad_avail_offset #=> Integer
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.encoder_settings.blackout_slate #=> Types::BlackoutSlate
    #   resp.data.encoder_settings.blackout_slate.blackout_slate_image #=> Types::InputLocation
    #   resp.data.encoder_settings.blackout_slate.network_end_blackout #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.blackout_slate.network_end_blackout_image #=> Types::InputLocation
    #   resp.data.encoder_settings.blackout_slate.network_id #=> String
    #   resp.data.encoder_settings.blackout_slate.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.caption_descriptions #=> Array<CaptionDescription>
    #   resp.data.encoder_settings.caption_descriptions[0] #=> Types::CaptionDescription
    #   resp.data.encoder_settings.caption_descriptions[0].caption_selector_name #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings #=> Types::CaptionDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.arib_destination_settings #=> Types::AribDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings #=> Types::BurnInDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font #=> Types::InputLocation
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_resolution #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_size #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_size #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.x_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.y_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings #=> Types::DvbSubDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font #=> Types::InputLocation
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_resolution #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_size #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_size #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_opacity #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.x_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.y_position #=> Integer
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings #=> Types::EbuTtDDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.copyright_holder #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.fill_line_gap #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.font_family #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.style_control #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.embedded_destination_settings #=> Types::EmbeddedDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.embedded_plus_scte20_destination_settings #=> Types::EmbeddedPlusScte20DestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.rtmp_caption_info_destination_settings #=> Types::RtmpCaptionInfoDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.scte20_plus_embedded_destination_settings #=> Types::Scte20PlusEmbeddedDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.scte27_destination_settings #=> Types::Scte27DestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.smpte_tt_destination_settings #=> Types::SmpteTtDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.teletext_destination_settings #=> Types::TeletextDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings #=> Types::TtmlDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings.style_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings #=> Types::WebvttDestinationSettings
    #   resp.data.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings.style_control #=> String, one of ["NO_STYLE_DATA", "PASSTHROUGH"]
    #   resp.data.encoder_settings.caption_descriptions[0].language_code #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].language_description #=> String
    #   resp.data.encoder_settings.caption_descriptions[0].name #=> String
    #   resp.data.encoder_settings.feature_activations #=> Types::FeatureActivations
    #   resp.data.encoder_settings.feature_activations.input_prepare_schedule_actions #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.global_configuration #=> Types::GlobalConfiguration
    #   resp.data.encoder_settings.global_configuration.initial_audio_gain #=> Integer
    #   resp.data.encoder_settings.global_configuration.input_end_action #=> String, one of ["NONE", "SWITCH_AND_LOOP_INPUTS"]
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior #=> Types::InputLossBehavior
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.black_frame_msec #=> Integer
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_color #=> String
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_slate #=> Types::InputLocation
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_type #=> String, one of ["COLOR", "SLATE"]
    #   resp.data.encoder_settings.global_configuration.input_loss_behavior.repeat_frame_msec #=> Integer
    #   resp.data.encoder_settings.global_configuration.output_locking_mode #=> String, one of ["EPOCH_LOCKING", "PIPELINE_LOCKING"]
    #   resp.data.encoder_settings.global_configuration.output_timing_source #=> String, one of ["INPUT_CLOCK", "SYSTEM_CLOCK"]
    #   resp.data.encoder_settings.global_configuration.support_low_framerate_inputs #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.motion_graphics_configuration #=> Types::MotionGraphicsConfiguration
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_insertion #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_settings #=> Types::MotionGraphicsSettings
    #   resp.data.encoder_settings.motion_graphics_configuration.motion_graphics_settings.html_motion_graphics_settings #=> Types::HtmlMotionGraphicsSettings
    #   resp.data.encoder_settings.nielsen_configuration #=> Types::NielsenConfiguration
    #   resp.data.encoder_settings.nielsen_configuration.distributor_id #=> String
    #   resp.data.encoder_settings.nielsen_configuration.nielsen_pcm_to_id3_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups #=> Array<OutputGroup>
    #   resp.data.encoder_settings.output_groups[0] #=> Types::OutputGroup
    #   resp.data.encoder_settings.output_groups[0].name #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings #=> Types::OutputGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings #=> Types::ArchiveGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings #=> Types::ArchiveCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings #=> Types::ArchiveS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination.destination_ref_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.rollover_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings #=> Types::FrameCaptureGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings #=> Types::FrameCaptureCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings #=> Types::FrameCaptureS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings #=> Types::HlsGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers[0] #=> String, one of ["ADOBE", "ELEMENTAL", "ELEMENTAL_SCTE35"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content1 #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest1 #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings #=> Array<CaptionLanguageMapping>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0] #=> Types::CaptionLanguageMapping
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].caption_channel #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_code #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_description #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_setting #=> String, one of ["INSERT", "NONE", "OMIT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.client_cache #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.codec_specification #=> String, one of ["RFC_4281", "RFC_6381"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.constant_iv #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.directory_structure #=> String, one of ["SINGLE_DIRECTORY", "SUBDIRECTORY_PER_STREAM"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.discontinuity_tags #=> String, one of ["INSERT", "NEVER_INSERT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.encryption_type #=> String, one of ["AES128", "SAMPLE_AES"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings #=> Types::HlsCdnSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings #=> Types::HlsAkamaiSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.salt #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.token #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings #=> Types::HlsBasicPutSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings #=> Types::HlsMediaStoreSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.media_store_storage_class #=> String, one of ["TEMPORAL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings #=> Types::HlsS3Settings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings #=> Types::HlsWebdavSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_id3_segment_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.i_frame_only_playlists #=> String, one of ["DISABLED", "STANDARD"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.incomplete_segment_behavior #=> String, one of ["AUTO", "SUPPRESS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.index_n_segments #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_in_manifest #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_source #=> String, one of ["EXPLICIT", "FOLLOWS_SEGMENT_NUMBER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.keep_segments #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format_versions #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings #=> Types::KeyProviderSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings #=> Types::StaticKeySettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.key_provider_server #=> Types::InputLocation
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.static_key_value #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_compression #=> String, one of ["GZIP", "NONE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_duration_format #=> String, one of ["FLOATING_POINT", "INTEGER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.min_segment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.mode #=> String, one of ["LIVE", "VOD"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.output_selection #=> String, one of ["MANIFESTS_AND_SEGMENTS", "SEGMENTS_ONLY", "VARIANT_MANIFESTS_AND_SEGMENTS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_clock #=> String, one of ["INITIALIZE_FROM_OUTPUT_TIMECODE", "SYSTEM_CLOCK"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.redundant_manifest #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segments_per_subdirectory #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.stream_inf_resolution #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timestamp_delta_milliseconds #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ts_file_mode #=> String, one of ["SEGMENTED_FILES", "SINGLE_FILE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings #=> Types::MediaPackageGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings #=> Types::MsSmoothGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.acquisition_point_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.audio_only_timecode_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED_CLOCK"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id_mode #=> String, one of ["NO_EVENT_ID", "USE_CONFIGURED", "USE_TIMESTAMP"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_stop_behavior #=> String, one of ["NONE", "SEND_EOS"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.filecache_duration #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.fragment_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.send_delay_ms #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.sparse_track_type #=> String, one of ["NONE", "SCTE_35", "SCTE_35_WITHOUT_SEGMENTATION"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.stream_manifest_behavior #=> String, one of ["DO_NOT_SEND", "SEND"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset #=> String
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset_mode #=> String, one of ["USE_CONFIGURED_OFFSET", "USE_EVENT_START_DATE"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.multiplex_group_settings #=> Types::MultiplexGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings #=> Types::RtmpGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers[0] #=> String, one of ["ON_CUE_POINT_SCTE35"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.authentication_scheme #=> String, one of ["AKAMAI", "COMMON"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_full_behavior #=> String, one of ["DISCONNECT_IMMEDIATELY", "WAIT_FOR_SERVER"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.caption_data #=> String, one of ["ALL", "FIELD1_608", "FIELD1_AND_FIELD2_608"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.restart_delay #=> Integer
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings #=> Types::UdpGroupSettings
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.input_loss_action #=> String, one of ["DROP_PROGRAM", "DROP_TS", "EMIT_PROGRAM"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs #=> Array<Output>
    #   resp.data.encoder_settings.output_groups[0].outputs[0] #=> Types::Output
    #   resp.data.encoder_settings.output_groups[0].outputs[0].audio_description_names #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].outputs[0].audio_description_names[0] #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].caption_description_names #=> Array<String>
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings #=> Types::OutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings #=> Types::ArchiveOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings #=> Types::ArchiveContainerSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.absent_input_audio_behavior #=> String, one of ["DROP", "ENCODE_SILENCE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid_control #=> String, one of ["AUTO", "USE_CONFIGURED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_buffer_model #=> String, one of ["ATSC", "DVB"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_frames_per_pes #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_stream_type #=> String, one of ["ATSC", "DVB"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.buffer_model #=> String, one of ["MULTIPLEX", "NONE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.cc_descriptor #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings #=> Types::DvbNitSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings #=> Types::DvbSdtSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.output_sdt #=> String, one of ["SDT_FOLLOW", "SDT_FOLLOW_IF_PRESENT", "SDT_MANUAL", "SDT_NONE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_provider_name #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sub_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings #=> Types::DvbTdtSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings.rep_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_teletext_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebif #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_audio_interval #=> String, one of ["VIDEO_AND_FIXED_INTERVALS", "VIDEO_INTERVAL"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_lookahead_ms #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_placement #=> String, one of ["VIDEO_AND_AUDIO_PIDS", "VIDEO_PID"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ecm_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.es_rate_in_pes #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_platform_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_signal_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.fragment_time #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv_data_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.null_packet_bitrate #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pat_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.program_num #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.rate_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte27_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_control #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_markers #=> String, one of ["EBP", "EBP_LEGACY", "NONE", "PSI_SEGSTART", "RAI_ADAPT", "RAI_SEGSTART"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_style #=> String, one of ["MAINTAIN_CADENCE", "RESET_CADENCE"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_time #=> Float
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.transport_stream_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.video_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.raw_settings #=> Types::RawSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.extension #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings #=> Types::FrameCaptureOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings #=> Types::HlsOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings #=> Types::HlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings #=> Types::AudioOnlyHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_group_id #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_only_image #=> Types::InputLocation
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_track_type #=> String, one of ["ALTERNATE_AUDIO_AUTO_SELECT", "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT", "ALTERNATE_AUDIO_NOT_AUTO_SELECT", "AUDIO_ONLY_VARIANT_STREAM"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.segment_type #=> String, one of ["AAC", "FMP4"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings #=> Types::Fmp4HlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.audio_rendition_sets #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.frame_capture_hls_settings #=> Types::FrameCaptureHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings #=> Types::StandardHlsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.audio_rendition_sets #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings #=> Types::M3u8Settings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_frames_per_pes #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_pids #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.ecm_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pat_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_period #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.program_num #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.transport_stream_id #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.video_pid #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.segment_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.media_package_output_settings #=> Types::MediaPackageOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings #=> Types::MsSmoothOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.name_modifier #=> String
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings #=> Types::MultiplexOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings #=> Types::RtmpOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.connection_retry_interval #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.num_retries #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings #=> Types::UdpOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.buffer_msec #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings #=> Types::UdpContainerSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings #=> Types::FecOutputSettings
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.column_depth #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.include_fec #=> String, one of ["COLUMN", "COLUMN_AND_ROW"]
    #   resp.data.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.row_length #=> Integer
    #   resp.data.encoder_settings.output_groups[0].outputs[0].video_description_name #=> String
    #   resp.data.encoder_settings.timecode_config #=> Types::TimecodeConfig
    #   resp.data.encoder_settings.timecode_config.source #=> String, one of ["EMBEDDED", "SYSTEMCLOCK", "ZEROBASED"]
    #   resp.data.encoder_settings.timecode_config.sync_threshold #=> Integer
    #   resp.data.encoder_settings.video_descriptions #=> Array<VideoDescription>
    #   resp.data.encoder_settings.video_descriptions[0] #=> Types::VideoDescription
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings #=> Types::VideoCodecSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings #=> Types::FrameCaptureSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval_units #=> String, one of ["MILLISECONDS", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings #=> Types::H264Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_fill_pct #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_size #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings #=> Types::H264ColorSpaceSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.entropy_encoding #=> String, one of ["CABAC", "CAVLC"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings #=> Types::H264FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.post_filter_sharpening #=> String, one of ["AUTO", "DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.strength #=> String, one of ["AUTO", "STRENGTH_1", "STRENGTH_2", "STRENGTH_3", "STRENGTH_4", "STRENGTH_5", "STRENGTH_6", "STRENGTH_7", "STRENGTH_8", "STRENGTH_9", "STRENGTH_10", "STRENGTH_11", "STRENGTH_12", "STRENGTH_13", "STRENGTH_14", "STRENGTH_15", "STRENGTH_16"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.force_field_pictures #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_b_reference #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_num_b_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.level #=> String, one of ["H264_LEVEL_1", "H264_LEVEL_1_1", "H264_LEVEL_1_2", "H264_LEVEL_1_3", "H264_LEVEL_2", "H264_LEVEL_2_1", "H264_LEVEL_2_2", "H264_LEVEL_3", "H264_LEVEL_3_1", "H264_LEVEL_3_2", "H264_LEVEL_4", "H264_LEVEL_4_1", "H264_LEVEL_4_2", "H264_LEVEL_5", "H264_LEVEL_5_1", "H264_LEVEL_5_2", "H264_LEVEL_AUTO"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.max_bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.min_i_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.num_ref_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.profile #=> String, one of ["BASELINE", "HIGH", "HIGH_10BIT", "HIGH_422", "HIGH_422_10BIT", "MAIN"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.quality_level #=> String, one of ["ENHANCED_QUALITY", "STANDARD_QUALITY"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.qvbr_quality_level #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR", "VBR"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.slices #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.softness #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.spatial_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.syntax #=> String, one of ["DEFAULT", "RP2027"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.temporal_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h264_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings #=> Types::H265Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.alternative_transfer_function #=> String, one of ["INSERT", "OMIT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.buf_size #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings #=> Types::H265ColorSpaceSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_cll #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_fall #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings #=> Types::H265FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.level #=> String, one of ["H265_LEVEL_1", "H265_LEVEL_2", "H265_LEVEL_2_1", "H265_LEVEL_3", "H265_LEVEL_3_1", "H265_LEVEL_4", "H265_LEVEL_4_1", "H265_LEVEL_5", "H265_LEVEL_5_1", "H265_LEVEL_5_2", "H265_LEVEL_6", "H265_LEVEL_6_1", "H265_LEVEL_6_2", "H265_LEVEL_AUTO"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.max_bitrate #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.min_i_interval #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.profile #=> String, one of ["MAIN", "MAIN_10BIT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.qvbr_quality_level #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.slices #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.tier #=> String, one of ["HIGH", "MAIN"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.h265_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings #=> Types::Mpeg2Settings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "LOW", "MEDIUM", "OFF"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_space #=> String, one of ["AUTO", "PASSTHROUGH"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.display_aspect_ratio #=> String, one of ["DISPLAYRATIO16X9", "DISPLAYRATIO4X3"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings #=> Types::Mpeg2FilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_denominator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_numerator #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_closed_cadence #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_num_b_frames #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size #=> Float
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.timecode_insertion #=> String, one of ["DISABLED", "GOP_TIMECODE"]
    #   resp.data.encoder_settings.video_descriptions[0].height #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].name #=> String
    #   resp.data.encoder_settings.video_descriptions[0].respond_to_afd #=> String, one of ["NONE", "PASSTHROUGH", "RESPOND"]
    #   resp.data.encoder_settings.video_descriptions[0].scaling_behavior #=> String, one of ["DEFAULT", "STRETCH_TO_OUTPUT"]
    #   resp.data.encoder_settings.video_descriptions[0].sharpness #=> Integer
    #   resp.data.encoder_settings.video_descriptions[0].width #=> Integer
    #   resp.data.id #=> String
    #   resp.data.input_attachments #=> Array<InputAttachment>
    #   resp.data.input_attachments[0] #=> Types::InputAttachment
    #   resp.data.input_attachments[0].automatic_input_failover_settings #=> Types::AutomaticInputFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.error_clear_time_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions #=> Array<FailoverCondition>
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0] #=> Types::FailoverCondition
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings #=> Types::FailoverConditionSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings #=> Types::AudioSilenceFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_selector_name #=> String
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_silence_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings #=> Types::InputLossFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings.input_loss_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings #=> Types::VideoBlackFailoverSettings
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.black_detect_threshold #=> Float
    #   resp.data.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.video_black_threshold_msec #=> Integer
    #   resp.data.input_attachments[0].automatic_input_failover_settings.input_preference #=> String, one of ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #   resp.data.input_attachments[0].automatic_input_failover_settings.secondary_input_id #=> String
    #   resp.data.input_attachments[0].input_attachment_name #=> String
    #   resp.data.input_attachments[0].input_id #=> String
    #   resp.data.input_attachments[0].input_settings #=> Types::InputSettings
    #   resp.data.input_attachments[0].input_settings.audio_selectors #=> Array<AudioSelector>
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0] #=> Types::AudioSelector
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].name #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings #=> Types::AudioSelectorSettings
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection #=> Types::AudioHlsRenditionSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.group_id #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.name #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection #=> Types::AudioLanguageSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_code #=> String
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_selection_policy #=> String, one of ["LOOSE", "STRICT"]
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection #=> Types::AudioPidSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection #=> Types::AudioTrackSelection
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks #=> Array<AudioTrack>
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0] #=> Types::AudioTrack
    #   resp.data.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0].track #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors #=> Array<CaptionSelector>
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0] #=> Types::CaptionSelector
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].language_code #=> String
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].name #=> String
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings #=> Types::CaptionSelectorSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings #=> Types::AncillarySourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings.source_ancillary_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.arib_source_settings #=> Types::AribSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings #=> Types::DvbSubSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings #=> Types::EmbeddedSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.scte20_detection #=> String, one of ["AUTO", "OFF"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_track_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings #=> Types::Scte20SourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.source608_channel_number #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings #=> Types::Scte27SourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings #=> Types::TeletextSourceSettings
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle #=> Types::CaptionRectangle
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.height #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.left_offset #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.top_offset #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.width #=> Float
    #   resp.data.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.page_number #=> String
    #   resp.data.input_attachments[0].input_settings.deblock_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.input_attachments[0].input_settings.denoise_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.input_attachments[0].input_settings.filter_strength #=> Integer
    #   resp.data.input_attachments[0].input_settings.input_filter #=> String, one of ["AUTO", "DISABLED", "FORCED"]
    #   resp.data.input_attachments[0].input_settings.network_input_settings #=> Types::NetworkInputSettings
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings #=> Types::HlsInputSettings
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.bandwidth #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.buffer_segments #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retries #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retry_interval #=> Integer
    #   resp.data.input_attachments[0].input_settings.network_input_settings.hls_input_settings.scte35_source #=> String, one of ["MANIFEST", "SEGMENTS"]
    #   resp.data.input_attachments[0].input_settings.network_input_settings.server_validation #=> String, one of ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #   resp.data.input_attachments[0].input_settings.scte35_pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.smpte2038_data_preference #=> String, one of ["IGNORE", "PREFER"]
    #   resp.data.input_attachments[0].input_settings.source_end_behavior #=> String, one of ["CONTINUE", "LOOP"]
    #   resp.data.input_attachments[0].input_settings.video_selector #=> Types::VideoSelector
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space #=> String, one of ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_settings #=> Types::VideoSelectorColorSpaceSettings
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.input_attachments[0].input_settings.video_selector.color_space_usage #=> String, one of ["FALLBACK", "FORCE"]
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings #=> Types::VideoSelectorSettings
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid #=> Types::VideoSelectorPid
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid.pid #=> Integer
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id #=> Types::VideoSelectorProgramId
    #   resp.data.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id.program_id #=> Integer
    #   resp.data.input_specification #=> Types::InputSpecification
    #   resp.data.input_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC"]
    #   resp.data.input_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.input_specification.resolution #=> String, one of ["SD", "HD", "UHD"]
    #   resp.data.log_level #=> String, one of ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #   resp.data.maintenance #=> Types::MaintenanceStatus
    #   resp.data.maintenance.maintenance_day #=> String, one of ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #   resp.data.maintenance.maintenance_deadline #=> String
    #   resp.data.maintenance.maintenance_scheduled_date #=> String
    #   resp.data.maintenance.maintenance_start_time #=> String
    #   resp.data.name #=> String
    #   resp.data.pipeline_details #=> Array<PipelineDetail>
    #   resp.data.pipeline_details[0] #=> Types::PipelineDetail
    #   resp.data.pipeline_details[0].active_input_attachment_name #=> String
    #   resp.data.pipeline_details[0].active_input_switch_action_name #=> String
    #   resp.data.pipeline_details[0].active_motion_graphics_action_name #=> String
    #   resp.data.pipeline_details[0].active_motion_graphics_uri #=> String
    #   resp.data.pipeline_details[0].pipeline_id #=> String
    #   resp.data.pipelines_running_count #=> Integer
    #   resp.data.role_arn #=> String
    #   resp.data.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED", "UPDATING", "UPDATE_FAILED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #   resp.data.vpc #=> Types::VpcOutputSettingsDescription
    #   resp.data.vpc.availability_zones #=> Array<String>
    #   resp.data.vpc.network_interface_ids #=> Array<String>
    #   resp.data.vpc.security_group_ids #=> Array<String>
    #   resp.data.vpc.subnet_ids #=> Array<String>
    #
    def stop_channel(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::StopChannelInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::StopChannelInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::StopChannel
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::StopChannel
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::StopChannel,
        stubs: @stubs,
        params_class: Params::StopChannelOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :stop_channel
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Stops a running multiplex. If the multiplex isn't running, this action has no effect.
    #
    # @param [Hash] params
    #   See {Types::StopMultiplexInput}.
    #
    # @option params [String] :multiplex_id
    #   The ID of the multiplex.
    #
    # @return [Types::StopMultiplexOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.stop_multiplex(
    #     multiplex_id: 'MultiplexId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::StopMultiplexOutput
    #   resp.data.arn #=> String
    #   resp.data.availability_zones #=> Array<String>
    #   resp.data.availability_zones[0] #=> String
    #   resp.data.destinations #=> Array<MultiplexOutputDestination>
    #   resp.data.destinations[0] #=> Types::MultiplexOutputDestination
    #   resp.data.destinations[0].media_connect_settings #=> Types::MultiplexMediaConnectOutputDestinationSettings
    #   resp.data.destinations[0].media_connect_settings.entitlement_arn #=> String
    #   resp.data.id #=> String
    #   resp.data.multiplex_settings #=> Types::MultiplexSettings
    #   resp.data.multiplex_settings.maximum_video_buffer_delay_milliseconds #=> Integer
    #   resp.data.multiplex_settings.transport_stream_bitrate #=> Integer
    #   resp.data.multiplex_settings.transport_stream_id #=> Integer
    #   resp.data.multiplex_settings.transport_stream_reserved_bitrate #=> Integer
    #   resp.data.name #=> String
    #   resp.data.pipelines_running_count #=> Integer
    #   resp.data.program_count #=> Integer
    #   resp.data.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED"]
    #   resp.data.tags #=> Hash<String, String>
    #   resp.data.tags['key'] #=> String
    #
    def stop_multiplex(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::StopMultiplexInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::StopMultiplexInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::StopMultiplex
      )
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 202, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::StopMultiplex
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::StopMultiplex,
        stubs: @stubs,
        params_class: Params::StopMultiplexOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :stop_multiplex
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Start an input device transfer to another AWS account. After you make the request, the other account must accept or reject the transfer.
    #
    # @param [Hash] params
    #   See {Types::TransferInputDeviceInput}.
    #
    # @option params [String] :input_device_id
    #   The unique ID of this input device. For example, hd-123456789abcdef.
    #
    # @option params [String] :target_customer_id
    #   The AWS account ID (12 digits) for the recipient of the device transfer.
    #
    # @option params [String] :target_region
    #   The target AWS region to transfer the device.
    #
    # @option params [String] :transfer_message
    #   An optional message for the recipient. Maximum 280 characters.
    #
    # @return [Types::TransferInputDeviceOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.transfer_input_device(
    #     input_device_id: 'InputDeviceId', # required
    #     target_customer_id: 'TargetCustomerId',
    #     target_region: 'TargetRegion',
    #     transfer_message: 'TransferMessage'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::TransferInputDeviceOutput
    #
    def transfer_input_device(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::TransferInputDeviceInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::TransferInputDeviceInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::TransferInputDevice
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::TransferInputDevice
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::TransferInputDevice,
        stubs: @stubs,
        params_class: Params::TransferInputDeviceOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :transfer_input_device
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Updates a channel.
    #
    # @param [Hash] params
    #   See {Types::UpdateChannelInput}.
    #
    # @option params [CdiInputSpecification] :cdi_input_specification
    #   Specification of CDI inputs for this channel
    #
    # @option params [String] :channel_id
    #   channel ID
    #
    # @option params [Array<OutputDestination>] :destinations
    #   A list of output destinations for this channel.
    #
    # @option params [EncoderSettings] :encoder_settings
    #   The encoder settings for this channel.
    #
    # @option params [Array<InputAttachment>] :input_attachments
    #   Placeholder documentation for __listOfInputAttachment
    #
    # @option params [InputSpecification] :input_specification
    #   Specification of network and file inputs for this channel
    #
    # @option params [String] :log_level
    #   The log level to write to CloudWatch Logs.
    #
    # @option params [MaintenanceUpdateSettings] :maintenance
    #   Maintenance settings for this channel.
    #
    # @option params [String] :name
    #   The name of the channel.
    #
    # @option params [String] :role_arn
    #   An optional Amazon Resource Name (ARN) of the role to assume when running the Channel. If you do not specify this on an update call but the role was previously set that role will be removed.
    #
    # @return [Types::UpdateChannelOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.update_channel(
    #     cdi_input_specification: {
    #       resolution: 'SD' # accepts ["SD", "HD", "FHD", "UHD"]
    #     },
    #     channel_id: 'ChannelId', # required
    #     destinations: [
    #       {
    #         id: 'Id',
    #         media_package_settings: [
    #           {
    #             channel_id: 'ChannelId'
    #           }
    #         ],
    #         multiplex_settings: {
    #           multiplex_id: 'MultiplexId',
    #           program_name: 'ProgramName'
    #         },
    #         settings: [
    #           {
    #             password_param: 'PasswordParam',
    #             stream_name: 'StreamName',
    #             url: 'Url',
    #             username: 'Username'
    #           }
    #         ]
    #       }
    #     ],
    #     encoder_settings: {
    #       audio_descriptions: [
    #         {
    #           audio_normalization_settings: {
    #             algorithm: 'ITU_1770_1', # accepts ["ITU_1770_1", "ITU_1770_2"]
    #             algorithm_control: 'CORRECT_AUDIO', # accepts ["CORRECT_AUDIO"]
    #             target_lkfs: 1.0
    #           },
    #           audio_selector_name: 'AudioSelectorName', # required
    #           audio_type: 'CLEAN_EFFECTS', # accepts ["CLEAN_EFFECTS", "HEARING_IMPAIRED", "UNDEFINED", "VISUAL_IMPAIRED_COMMENTARY"]
    #           audio_type_control: 'FOLLOW_INPUT', # accepts ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #           audio_watermarking_settings: {
    #             nielsen_watermarks_settings: {
    #               nielsen_cbet_settings: {
    #                 cbet_check_digit_string: 'CbetCheckDigitString', # required
    #                 cbet_stepaside: 'DISABLED', # required - accepts ["DISABLED", "ENABLED"]
    #                 csid: 'Csid' # required
    #               },
    #               nielsen_distribution_type: 'FINAL_DISTRIBUTOR', # accepts ["FINAL_DISTRIBUTOR", "PROGRAM_CONTENT"]
    #               nielsen_naes_ii_nw_settings: {
    #                 check_digit_string: 'CheckDigitString', # required
    #                 sid: 1.0 # required
    #               }
    #             }
    #           },
    #           codec_settings: {
    #             aac_settings: {
    #               bitrate: 1.0,
    #               coding_mode: 'AD_RECEIVER_MIX', # accepts ["AD_RECEIVER_MIX", "CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_5_1"]
    #               input_type: 'BROADCASTER_MIXED_AD', # accepts ["BROADCASTER_MIXED_AD", "NORMAL"]
    #               profile: 'HEV1', # accepts ["HEV1", "HEV2", "LC"]
    #               rate_control_mode: 'CBR', # accepts ["CBR", "VBR"]
    #               raw_format: 'LATM_LOAS', # accepts ["LATM_LOAS", "NONE"]
    #               sample_rate: 1.0,
    #               spec: 'MPEG2', # accepts ["MPEG2", "MPEG4"]
    #               vbr_quality: 'HIGH' # accepts ["HIGH", "LOW", "MEDIUM_HIGH", "MEDIUM_LOW"]
    #             },
    #             ac3_settings: {
    #               bitrate: 1.0,
    #               bitstream_mode: 'COMMENTARY', # accepts ["COMMENTARY", "COMPLETE_MAIN", "DIALOGUE", "EMERGENCY", "HEARING_IMPAIRED", "MUSIC_AND_EFFECTS", "VISUALLY_IMPAIRED", "VOICE_OVER"]
    #               coding_mode: 'CODING_MODE_1_0', # accepts ["CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_3_2_LFE"]
    #               dialnorm: 1,
    #               drc_profile: 'FILM_STANDARD', # accepts ["FILM_STANDARD", "NONE"]
    #               lfe_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               metadata_control: 'FOLLOW_INPUT' # accepts ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #             },
    #             eac3_settings: {
    #               attenuation_control: 'ATTENUATE_3_DB', # accepts ["ATTENUATE_3_DB", "NONE"]
    #               bitrate: 1.0,
    #               bitstream_mode: 'COMMENTARY', # accepts ["COMMENTARY", "COMPLETE_MAIN", "EMERGENCY", "HEARING_IMPAIRED", "VISUALLY_IMPAIRED"]
    #               coding_mode: 'CODING_MODE_1_0', # accepts ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_3_2"]
    #               dc_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               dialnorm: 1,
    #               drc_line: 'FILM_LIGHT', # accepts ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #               drc_rf: 'FILM_LIGHT', # accepts ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #               lfe_control: 'LFE', # accepts ["LFE", "NO_LFE"]
    #               lfe_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               lo_ro_center_mix_level: 1.0,
    #               lo_ro_surround_mix_level: 1.0,
    #               lt_rt_center_mix_level: 1.0,
    #               lt_rt_surround_mix_level: 1.0,
    #               metadata_control: 'FOLLOW_INPUT', # accepts ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #               passthrough_control: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "WHEN_POSSIBLE"]
    #               phase_control: 'NO_SHIFT', # accepts ["NO_SHIFT", "SHIFT_90_DEGREES"]
    #               stereo_downmix: 'DPL2', # accepts ["DPL2", "LO_RO", "LT_RT", "NOT_INDICATED"]
    #               surround_ex_mode: 'DISABLED', # accepts ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #               surround_mode: 'DISABLED' # accepts ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #             },
    #             mp2_settings: {
    #               bitrate: 1.0,
    #               coding_mode: 'CODING_MODE_1_0', # accepts ["CODING_MODE_1_0", "CODING_MODE_2_0"]
    #               sample_rate: 1.0
    #             },
    #             pass_through_settings: { },
    #             wav_settings: {
    #               bit_depth: 1.0,
    #               coding_mode: 'CODING_MODE_1_0', # accepts ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_4_0", "CODING_MODE_8_0"]
    #               sample_rate: 1.0
    #             }
    #           },
    #           language_code: 'LanguageCode',
    #           language_code_control: 'FOLLOW_INPUT', # accepts ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #           name: 'Name', # required
    #           remix_settings: {
    #             channel_mappings: [
    #               {
    #                 input_channel_levels: [
    #                   {
    #                     gain: 1, # required
    #                     input_channel: 1 # required
    #                   }
    #                 ], # required
    #                 output_channel: 1 # required
    #               }
    #             ], # required
    #             channels_in: 1,
    #             channels_out: 1
    #           },
    #           stream_name: 'StreamName'
    #         }
    #       ], # required
    #       avail_blanking: {
    #         avail_blanking_image: {
    #           password_param: 'PasswordParam',
    #           uri: 'Uri', # required
    #           username: 'Username'
    #         },
    #         state: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       avail_configuration: {
    #         avail_settings: {
    #           scte35_splice_insert: {
    #             ad_avail_offset: 1,
    #             no_regional_blackout_flag: 'FOLLOW', # accepts ["FOLLOW", "IGNORE"]
    #             web_delivery_allowed_flag: 'FOLLOW' # accepts ["FOLLOW", "IGNORE"]
    #           },
    #           scte35_time_signal_apos: {
    #             ad_avail_offset: 1,
    #             no_regional_blackout_flag: 'FOLLOW', # accepts ["FOLLOW", "IGNORE"]
    #             web_delivery_allowed_flag: 'FOLLOW' # accepts ["FOLLOW", "IGNORE"]
    #           }
    #         }
    #       },
    #       blackout_slate: {
    #         network_end_blackout: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #         network_id: 'NetworkId',
    #         state: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       caption_descriptions: [
    #         {
    #           caption_selector_name: 'CaptionSelectorName', # required
    #           destination_settings: {
    #             arib_destination_settings: { },
    #             burn_in_destination_settings: {
    #               alignment: 'CENTERED', # accepts ["CENTERED", "LEFT", "SMART"]
    #               background_color: 'BLACK', # accepts ["BLACK", "NONE", "WHITE"]
    #               background_opacity: 1,
    #               font_color: 'BLACK', # accepts ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #               font_opacity: 1,
    #               font_resolution: 1,
    #               font_size: 'FontSize',
    #               outline_color: 'BLACK', # accepts ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #               outline_size: 1,
    #               shadow_color: 'BLACK', # accepts ["BLACK", "NONE", "WHITE"]
    #               shadow_opacity: 1,
    #               shadow_x_offset: 1,
    #               shadow_y_offset: 1,
    #               teletext_grid_control: 'FIXED', # accepts ["FIXED", "SCALED"]
    #               x_position: 1,
    #               y_position: 1
    #             },
    #             dvb_sub_destination_settings: {
    #               alignment: 'CENTERED', # accepts ["CENTERED", "LEFT", "SMART"]
    #               background_color: 'BLACK', # accepts ["BLACK", "NONE", "WHITE"]
    #               background_opacity: 1,
    #               font_color: 'BLACK', # accepts ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #               font_opacity: 1,
    #               font_resolution: 1,
    #               font_size: 'FontSize',
    #               outline_color: 'BLACK', # accepts ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #               outline_size: 1,
    #               shadow_color: 'BLACK', # accepts ["BLACK", "NONE", "WHITE"]
    #               shadow_opacity: 1,
    #               shadow_x_offset: 1,
    #               shadow_y_offset: 1,
    #               teletext_grid_control: 'FIXED', # accepts ["FIXED", "SCALED"]
    #               x_position: 1,
    #               y_position: 1
    #             },
    #             ebu_tt_d_destination_settings: {
    #               copyright_holder: 'CopyrightHolder',
    #               fill_line_gap: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               font_family: 'FontFamily',
    #               style_control: 'EXCLUDE' # accepts ["EXCLUDE", "INCLUDE"]
    #             },
    #             embedded_destination_settings: { },
    #             embedded_plus_scte20_destination_settings: { },
    #             rtmp_caption_info_destination_settings: { },
    #             scte20_plus_embedded_destination_settings: { },
    #             scte27_destination_settings: { },
    #             smpte_tt_destination_settings: { },
    #             teletext_destination_settings: { },
    #             ttml_destination_settings: {
    #               style_control: 'PASSTHROUGH' # accepts ["PASSTHROUGH", "USE_CONFIGURED"]
    #             },
    #             webvtt_destination_settings: {
    #               style_control: 'NO_STYLE_DATA' # accepts ["NO_STYLE_DATA", "PASSTHROUGH"]
    #             }
    #           },
    #           language_code: 'LanguageCode',
    #           language_description: 'LanguageDescription',
    #           name: 'Name' # required
    #         }
    #       ],
    #       feature_activations: {
    #         input_prepare_schedule_actions: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       global_configuration: {
    #         initial_audio_gain: 1,
    #         input_end_action: 'NONE', # accepts ["NONE", "SWITCH_AND_LOOP_INPUTS"]
    #         input_loss_behavior: {
    #           black_frame_msec: 1,
    #           input_loss_image_color: 'InputLossImageColor',
    #           input_loss_image_type: 'COLOR', # accepts ["COLOR", "SLATE"]
    #           repeat_frame_msec: 1
    #         },
    #         output_locking_mode: 'EPOCH_LOCKING', # accepts ["EPOCH_LOCKING", "PIPELINE_LOCKING"]
    #         output_timing_source: 'INPUT_CLOCK', # accepts ["INPUT_CLOCK", "SYSTEM_CLOCK"]
    #         support_low_framerate_inputs: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       motion_graphics_configuration: {
    #         motion_graphics_insertion: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #         motion_graphics_settings: {
    #           html_motion_graphics_settings: { }
    #         } # required
    #       },
    #       nielsen_configuration: {
    #         distributor_id: 'DistributorId',
    #         nielsen_pcm_to_id3_tagging: 'DISABLED' # accepts ["DISABLED", "ENABLED"]
    #       },
    #       output_groups: [
    #         {
    #           name: 'Name',
    #           output_group_settings: {
    #             archive_group_settings: {
    #               archive_cdn_settings: {
    #                 archive_s3_settings: {
    #                   canned_acl: 'AUTHENTICATED_READ' # accepts ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #                 }
    #               },
    #               destination: {
    #                 destination_ref_id: 'DestinationRefId'
    #               }, # required
    #               rollover_interval: 1
    #             },
    #             frame_capture_group_settings: {
    #               frame_capture_cdn_settings: {
    #                 frame_capture_s3_settings: {
    #                   canned_acl: 'AUTHENTICATED_READ' # accepts ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #                 }
    #               }
    #             },
    #             hls_group_settings: {
    #               ad_markers: [
    #                 'ADOBE' # accepts ["ADOBE", "ELEMENTAL", "ELEMENTAL_SCTE35"]
    #               ],
    #               base_url_content: 'BaseUrlContent',
    #               base_url_content1: 'BaseUrlContent1',
    #               base_url_manifest: 'BaseUrlManifest',
    #               base_url_manifest1: 'BaseUrlManifest1',
    #               caption_language_mappings: [
    #                 {
    #                   caption_channel: 1, # required
    #                   language_code: 'LanguageCode', # required
    #                   language_description: 'LanguageDescription' # required
    #                 }
    #               ],
    #               caption_language_setting: 'INSERT', # accepts ["INSERT", "NONE", "OMIT"]
    #               client_cache: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               codec_specification: 'RFC_4281', # accepts ["RFC_4281", "RFC_6381"]
    #               constant_iv: 'ConstantIv',
    #               directory_structure: 'SINGLE_DIRECTORY', # accepts ["SINGLE_DIRECTORY", "SUBDIRECTORY_PER_STREAM"]
    #               discontinuity_tags: 'INSERT', # accepts ["INSERT", "NEVER_INSERT"]
    #               encryption_type: 'AES128', # accepts ["AES128", "SAMPLE_AES"]
    #               hls_cdn_settings: {
    #                 hls_akamai_settings: {
    #                   connection_retry_interval: 1,
    #                   filecache_duration: 1,
    #                   http_transfer_mode: 'CHUNKED', # accepts ["CHUNKED", "NON_CHUNKED"]
    #                   num_retries: 1,
    #                   restart_delay: 1,
    #                   salt: 'Salt',
    #                   token: 'Token'
    #                 },
    #                 hls_basic_put_settings: {
    #                   connection_retry_interval: 1,
    #                   filecache_duration: 1,
    #                   num_retries: 1,
    #                   restart_delay: 1
    #                 },
    #                 hls_media_store_settings: {
    #                   connection_retry_interval: 1,
    #                   filecache_duration: 1,
    #                   media_store_storage_class: 'TEMPORAL', # accepts ["TEMPORAL"]
    #                   num_retries: 1,
    #                   restart_delay: 1
    #                 },
    #                 hls_s3_settings: {
    #                   canned_acl: 'AUTHENTICATED_READ' # accepts ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #                 },
    #                 hls_webdav_settings: {
    #                   connection_retry_interval: 1,
    #                   filecache_duration: 1,
    #                   http_transfer_mode: 'CHUNKED', # accepts ["CHUNKED", "NON_CHUNKED"]
    #                   num_retries: 1,
    #                   restart_delay: 1
    #                 }
    #               },
    #               hls_id3_segment_tagging: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               i_frame_only_playlists: 'DISABLED', # accepts ["DISABLED", "STANDARD"]
    #               incomplete_segment_behavior: 'AUTO', # accepts ["AUTO", "SUPPRESS"]
    #               index_n_segments: 1,
    #               input_loss_action: 'EMIT_OUTPUT', # accepts ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #               iv_in_manifest: 'EXCLUDE', # accepts ["EXCLUDE", "INCLUDE"]
    #               iv_source: 'EXPLICIT', # accepts ["EXPLICIT", "FOLLOWS_SEGMENT_NUMBER"]
    #               keep_segments: 1,
    #               key_format: 'KeyFormat',
    #               key_format_versions: 'KeyFormatVersions',
    #               key_provider_settings: {
    #                 static_key_settings: {
    #                   static_key_value: 'StaticKeyValue' # required
    #                 }
    #               },
    #               manifest_compression: 'GZIP', # accepts ["GZIP", "NONE"]
    #               manifest_duration_format: 'FLOATING_POINT', # accepts ["FLOATING_POINT", "INTEGER"]
    #               min_segment_length: 1,
    #               mode: 'LIVE', # accepts ["LIVE", "VOD"]
    #               output_selection: 'MANIFESTS_AND_SEGMENTS', # accepts ["MANIFESTS_AND_SEGMENTS", "SEGMENTS_ONLY", "VARIANT_MANIFESTS_AND_SEGMENTS"]
    #               program_date_time: 'EXCLUDE', # accepts ["EXCLUDE", "INCLUDE"]
    #               program_date_time_clock: 'INITIALIZE_FROM_OUTPUT_TIMECODE', # accepts ["INITIALIZE_FROM_OUTPUT_TIMECODE", "SYSTEM_CLOCK"]
    #               program_date_time_period: 1,
    #               redundant_manifest: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               segment_length: 1,
    #               segmentation_mode: 'USE_INPUT_SEGMENTATION', # accepts ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #               segments_per_subdirectory: 1,
    #               stream_inf_resolution: 'EXCLUDE', # accepts ["EXCLUDE", "INCLUDE"]
    #               timed_metadata_id3_frame: 'NONE', # accepts ["NONE", "PRIV", "TDRL"]
    #               timed_metadata_id3_period: 1,
    #               timestamp_delta_milliseconds: 1,
    #               ts_file_mode: 'SEGMENTED_FILES' # accepts ["SEGMENTED_FILES", "SINGLE_FILE"]
    #             },
    #             media_package_group_settings: {
    #             },
    #             ms_smooth_group_settings: {
    #               acquisition_point_id: 'AcquisitionPointId',
    #               audio_only_timecode_control: 'PASSTHROUGH', # accepts ["PASSTHROUGH", "USE_CONFIGURED_CLOCK"]
    #               certificate_mode: 'SELF_SIGNED', # accepts ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #               connection_retry_interval: 1,
    #               event_id: 'EventId',
    #               event_id_mode: 'NO_EVENT_ID', # accepts ["NO_EVENT_ID", "USE_CONFIGURED", "USE_TIMESTAMP"]
    #               event_stop_behavior: 'NONE', # accepts ["NONE", "SEND_EOS"]
    #               filecache_duration: 1,
    #               fragment_length: 1,
    #               input_loss_action: 'EMIT_OUTPUT', # accepts ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #               num_retries: 1,
    #               restart_delay: 1,
    #               segmentation_mode: 'USE_INPUT_SEGMENTATION', # accepts ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #               send_delay_ms: 1,
    #               sparse_track_type: 'NONE', # accepts ["NONE", "SCTE_35", "SCTE_35_WITHOUT_SEGMENTATION"]
    #               stream_manifest_behavior: 'DO_NOT_SEND', # accepts ["DO_NOT_SEND", "SEND"]
    #               timestamp_offset: 'TimestampOffset',
    #               timestamp_offset_mode: 'USE_CONFIGURED_OFFSET' # accepts ["USE_CONFIGURED_OFFSET", "USE_EVENT_START_DATE"]
    #             },
    #             multiplex_group_settings: { },
    #             rtmp_group_settings: {
    #               ad_markers: [
    #                 'ON_CUE_POINT_SCTE35' # accepts ["ON_CUE_POINT_SCTE35"]
    #               ],
    #               authentication_scheme: 'AKAMAI', # accepts ["AKAMAI", "COMMON"]
    #               cache_full_behavior: 'DISCONNECT_IMMEDIATELY', # accepts ["DISCONNECT_IMMEDIATELY", "WAIT_FOR_SERVER"]
    #               cache_length: 1,
    #               caption_data: 'ALL', # accepts ["ALL", "FIELD1_608", "FIELD1_AND_FIELD2_608"]
    #               input_loss_action: 'EMIT_OUTPUT', # accepts ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #               restart_delay: 1
    #             },
    #             udp_group_settings: {
    #               input_loss_action: 'DROP_PROGRAM', # accepts ["DROP_PROGRAM", "DROP_TS", "EMIT_PROGRAM"]
    #               timed_metadata_id3_frame: 'NONE', # accepts ["NONE", "PRIV", "TDRL"]
    #               timed_metadata_id3_period: 1
    #             }
    #           }, # required
    #           outputs: [
    #             {
    #               audio_description_names: [
    #                 'member'
    #               ],
    #               output_name: 'OutputName',
    #               output_settings: {
    #                 archive_output_settings: {
    #                   container_settings: {
    #                     m2ts_settings: {
    #                       absent_input_audio_behavior: 'DROP', # accepts ["DROP", "ENCODE_SILENCE"]
    #                       arib: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #                       arib_captions_pid: 'AribCaptionsPid',
    #                       arib_captions_pid_control: 'AUTO', # accepts ["AUTO", "USE_CONFIGURED"]
    #                       audio_buffer_model: 'ATSC', # accepts ["ATSC", "DVB"]
    #                       audio_frames_per_pes: 1,
    #                       audio_pids: 'AudioPids',
    #                       audio_stream_type: 'ATSC', # accepts ["ATSC", "DVB"]
    #                       bitrate: 1,
    #                       buffer_model: 'MULTIPLEX', # accepts ["MULTIPLEX", "NONE"]
    #                       cc_descriptor: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #                       dvb_nit_settings: {
    #                         network_id: 1, # required
    #                         network_name: 'NetworkName', # required
    #                         rep_interval: 1
    #                       },
    #                       dvb_sdt_settings: {
    #                         output_sdt: 'SDT_FOLLOW', # accepts ["SDT_FOLLOW", "SDT_FOLLOW_IF_PRESENT", "SDT_MANUAL", "SDT_NONE"]
    #                         rep_interval: 1,
    #                         service_name: 'ServiceName',
    #                         service_provider_name: 'ServiceProviderName'
    #                       },
    #                       dvb_sub_pids: 'DvbSubPids',
    #                       dvb_tdt_settings: {
    #                         rep_interval: 1
    #                       },
    #                       dvb_teletext_pid: 'DvbTeletextPid',
    #                       ebif: 'NONE', # accepts ["NONE", "PASSTHROUGH"]
    #                       ebp_audio_interval: 'VIDEO_AND_FIXED_INTERVALS', # accepts ["VIDEO_AND_FIXED_INTERVALS", "VIDEO_INTERVAL"]
    #                       ebp_lookahead_ms: 1,
    #                       ebp_placement: 'VIDEO_AND_AUDIO_PIDS', # accepts ["VIDEO_AND_AUDIO_PIDS", "VIDEO_PID"]
    #                       ecm_pid: 'EcmPid',
    #                       es_rate_in_pes: 'EXCLUDE', # accepts ["EXCLUDE", "INCLUDE"]
    #                       etv_platform_pid: 'EtvPlatformPid',
    #                       etv_signal_pid: 'EtvSignalPid',
    #                       fragment_time: 1.0,
    #                       klv: 'NONE', # accepts ["NONE", "PASSTHROUGH"]
    #                       klv_data_pids: 'KlvDataPids',
    #                       nielsen_id3_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                       null_packet_bitrate: 1.0,
    #                       pat_interval: 1,
    #                       pcr_control: 'CONFIGURED_PCR_PERIOD', # accepts ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #                       pcr_period: 1,
    #                       pcr_pid: 'PcrPid',
    #                       pmt_interval: 1,
    #                       pmt_pid: 'PmtPid',
    #                       program_num: 1,
    #                       rate_mode: 'CBR', # accepts ["CBR", "VBR"]
    #                       scte27_pids: 'Scte27Pids',
    #                       scte35_control: 'NONE', # accepts ["NONE", "PASSTHROUGH"]
    #                       scte35_pid: 'Scte35Pid',
    #                       segmentation_markers: 'EBP', # accepts ["EBP", "EBP_LEGACY", "NONE", "PSI_SEGSTART", "RAI_ADAPT", "RAI_SEGSTART"]
    #                       segmentation_style: 'MAINTAIN_CADENCE', # accepts ["MAINTAIN_CADENCE", "RESET_CADENCE"]
    #                       segmentation_time: 1.0,
    #                       timed_metadata_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                       timed_metadata_pid: 'TimedMetadataPid',
    #                       transport_stream_id: 1,
    #                       video_pid: 'VideoPid'
    #                     },
    #                     raw_settings: { }
    #                   }, # required
    #                   extension: 'Extension',
    #                   name_modifier: 'NameModifier'
    #                 },
    #                 frame_capture_output_settings: {
    #                   name_modifier: 'NameModifier'
    #                 },
    #                 hls_output_settings: {
    #                   h265_packaging_type: 'HEV1', # accepts ["HEV1", "HVC1"]
    #                   hls_settings: {
    #                     audio_only_hls_settings: {
    #                       audio_group_id: 'AudioGroupId',
    #                       audio_track_type: 'ALTERNATE_AUDIO_AUTO_SELECT', # accepts ["ALTERNATE_AUDIO_AUTO_SELECT", "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT", "ALTERNATE_AUDIO_NOT_AUTO_SELECT", "AUDIO_ONLY_VARIANT_STREAM"]
    #                       segment_type: 'AAC' # accepts ["AAC", "FMP4"]
    #                     },
    #                     fmp4_hls_settings: {
    #                       audio_rendition_sets: 'AudioRenditionSets',
    #                       nielsen_id3_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                       timed_metadata_behavior: 'NO_PASSTHROUGH' # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                     },
    #                     frame_capture_hls_settings: { },
    #                     standard_hls_settings: {
    #                       audio_rendition_sets: 'AudioRenditionSets',
    #                       m3u8_settings: {
    #                         audio_frames_per_pes: 1,
    #                         audio_pids: 'AudioPids',
    #                         ecm_pid: 'EcmPid',
    #                         nielsen_id3_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                         pat_interval: 1,
    #                         pcr_control: 'CONFIGURED_PCR_PERIOD', # accepts ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #                         pcr_period: 1,
    #                         pcr_pid: 'PcrPid',
    #                         pmt_interval: 1,
    #                         pmt_pid: 'PmtPid',
    #                         program_num: 1,
    #                         scte35_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                         scte35_pid: 'Scte35Pid',
    #                         timed_metadata_behavior: 'NO_PASSTHROUGH', # accepts ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #                         timed_metadata_pid: 'TimedMetadataPid',
    #                         transport_stream_id: 1,
    #                         video_pid: 'VideoPid'
    #                       } # required
    #                     }
    #                   }, # required
    #                   name_modifier: 'NameModifier',
    #                   segment_modifier: 'SegmentModifier'
    #                 },
    #                 media_package_output_settings: { },
    #                 ms_smooth_output_settings: {
    #                   h265_packaging_type: 'HEV1', # accepts ["HEV1", "HVC1"]
    #                   name_modifier: 'NameModifier'
    #                 },
    #                 multiplex_output_settings: {
    #                 },
    #                 rtmp_output_settings: {
    #                   certificate_mode: 'SELF_SIGNED', # accepts ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #                   connection_retry_interval: 1,
    #                   num_retries: 1
    #                 },
    #                 udp_output_settings: {
    #                   buffer_msec: 1,
    #                   container_settings: {
    #                   }, # required
    #                   fec_output_settings: {
    #                     column_depth: 1,
    #                     include_fec: 'COLUMN', # accepts ["COLUMN", "COLUMN_AND_ROW"]
    #                     row_length: 1
    #                   }
    #                 }
    #               }, # required
    #               video_description_name: 'VideoDescriptionName'
    #             }
    #           ] # required
    #         }
    #       ], # required
    #       timecode_config: {
    #         source: 'EMBEDDED', # required - accepts ["EMBEDDED", "SYSTEMCLOCK", "ZEROBASED"]
    #         sync_threshold: 1
    #       }, # required
    #       video_descriptions: [
    #         {
    #           codec_settings: {
    #             frame_capture_settings: {
    #               capture_interval: 1,
    #               capture_interval_units: 'MILLISECONDS' # accepts ["MILLISECONDS", "SECONDS"]
    #             },
    #             h264_settings: {
    #               adaptive_quantization: 'AUTO', # accepts ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #               afd_signaling: 'AUTO', # accepts ["AUTO", "FIXED", "NONE"]
    #               bitrate: 1,
    #               buf_fill_pct: 1,
    #               buf_size: 1,
    #               color_metadata: 'IGNORE', # accepts ["IGNORE", "INSERT"]
    #               color_space_settings: {
    #                 color_space_passthrough_settings: { },
    #                 rec601_settings: { },
    #                 rec709_settings: { }
    #               },
    #               entropy_encoding: 'CABAC', # accepts ["CABAC", "CAVLC"]
    #               filter_settings: {
    #                 temporal_filter_settings: {
    #                   post_filter_sharpening: 'AUTO', # accepts ["AUTO", "DISABLED", "ENABLED"]
    #                   strength: 'AUTO' # accepts ["AUTO", "STRENGTH_1", "STRENGTH_2", "STRENGTH_3", "STRENGTH_4", "STRENGTH_5", "STRENGTH_6", "STRENGTH_7", "STRENGTH_8", "STRENGTH_9", "STRENGTH_10", "STRENGTH_11", "STRENGTH_12", "STRENGTH_13", "STRENGTH_14", "STRENGTH_15", "STRENGTH_16"]
    #                 }
    #               },
    #               fixed_afd: 'AFD_0000', # accepts ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #               flicker_aq: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               force_field_pictures: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               framerate_control: 'INITIALIZE_FROM_SOURCE', # accepts ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #               framerate_denominator: 1,
    #               framerate_numerator: 1,
    #               gop_b_reference: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               gop_closed_cadence: 1,
    #               gop_num_b_frames: 1,
    #               gop_size: 1.0,
    #               gop_size_units: 'FRAMES', # accepts ["FRAMES", "SECONDS"]
    #               level: 'H264_LEVEL_1', # accepts ["H264_LEVEL_1", "H264_LEVEL_1_1", "H264_LEVEL_1_2", "H264_LEVEL_1_3", "H264_LEVEL_2", "H264_LEVEL_2_1", "H264_LEVEL_2_2", "H264_LEVEL_3", "H264_LEVEL_3_1", "H264_LEVEL_3_2", "H264_LEVEL_4", "H264_LEVEL_4_1", "H264_LEVEL_4_2", "H264_LEVEL_5", "H264_LEVEL_5_1", "H264_LEVEL_5_2", "H264_LEVEL_AUTO"]
    #               look_ahead_rate_control: 'HIGH', # accepts ["HIGH", "LOW", "MEDIUM"]
    #               max_bitrate: 1,
    #               min_i_interval: 1,
    #               num_ref_frames: 1,
    #               par_control: 'INITIALIZE_FROM_SOURCE', # accepts ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #               par_denominator: 1,
    #               par_numerator: 1,
    #               profile: 'BASELINE', # accepts ["BASELINE", "HIGH", "HIGH_10BIT", "HIGH_422", "HIGH_422_10BIT", "MAIN"]
    #               quality_level: 'ENHANCED_QUALITY', # accepts ["ENHANCED_QUALITY", "STANDARD_QUALITY"]
    #               qvbr_quality_level: 1,
    #               rate_control_mode: 'CBR', # accepts ["CBR", "MULTIPLEX", "QVBR", "VBR"]
    #               scan_type: 'INTERLACED', # accepts ["INTERLACED", "PROGRESSIVE"]
    #               scene_change_detect: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               slices: 1,
    #               softness: 1,
    #               spatial_aq: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               subgop_length: 'DYNAMIC', # accepts ["DYNAMIC", "FIXED"]
    #               syntax: 'DEFAULT', # accepts ["DEFAULT", "RP2027"]
    #               temporal_aq: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               timecode_insertion: 'DISABLED' # accepts ["DISABLED", "PIC_TIMING_SEI"]
    #             },
    #             h265_settings: {
    #               adaptive_quantization: 'AUTO', # accepts ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #               afd_signaling: 'AUTO', # accepts ["AUTO", "FIXED", "NONE"]
    #               alternative_transfer_function: 'INSERT', # accepts ["INSERT", "OMIT"]
    #               bitrate: 1,
    #               buf_size: 1,
    #               color_metadata: 'IGNORE', # accepts ["IGNORE", "INSERT"]
    #               color_space_settings: {
    #                 hdr10_settings: {
    #                   max_cll: 1,
    #                   max_fall: 1
    #                 },
    #               },
    #               filter_settings: {
    #               },
    #               fixed_afd: 'AFD_0000', # accepts ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #               flicker_aq: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               framerate_denominator: 1, # required
    #               framerate_numerator: 1, # required
    #               gop_closed_cadence: 1,
    #               gop_size: 1.0,
    #               gop_size_units: 'FRAMES', # accepts ["FRAMES", "SECONDS"]
    #               level: 'H265_LEVEL_1', # accepts ["H265_LEVEL_1", "H265_LEVEL_2", "H265_LEVEL_2_1", "H265_LEVEL_3", "H265_LEVEL_3_1", "H265_LEVEL_4", "H265_LEVEL_4_1", "H265_LEVEL_5", "H265_LEVEL_5_1", "H265_LEVEL_5_2", "H265_LEVEL_6", "H265_LEVEL_6_1", "H265_LEVEL_6_2", "H265_LEVEL_AUTO"]
    #               look_ahead_rate_control: 'HIGH', # accepts ["HIGH", "LOW", "MEDIUM"]
    #               max_bitrate: 1,
    #               min_i_interval: 1,
    #               par_denominator: 1,
    #               par_numerator: 1,
    #               profile: 'MAIN', # accepts ["MAIN", "MAIN_10BIT"]
    #               qvbr_quality_level: 1,
    #               rate_control_mode: 'CBR', # accepts ["CBR", "MULTIPLEX", "QVBR"]
    #               scan_type: 'INTERLACED', # accepts ["INTERLACED", "PROGRESSIVE"]
    #               scene_change_detect: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #               slices: 1,
    #               tier: 'HIGH', # accepts ["HIGH", "MAIN"]
    #               timecode_insertion: 'DISABLED' # accepts ["DISABLED", "PIC_TIMING_SEI"]
    #             },
    #             mpeg2_settings: {
    #               adaptive_quantization: 'AUTO', # accepts ["AUTO", "HIGH", "LOW", "MEDIUM", "OFF"]
    #               afd_signaling: 'AUTO', # accepts ["AUTO", "FIXED", "NONE"]
    #               color_metadata: 'IGNORE', # accepts ["IGNORE", "INSERT"]
    #               color_space: 'AUTO', # accepts ["AUTO", "PASSTHROUGH"]
    #               display_aspect_ratio: 'DISPLAYRATIO16X9', # accepts ["DISPLAYRATIO16X9", "DISPLAYRATIO4X3"]
    #               filter_settings: {
    #               },
    #               fixed_afd: 'AFD_0000', # accepts ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #               framerate_denominator: 1, # required
    #               framerate_numerator: 1, # required
    #               gop_closed_cadence: 1,
    #               gop_num_b_frames: 1,
    #               gop_size: 1.0,
    #               gop_size_units: 'FRAMES', # accepts ["FRAMES", "SECONDS"]
    #               scan_type: 'INTERLACED', # accepts ["INTERLACED", "PROGRESSIVE"]
    #               subgop_length: 'DYNAMIC', # accepts ["DYNAMIC", "FIXED"]
    #               timecode_insertion: 'DISABLED' # accepts ["DISABLED", "GOP_TIMECODE"]
    #             }
    #           },
    #           height: 1,
    #           name: 'Name', # required
    #           respond_to_afd: 'NONE', # accepts ["NONE", "PASSTHROUGH", "RESPOND"]
    #           scaling_behavior: 'DEFAULT', # accepts ["DEFAULT", "STRETCH_TO_OUTPUT"]
    #           sharpness: 1,
    #           width: 1
    #         }
    #       ] # required
    #     },
    #     input_attachments: [
    #       {
    #         automatic_input_failover_settings: {
    #           error_clear_time_msec: 1,
    #           failover_conditions: [
    #             {
    #               failover_condition_settings: {
    #                 audio_silence_settings: {
    #                   audio_selector_name: 'AudioSelectorName', # required
    #                   audio_silence_threshold_msec: 1
    #                 },
    #                 input_loss_settings: {
    #                   input_loss_threshold_msec: 1
    #                 },
    #                 video_black_settings: {
    #                   black_detect_threshold: 1.0,
    #                   video_black_threshold_msec: 1
    #                 }
    #               }
    #             }
    #           ],
    #           input_preference: 'EQUAL_INPUT_PREFERENCE', # accepts ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #           secondary_input_id: 'SecondaryInputId' # required
    #         },
    #         input_attachment_name: 'InputAttachmentName',
    #         input_id: 'InputId',
    #         input_settings: {
    #           audio_selectors: [
    #             {
    #               name: 'Name', # required
    #               selector_settings: {
    #                 audio_hls_rendition_selection: {
    #                   group_id: 'GroupId', # required
    #                   name: 'Name' # required
    #                 },
    #                 audio_language_selection: {
    #                   language_code: 'LanguageCode', # required
    #                   language_selection_policy: 'LOOSE' # accepts ["LOOSE", "STRICT"]
    #                 },
    #                 audio_pid_selection: {
    #                   pid: 1 # required
    #                 },
    #                 audio_track_selection: {
    #                   tracks: [
    #                     {
    #                       track: 1 # required
    #                     }
    #                   ] # required
    #                 }
    #               }
    #             }
    #           ],
    #           caption_selectors: [
    #             {
    #               language_code: 'LanguageCode',
    #               name: 'Name', # required
    #               selector_settings: {
    #                 ancillary_source_settings: {
    #                   source_ancillary_channel_number: 1
    #                 },
    #                 arib_source_settings: { },
    #                 dvb_sub_source_settings: {
    #                   ocr_language: 'DEU', # accepts ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #                   pid: 1
    #                 },
    #                 embedded_source_settings: {
    #                   convert608_to708: 'DISABLED', # accepts ["DISABLED", "UPCONVERT"]
    #                   scte20_detection: 'AUTO', # accepts ["AUTO", "OFF"]
    #                   source608_channel_number: 1,
    #                   source608_track_number: 1
    #                 },
    #                 scte20_source_settings: {
    #                   convert608_to708: 'DISABLED', # accepts ["DISABLED", "UPCONVERT"]
    #                   source608_channel_number: 1
    #                 },
    #                 scte27_source_settings: {
    #                   ocr_language: 'DEU', # accepts ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #                   pid: 1
    #                 },
    #                 teletext_source_settings: {
    #                   output_rectangle: {
    #                     height: 1.0, # required
    #                     left_offset: 1.0, # required
    #                     top_offset: 1.0, # required
    #                     width: 1.0 # required
    #                   },
    #                   page_number: 'PageNumber'
    #                 }
    #               }
    #             }
    #           ],
    #           deblock_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #           denoise_filter: 'DISABLED', # accepts ["DISABLED", "ENABLED"]
    #           filter_strength: 1,
    #           input_filter: 'AUTO', # accepts ["AUTO", "DISABLED", "FORCED"]
    #           network_input_settings: {
    #             hls_input_settings: {
    #               bandwidth: 1,
    #               buffer_segments: 1,
    #               retries: 1,
    #               retry_interval: 1,
    #               scte35_source: 'MANIFEST' # accepts ["MANIFEST", "SEGMENTS"]
    #             },
    #             server_validation: 'CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME' # accepts ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #           },
    #           scte35_pid: 1,
    #           smpte2038_data_preference: 'IGNORE', # accepts ["IGNORE", "PREFER"]
    #           source_end_behavior: 'CONTINUE', # accepts ["CONTINUE", "LOOP"]
    #           video_selector: {
    #             color_space: 'FOLLOW', # accepts ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #             color_space_settings: {
    #             },
    #             color_space_usage: 'FALLBACK', # accepts ["FALLBACK", "FORCE"]
    #             selector_settings: {
    #               video_selector_pid: {
    #                 pid: 1
    #               },
    #               video_selector_program_id: {
    #                 program_id: 1
    #               }
    #             }
    #           }
    #         }
    #       }
    #     ],
    #     input_specification: {
    #       codec: 'MPEG2', # accepts ["MPEG2", "AVC", "HEVC"]
    #       maximum_bitrate: 'MAX_10_MBPS', # accepts ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #       resolution: 'SD' # accepts ["SD", "HD", "UHD"]
    #     },
    #     log_level: 'ERROR', # accepts ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #     maintenance: {
    #       maintenance_day: 'MONDAY', # accepts ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #       maintenance_scheduled_date: 'MaintenanceScheduledDate',
    #       maintenance_start_time: 'MaintenanceStartTime'
    #     },
    #     name: 'Name',
    #     role_arn: 'RoleArn'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::UpdateChannelOutput
    #   resp.data.channel #=> Types::Channel
    #   resp.data.channel.arn #=> String
    #   resp.data.channel.cdi_input_specification #=> Types::CdiInputSpecification
    #   resp.data.channel.cdi_input_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.channel.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.channel.destinations #=> Array<OutputDestination>
    #   resp.data.channel.destinations[0] #=> Types::OutputDestination
    #   resp.data.channel.destinations[0].id #=> String
    #   resp.data.channel.destinations[0].media_package_settings #=> Array<MediaPackageOutputDestinationSettings>
    #   resp.data.channel.destinations[0].media_package_settings[0] #=> Types::MediaPackageOutputDestinationSettings
    #   resp.data.channel.destinations[0].media_package_settings[0].channel_id #=> String
    #   resp.data.channel.destinations[0].multiplex_settings #=> Types::MultiplexProgramChannelDestinationSettings
    #   resp.data.channel.destinations[0].multiplex_settings.multiplex_id #=> String
    #   resp.data.channel.destinations[0].multiplex_settings.program_name #=> String
    #   resp.data.channel.destinations[0].settings #=> Array<OutputDestinationSettings>
    #   resp.data.channel.destinations[0].settings[0] #=> Types::OutputDestinationSettings
    #   resp.data.channel.destinations[0].settings[0].password_param #=> String
    #   resp.data.channel.destinations[0].settings[0].stream_name #=> String
    #   resp.data.channel.destinations[0].settings[0].url #=> String
    #   resp.data.channel.destinations[0].settings[0].username #=> String
    #   resp.data.channel.egress_endpoints #=> Array<ChannelEgressEndpoint>
    #   resp.data.channel.egress_endpoints[0] #=> Types::ChannelEgressEndpoint
    #   resp.data.channel.egress_endpoints[0].source_ip #=> String
    #   resp.data.channel.encoder_settings #=> Types::EncoderSettings
    #   resp.data.channel.encoder_settings.audio_descriptions #=> Array<AudioDescription>
    #   resp.data.channel.encoder_settings.audio_descriptions[0] #=> Types::AudioDescription
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings #=> Types::AudioNormalizationSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm #=> String, one of ["ITU_1770_1", "ITU_1770_2"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm_control #=> String, one of ["CORRECT_AUDIO"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings.target_lkfs #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_selector_name #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_type #=> String, one of ["CLEAN_EFFECTS", "HEARING_IMPAIRED", "UNDEFINED", "VISUAL_IMPAIRED_COMMENTARY"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_type_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings #=> Types::AudioWatermarkSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings #=> Types::NielsenWatermarksSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings #=> Types::NielsenCBET
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_check_digit_string #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_stepaside #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.csid #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_distribution_type #=> String, one of ["FINAL_DISTRIBUTOR", "PROGRAM_CONTENT"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings #=> Types::NielsenNaesIiNw
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.check_digit_string #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.sid #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings #=> Types::AudioCodecSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings #=> Types::AacSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.coding_mode #=> String, one of ["AD_RECEIVER_MIX", "CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_5_1"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.input_type #=> String, one of ["BROADCASTER_MIXED_AD", "NORMAL"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.profile #=> String, one of ["HEV1", "HEV2", "LC"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.rate_control_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.raw_format #=> String, one of ["LATM_LOAS", "NONE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.sample_rate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.spec #=> String, one of ["MPEG2", "MPEG4"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.vbr_quality #=> String, one of ["HIGH", "LOW", "MEDIUM_HIGH", "MEDIUM_LOW"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings #=> Types::Ac3Settings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "DIALOGUE", "EMERGENCY", "HEARING_IMPAIRED", "MUSIC_AND_EFFECTS", "VISUALLY_IMPAIRED", "VOICE_OVER"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_3_2_LFE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.dialnorm #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.drc_profile #=> String, one of ["FILM_STANDARD", "NONE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings #=> Types::Eac3Settings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.attenuation_control #=> String, one of ["ATTENUATE_3_DB", "NONE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "EMERGENCY", "HEARING_IMPAIRED", "VISUALLY_IMPAIRED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_3_2"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dc_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dialnorm #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_line #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_rf #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_control #=> String, one of ["LFE", "NO_LFE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_center_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_surround_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_center_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_surround_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.passthrough_control #=> String, one of ["NO_PASSTHROUGH", "WHEN_POSSIBLE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.phase_control #=> String, one of ["NO_SHIFT", "SHIFT_90_DEGREES"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.stereo_downmix #=> String, one of ["DPL2", "LO_RO", "LT_RT", "NOT_INDICATED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_ex_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings #=> Types::Mp2Settings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.sample_rate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.pass_through_settings #=> Types::PassThroughSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings #=> Types::WavSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.bit_depth #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_4_0", "CODING_MODE_8_0"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.sample_rate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].language_code #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].language_code_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].name #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings #=> Types::RemixSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings #=> Array<AudioChannelMapping>
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0] #=> Types::AudioChannelMapping
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels #=> Array<InputChannelLevel>
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0] #=> Types::InputChannelLevel
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].gain #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].input_channel #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].output_channel #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channels_in #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channels_out #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].stream_name #=> String
    #   resp.data.channel.encoder_settings.avail_blanking #=> Types::AvailBlanking
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image.password_param #=> String
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image.uri #=> String
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image.username #=> String
    #   resp.data.channel.encoder_settings.avail_blanking.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.avail_configuration #=> Types::AvailConfiguration
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings #=> Types::AvailSettings
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert #=> Types::Scte35SpliceInsert
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.ad_avail_offset #=> Integer
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos #=> Types::Scte35TimeSignalApos
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.ad_avail_offset #=> Integer
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.blackout_slate #=> Types::BlackoutSlate
    #   resp.data.channel.encoder_settings.blackout_slate.blackout_slate_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.blackout_slate.network_end_blackout #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.blackout_slate.network_end_blackout_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.blackout_slate.network_id #=> String
    #   resp.data.channel.encoder_settings.blackout_slate.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.caption_descriptions #=> Array<CaptionDescription>
    #   resp.data.channel.encoder_settings.caption_descriptions[0] #=> Types::CaptionDescription
    #   resp.data.channel.encoder_settings.caption_descriptions[0].caption_selector_name #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings #=> Types::CaptionDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.arib_destination_settings #=> Types::AribDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings #=> Types::BurnInDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_resolution #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_size #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_size #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.x_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.y_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings #=> Types::DvbSubDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_resolution #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_size #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_size #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.x_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.y_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings #=> Types::EbuTtDDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.copyright_holder #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.fill_line_gap #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.font_family #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.style_control #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.embedded_destination_settings #=> Types::EmbeddedDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.embedded_plus_scte20_destination_settings #=> Types::EmbeddedPlusScte20DestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.rtmp_caption_info_destination_settings #=> Types::RtmpCaptionInfoDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.scte20_plus_embedded_destination_settings #=> Types::Scte20PlusEmbeddedDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.scte27_destination_settings #=> Types::Scte27DestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.smpte_tt_destination_settings #=> Types::SmpteTtDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.teletext_destination_settings #=> Types::TeletextDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings #=> Types::TtmlDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings.style_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings #=> Types::WebvttDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings.style_control #=> String, one of ["NO_STYLE_DATA", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].language_code #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].language_description #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].name #=> String
    #   resp.data.channel.encoder_settings.feature_activations #=> Types::FeatureActivations
    #   resp.data.channel.encoder_settings.feature_activations.input_prepare_schedule_actions #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.global_configuration #=> Types::GlobalConfiguration
    #   resp.data.channel.encoder_settings.global_configuration.initial_audio_gain #=> Integer
    #   resp.data.channel.encoder_settings.global_configuration.input_end_action #=> String, one of ["NONE", "SWITCH_AND_LOOP_INPUTS"]
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior #=> Types::InputLossBehavior
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.black_frame_msec #=> Integer
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_color #=> String
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_slate #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_type #=> String, one of ["COLOR", "SLATE"]
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.repeat_frame_msec #=> Integer
    #   resp.data.channel.encoder_settings.global_configuration.output_locking_mode #=> String, one of ["EPOCH_LOCKING", "PIPELINE_LOCKING"]
    #   resp.data.channel.encoder_settings.global_configuration.output_timing_source #=> String, one of ["INPUT_CLOCK", "SYSTEM_CLOCK"]
    #   resp.data.channel.encoder_settings.global_configuration.support_low_framerate_inputs #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.motion_graphics_configuration #=> Types::MotionGraphicsConfiguration
    #   resp.data.channel.encoder_settings.motion_graphics_configuration.motion_graphics_insertion #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.motion_graphics_configuration.motion_graphics_settings #=> Types::MotionGraphicsSettings
    #   resp.data.channel.encoder_settings.motion_graphics_configuration.motion_graphics_settings.html_motion_graphics_settings #=> Types::HtmlMotionGraphicsSettings
    #   resp.data.channel.encoder_settings.nielsen_configuration #=> Types::NielsenConfiguration
    #   resp.data.channel.encoder_settings.nielsen_configuration.distributor_id #=> String
    #   resp.data.channel.encoder_settings.nielsen_configuration.nielsen_pcm_to_id3_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups #=> Array<OutputGroup>
    #   resp.data.channel.encoder_settings.output_groups[0] #=> Types::OutputGroup
    #   resp.data.channel.encoder_settings.output_groups[0].name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings #=> Types::OutputGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings #=> Types::ArchiveGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings #=> Types::ArchiveCdnSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings #=> Types::ArchiveS3Settings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination.destination_ref_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.rollover_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings #=> Types::FrameCaptureGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings #=> Types::FrameCaptureCdnSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings #=> Types::FrameCaptureS3Settings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings #=> Types::HlsGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers[0] #=> String, one of ["ADOBE", "ELEMENTAL", "ELEMENTAL_SCTE35"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content1 #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest1 #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings #=> Array<CaptionLanguageMapping>
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0] #=> Types::CaptionLanguageMapping
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].caption_channel #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_code #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_description #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_setting #=> String, one of ["INSERT", "NONE", "OMIT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.client_cache #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.codec_specification #=> String, one of ["RFC_4281", "RFC_6381"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.constant_iv #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.directory_structure #=> String, one of ["SINGLE_DIRECTORY", "SUBDIRECTORY_PER_STREAM"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.discontinuity_tags #=> String, one of ["INSERT", "NEVER_INSERT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.encryption_type #=> String, one of ["AES128", "SAMPLE_AES"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings #=> Types::HlsCdnSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings #=> Types::HlsAkamaiSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.salt #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.token #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings #=> Types::HlsBasicPutSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings #=> Types::HlsMediaStoreSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.media_store_storage_class #=> String, one of ["TEMPORAL"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings #=> Types::HlsS3Settings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings #=> Types::HlsWebdavSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_id3_segment_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.i_frame_only_playlists #=> String, one of ["DISABLED", "STANDARD"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.incomplete_segment_behavior #=> String, one of ["AUTO", "SUPPRESS"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.index_n_segments #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_in_manifest #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_source #=> String, one of ["EXPLICIT", "FOLLOWS_SEGMENT_NUMBER"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.keep_segments #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format_versions #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings #=> Types::KeyProviderSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings #=> Types::StaticKeySettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.key_provider_server #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.static_key_value #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_compression #=> String, one of ["GZIP", "NONE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_duration_format #=> String, one of ["FLOATING_POINT", "INTEGER"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.min_segment_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.mode #=> String, one of ["LIVE", "VOD"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.output_selection #=> String, one of ["MANIFESTS_AND_SEGMENTS", "SEGMENTS_ONLY", "VARIANT_MANIFESTS_AND_SEGMENTS"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_clock #=> String, one of ["INITIALIZE_FROM_OUTPUT_TIMECODE", "SYSTEM_CLOCK"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.redundant_manifest #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segment_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segments_per_subdirectory #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.stream_inf_resolution #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timestamp_delta_milliseconds #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ts_file_mode #=> String, one of ["SEGMENTED_FILES", "SINGLE_FILE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings #=> Types::MediaPackageGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings #=> Types::MsSmoothGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.acquisition_point_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.audio_only_timecode_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED_CLOCK"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id_mode #=> String, one of ["NO_EVENT_ID", "USE_CONFIGURED", "USE_TIMESTAMP"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_stop_behavior #=> String, one of ["NONE", "SEND_EOS"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.fragment_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.send_delay_ms #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.sparse_track_type #=> String, one of ["NONE", "SCTE_35", "SCTE_35_WITHOUT_SEGMENTATION"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.stream_manifest_behavior #=> String, one of ["DO_NOT_SEND", "SEND"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset_mode #=> String, one of ["USE_CONFIGURED_OFFSET", "USE_EVENT_START_DATE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.multiplex_group_settings #=> Types::MultiplexGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings #=> Types::RtmpGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers[0] #=> String, one of ["ON_CUE_POINT_SCTE35"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.authentication_scheme #=> String, one of ["AKAMAI", "COMMON"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_full_behavior #=> String, one of ["DISCONNECT_IMMEDIATELY", "WAIT_FOR_SERVER"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.caption_data #=> String, one of ["ALL", "FIELD1_608", "FIELD1_AND_FIELD2_608"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings #=> Types::UdpGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.input_loss_action #=> String, one of ["DROP_PROGRAM", "DROP_TS", "EMIT_PROGRAM"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs #=> Array<Output>
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0] #=> Types::Output
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].audio_description_names #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].audio_description_names[0] #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].caption_description_names #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings #=> Types::OutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings #=> Types::ArchiveOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings #=> Types::ArchiveContainerSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.absent_input_audio_behavior #=> String, one of ["DROP", "ENCODE_SILENCE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid_control #=> String, one of ["AUTO", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_buffer_model #=> String, one of ["ATSC", "DVB"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_frames_per_pes #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_stream_type #=> String, one of ["ATSC", "DVB"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.bitrate #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.buffer_model #=> String, one of ["MULTIPLEX", "NONE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.cc_descriptor #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings #=> Types::DvbNitSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_id #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.rep_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings #=> Types::DvbSdtSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.output_sdt #=> String, one of ["SDT_FOLLOW", "SDT_FOLLOW_IF_PRESENT", "SDT_MANUAL", "SDT_NONE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.rep_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_provider_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sub_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings #=> Types::DvbTdtSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings.rep_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_teletext_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebif #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_audio_interval #=> String, one of ["VIDEO_AND_FIXED_INTERVALS", "VIDEO_INTERVAL"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_lookahead_ms #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_placement #=> String, one of ["VIDEO_AND_AUDIO_PIDS", "VIDEO_PID"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ecm_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.es_rate_in_pes #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_platform_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_signal_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.fragment_time #=> Float
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv_data_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.null_packet_bitrate #=> Float
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pat_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.program_num #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.rate_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte27_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_control #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_markers #=> String, one of ["EBP", "EBP_LEGACY", "NONE", "PSI_SEGSTART", "RAI_ADAPT", "RAI_SEGSTART"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_style #=> String, one of ["MAINTAIN_CADENCE", "RESET_CADENCE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_time #=> Float
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.transport_stream_id #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.video_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.raw_settings #=> Types::RawSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.extension #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings #=> Types::FrameCaptureOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings #=> Types::HlsOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings #=> Types::HlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings #=> Types::AudioOnlyHlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_group_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_only_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_track_type #=> String, one of ["ALTERNATE_AUDIO_AUTO_SELECT", "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT", "ALTERNATE_AUDIO_NOT_AUTO_SELECT", "AUDIO_ONLY_VARIANT_STREAM"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.segment_type #=> String, one of ["AAC", "FMP4"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings #=> Types::Fmp4HlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.audio_rendition_sets #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.frame_capture_hls_settings #=> Types::FrameCaptureHlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings #=> Types::StandardHlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.audio_rendition_sets #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings #=> Types::M3u8Settings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_frames_per_pes #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.ecm_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pat_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.program_num #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.transport_stream_id #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.video_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.segment_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.media_package_output_settings #=> Types::MediaPackageOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings #=> Types::MsSmoothOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings #=> Types::MultiplexOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings #=> Types::RtmpOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings #=> Types::UdpOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.buffer_msec #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings #=> Types::UdpContainerSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings #=> Types::FecOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.column_depth #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.include_fec #=> String, one of ["COLUMN", "COLUMN_AND_ROW"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.row_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].video_description_name #=> String
    #   resp.data.channel.encoder_settings.timecode_config #=> Types::TimecodeConfig
    #   resp.data.channel.encoder_settings.timecode_config.source #=> String, one of ["EMBEDDED", "SYSTEMCLOCK", "ZEROBASED"]
    #   resp.data.channel.encoder_settings.timecode_config.sync_threshold #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions #=> Array<VideoDescription>
    #   resp.data.channel.encoder_settings.video_descriptions[0] #=> Types::VideoDescription
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings #=> Types::VideoCodecSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings #=> Types::FrameCaptureSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval_units #=> String, one of ["MILLISECONDS", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings #=> Types::H264Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_fill_pct #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_size #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings #=> Types::H264ColorSpaceSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.entropy_encoding #=> String, one of ["CABAC", "CAVLC"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings #=> Types::H264FilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.post_filter_sharpening #=> String, one of ["AUTO", "DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.strength #=> String, one of ["AUTO", "STRENGTH_1", "STRENGTH_2", "STRENGTH_3", "STRENGTH_4", "STRENGTH_5", "STRENGTH_6", "STRENGTH_7", "STRENGTH_8", "STRENGTH_9", "STRENGTH_10", "STRENGTH_11", "STRENGTH_12", "STRENGTH_13", "STRENGTH_14", "STRENGTH_15", "STRENGTH_16"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.force_field_pictures #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_b_reference #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_closed_cadence #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_num_b_frames #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size #=> Float
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.level #=> String, one of ["H264_LEVEL_1", "H264_LEVEL_1_1", "H264_LEVEL_1_2", "H264_LEVEL_1_3", "H264_LEVEL_2", "H264_LEVEL_2_1", "H264_LEVEL_2_2", "H264_LEVEL_3", "H264_LEVEL_3_1", "H264_LEVEL_3_2", "H264_LEVEL_4", "H264_LEVEL_4_1", "H264_LEVEL_4_2", "H264_LEVEL_5", "H264_LEVEL_5_1", "H264_LEVEL_5_2", "H264_LEVEL_AUTO"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.max_bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.min_i_interval #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.num_ref_frames #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.profile #=> String, one of ["BASELINE", "HIGH", "HIGH_10BIT", "HIGH_422", "HIGH_422_10BIT", "MAIN"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.quality_level #=> String, one of ["ENHANCED_QUALITY", "STANDARD_QUALITY"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.qvbr_quality_level #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR", "VBR"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.slices #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.softness #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.spatial_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.syntax #=> String, one of ["DEFAULT", "RP2027"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.temporal_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings #=> Types::H265Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.alternative_transfer_function #=> String, one of ["INSERT", "OMIT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.buf_size #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings #=> Types::H265ColorSpaceSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_cll #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_fall #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings #=> Types::H265FilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_closed_cadence #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size #=> Float
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.level #=> String, one of ["H265_LEVEL_1", "H265_LEVEL_2", "H265_LEVEL_2_1", "H265_LEVEL_3", "H265_LEVEL_3_1", "H265_LEVEL_4", "H265_LEVEL_4_1", "H265_LEVEL_5", "H265_LEVEL_5_1", "H265_LEVEL_5_2", "H265_LEVEL_6", "H265_LEVEL_6_1", "H265_LEVEL_6_2", "H265_LEVEL_AUTO"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.max_bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.min_i_interval #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.profile #=> String, one of ["MAIN", "MAIN_10BIT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.qvbr_quality_level #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.slices #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.tier #=> String, one of ["HIGH", "MAIN"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings #=> Types::Mpeg2Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "LOW", "MEDIUM", "OFF"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_space #=> String, one of ["AUTO", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.display_aspect_ratio #=> String, one of ["DISPLAYRATIO16X9", "DISPLAYRATIO4X3"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings #=> Types::Mpeg2FilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_closed_cadence #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_num_b_frames #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size #=> Float
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.timecode_insertion #=> String, one of ["DISABLED", "GOP_TIMECODE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].height #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].name #=> String
    #   resp.data.channel.encoder_settings.video_descriptions[0].respond_to_afd #=> String, one of ["NONE", "PASSTHROUGH", "RESPOND"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].scaling_behavior #=> String, one of ["DEFAULT", "STRETCH_TO_OUTPUT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].sharpness #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].width #=> Integer
    #   resp.data.channel.id #=> String
    #   resp.data.channel.input_attachments #=> Array<InputAttachment>
    #   resp.data.channel.input_attachments[0] #=> Types::InputAttachment
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings #=> Types::AutomaticInputFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.error_clear_time_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions #=> Array<FailoverCondition>
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0] #=> Types::FailoverCondition
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings #=> Types::FailoverConditionSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings #=> Types::AudioSilenceFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_selector_name #=> String
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_silence_threshold_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings #=> Types::InputLossFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings.input_loss_threshold_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings #=> Types::VideoBlackFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.black_detect_threshold #=> Float
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.video_black_threshold_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.input_preference #=> String, one of ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.secondary_input_id #=> String
    #   resp.data.channel.input_attachments[0].input_attachment_name #=> String
    #   resp.data.channel.input_attachments[0].input_id #=> String
    #   resp.data.channel.input_attachments[0].input_settings #=> Types::InputSettings
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors #=> Array<AudioSelector>
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0] #=> Types::AudioSelector
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].name #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings #=> Types::AudioSelectorSettings
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection #=> Types::AudioHlsRenditionSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.group_id #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.name #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection #=> Types::AudioLanguageSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_code #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_selection_policy #=> String, one of ["LOOSE", "STRICT"]
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection #=> Types::AudioPidSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection #=> Types::AudioTrackSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks #=> Array<AudioTrack>
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0] #=> Types::AudioTrack
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0].track #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors #=> Array<CaptionSelector>
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0] #=> Types::CaptionSelector
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].language_code #=> String
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].name #=> String
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings #=> Types::CaptionSelectorSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings #=> Types::AncillarySourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings.source_ancillary_channel_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.arib_source_settings #=> Types::AribSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings #=> Types::DvbSubSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings #=> Types::EmbeddedSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.scte20_detection #=> String, one of ["AUTO", "OFF"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_channel_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_track_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings #=> Types::Scte20SourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.source608_channel_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings #=> Types::Scte27SourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings #=> Types::TeletextSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle #=> Types::CaptionRectangle
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.height #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.left_offset #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.top_offset #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.width #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.page_number #=> String
    #   resp.data.channel.input_attachments[0].input_settings.deblock_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.input_attachments[0].input_settings.denoise_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.input_attachments[0].input_settings.filter_strength #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.input_filter #=> String, one of ["AUTO", "DISABLED", "FORCED"]
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings #=> Types::NetworkInputSettings
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings #=> Types::HlsInputSettings
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.bandwidth #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.buffer_segments #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retries #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retry_interval #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.scte35_source #=> String, one of ["MANIFEST", "SEGMENTS"]
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.server_validation #=> String, one of ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #   resp.data.channel.input_attachments[0].input_settings.scte35_pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.smpte2038_data_preference #=> String, one of ["IGNORE", "PREFER"]
    #   resp.data.channel.input_attachments[0].input_settings.source_end_behavior #=> String, one of ["CONTINUE", "LOOP"]
    #   resp.data.channel.input_attachments[0].input_settings.video_selector #=> Types::VideoSelector
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space #=> String, one of ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space_settings #=> Types::VideoSelectorColorSpaceSettings
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space_usage #=> String, one of ["FALLBACK", "FORCE"]
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings #=> Types::VideoSelectorSettings
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid #=> Types::VideoSelectorPid
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id #=> Types::VideoSelectorProgramId
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id.program_id #=> Integer
    #   resp.data.channel.input_specification #=> Types::InputSpecification
    #   resp.data.channel.input_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC"]
    #   resp.data.channel.input_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.channel.input_specification.resolution #=> String, one of ["SD", "HD", "UHD"]
    #   resp.data.channel.log_level #=> String, one of ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #   resp.data.channel.maintenance #=> Types::MaintenanceStatus
    #   resp.data.channel.maintenance.maintenance_day #=> String, one of ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #   resp.data.channel.maintenance.maintenance_deadline #=> String
    #   resp.data.channel.maintenance.maintenance_scheduled_date #=> String
    #   resp.data.channel.maintenance.maintenance_start_time #=> String
    #   resp.data.channel.name #=> String
    #   resp.data.channel.pipeline_details #=> Array<PipelineDetail>
    #   resp.data.channel.pipeline_details[0] #=> Types::PipelineDetail
    #   resp.data.channel.pipeline_details[0].active_input_attachment_name #=> String
    #   resp.data.channel.pipeline_details[0].active_input_switch_action_name #=> String
    #   resp.data.channel.pipeline_details[0].active_motion_graphics_action_name #=> String
    #   resp.data.channel.pipeline_details[0].active_motion_graphics_uri #=> String
    #   resp.data.channel.pipeline_details[0].pipeline_id #=> String
    #   resp.data.channel.pipelines_running_count #=> Integer
    #   resp.data.channel.role_arn #=> String
    #   resp.data.channel.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED", "UPDATING", "UPDATE_FAILED"]
    #   resp.data.channel.tags #=> Hash<String, String>
    #   resp.data.channel.tags['key'] #=> String
    #   resp.data.channel.vpc #=> Types::VpcOutputSettingsDescription
    #   resp.data.channel.vpc.availability_zones #=> Array<String>
    #   resp.data.channel.vpc.network_interface_ids #=> Array<String>
    #   resp.data.channel.vpc.security_group_ids #=> Array<String>
    #   resp.data.channel.vpc.subnet_ids #=> Array<String>
    #
    def update_channel(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::UpdateChannelInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::UpdateChannelInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::UpdateChannel
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException]),
        data_parser: Parsers::UpdateChannel
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::UpdateChannel,
        stubs: @stubs,
        params_class: Params::UpdateChannelOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :update_channel
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Changes the class of the channel.
    #
    # @param [Hash] params
    #   See {Types::UpdateChannelClassInput}.
    #
    # @option params [String] :channel_class
    #   The channel class that you wish to update this channel to use.
    #
    # @option params [String] :channel_id
    #   Channel Id of the channel whose class should be updated.
    #
    # @option params [Array<OutputDestination>] :destinations
    #   A list of output destinations for this channel.
    #
    # @return [Types::UpdateChannelClassOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.update_channel_class(
    #     channel_class: 'STANDARD', # required - accepts ["STANDARD", "SINGLE_PIPELINE"]
    #     channel_id: 'ChannelId', # required
    #     destinations: [
    #       {
    #         id: 'Id',
    #         media_package_settings: [
    #           {
    #             channel_id: 'ChannelId'
    #           }
    #         ],
    #         multiplex_settings: {
    #           multiplex_id: 'MultiplexId',
    #           program_name: 'ProgramName'
    #         },
    #         settings: [
    #           {
    #             password_param: 'PasswordParam',
    #             stream_name: 'StreamName',
    #             url: 'Url',
    #             username: 'Username'
    #           }
    #         ]
    #       }
    #     ]
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::UpdateChannelClassOutput
    #   resp.data.channel #=> Types::Channel
    #   resp.data.channel.arn #=> String
    #   resp.data.channel.cdi_input_specification #=> Types::CdiInputSpecification
    #   resp.data.channel.cdi_input_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.channel.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.channel.destinations #=> Array<OutputDestination>
    #   resp.data.channel.destinations[0] #=> Types::OutputDestination
    #   resp.data.channel.destinations[0].id #=> String
    #   resp.data.channel.destinations[0].media_package_settings #=> Array<MediaPackageOutputDestinationSettings>
    #   resp.data.channel.destinations[0].media_package_settings[0] #=> Types::MediaPackageOutputDestinationSettings
    #   resp.data.channel.destinations[0].media_package_settings[0].channel_id #=> String
    #   resp.data.channel.destinations[0].multiplex_settings #=> Types::MultiplexProgramChannelDestinationSettings
    #   resp.data.channel.destinations[0].multiplex_settings.multiplex_id #=> String
    #   resp.data.channel.destinations[0].multiplex_settings.program_name #=> String
    #   resp.data.channel.destinations[0].settings #=> Array<OutputDestinationSettings>
    #   resp.data.channel.destinations[0].settings[0] #=> Types::OutputDestinationSettings
    #   resp.data.channel.destinations[0].settings[0].password_param #=> String
    #   resp.data.channel.destinations[0].settings[0].stream_name #=> String
    #   resp.data.channel.destinations[0].settings[0].url #=> String
    #   resp.data.channel.destinations[0].settings[0].username #=> String
    #   resp.data.channel.egress_endpoints #=> Array<ChannelEgressEndpoint>
    #   resp.data.channel.egress_endpoints[0] #=> Types::ChannelEgressEndpoint
    #   resp.data.channel.egress_endpoints[0].source_ip #=> String
    #   resp.data.channel.encoder_settings #=> Types::EncoderSettings
    #   resp.data.channel.encoder_settings.audio_descriptions #=> Array<AudioDescription>
    #   resp.data.channel.encoder_settings.audio_descriptions[0] #=> Types::AudioDescription
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings #=> Types::AudioNormalizationSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm #=> String, one of ["ITU_1770_1", "ITU_1770_2"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings.algorithm_control #=> String, one of ["CORRECT_AUDIO"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_normalization_settings.target_lkfs #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_selector_name #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_type #=> String, one of ["CLEAN_EFFECTS", "HEARING_IMPAIRED", "UNDEFINED", "VISUAL_IMPAIRED_COMMENTARY"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_type_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings #=> Types::AudioWatermarkSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings #=> Types::NielsenWatermarksSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings #=> Types::NielsenCBET
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_check_digit_string #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.cbet_stepaside #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_cbet_settings.csid #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_distribution_type #=> String, one of ["FINAL_DISTRIBUTOR", "PROGRAM_CONTENT"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings #=> Types::NielsenNaesIiNw
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.check_digit_string #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].audio_watermarking_settings.nielsen_watermarks_settings.nielsen_naes_ii_nw_settings.sid #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings #=> Types::AudioCodecSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings #=> Types::AacSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.coding_mode #=> String, one of ["AD_RECEIVER_MIX", "CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_5_1"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.input_type #=> String, one of ["BROADCASTER_MIXED_AD", "NORMAL"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.profile #=> String, one of ["HEV1", "HEV2", "LC"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.rate_control_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.raw_format #=> String, one of ["LATM_LOAS", "NONE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.sample_rate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.spec #=> String, one of ["MPEG2", "MPEG4"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.aac_settings.vbr_quality #=> String, one of ["HIGH", "LOW", "MEDIUM_HIGH", "MEDIUM_LOW"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings #=> Types::Ac3Settings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "DIALOGUE", "EMERGENCY", "HEARING_IMPAIRED", "MUSIC_AND_EFFECTS", "VISUALLY_IMPAIRED", "VOICE_OVER"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_1_1", "CODING_MODE_2_0", "CODING_MODE_3_2_LFE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.dialnorm #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.drc_profile #=> String, one of ["FILM_STANDARD", "NONE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.ac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings #=> Types::Eac3Settings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.attenuation_control #=> String, one of ["ATTENUATE_3_DB", "NONE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.bitstream_mode #=> String, one of ["COMMENTARY", "COMPLETE_MAIN", "EMERGENCY", "HEARING_IMPAIRED", "VISUALLY_IMPAIRED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_3_2"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dc_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.dialnorm #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_line #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.drc_rf #=> String, one of ["FILM_LIGHT", "FILM_STANDARD", "MUSIC_LIGHT", "MUSIC_STANDARD", "NONE", "SPEECH"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_control #=> String, one of ["LFE", "NO_LFE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lfe_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_center_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lo_ro_surround_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_center_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.lt_rt_surround_mix_level #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.metadata_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.passthrough_control #=> String, one of ["NO_PASSTHROUGH", "WHEN_POSSIBLE"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.phase_control #=> String, one of ["NO_SHIFT", "SHIFT_90_DEGREES"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.stereo_downmix #=> String, one of ["DPL2", "LO_RO", "LT_RT", "NOT_INDICATED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_ex_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.eac3_settings.surround_mode #=> String, one of ["DISABLED", "ENABLED", "NOT_INDICATED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings #=> Types::Mp2Settings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.bitrate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.mp2_settings.sample_rate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.pass_through_settings #=> Types::PassThroughSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings #=> Types::WavSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.bit_depth #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.coding_mode #=> String, one of ["CODING_MODE_1_0", "CODING_MODE_2_0", "CODING_MODE_4_0", "CODING_MODE_8_0"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].codec_settings.wav_settings.sample_rate #=> Float
    #   resp.data.channel.encoder_settings.audio_descriptions[0].language_code #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].language_code_control #=> String, one of ["FOLLOW_INPUT", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.audio_descriptions[0].name #=> String
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings #=> Types::RemixSettings
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings #=> Array<AudioChannelMapping>
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0] #=> Types::AudioChannelMapping
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels #=> Array<InputChannelLevel>
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0] #=> Types::InputChannelLevel
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].gain #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].input_channel_levels[0].input_channel #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channel_mappings[0].output_channel #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channels_in #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].remix_settings.channels_out #=> Integer
    #   resp.data.channel.encoder_settings.audio_descriptions[0].stream_name #=> String
    #   resp.data.channel.encoder_settings.avail_blanking #=> Types::AvailBlanking
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image.password_param #=> String
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image.uri #=> String
    #   resp.data.channel.encoder_settings.avail_blanking.avail_blanking_image.username #=> String
    #   resp.data.channel.encoder_settings.avail_blanking.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.avail_configuration #=> Types::AvailConfiguration
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings #=> Types::AvailSettings
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert #=> Types::Scte35SpliceInsert
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.ad_avail_offset #=> Integer
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_splice_insert.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos #=> Types::Scte35TimeSignalApos
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.ad_avail_offset #=> Integer
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.no_regional_blackout_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.avail_configuration.avail_settings.scte35_time_signal_apos.web_delivery_allowed_flag #=> String, one of ["FOLLOW", "IGNORE"]
    #   resp.data.channel.encoder_settings.blackout_slate #=> Types::BlackoutSlate
    #   resp.data.channel.encoder_settings.blackout_slate.blackout_slate_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.blackout_slate.network_end_blackout #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.blackout_slate.network_end_blackout_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.blackout_slate.network_id #=> String
    #   resp.data.channel.encoder_settings.blackout_slate.state #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.caption_descriptions #=> Array<CaptionDescription>
    #   resp.data.channel.encoder_settings.caption_descriptions[0] #=> Types::CaptionDescription
    #   resp.data.channel.encoder_settings.caption_descriptions[0].caption_selector_name #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings #=> Types::CaptionDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.arib_destination_settings #=> Types::AribDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings #=> Types::BurnInDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.background_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_resolution #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.font_size #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.outline_size #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.x_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.burn_in_destination_settings.y_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings #=> Types::DvbSubDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.alignment #=> String, one of ["CENTERED", "LEFT", "SMART"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.background_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_resolution #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.font_size #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_color #=> String, one of ["BLACK", "BLUE", "GREEN", "RED", "WHITE", "YELLOW"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.outline_size #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_color #=> String, one of ["BLACK", "NONE", "WHITE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_opacity #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_x_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.shadow_y_offset #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.teletext_grid_control #=> String, one of ["FIXED", "SCALED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.x_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.dvb_sub_destination_settings.y_position #=> Integer
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings #=> Types::EbuTtDDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.copyright_holder #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.fill_line_gap #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.font_family #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ebu_tt_d_destination_settings.style_control #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.embedded_destination_settings #=> Types::EmbeddedDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.embedded_plus_scte20_destination_settings #=> Types::EmbeddedPlusScte20DestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.rtmp_caption_info_destination_settings #=> Types::RtmpCaptionInfoDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.scte20_plus_embedded_destination_settings #=> Types::Scte20PlusEmbeddedDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.scte27_destination_settings #=> Types::Scte27DestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.smpte_tt_destination_settings #=> Types::SmpteTtDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.teletext_destination_settings #=> Types::TeletextDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings #=> Types::TtmlDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.ttml_destination_settings.style_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings #=> Types::WebvttDestinationSettings
    #   resp.data.channel.encoder_settings.caption_descriptions[0].destination_settings.webvtt_destination_settings.style_control #=> String, one of ["NO_STYLE_DATA", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.caption_descriptions[0].language_code #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].language_description #=> String
    #   resp.data.channel.encoder_settings.caption_descriptions[0].name #=> String
    #   resp.data.channel.encoder_settings.feature_activations #=> Types::FeatureActivations
    #   resp.data.channel.encoder_settings.feature_activations.input_prepare_schedule_actions #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.global_configuration #=> Types::GlobalConfiguration
    #   resp.data.channel.encoder_settings.global_configuration.initial_audio_gain #=> Integer
    #   resp.data.channel.encoder_settings.global_configuration.input_end_action #=> String, one of ["NONE", "SWITCH_AND_LOOP_INPUTS"]
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior #=> Types::InputLossBehavior
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.black_frame_msec #=> Integer
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_color #=> String
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_slate #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.input_loss_image_type #=> String, one of ["COLOR", "SLATE"]
    #   resp.data.channel.encoder_settings.global_configuration.input_loss_behavior.repeat_frame_msec #=> Integer
    #   resp.data.channel.encoder_settings.global_configuration.output_locking_mode #=> String, one of ["EPOCH_LOCKING", "PIPELINE_LOCKING"]
    #   resp.data.channel.encoder_settings.global_configuration.output_timing_source #=> String, one of ["INPUT_CLOCK", "SYSTEM_CLOCK"]
    #   resp.data.channel.encoder_settings.global_configuration.support_low_framerate_inputs #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.motion_graphics_configuration #=> Types::MotionGraphicsConfiguration
    #   resp.data.channel.encoder_settings.motion_graphics_configuration.motion_graphics_insertion #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.motion_graphics_configuration.motion_graphics_settings #=> Types::MotionGraphicsSettings
    #   resp.data.channel.encoder_settings.motion_graphics_configuration.motion_graphics_settings.html_motion_graphics_settings #=> Types::HtmlMotionGraphicsSettings
    #   resp.data.channel.encoder_settings.nielsen_configuration #=> Types::NielsenConfiguration
    #   resp.data.channel.encoder_settings.nielsen_configuration.distributor_id #=> String
    #   resp.data.channel.encoder_settings.nielsen_configuration.nielsen_pcm_to_id3_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups #=> Array<OutputGroup>
    #   resp.data.channel.encoder_settings.output_groups[0] #=> Types::OutputGroup
    #   resp.data.channel.encoder_settings.output_groups[0].name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings #=> Types::OutputGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings #=> Types::ArchiveGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings #=> Types::ArchiveCdnSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings #=> Types::ArchiveS3Settings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.archive_cdn_settings.archive_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.destination.destination_ref_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.archive_group_settings.rollover_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings #=> Types::FrameCaptureGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings #=> Types::FrameCaptureCdnSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings #=> Types::FrameCaptureS3Settings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.frame_capture_group_settings.frame_capture_cdn_settings.frame_capture_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings #=> Types::HlsGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ad_markers[0] #=> String, one of ["ADOBE", "ELEMENTAL", "ELEMENTAL_SCTE35"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_content1 #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.base_url_manifest1 #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings #=> Array<CaptionLanguageMapping>
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0] #=> Types::CaptionLanguageMapping
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].caption_channel #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_code #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_mappings[0].language_description #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.caption_language_setting #=> String, one of ["INSERT", "NONE", "OMIT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.client_cache #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.codec_specification #=> String, one of ["RFC_4281", "RFC_6381"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.constant_iv #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.directory_structure #=> String, one of ["SINGLE_DIRECTORY", "SUBDIRECTORY_PER_STREAM"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.discontinuity_tags #=> String, one of ["INSERT", "NEVER_INSERT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.encryption_type #=> String, one of ["AES128", "SAMPLE_AES"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings #=> Types::HlsCdnSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings #=> Types::HlsAkamaiSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.salt #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_akamai_settings.token #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings #=> Types::HlsBasicPutSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_basic_put_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings #=> Types::HlsMediaStoreSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.media_store_storage_class #=> String, one of ["TEMPORAL"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_media_store_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings #=> Types::HlsS3Settings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_s3_settings.canned_acl #=> String, one of ["AUTHENTICATED_READ", "BUCKET_OWNER_FULL_CONTROL", "BUCKET_OWNER_READ", "PUBLIC_READ"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings #=> Types::HlsWebdavSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.http_transfer_mode #=> String, one of ["CHUNKED", "NON_CHUNKED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_cdn_settings.hls_webdav_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.hls_id3_segment_tagging #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.i_frame_only_playlists #=> String, one of ["DISABLED", "STANDARD"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.incomplete_segment_behavior #=> String, one of ["AUTO", "SUPPRESS"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.index_n_segments #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_in_manifest #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.iv_source #=> String, one of ["EXPLICIT", "FOLLOWS_SEGMENT_NUMBER"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.keep_segments #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_format_versions #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings #=> Types::KeyProviderSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings #=> Types::StaticKeySettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.key_provider_server #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.key_provider_settings.static_key_settings.static_key_value #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_compression #=> String, one of ["GZIP", "NONE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.manifest_duration_format #=> String, one of ["FLOATING_POINT", "INTEGER"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.min_segment_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.mode #=> String, one of ["LIVE", "VOD"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.output_selection #=> String, one of ["MANIFESTS_AND_SEGMENTS", "SEGMENTS_ONLY", "VARIANT_MANIFESTS_AND_SEGMENTS"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_clock #=> String, one of ["INITIALIZE_FROM_OUTPUT_TIMECODE", "SYSTEM_CLOCK"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.program_date_time_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.redundant_manifest #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segment_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.segments_per_subdirectory #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.stream_inf_resolution #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.timestamp_delta_milliseconds #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.hls_group_settings.ts_file_mode #=> String, one of ["SEGMENTED_FILES", "SINGLE_FILE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings #=> Types::MediaPackageGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.media_package_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings #=> Types::MsSmoothGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.acquisition_point_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.audio_only_timecode_control #=> String, one of ["PASSTHROUGH", "USE_CONFIGURED_CLOCK"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_id_mode #=> String, one of ["NO_EVENT_ID", "USE_CONFIGURED", "USE_TIMESTAMP"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.event_stop_behavior #=> String, one of ["NONE", "SEND_EOS"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.filecache_duration #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.fragment_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.segmentation_mode #=> String, one of ["USE_INPUT_SEGMENTATION", "USE_SEGMENT_DURATION"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.send_delay_ms #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.sparse_track_type #=> String, one of ["NONE", "SCTE_35", "SCTE_35_WITHOUT_SEGMENTATION"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.stream_manifest_behavior #=> String, one of ["DO_NOT_SEND", "SEND"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.ms_smooth_group_settings.timestamp_offset_mode #=> String, one of ["USE_CONFIGURED_OFFSET", "USE_EVENT_START_DATE"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.multiplex_group_settings #=> Types::MultiplexGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings #=> Types::RtmpGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.ad_markers[0] #=> String, one of ["ON_CUE_POINT_SCTE35"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.authentication_scheme #=> String, one of ["AKAMAI", "COMMON"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_full_behavior #=> String, one of ["DISCONNECT_IMMEDIATELY", "WAIT_FOR_SERVER"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.cache_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.caption_data #=> String, one of ["ALL", "FIELD1_608", "FIELD1_AND_FIELD2_608"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.input_loss_action #=> String, one of ["EMIT_OUTPUT", "PAUSE_OUTPUT"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.rtmp_group_settings.restart_delay #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings #=> Types::UdpGroupSettings
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.input_loss_action #=> String, one of ["DROP_PROGRAM", "DROP_TS", "EMIT_PROGRAM"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_frame #=> String, one of ["NONE", "PRIV", "TDRL"]
    #   resp.data.channel.encoder_settings.output_groups[0].output_group_settings.udp_group_settings.timed_metadata_id3_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs #=> Array<Output>
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0] #=> Types::Output
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].audio_description_names #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].audio_description_names[0] #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].caption_description_names #=> Array<String>
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings #=> Types::OutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings #=> Types::ArchiveOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings #=> Types::ArchiveContainerSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.absent_input_audio_behavior #=> String, one of ["DROP", "ENCODE_SILENCE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.arib_captions_pid_control #=> String, one of ["AUTO", "USE_CONFIGURED"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_buffer_model #=> String, one of ["ATSC", "DVB"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_frames_per_pes #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.audio_stream_type #=> String, one of ["ATSC", "DVB"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.bitrate #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.buffer_model #=> String, one of ["MULTIPLEX", "NONE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.cc_descriptor #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings #=> Types::DvbNitSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_id #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.network_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_nit_settings.rep_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings #=> Types::DvbSdtSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.output_sdt #=> String, one of ["SDT_FOLLOW", "SDT_FOLLOW_IF_PRESENT", "SDT_MANUAL", "SDT_NONE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.rep_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sdt_settings.service_provider_name #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_sub_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings #=> Types::DvbTdtSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_tdt_settings.rep_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.dvb_teletext_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebif #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_audio_interval #=> String, one of ["VIDEO_AND_FIXED_INTERVALS", "VIDEO_INTERVAL"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_lookahead_ms #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ebp_placement #=> String, one of ["VIDEO_AND_AUDIO_PIDS", "VIDEO_PID"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.ecm_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.es_rate_in_pes #=> String, one of ["EXCLUDE", "INCLUDE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_platform_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.etv_signal_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.fragment_time #=> Float
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.klv_data_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.null_packet_bitrate #=> Float
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pat_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pcr_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.pmt_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.program_num #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.rate_mode #=> String, one of ["CBR", "VBR"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte27_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_control #=> String, one of ["NONE", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.scte35_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_markers #=> String, one of ["EBP", "EBP_LEGACY", "NONE", "PSI_SEGSTART", "RAI_ADAPT", "RAI_SEGSTART"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_style #=> String, one of ["MAINTAIN_CADENCE", "RESET_CADENCE"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.segmentation_time #=> Float
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.timed_metadata_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.transport_stream_id #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.m2ts_settings.video_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.container_settings.raw_settings #=> Types::RawSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.extension #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.archive_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings #=> Types::FrameCaptureOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.frame_capture_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings #=> Types::HlsOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings #=> Types::HlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings #=> Types::AudioOnlyHlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_group_id #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_only_image #=> Types::InputLocation
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.audio_track_type #=> String, one of ["ALTERNATE_AUDIO_AUTO_SELECT", "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT", "ALTERNATE_AUDIO_NOT_AUTO_SELECT", "AUDIO_ONLY_VARIANT_STREAM"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.audio_only_hls_settings.segment_type #=> String, one of ["AAC", "FMP4"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings #=> Types::Fmp4HlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.audio_rendition_sets #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.fmp4_hls_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.frame_capture_hls_settings #=> Types::FrameCaptureHlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings #=> Types::StandardHlsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.audio_rendition_sets #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings #=> Types::M3u8Settings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_frames_per_pes #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.audio_pids #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.ecm_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.nielsen_id3_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pat_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_control #=> String, one of ["CONFIGURED_PCR_PERIOD", "PCR_EVERY_PES_PACKET"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_period #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pcr_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.pmt_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.program_num #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.scte35_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_behavior #=> String, one of ["NO_PASSTHROUGH", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.timed_metadata_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.transport_stream_id #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.hls_settings.standard_hls_settings.m3u8_settings.video_pid #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.hls_output_settings.segment_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.media_package_output_settings #=> Types::MediaPackageOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings #=> Types::MsSmoothOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.h265_packaging_type #=> String, one of ["HEV1", "HVC1"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.ms_smooth_output_settings.name_modifier #=> String
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings #=> Types::MultiplexOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.multiplex_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings #=> Types::RtmpOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.certificate_mode #=> String, one of ["SELF_SIGNED", "VERIFY_AUTHENTICITY"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.connection_retry_interval #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.rtmp_output_settings.num_retries #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings #=> Types::UdpOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.buffer_msec #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings #=> Types::UdpContainerSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.container_settings.m2ts_settings #=> Types::M2tsSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.destination #=> Types::OutputLocationRef
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings #=> Types::FecOutputSettings
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.column_depth #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.include_fec #=> String, one of ["COLUMN", "COLUMN_AND_ROW"]
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].output_settings.udp_output_settings.fec_output_settings.row_length #=> Integer
    #   resp.data.channel.encoder_settings.output_groups[0].outputs[0].video_description_name #=> String
    #   resp.data.channel.encoder_settings.timecode_config #=> Types::TimecodeConfig
    #   resp.data.channel.encoder_settings.timecode_config.source #=> String, one of ["EMBEDDED", "SYSTEMCLOCK", "ZEROBASED"]
    #   resp.data.channel.encoder_settings.timecode_config.sync_threshold #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions #=> Array<VideoDescription>
    #   resp.data.channel.encoder_settings.video_descriptions[0] #=> Types::VideoDescription
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings #=> Types::VideoCodecSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings #=> Types::FrameCaptureSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.frame_capture_settings.capture_interval_units #=> String, one of ["MILLISECONDS", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings #=> Types::H264Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_fill_pct #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.buf_size #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings #=> Types::H264ColorSpaceSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.entropy_encoding #=> String, one of ["CABAC", "CAVLC"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings #=> Types::H264FilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.post_filter_sharpening #=> String, one of ["AUTO", "DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.filter_settings.temporal_filter_settings.strength #=> String, one of ["AUTO", "STRENGTH_1", "STRENGTH_2", "STRENGTH_3", "STRENGTH_4", "STRENGTH_5", "STRENGTH_6", "STRENGTH_7", "STRENGTH_8", "STRENGTH_9", "STRENGTH_10", "STRENGTH_11", "STRENGTH_12", "STRENGTH_13", "STRENGTH_14", "STRENGTH_15", "STRENGTH_16"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.force_field_pictures #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.framerate_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_b_reference #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_closed_cadence #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_num_b_frames #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size #=> Float
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.level #=> String, one of ["H264_LEVEL_1", "H264_LEVEL_1_1", "H264_LEVEL_1_2", "H264_LEVEL_1_3", "H264_LEVEL_2", "H264_LEVEL_2_1", "H264_LEVEL_2_2", "H264_LEVEL_3", "H264_LEVEL_3_1", "H264_LEVEL_3_2", "H264_LEVEL_4", "H264_LEVEL_4_1", "H264_LEVEL_4_2", "H264_LEVEL_5", "H264_LEVEL_5_1", "H264_LEVEL_5_2", "H264_LEVEL_AUTO"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.max_bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.min_i_interval #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.num_ref_frames #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_control #=> String, one of ["INITIALIZE_FROM_SOURCE", "SPECIFIED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.par_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.profile #=> String, one of ["BASELINE", "HIGH", "HIGH_10BIT", "HIGH_422", "HIGH_422_10BIT", "MAIN"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.quality_level #=> String, one of ["ENHANCED_QUALITY", "STANDARD_QUALITY"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.qvbr_quality_level #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR", "VBR"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.slices #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.softness #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.spatial_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.syntax #=> String, one of ["DEFAULT", "RP2027"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.temporal_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h264_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings #=> Types::H265Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "HIGHER", "LOW", "MAX", "MEDIUM", "OFF"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.alternative_transfer_function #=> String, one of ["INSERT", "OMIT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.buf_size #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings #=> Types::H265ColorSpaceSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.color_space_passthrough_settings #=> Types::ColorSpacePassthroughSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_cll #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.hdr10_settings.max_fall #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec601_settings #=> Types::Rec601Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.color_space_settings.rec709_settings #=> Types::Rec709Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings #=> Types::H265FilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.flicker_aq #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.framerate_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_closed_cadence #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size #=> Float
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.level #=> String, one of ["H265_LEVEL_1", "H265_LEVEL_2", "H265_LEVEL_2_1", "H265_LEVEL_3", "H265_LEVEL_3_1", "H265_LEVEL_4", "H265_LEVEL_4_1", "H265_LEVEL_5", "H265_LEVEL_5_1", "H265_LEVEL_5_2", "H265_LEVEL_6", "H265_LEVEL_6_1", "H265_LEVEL_6_2", "H265_LEVEL_AUTO"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.look_ahead_rate_control #=> String, one of ["HIGH", "LOW", "MEDIUM"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.max_bitrate #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.min_i_interval #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.par_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.profile #=> String, one of ["MAIN", "MAIN_10BIT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.qvbr_quality_level #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.rate_control_mode #=> String, one of ["CBR", "MULTIPLEX", "QVBR"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.scene_change_detect #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.slices #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.tier #=> String, one of ["HIGH", "MAIN"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.h265_settings.timecode_insertion #=> String, one of ["DISABLED", "PIC_TIMING_SEI"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings #=> Types::Mpeg2Settings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.adaptive_quantization #=> String, one of ["AUTO", "HIGH", "LOW", "MEDIUM", "OFF"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.afd_signaling #=> String, one of ["AUTO", "FIXED", "NONE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_metadata #=> String, one of ["IGNORE", "INSERT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.color_space #=> String, one of ["AUTO", "PASSTHROUGH"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.display_aspect_ratio #=> String, one of ["DISPLAYRATIO16X9", "DISPLAYRATIO4X3"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings #=> Types::Mpeg2FilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.filter_settings.temporal_filter_settings #=> Types::TemporalFilterSettings
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.fixed_afd #=> String, one of ["AFD_0000", "AFD_0010", "AFD_0011", "AFD_0100", "AFD_1000", "AFD_1001", "AFD_1010", "AFD_1011", "AFD_1101", "AFD_1110", "AFD_1111"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_denominator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.framerate_numerator #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_closed_cadence #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_num_b_frames #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size #=> Float
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.gop_size_units #=> String, one of ["FRAMES", "SECONDS"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.subgop_length #=> String, one of ["DYNAMIC", "FIXED"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].codec_settings.mpeg2_settings.timecode_insertion #=> String, one of ["DISABLED", "GOP_TIMECODE"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].height #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].name #=> String
    #   resp.data.channel.encoder_settings.video_descriptions[0].respond_to_afd #=> String, one of ["NONE", "PASSTHROUGH", "RESPOND"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].scaling_behavior #=> String, one of ["DEFAULT", "STRETCH_TO_OUTPUT"]
    #   resp.data.channel.encoder_settings.video_descriptions[0].sharpness #=> Integer
    #   resp.data.channel.encoder_settings.video_descriptions[0].width #=> Integer
    #   resp.data.channel.id #=> String
    #   resp.data.channel.input_attachments #=> Array<InputAttachment>
    #   resp.data.channel.input_attachments[0] #=> Types::InputAttachment
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings #=> Types::AutomaticInputFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.error_clear_time_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions #=> Array<FailoverCondition>
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0] #=> Types::FailoverCondition
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings #=> Types::FailoverConditionSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings #=> Types::AudioSilenceFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_selector_name #=> String
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.audio_silence_settings.audio_silence_threshold_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings #=> Types::InputLossFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.input_loss_settings.input_loss_threshold_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings #=> Types::VideoBlackFailoverSettings
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.black_detect_threshold #=> Float
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.failover_conditions[0].failover_condition_settings.video_black_settings.video_black_threshold_msec #=> Integer
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.input_preference #=> String, one of ["EQUAL_INPUT_PREFERENCE", "PRIMARY_INPUT_PREFERRED"]
    #   resp.data.channel.input_attachments[0].automatic_input_failover_settings.secondary_input_id #=> String
    #   resp.data.channel.input_attachments[0].input_attachment_name #=> String
    #   resp.data.channel.input_attachments[0].input_id #=> String
    #   resp.data.channel.input_attachments[0].input_settings #=> Types::InputSettings
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors #=> Array<AudioSelector>
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0] #=> Types::AudioSelector
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].name #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings #=> Types::AudioSelectorSettings
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection #=> Types::AudioHlsRenditionSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.group_id #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_hls_rendition_selection.name #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection #=> Types::AudioLanguageSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_code #=> String
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_language_selection.language_selection_policy #=> String, one of ["LOOSE", "STRICT"]
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection #=> Types::AudioPidSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_pid_selection.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection #=> Types::AudioTrackSelection
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks #=> Array<AudioTrack>
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0] #=> Types::AudioTrack
    #   resp.data.channel.input_attachments[0].input_settings.audio_selectors[0].selector_settings.audio_track_selection.tracks[0].track #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors #=> Array<CaptionSelector>
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0] #=> Types::CaptionSelector
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].language_code #=> String
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].name #=> String
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings #=> Types::CaptionSelectorSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings #=> Types::AncillarySourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.ancillary_source_settings.source_ancillary_channel_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.arib_source_settings #=> Types::AribSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings #=> Types::DvbSubSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.dvb_sub_source_settings.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings #=> Types::EmbeddedSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.scte20_detection #=> String, one of ["AUTO", "OFF"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_channel_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.embedded_source_settings.source608_track_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings #=> Types::Scte20SourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.convert608_to708 #=> String, one of ["DISABLED", "UPCONVERT"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte20_source_settings.source608_channel_number #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings #=> Types::Scte27SourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.ocr_language #=> String, one of ["DEU", "ENG", "FRA", "NLD", "POR", "SPA"]
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.scte27_source_settings.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings #=> Types::TeletextSourceSettings
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle #=> Types::CaptionRectangle
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.height #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.left_offset #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.top_offset #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.output_rectangle.width #=> Float
    #   resp.data.channel.input_attachments[0].input_settings.caption_selectors[0].selector_settings.teletext_source_settings.page_number #=> String
    #   resp.data.channel.input_attachments[0].input_settings.deblock_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.input_attachments[0].input_settings.denoise_filter #=> String, one of ["DISABLED", "ENABLED"]
    #   resp.data.channel.input_attachments[0].input_settings.filter_strength #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.input_filter #=> String, one of ["AUTO", "DISABLED", "FORCED"]
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings #=> Types::NetworkInputSettings
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings #=> Types::HlsInputSettings
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.bandwidth #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.buffer_segments #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retries #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.retry_interval #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.hls_input_settings.scte35_source #=> String, one of ["MANIFEST", "SEGMENTS"]
    #   resp.data.channel.input_attachments[0].input_settings.network_input_settings.server_validation #=> String, one of ["CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME", "CHECK_CRYPTOGRAPHY_ONLY"]
    #   resp.data.channel.input_attachments[0].input_settings.scte35_pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.smpte2038_data_preference #=> String, one of ["IGNORE", "PREFER"]
    #   resp.data.channel.input_attachments[0].input_settings.source_end_behavior #=> String, one of ["CONTINUE", "LOOP"]
    #   resp.data.channel.input_attachments[0].input_settings.video_selector #=> Types::VideoSelector
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space #=> String, one of ["FOLLOW", "HDR10", "HLG_2020", "REC_601", "REC_709"]
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space_settings #=> Types::VideoSelectorColorSpaceSettings
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space_settings.hdr10_settings #=> Types::Hdr10Settings
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.color_space_usage #=> String, one of ["FALLBACK", "FORCE"]
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings #=> Types::VideoSelectorSettings
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid #=> Types::VideoSelectorPid
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_pid.pid #=> Integer
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id #=> Types::VideoSelectorProgramId
    #   resp.data.channel.input_attachments[0].input_settings.video_selector.selector_settings.video_selector_program_id.program_id #=> Integer
    #   resp.data.channel.input_specification #=> Types::InputSpecification
    #   resp.data.channel.input_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC"]
    #   resp.data.channel.input_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.channel.input_specification.resolution #=> String, one of ["SD", "HD", "UHD"]
    #   resp.data.channel.log_level #=> String, one of ["ERROR", "WARNING", "INFO", "DEBUG", "DISABLED"]
    #   resp.data.channel.maintenance #=> Types::MaintenanceStatus
    #   resp.data.channel.maintenance.maintenance_day #=> String, one of ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
    #   resp.data.channel.maintenance.maintenance_deadline #=> String
    #   resp.data.channel.maintenance.maintenance_scheduled_date #=> String
    #   resp.data.channel.maintenance.maintenance_start_time #=> String
    #   resp.data.channel.name #=> String
    #   resp.data.channel.pipeline_details #=> Array<PipelineDetail>
    #   resp.data.channel.pipeline_details[0] #=> Types::PipelineDetail
    #   resp.data.channel.pipeline_details[0].active_input_attachment_name #=> String
    #   resp.data.channel.pipeline_details[0].active_input_switch_action_name #=> String
    #   resp.data.channel.pipeline_details[0].active_motion_graphics_action_name #=> String
    #   resp.data.channel.pipeline_details[0].active_motion_graphics_uri #=> String
    #   resp.data.channel.pipeline_details[0].pipeline_id #=> String
    #   resp.data.channel.pipelines_running_count #=> Integer
    #   resp.data.channel.role_arn #=> String
    #   resp.data.channel.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED", "UPDATING", "UPDATE_FAILED"]
    #   resp.data.channel.tags #=> Hash<String, String>
    #   resp.data.channel.tags['key'] #=> String
    #   resp.data.channel.vpc #=> Types::VpcOutputSettingsDescription
    #   resp.data.channel.vpc.availability_zones #=> Array<String>
    #   resp.data.channel.vpc.network_interface_ids #=> Array<String>
    #   resp.data.channel.vpc.security_group_ids #=> Array<String>
    #   resp.data.channel.vpc.subnet_ids #=> Array<String>
    #
    def update_channel_class(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::UpdateChannelClassInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::UpdateChannelClassInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::UpdateChannelClass
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::UpdateChannelClass
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::UpdateChannelClass,
        stubs: @stubs,
        params_class: Params::UpdateChannelClassOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :update_channel_class
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Updates an input.
    #
    # @param [Hash] params
    #   See {Types::UpdateInputInput}.
    #
    # @option params [Array<InputDestinationRequest>] :destinations
    #   Destination settings for PUSH type inputs.
    #
    # @option params [Array<InputDeviceRequest>] :input_devices
    #   Settings for the devices.
    #
    # @option params [String] :input_id
    #   Unique ID of the input.
    #
    # @option params [Array<String>] :input_security_groups
    #   A list of security groups referenced by IDs to attach to the input.
    #
    # @option params [Array<MediaConnectFlowRequest>] :media_connect_flows
    #   A list of the MediaConnect Flow ARNs that you want to use as the source of the input. You can specify as few as one
    #   Flow and presently, as many as two. The only requirement is when you have more than one is that each Flow is in a
    #   separate Availability Zone as this ensures your EML input is redundant to AZ issues.
    #
    # @option params [String] :name
    #   Name of the input.
    #
    # @option params [String] :role_arn
    #   The Amazon Resource Name (ARN) of the role this input assumes during and after creation.
    #
    # @option params [Array<InputSourceRequest>] :sources
    #   The source URLs for a PULL-type input. Every PULL type input needs
    #   exactly two source URLs for redundancy.
    #   Only specify sources for PULL type Inputs. Leave Destinations empty.
    #
    # @return [Types::UpdateInputOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.update_input(
    #     destinations: [
    #       {
    #         stream_name: 'StreamName'
    #       }
    #     ],
    #     input_devices: [
    #       {
    #         id: 'Id'
    #       }
    #     ],
    #     input_id: 'InputId', # required
    #     input_security_groups: [
    #       'member'
    #     ],
    #     media_connect_flows: [
    #       {
    #         flow_arn: 'FlowArn'
    #       }
    #     ],
    #     name: 'Name',
    #     role_arn: 'RoleArn',
    #     sources: [
    #       {
    #         password_param: 'PasswordParam',
    #         url: 'Url',
    #         username: 'Username'
    #       }
    #     ]
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::UpdateInputOutput
    #   resp.data.input #=> Types::Input
    #   resp.data.input.arn #=> String
    #   resp.data.input.attached_channels #=> Array<String>
    #   resp.data.input.attached_channels[0] #=> String
    #   resp.data.input.destinations #=> Array<InputDestination>
    #   resp.data.input.destinations[0] #=> Types::InputDestination
    #   resp.data.input.destinations[0].ip #=> String
    #   resp.data.input.destinations[0].port #=> String
    #   resp.data.input.destinations[0].url #=> String
    #   resp.data.input.destinations[0].vpc #=> Types::InputDestinationVpc
    #   resp.data.input.destinations[0].vpc.availability_zone #=> String
    #   resp.data.input.destinations[0].vpc.network_interface_id #=> String
    #   resp.data.input.id #=> String
    #   resp.data.input.input_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.input.input_devices #=> Array<InputDeviceSettings>
    #   resp.data.input.input_devices[0] #=> Types::InputDeviceSettings
    #   resp.data.input.input_devices[0].id #=> String
    #   resp.data.input.input_partner_ids #=> Array<String>
    #   resp.data.input.input_source_type #=> String, one of ["STATIC", "DYNAMIC"]
    #   resp.data.input.media_connect_flows #=> Array<MediaConnectFlow>
    #   resp.data.input.media_connect_flows[0] #=> Types::MediaConnectFlow
    #   resp.data.input.media_connect_flows[0].flow_arn #=> String
    #   resp.data.input.name #=> String
    #   resp.data.input.role_arn #=> String
    #   resp.data.input.security_groups #=> Array<String>
    #   resp.data.input.sources #=> Array<InputSource>
    #   resp.data.input.sources[0] #=> Types::InputSource
    #   resp.data.input.sources[0].password_param #=> String
    #   resp.data.input.sources[0].url #=> String
    #   resp.data.input.sources[0].username #=> String
    #   resp.data.input.state #=> String, one of ["CREATING", "DETACHED", "ATTACHED", "DELETING", "DELETED"]
    #   resp.data.input.tags #=> Hash<String, String>
    #   resp.data.input.tags['key'] #=> String
    #   resp.data.input.type #=> String, one of ["UDP_PUSH", "RTP_PUSH", "RTMP_PUSH", "RTMP_PULL", "URL_PULL", "MP4_FILE", "MEDIACONNECT", "INPUT_DEVICE", "AWS_CDI", "TS_FILE"]
    #
    def update_input(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::UpdateInputInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::UpdateInputInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::UpdateInput
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::UpdateInput
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::UpdateInput,
        stubs: @stubs,
        params_class: Params::UpdateInputOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :update_input
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Updates the parameters for the input device.
    #
    # @param [Hash] params
    #   See {Types::UpdateInputDeviceInput}.
    #
    # @option params [InputDeviceConfigurableSettings] :hd_device_settings
    #   The settings that you want to apply to the HD input device.
    #
    # @option params [String] :input_device_id
    #   The unique ID of the input device. For example, hd-123456789abcdef.
    #
    # @option params [String] :name
    #   The name that you assigned to this input device (not the unique ID).
    #
    # @option params [InputDeviceConfigurableSettings] :uhd_device_settings
    #   The settings that you want to apply to the UHD input device.
    #
    # @return [Types::UpdateInputDeviceOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.update_input_device(
    #     hd_device_settings: {
    #       configured_input: 'AUTO', # accepts ["AUTO", "HDMI", "SDI"]
    #       max_bitrate: 1
    #     },
    #     input_device_id: 'InputDeviceId', # required
    #     name: 'Name',
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::UpdateInputDeviceOutput
    #   resp.data.arn #=> String
    #   resp.data.connection_state #=> String, one of ["DISCONNECTED", "CONNECTED"]
    #   resp.data.device_settings_sync_state #=> String, one of ["SYNCED", "SYNCING"]
    #   resp.data.device_update_status #=> String, one of ["UP_TO_DATE", "NOT_UP_TO_DATE"]
    #   resp.data.hd_device_settings #=> Types::InputDeviceHdSettings
    #   resp.data.hd_device_settings.active_input #=> String, one of ["HDMI", "SDI"]
    #   resp.data.hd_device_settings.configured_input #=> String, one of ["AUTO", "HDMI", "SDI"]
    #   resp.data.hd_device_settings.device_state #=> String, one of ["IDLE", "STREAMING"]
    #   resp.data.hd_device_settings.framerate #=> Float
    #   resp.data.hd_device_settings.height #=> Integer
    #   resp.data.hd_device_settings.max_bitrate #=> Integer
    #   resp.data.hd_device_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.hd_device_settings.width #=> Integer
    #   resp.data.id #=> String
    #   resp.data.mac_address #=> String
    #   resp.data.name #=> String
    #   resp.data.network_settings #=> Types::InputDeviceNetworkSettings
    #   resp.data.network_settings.dns_addresses #=> Array<String>
    #   resp.data.network_settings.dns_addresses[0] #=> String
    #   resp.data.network_settings.gateway #=> String
    #   resp.data.network_settings.ip_address #=> String
    #   resp.data.network_settings.ip_scheme #=> String, one of ["STATIC", "DHCP"]
    #   resp.data.network_settings.subnet_mask #=> String
    #   resp.data.serial_number #=> String
    #   resp.data.type #=> String, one of ["HD"]
    #   resp.data.uhd_device_settings #=> Types::InputDeviceUhdSettings
    #   resp.data.uhd_device_settings.active_input #=> String, one of ["HDMI", "SDI"]
    #   resp.data.uhd_device_settings.configured_input #=> String, one of ["AUTO", "HDMI", "SDI"]
    #   resp.data.uhd_device_settings.device_state #=> String, one of ["IDLE", "STREAMING"]
    #   resp.data.uhd_device_settings.framerate #=> Float
    #   resp.data.uhd_device_settings.height #=> Integer
    #   resp.data.uhd_device_settings.max_bitrate #=> Integer
    #   resp.data.uhd_device_settings.scan_type #=> String, one of ["INTERLACED", "PROGRESSIVE"]
    #   resp.data.uhd_device_settings.width #=> Integer
    #
    def update_input_device(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::UpdateInputDeviceInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::UpdateInputDeviceInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::UpdateInputDevice
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::UpdateInputDevice
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::UpdateInputDevice,
        stubs: @stubs,
        params_class: Params::UpdateInputDeviceOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :update_input_device
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Update an Input Security Group's Whilelists.
    #
    # @param [Hash] params
    #   See {Types::UpdateInputSecurityGroupInput}.
    #
    # @option params [String] :input_security_group_id
    #   The id of the Input Security Group to update.
    #
    # @option params [Hash<String, String>] :tags
    #   A collection of key-value pairs.
    #
    # @option params [Array<InputWhitelistRuleCidr>] :whitelist_rules
    #   List of IPv4 CIDR addresses to whitelist
    #
    # @return [Types::UpdateInputSecurityGroupOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.update_input_security_group(
    #     input_security_group_id: 'InputSecurityGroupId', # required
    #     tags: {
    #       'key' => 'value'
    #     },
    #     whitelist_rules: [
    #       {
    #         cidr: 'Cidr'
    #       }
    #     ]
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::UpdateInputSecurityGroupOutput
    #   resp.data.security_group #=> Types::InputSecurityGroup
    #   resp.data.security_group.arn #=> String
    #   resp.data.security_group.id #=> String
    #   resp.data.security_group.inputs #=> Array<String>
    #   resp.data.security_group.inputs[0] #=> String
    #   resp.data.security_group.state #=> String, one of ["IDLE", "IN_USE", "UPDATING", "DELETED"]
    #   resp.data.security_group.tags #=> Hash<String, String>
    #   resp.data.security_group.tags['key'] #=> String
    #   resp.data.security_group.whitelist_rules #=> Array<InputWhitelistRule>
    #   resp.data.security_group.whitelist_rules[0] #=> Types::InputWhitelistRule
    #   resp.data.security_group.whitelist_rules[0].cidr #=> String
    #
    def update_input_security_group(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::UpdateInputSecurityGroupInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::UpdateInputSecurityGroupInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::UpdateInputSecurityGroup
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::UpdateInputSecurityGroup
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::UpdateInputSecurityGroup,
        stubs: @stubs,
        params_class: Params::UpdateInputSecurityGroupOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :update_input_security_group
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Updates a multiplex.
    #
    # @param [Hash] params
    #   See {Types::UpdateMultiplexInput}.
    #
    # @option params [String] :multiplex_id
    #   ID of the multiplex to update.
    #
    # @option params [MultiplexSettings] :multiplex_settings
    #   The new settings for a multiplex.
    #
    # @option params [String] :name
    #   Name of the multiplex.
    #
    # @return [Types::UpdateMultiplexOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.update_multiplex(
    #     multiplex_id: 'MultiplexId', # required
    #     multiplex_settings: {
    #       maximum_video_buffer_delay_milliseconds: 1,
    #       transport_stream_bitrate: 1, # required
    #       transport_stream_id: 1, # required
    #       transport_stream_reserved_bitrate: 1
    #     },
    #     name: 'Name'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::UpdateMultiplexOutput
    #   resp.data.multiplex #=> Types::Multiplex
    #   resp.data.multiplex.arn #=> String
    #   resp.data.multiplex.availability_zones #=> Array<String>
    #   resp.data.multiplex.availability_zones[0] #=> String
    #   resp.data.multiplex.destinations #=> Array<MultiplexOutputDestination>
    #   resp.data.multiplex.destinations[0] #=> Types::MultiplexOutputDestination
    #   resp.data.multiplex.destinations[0].media_connect_settings #=> Types::MultiplexMediaConnectOutputDestinationSettings
    #   resp.data.multiplex.destinations[0].media_connect_settings.entitlement_arn #=> String
    #   resp.data.multiplex.id #=> String
    #   resp.data.multiplex.multiplex_settings #=> Types::MultiplexSettings
    #   resp.data.multiplex.multiplex_settings.maximum_video_buffer_delay_milliseconds #=> Integer
    #   resp.data.multiplex.multiplex_settings.transport_stream_bitrate #=> Integer
    #   resp.data.multiplex.multiplex_settings.transport_stream_id #=> Integer
    #   resp.data.multiplex.multiplex_settings.transport_stream_reserved_bitrate #=> Integer
    #   resp.data.multiplex.name #=> String
    #   resp.data.multiplex.pipelines_running_count #=> Integer
    #   resp.data.multiplex.program_count #=> Integer
    #   resp.data.multiplex.state #=> String, one of ["CREATING", "CREATE_FAILED", "IDLE", "STARTING", "RUNNING", "RECOVERING", "STOPPING", "DELETING", "DELETED"]
    #   resp.data.multiplex.tags #=> Hash<String, String>
    #   resp.data.multiplex.tags['key'] #=> String
    #
    def update_multiplex(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::UpdateMultiplexInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::UpdateMultiplexInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::UpdateMultiplex
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::UpdateMultiplex
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::UpdateMultiplex,
        stubs: @stubs,
        params_class: Params::UpdateMultiplexOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :update_multiplex
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Update a program in a multiplex.
    #
    # @param [Hash] params
    #   See {Types::UpdateMultiplexProgramInput}.
    #
    # @option params [String] :multiplex_id
    #   The ID of the multiplex of the program to update.
    #
    # @option params [MultiplexProgramSettings] :multiplex_program_settings
    #   The new settings for a multiplex program.
    #
    # @option params [String] :program_name
    #   The name of the program to update.
    #
    # @return [Types::UpdateMultiplexProgramOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.update_multiplex_program(
    #     multiplex_id: 'MultiplexId', # required
    #     multiplex_program_settings: {
    #       preferred_channel_pipeline: 'CURRENTLY_ACTIVE', # accepts ["CURRENTLY_ACTIVE", "PIPELINE_0", "PIPELINE_1"]
    #       program_number: 1, # required
    #       service_descriptor: {
    #         provider_name: 'ProviderName', # required
    #         service_name: 'ServiceName' # required
    #       },
    #       video_settings: {
    #         constant_bitrate: 1,
    #         statmux_settings: {
    #           maximum_bitrate: 1,
    #           minimum_bitrate: 1,
    #           priority: 1
    #         }
    #       }
    #     },
    #     program_name: 'ProgramName' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::UpdateMultiplexProgramOutput
    #   resp.data.multiplex_program #=> Types::MultiplexProgram
    #   resp.data.multiplex_program.channel_id #=> String
    #   resp.data.multiplex_program.multiplex_program_settings #=> Types::MultiplexProgramSettings
    #   resp.data.multiplex_program.multiplex_program_settings.preferred_channel_pipeline #=> String, one of ["CURRENTLY_ACTIVE", "PIPELINE_0", "PIPELINE_1"]
    #   resp.data.multiplex_program.multiplex_program_settings.program_number #=> Integer
    #   resp.data.multiplex_program.multiplex_program_settings.service_descriptor #=> Types::MultiplexProgramServiceDescriptor
    #   resp.data.multiplex_program.multiplex_program_settings.service_descriptor.provider_name #=> String
    #   resp.data.multiplex_program.multiplex_program_settings.service_descriptor.service_name #=> String
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings #=> Types::MultiplexVideoSettings
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.constant_bitrate #=> Integer
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.statmux_settings #=> Types::MultiplexStatmuxVideoSettings
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.statmux_settings.maximum_bitrate #=> Integer
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.statmux_settings.minimum_bitrate #=> Integer
    #   resp.data.multiplex_program.multiplex_program_settings.video_settings.statmux_settings.priority #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map #=> Types::MultiplexProgramPacketIdentifiersMap
    #   resp.data.multiplex_program.packet_identifiers_map.audio_pids #=> Array<Integer>
    #   resp.data.multiplex_program.packet_identifiers_map.audio_pids[0] #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.dvb_sub_pids #=> Array<Integer>
    #   resp.data.multiplex_program.packet_identifiers_map.dvb_teletext_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.etv_platform_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.etv_signal_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.klv_data_pids #=> Array<Integer>
    #   resp.data.multiplex_program.packet_identifiers_map.pcr_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.pmt_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.private_metadata_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.scte27_pids #=> Array<Integer>
    #   resp.data.multiplex_program.packet_identifiers_map.scte35_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.timed_metadata_pid #=> Integer
    #   resp.data.multiplex_program.packet_identifiers_map.video_pid #=> Integer
    #   resp.data.multiplex_program.pipeline_details #=> Array<MultiplexProgramPipelineDetail>
    #   resp.data.multiplex_program.pipeline_details[0] #=> Types::MultiplexProgramPipelineDetail
    #   resp.data.multiplex_program.pipeline_details[0].active_channel_pipeline #=> String
    #   resp.data.multiplex_program.pipeline_details[0].pipeline_id #=> String
    #   resp.data.multiplex_program.program_name #=> String
    #
    def update_multiplex_program(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::UpdateMultiplexProgramInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::UpdateMultiplexProgramInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::UpdateMultiplexProgram
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::GatewayTimeoutException, Errors::UnprocessableEntityException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::UpdateMultiplexProgram
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::UpdateMultiplexProgram,
        stubs: @stubs,
        params_class: Params::UpdateMultiplexProgramOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :update_multiplex_program
        )
      )
      raise resp.error if resp.error
      resp
    end

    # Update reservation.
    #
    # @param [Hash] params
    #   See {Types::UpdateReservationInput}.
    #
    # @option params [String] :name
    #   Name of the reservation
    #
    # @option params [String] :reservation_id
    #   Unique reservation ID, e.g. '1234567'
    #
    # @return [Types::UpdateReservationOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.update_reservation(
    #     name: 'Name',
    #     reservation_id: 'ReservationId' # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::UpdateReservationOutput
    #   resp.data.reservation #=> Types::Reservation
    #   resp.data.reservation.arn #=> String
    #   resp.data.reservation.count #=> Integer
    #   resp.data.reservation.currency_code #=> String
    #   resp.data.reservation.duration #=> Integer
    #   resp.data.reservation.duration_units #=> String, one of ["MONTHS"]
    #   resp.data.reservation.end #=> String
    #   resp.data.reservation.fixed_price #=> Float
    #   resp.data.reservation.name #=> String
    #   resp.data.reservation.offering_description #=> String
    #   resp.data.reservation.offering_id #=> String
    #   resp.data.reservation.offering_type #=> String, one of ["NO_UPFRONT"]
    #   resp.data.reservation.region #=> String
    #   resp.data.reservation.reservation_id #=> String
    #   resp.data.reservation.resource_specification #=> Types::ReservationResourceSpecification
    #   resp.data.reservation.resource_specification.channel_class #=> String, one of ["STANDARD", "SINGLE_PIPELINE"]
    #   resp.data.reservation.resource_specification.codec #=> String, one of ["MPEG2", "AVC", "HEVC", "AUDIO", "LINK"]
    #   resp.data.reservation.resource_specification.maximum_bitrate #=> String, one of ["MAX_10_MBPS", "MAX_20_MBPS", "MAX_50_MBPS"]
    #   resp.data.reservation.resource_specification.maximum_framerate #=> String, one of ["MAX_30_FPS", "MAX_60_FPS"]
    #   resp.data.reservation.resource_specification.resolution #=> String, one of ["SD", "HD", "FHD", "UHD"]
    #   resp.data.reservation.resource_specification.resource_type #=> String, one of ["INPUT", "OUTPUT", "MULTIPLEX", "CHANNEL"]
    #   resp.data.reservation.resource_specification.special_feature #=> String, one of ["ADVANCED_AUDIO", "AUDIO_NORMALIZATION", "MGHD", "MGUHD"]
    #   resp.data.reservation.resource_specification.video_quality #=> String, one of ["STANDARD", "ENHANCED", "PREMIUM"]
    #   resp.data.reservation.start #=> String
    #   resp.data.reservation.state #=> String, one of ["ACTIVE", "EXPIRED", "CANCELED", "DELETED"]
    #   resp.data.reservation.tags #=> Hash<String, String>
    #   resp.data.reservation.tags['key'] #=> String
    #   resp.data.reservation.usage_price #=> Float
    #
    def update_reservation(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::UpdateReservationInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::UpdateReservationInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::UpdateReservation
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ConflictException, Errors::TooManyRequestsException, Errors::GatewayTimeoutException, Errors::BadRequestException, Errors::ForbiddenException, Errors::InternalServerErrorException, Errors::BadGatewayException, Errors::NotFoundException]),
        data_parser: Parsers::UpdateReservation
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::UpdateReservation,
        stubs: @stubs,
        params_class: Params::UpdateReservationOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :update_reservation
        )
      )
      raise resp.error if resp.error
      resp
    end

    private

    def apply_middleware(middleware_stack, middleware)
      Client.middleware.apply(middleware_stack)
      @middleware.apply(middleware_stack)
      Hearth::MiddlewareBuilder.new(middleware).apply(middleware_stack)
    end

    def output_stream(options = {}, &block)
      return options[:output_stream] if options[:output_stream]
      return Hearth::BlockIO.new(block) if block

      ::StringIO.new
    end
  end
end
