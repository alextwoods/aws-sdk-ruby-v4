# frozen_string_literal: true

# WARNING ABOUT GENERATED CODE
#
# This file was code generated using smithy-ruby.
# https://github.com/awslabs/smithy-ruby
#
# WARNING ABOUT GENERATED CODE

require 'stringio'

require_relative 'middleware/request_id'

module AWS::SDK::Forecastquery
  # An API client for AmazonForecastRuntime
  # See {#initialize} for a full list of supported configuration options
  # <p>Provides APIs for creating and managing Amazon Forecast resources.</p>
  #
  class Client
    include Hearth::ClientStubs

    @middleware = Hearth::MiddlewareBuilder.new

    def self.middleware
      @middleware
    end

    # @param [Config] config
    #   An instance of {Config}
    #
    def initialize(config = AWS::SDK::Forecastquery::Config.new, options = {})
      @config = config
      @middleware = Hearth::MiddlewareBuilder.new(options[:middleware])
      @stubs = Hearth::Stubbing::Stubs.new
      @retry_quota = Hearth::Retry::RetryQuota.new
      @client_rate_limiter = Hearth::Retry::ClientRateLimiter.new
    end

    # <p>Retrieves a forecast for a single item, filtered by the supplied criteria.</p>
    #          <p>The criteria is a key-value pair. The key is either <code>item_id</code> (or the
    #       equivalent non-timestamp, non-target field) from the <code>TARGET_TIME_SERIES</code> dataset,
    #       or one of the forecast dimensions specified as part of the <code>FeaturizationConfig</code>
    #       object.</p>
    #          <p>By default, <code>QueryForecast</code> returns the complete date range for the filtered
    #       forecast. You can request a specific date range.</p>
    #          <p>To get the full forecast, use the <a href="https://docs.aws.amazon.com/en_us/forecast/latest/dg/API_CreateForecastExportJob.html">CreateForecastExportJob</a> operation.</p>
    #          <note>
    #             <p>The forecasts generated by Amazon Forecast are in the same timezone as the dataset that was
    #         used to create the predictor.</p>
    #          </note>
    #
    # @param [Hash] params
    #   See {Types::QueryForecastInput}.
    #
    # @option params [String] :forecast_arn
    #   <p>The Amazon Resource Name (ARN) of the forecast to query.</p>
    #
    # @option params [String] :start_date
    #   <p>The start date for the forecast. Specify the date using this format: yyyy-MM-dd'T'HH:mm:ss
    #         (ISO 8601 format). For example, 2015-01-01T08:00:00.</p>
    #
    # @option params [String] :end_date
    #   <p>The end date for the forecast. Specify the date using this format: yyyy-MM-dd'T'HH:mm:ss
    #         (ISO 8601 format). For example, 2015-01-01T20:00:00. </p>
    #
    # @option params [Hash<String, String>] :filters
    #   <p>The filtering criteria to apply when retrieving the forecast. For example, to get the
    #         forecast for <code>client_21</code> in the electricity usage dataset, specify the
    #         following:</p>
    #            <p>
    #               <code>{"item_id" : "client_21"}</code>
    #            </p>
    #
    #
    #            <p>To get the full forecast, use the <a href="https://docs.aws.amazon.com/en_us/forecast/latest/dg/API_CreateForecastExportJob.html">CreateForecastExportJob</a> operation.</p>
    #
    # @option params [String] :next_token
    #   <p>If the result of the previous request was truncated, the response includes a
    #           <code>NextToken</code>. To retrieve the next set of results, use the token in the next
    #         request. Tokens expire after 24 hours.</p>
    #
    # @return [Types::QueryForecastOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.query_forecast(
    #     forecast_arn: 'ForecastArn', # required
    #     start_date: 'StartDate',
    #     end_date: 'EndDate',
    #     filters: {
    #       'key' => 'value'
    #     }, # required
    #     next_token: 'NextToken'
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::QueryForecastOutput
    #   resp.data.forecast #=> Types::Forecast
    #   resp.data.forecast.predictions #=> Hash<String, Array<DataPoint>>
    #   resp.data.forecast.predictions['key'] #=> Array<DataPoint>
    #   resp.data.forecast.predictions['key'][0] #=> Types::DataPoint
    #   resp.data.forecast.predictions['key'][0].timestamp #=> String
    #   resp.data.forecast.predictions['key'][0].value #=> Float
    #
    def query_forecast(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::QueryForecastInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::QueryForecastInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::QueryForecast
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::InvalidInputException, Errors::ResourceInUseException, Errors::InvalidNextTokenException, Errors::LimitExceededException, Errors::ResourceNotFoundException]),
        data_parser: Parsers::QueryForecast
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::QueryForecast,
        stubs: @stubs,
        params_class: Params::QueryForecastOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :query_forecast
        )
      )
      raise resp.error if resp.error
      resp
    end

    private

    def apply_middleware(middleware_stack, middleware)
      Client.middleware.apply(middleware_stack)
      @middleware.apply(middleware_stack)
      Hearth::MiddlewareBuilder.new(middleware).apply(middleware_stack)
    end
  end
end
