# frozen_string_literal: true

# WARNING ABOUT GENERATED CODE
#
# This file was code generated using smithy-ruby.
# https://github.com/awslabs/smithy-ruby
#
# WARNING ABOUT GENERATED CODE

require 'stringio'

require_relative 'middleware/request_id'

module AWS::SDK::PersonalizeEvents
  # An API client for AmazonPersonalizeEvents
  # See {#initialize} for a full list of supported configuration options
  # <p>Amazon Personalize can consume real-time user event data, such as <i>stream</i> or <i>click</i> data, and use
  #       it for model training either alone or combined with historical data. For more information see
  #       <a href="https://docs.aws.amazon.com/personalize/latest/dg/recording-events.html">Recording Events</a>.</p>
  #
  class Client
    include Hearth::ClientStubs

    @middleware = Hearth::MiddlewareBuilder.new

    def self.middleware
      @middleware
    end

    # @param [Config] config
    #   An instance of {Config}
    #
    def initialize(config = AWS::SDK::PersonalizeEvents::Config.new, options = {})
      @config = config
      @middleware = Hearth::MiddlewareBuilder.new(options[:middleware])
      @stubs = Hearth::Stubbing::Stubs.new
      @retry_quota = Hearth::Retry::RetryQuota.new
      @client_rate_limiter = Hearth::Retry::ClientRateLimiter.new
    end

    # <p>Records user interaction event data. For more information see
    #       <a href="https://docs.aws.amazon.com/personalize/latest/dg/recording-events.html">Recording Events</a>.</p>
    #
    # @param [Hash] params
    #   See {Types::PutEventsInput}.
    #
    # @option params [String] :tracking_id
    #   <p>The tracking ID for the event.
    #         The ID is generated by a call to the
    #         <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_CreateEventTracker.html">CreateEventTracker</a> API.</p>
    #
    # @option params [String] :user_id
    #   <p>The user associated with the event.</p>
    #
    # @option params [String] :session_id
    #   <p>The session ID associated with the user's visit. Your application generates the sessionId when a user first visits your website or uses your application.
    #         Amazon Personalize uses the sessionId to associate events with the user before they log in. For more information, see
    #         <a href="https://docs.aws.amazon.com/personalize/latest/dg/recording-events.html">Recording Events</a>.</p>
    #
    # @option params [Array<Event>] :event_list
    #   <p>A list of event data from the session.</p>
    #
    # @return [Types::PutEventsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.put_events(
    #     tracking_id: 'trackingId', # required
    #     user_id: 'userId',
    #     session_id: 'sessionId', # required
    #     event_list: [
    #       {
    #         event_id: 'eventId',
    #         event_type: 'eventType', # required
    #         event_value: 1.0,
    #         item_id: 'itemId',
    #         properties: 'properties',
    #         sent_at: Time.now, # required
    #         recommendation_id: 'recommendationId',
    #         impression: [
    #           'member'
    #         ]
    #       }
    #     ] # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::PutEventsOutput
    #
    def put_events(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::PutEventsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::PutEventsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::PutEvents
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::InvalidInputException]),
        data_parser: Parsers::PutEvents
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::PutEvents,
        stubs: @stubs,
        params_class: Params::PutEventsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :put_events
        )
      )
      raise resp.error if resp.error
      resp
    end

    # <p>Adds one or more items to an Items dataset. For more information see
    #       <a href="https://docs.aws.amazon.com/personalize/latest/dg/importing-items.html">Importing Items Incrementally</a>.
    #      </p>
    #
    # @param [Hash] params
    #   See {Types::PutItemsInput}.
    #
    # @option params [String] :dataset_arn
    #   <p>The Amazon Resource Name (ARN) of the Items dataset you are adding the item or items to.</p>
    #
    # @option params [Array<Item>] :items
    #   <p>A list of item data.</p>
    #
    # @return [Types::PutItemsOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.put_items(
    #     dataset_arn: 'datasetArn', # required
    #     items: [
    #       {
    #         item_id: 'itemId', # required
    #         properties: 'properties'
    #       }
    #     ] # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::PutItemsOutput
    #
    def put_items(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::PutItemsInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::PutItemsInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::PutItems
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ResourceInUseException, Errors::InvalidInputException, Errors::ResourceNotFoundException]),
        data_parser: Parsers::PutItems
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::PutItems,
        stubs: @stubs,
        params_class: Params::PutItemsOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :put_items
        )
      )
      raise resp.error if resp.error
      resp
    end

    # <p>Adds one or more users to a Users dataset. For more information see
    #       <a href="https://docs.aws.amazon.com/personalize/latest/dg/importing-users.html">Importing Users Incrementally</a>.</p>
    #
    # @param [Hash] params
    #   See {Types::PutUsersInput}.
    #
    # @option params [String] :dataset_arn
    #   <p>The Amazon Resource Name (ARN) of the Users dataset you are adding the user or users to.</p>
    #
    # @option params [Array<User>] :users
    #   <p>A list of user data.</p>
    #
    # @return [Types::PutUsersOutput]
    #
    # @example Request syntax with placeholder values
    #
    #   resp = client.put_users(
    #     dataset_arn: 'datasetArn', # required
    #     users: [
    #       {
    #         user_id: 'userId', # required
    #         properties: 'properties'
    #       }
    #     ] # required
    #   )
    #
    # @example Response structure
    #
    #   resp.data #=> Types::PutUsersOutput
    #
    def put_users(params = {}, options = {}, &block)
      stack = Hearth::MiddlewareStack.new
      input = Params::PutUsersInput.build(params)
      response_body = ::StringIO.new
      stack.use(Hearth::Middleware::Validate,
        validator: Validators::PutUsersInput,
        validate_input: @config.validate_input
      )
      stack.use(Hearth::Middleware::Build,
        builder: Builders::PutUsers
      )
      stack.use(Hearth::HTTP::Middleware::ContentLength)
      stack.use(Hearth::Middleware::Retry,
        retry_mode: @config.retry_mode,
        error_inspector_class: Hearth::Retry::ErrorInspector,
        retry_quota: @retry_quota,
        max_attempts: @config.max_attempts,
        client_rate_limiter: @client_rate_limiter,
        adaptive_retry_wait_to_fill: @config.adaptive_retry_wait_to_fill
      )
      stack.use(AWS::SDK::Core::Middleware::Signer,
        signer: @config.signer
      )
      stack.use(Hearth::Middleware::Parse,
        error_parser: Hearth::HTTP::ErrorParser.new(error_module: Errors, success_status: 200, errors: [Errors::ResourceInUseException, Errors::InvalidInputException, Errors::ResourceNotFoundException]),
        data_parser: Parsers::PutUsers
      )
      stack.use(Middleware::RequestId)
      stack.use(Hearth::Middleware::Send,
        stub_responses: @config.stub_responses,
        client: Hearth::HTTP::Client.new(logger: @config.logger, http_wire_trace: options.fetch(:http_wire_trace, @config.http_wire_trace)),
        stub_class: Stubs::PutUsers,
        stubs: @stubs,
        params_class: Params::PutUsersOutput
      )
      apply_middleware(stack, options[:middleware])

      resp = stack.run(
        input: input,
        context: Hearth::Context.new(
          request: Hearth::HTTP::Request.new(url: options.fetch(:endpoint, @config.endpoint)),
          response: Hearth::HTTP::Response.new(body: response_body),
          params: params,
          logger: @config.logger,
          operation_name: :put_users
        )
      )
      raise resp.error if resp.error
      resp
    end

    private

    def apply_middleware(middleware_stack, middleware)
      Client.middleware.apply(middleware_stack)
      @middleware.apply(middleware_stack)
      Hearth::MiddlewareBuilder.new(middleware).apply(middleware_stack)
    end
  end
end
